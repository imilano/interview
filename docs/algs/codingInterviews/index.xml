<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Interview</title><link>https://example.com/docs/algs/codingInterviews/</link><description>Recent content on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/docs/algs/codingInterviews/index.xml" rel="self" type="application/rss+xml"/><item><title>28. 对称的二叉树</title><link>https://example.com/docs/algs/codingInterviews/28_%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/28_%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>Description # 给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）
Solutions # Recursive # func isSymmetrical( pRoot *TreeNode ) bool { // write code here if pRoot == nil { return true } return isSameTree(pRoot.Left, pRoot.Right) } func isSameTree(root1, root2 *TreeNode) bool { if root1 == nil &amp;amp;&amp;amp; root2 == nil { return true } if root1 == nil || root2 == nil { return false } if root1.</description></item><item><title>37. 序列化二叉树</title><link>https://example.com/docs/algs/codingInterviews/37_%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/37_%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>Description # 请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树。
二叉树的序列化(Serialize)是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树等遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#）
二叉树的反序列化(Deserialize)是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。
Solutions # PreOrder Traversal # 采用先序遍历的方式进行序列化，同样采用先序遍历的方式进行反序列化。
var emptyNode string = &amp;#34;#&amp;#34; var seperator string = &amp;#34; &amp;#34; func Serialize( root *TreeNode ) string { // write code here if root == nil { return &amp;#34;&amp;#34; } var res []string _serialize(root, &amp;amp;res) return strings.Join(res, seperator) } func _serialize(root *TreeNode, res *[]string) { if root !</description></item><item><title>78. 把二叉树打印成多行</title><link>https://example.com/docs/algs/codingInterviews/78_%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/78_%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/</guid><description>Description # 给定一个节点数为 n 二叉树，要求从上到下按层打印二叉树的 val 值，同一层结点从左至右输出，每一层输出一行，将输出的结果存放到一个二维数组中返回。
Solutions # Level Order Traversal # 简单题，只需要进行一次层次遍历即可。
func Print( pRoot *TreeNode ) [][]int { // write code here var res [][]int if pRoot == nil { return res } var queue []*TreeNode queue = append(queue, pRoot) for len(queue) != 0 { size := len(queue) var level []int for i := 0; i &amp;lt; size; i++ { node := queue[i] level = append(level, node.</description></item><item><title>84. 二叉树中和为某一值的路径 III</title><link>https://example.com/docs/algs/codingInterviews/84_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84III/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/84_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84III/</guid><description>Description # 给定一个二叉树root和一个整数值 sum ，求该树有多少路径的的节点值之和等于 sum 。 1.该题路径定义不需要从根节点开始，也不需要在叶子节点结束，但是一定是从父亲节点往下到孩子节点 2.总节点数目为n 3.保证最后返回的路径个数在整形范围内(即路径个数小于$2^{31}$-1)
Solutions # 注意，这里的路径不一定需要从根节点开始，也不一定需要在叶节点结束。
Recursice # 核心思想就是，每个节点都可能是一条路径的起始节点，所以每个节点都需要作为根节点来遍历一次。
var res int func FindPath( root *TreeNode , sum int ) int { // write code here if root == nil { return res } findPathHelper(root, sum) // 每个节点都需要作为根节点来进行一次查找 FindPath(root.Left, sum) FindPath(root.Right, sum) return res } func findPathHelper(root *TreeNode, sum int) { if root == nil { return } // 注意这里的小技巧 if sum == root.</description></item><item><title>86. 二叉树中两个节点的最近公共祖先</title><link>https://example.com/docs/algs/codingInterviews/86_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/86_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid><description>Description # 给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。
数据范围：树上节点数满足$1 \le n \le 10^5$, 节点值val满足区间 [0,n) 要求：时间复杂度 $\Omicron(n)$
Solutions # Recursive # 具体解释看注释即可。
func lowestCommonAncestor( root *TreeNode , o1 int , o2 int ) int { // write code here if root == nil { return -1 } res := lcaHelper(root, o1, o2) return res.Val } func lcaHelper(root *TreeNode, o1, o2 int) *TreeNode { // 如果已经遍历到空节点或者已经找到其中一个节点，则返回该节点 if root == nil || root.</description></item><item><title>9. 双栈实现队列</title><link>https://example.com/docs/algs/codingInterviews/9_%E5%8F%8C%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/9_%E5%8F%8C%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</guid><description>Description # 用两个栈来实现一个队列，使用n个元素来完成 n 次在队列尾部插入整数(push)和n次在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。
数据范围： $n \le 1000$ 要求：存储n个元素的空间复杂度为 $\Omicron(n)$ ，插入与删除的时间复杂度都是 $\Omicron(1)$
Solutions # 使用两个队列，队列1专用于push，队列用专用于pop 和 peek。push 时，入队 stack1； pop 时，如果 stack2 不为空，则弹出 stack2 栈顶即可，若 stack2 为空，则将 stack1 的所有元素压入 stack2， 然后将 stack2 的栈顶元素弹出。
type MyQueue struct { stack1 []int stack2 []int } func Constructor() MyQueue { return MyQueue{ stack1: make([]int, 0), stack2: make([]int, 0), } } func (this *MyQueue) Push(x int) { this.</description></item><item><title/><link>https://example.com/docs/algs/codingInterviews/30_%E5%8C%85%E5%90%AB-min-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/30_%E5%8C%85%E5%90%AB-min-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</guid><description>Description # 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数，输入操作时保证 pop、top 和 min 函数操作时，栈中一定有元素。
此栈包含的方法有： push(value):将value压入栈中 pop():弹出栈顶元素 top():获取栈顶元素 min():获取栈中最小元素
数据范围：操作数量满足 $0 \le n \le 300$ ，输入的元素满足 $|val| \le 10000$ 进阶：栈的各个操作的时间复杂度是 $\Omicron(1)$ ，空间复杂度是 $\Omicron(n)$。
Solutions # Stack # 使用两个栈，一个栈stack1用于正常压入和弹出，另一个栈stack2用于实现单调栈。当压入一个元素时，如果当前元素比 stack2 的栈顶元素还要大，则将当前元素压入 stack1 的同时，还将当前元素压入 stack2，如果当前元素不比 stack2 的栈顶元素要大，则将 stack2 的栈顶元素重复入栈。当弹出元素时，将 stack1 和 stack2 的栈顶元素同步弹出。当获取最小值时，只需要取出 stack2 的栈顶元素即可。
// 用于实现正常的 push 与 pop 操作 var stack1 []int // 用于存储最小值 var stack2 []int func Push(node int) { // write code here stack1 = append(stack1, node) size := len(stack2) if size == 0 || stack2[size-1] &amp;gt; node { stack2 = append(stack2, node) } else { stack2 = append(stack2, stack2[size-1]) } } func Pop() { // write code here size := len(stack1) stack1 = stack1[:size-1] stack2 = stack2[:size-1] } func Top() int { // write code here size := len(stack1) return stack1[size-1] } func Min() int { // write code here size := len(stack2) return stack2[size-1] }</description></item><item><title/><link>https://example.com/docs/algs/codingInterviews/68_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/68_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid><description>Description # 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
Solutions # Recursive # 如果当前节点的值比要查找的值的最小值还要小，说明应该往当前节点的右节点进行查找；如果当前节点的值比要查找的值的最大值还要大，说明应该往当前节点的左子树进行查找。否则说明当前节点处于要查找的值之间，那么当前节点就是我们要查找的最近公共祖先。
func lowestCommonAncestor( root *TreeNode , p int , q int ) int { // write code here if root == nil { return -1 } // 保持 p 比 q 要小 if p &amp;gt; q { p,q = q, p } res := lcaHelper(root, p, q) return res.</description></item></channel></rss>