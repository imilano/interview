<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Interview</title><link>https://example.com/docs/algs/codingInterviews/</link><description>Recent content on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/docs/algs/codingInterviews/index.xml" rel="self" type="application/rss+xml"/><item><title>03. 数组中重复的数字</title><link>https://example.com/docs/algs/codingInterviews/03_%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E7%BB%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/03_%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E7%BB%84/</guid><description> Description # 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组[2,3,1,0,2,5,3]，那么对应的输出是2或者3。存在不合法的输入的话输出-1
数据范围： \($0\le n \le 10000$\) 进阶：时间复杂度 \($\Omicron(n)$\) ，空间复杂度 \($\Omicron(n)$\) Solutions # Hash table # 简单题，要么使用哈希表，要么就排一下序。
func duplicate( numbers []int ) int { // write code here // size := len(numbers) dict := make(map[int]bool) for _, value := range numbers { if _, ok := dict[value]; ok { return value } dict[value] = true } return -1 }</description></item><item><title>04. 二维数组中的查找</title><link>https://example.com/docs/algs/codingInterviews/04_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/04_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</guid><description> Description # 在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
数据范围：矩阵的长宽满足 \($0 \le n$\) , \($m \le 500$\) ， 矩阵中的值满足 \($0 \le val \le 10^9$\) 。
进阶：空间复杂度 O(1)O(1) ，时间复杂度 O(n+m)O(n+m)
Solutions # 从左下角开始进行遍历，因为数组维持了从左到右递增，从上到下递增的性质，那么如果当前元素比 target 要大， target 一定位于当前元素的右边；如果当前元素比 target 要小，那么 target 一定位于当前元素的上侧。
func Find( target int , array [][]int ) bool { // write code here var res bool m, n := len(array), len(array[0]) x, y := m-1, 0 for { if x &amp;lt; 0 || y &amp;gt;= n { break } if array[x][y] == target { res = true break } if target &amp;gt; array[x][y] { y++ } // 这里要加上一个 y &amp;lt; n, 因为上一个 if 对 y 进行了自增，导致这里的 y 不一定合法 if y &amp;lt; n &amp;amp;&amp;amp; target &amp;lt; array[x][y] { x-- } } return res }</description></item><item><title>05. 替换空格</title><link>https://example.com/docs/algs/codingInterviews/05_%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/05_%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</guid><description> Description # 请实现一个函数，将一个字符串s中的每个空格替换成“%20”。 例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
数据范围: \($0 \le len(s) \le 1000$\) 。保证字符串中的字符为大写英文字母、小写英文字母和空格中的一种。
Solutions # func replaceSpace( s string ) string { // write code here var res string size := len(s) if size == 0 { return res } for _, r := range s { if r != &amp;#39; &amp;#39; { res += string(r) } else { res += &amp;#34;%20&amp;#34; } } return res }</description></item><item><title>06. 从尾到头打印链表</title><link>https://example.com/docs/algs/codingInterviews/06_%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/06_%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</guid><description>Description # 输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。
Solutions # Recursive # 递归解法，太简单直接看代码就可以。
func printListFromTailToHead( head *ListNode) []int { // write code here var res []int printListFromTailToHeadHelper(head, &amp;amp;res) return res } func printListFromTailToHeadHelper(head *ListNode, res *[]int) { if head == nil { return } printListFromTailToHeadHelper(head.Next, res) *res = append(*res, head.Val) } Stack # 当然了，不用递归也可以用栈，直接看代码：
func printListFromTailToHead( head *ListNode) []int { // write code here var res []int if head == nil { return res } var stack []*ListNode cur := head for cur !</description></item><item><title>07. 重建二叉树</title><link>https://example.com/docs/algs/codingInterviews/07_%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/07_%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>Description # 给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。
Solutions # TODO
func reConstructBinaryTree( pre []int , vin []int ) *TreeNode { // write code here pre_size, in_size := len(pre), len(vin) return buildTreeSolution(pre, 0, pre_size-1, vin, 0, in_size-1) } func buildTreeSolution(preorder []int, pleft, pright int, inorder []int, ileft, iright int) *TreeNode { if pleft &amp;gt; pright || ileft &amp;gt; iright { return nil } var rootIndex int for i := ileft; i &amp;lt;= iright; i++ { if inorder[i] == preorder[pleft] { rootIndex = i break } } root := new(TreeNode) root.</description></item><item><title>08. 二叉树的下一个节点</title><link>https://example.com/docs/algs/codingInterviews/08_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/08_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/</guid><description>Description # 给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的next指针。下图为一棵有9个节点的二叉树。树中从父节点指向子节点的指针用实线表示，从子节点指向父节点的用虚线表示
Solutions # 一般我们中序遍历都是从根节点开始的，但是这里并没有给出根节点，而是给出了一个要查找的节点。那首先我们可以通过不断的往上走，直到找到根节点，然后进行中序遍历，这样就可以找到我们需要的节点的下一个节点。这里的写法很简单，我们就不上代码了。
那如果我们不找根节点，直接从当前节点开始遍历呢？这里情形就稍微有点复杂了，需要分情况讨论: - 如果当前节点有右节点，则右节点的最左节点就是我们所找的节点 - 如果当前节点没有右节点，且当前节点没有父节点，则返回 nil - 如果当前节点没有右节点，当前节点有父节点，且当前节点是父节点的左子节点，则返回当前节点的父节点 - 如果当前节点没有右节点，当前节点有父节点，且当前节点是父节点的右子节点，则一路向上查找，直到找到一个节点，这个节点是其父节点的左子节点，返回父节点；如果没有这样的父节点，返回 nil。
下面给出上面第二种方法的代码。
func GetNext(pNode *TreeLinkNode) *TreeLinkNode { if pNode == nil { return nil } // 情况一，当前节点的右子树非空，则直接找出当前节点的右子树的最左节点即可 if pNode.Right != nil { pNode = pNode.Right for pNode.Left != nil { pNode = pNode.Left } return pNode } // 情况二，当前节点的右子树为空，且父节点也为空，说明当前节点就是根节点，没有下一个节点，返回 nil 即可。 if pNode.Next == nil { return nil } // 情况三， 当前节点右子树为空，父节点非空，并且当前节点是其父节点的左节点，那么直接返回其父节点 if pNode == pNode.</description></item><item><title>09. 双栈实现队列</title><link>https://example.com/docs/algs/codingInterviews/09_%E5%8F%8C%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/09_%E5%8F%8C%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</guid><description>Description # 用两个栈来实现一个队列，使用n个元素来完成 n 次在队列尾部插入整数(push)和n次在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。
数据范围： \($n \le 1000$\) 要求：存储n个元素的空间复杂度为 \($\Omicron(n)$\) ，插入与删除的时间复杂度都是 \($\Omicron(1)$\) Solutions # 使用两个队列，队列1专用于push，队列用专用于pop 和 peek。push 时，入队 stack1； pop 时，如果 stack2 不为空，则弹出 stack2 栈顶即可，若 stack2 为空，则将 stack1 的所有元素压入 stack2， 然后将 stack2 的栈顶元素弹出。
type MyQueue struct { stack1 []int stack2 []int } func Constructor() MyQueue { return MyQueue{ stack1: make([]int, 0), stack2: make([]int, 0), } } func (this *MyQueue) Push(x int) { this.stack1 = append(this.stack1, x) } func (this *MyQueue) Pop() int { var res int len1, len2 := len(this.</description></item><item><title>10. 斐波那契数列</title><link>https://example.com/docs/algs/codingInterviews/10_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/10_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</guid><description> Description # 输入一个正整数 n ，请你输出斐波那契数列的第 n 项
Solutions # 简单题，简单的动态规划。
func Fibonacci( n int ) int { // write code here if n &amp;lt;= 2 { return 1 } NMinusOne, NMinusTwo := 1, 1 for i := 3; i &amp;lt;= n; i++ { N := NMinusOne + NMinusTwo NMinusTwo = NMinusOne NMinusOne = N } return NMinusOne }</description></item><item><title>11. 旋转数组的最小数字</title><link>https://example.com/docs/algs/codingInterviews/11_%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/11_%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</guid><description> Descriptioin # 有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。
数据范围： \($1 \le n \le 10000$\) ，数组中任意元素的值: \($0 \le val \le 10000$\) 。 要求：空间复杂度： \($\Omicron(1)$\) ，时间复杂度： \($\Omicron(\log n)$\) Solutions # Binary Search # 二分查找，使用两个指针 left 和 right 分别指向数组的待查找序列的左侧和右侧，则：
如果中间元素比右侧元素小，那么向左查找，即 right = mid 如果中间元素比右侧元素大，那么向右查找， 即 left = mid + 1 如果中间元素等于右侧元素，那么最小元素即可能在左边，也可能在右边，则可以收缩右边界 最后返回 left 指向的元素即可。 func minNumberInRotateArray( nums []int ) int { // write code here var res int size := len(nums) if size == 0 { return res } left, right := 0, size -1 for left &amp;lt; right { mid := (left+right)/2 if nums[mid] &amp;gt; nums[right] { left = mid + 1 } else if nums[mid] &amp;lt; nums[right] { right = mid } else if nums[mid] == nums[right] { right = right -1 } } return nums[left] }</description></item><item><title>12. 矩阵中的路径</title><link>https://example.com/docs/algs/codingInterviews/12_%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/12_%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</guid><description>Description # 请设计一个函数，用来判断在一个n乘m的矩阵中是否存在一条包含某长度为len的字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如: \($\begin{bmatrix} a &amp;amp; b &amp;amp; c &amp;amp;e \\ s &amp;amp; f &amp;amp; c &amp;amp; s \\ a &amp;amp; d &amp;amp; e&amp;amp; e\\ \end{bmatrix}\quad$\) 矩阵中包含一条字符串&amp;quot;bcced&amp;quot;的路径，但是矩阵中不包含&amp;quot;abcb&amp;quot;路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 数据范围： \($0 \le n,m \le 20$\) , \($1\le len \le 25$\) Solutions # Backtracing # func hasPath( matrix [][]byte , word string ) bool { // write code here n,m := len(matrix), len(matrix[0]) for i := 0; i &amp;lt; n; i++ { for j := 0; j &amp;lt; m; j++ { // 剪枝 if word[0] == matrix[i][j] &amp;amp;&amp;amp; helper(matrix, word, i, j, n, m) { return true } } } return false } func helper(matrix [][]byte, word string, x,y,n,m int) bool { size := len(word) // 这里之所以可以直接取 word[0] 而不用判断数组越界，主要是因为下面第二个 if 语句会保证进入递归的 word 一定不是空串 if x &amp;lt; 0 || x &amp;gt;= n || y &amp;lt; 0 || y &amp;gt;= m || matrix[x][y] == &amp;#39;.</description></item><item><title>13. 机器人的运动范围</title><link>https://example.com/docs/algs/codingInterviews/13_%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/13_%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</guid><description>Description # 地上有一个 rows 行和 cols 列的方格。坐标从 [0,0] 到 [rows-1,cols-1] 。一个机器人从坐标 [0,0] 的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 threshold 的格子。 例如，当 threshold 为 18 时，机器人能够进入方格 [35,37] ，因为 3+5+3+7 = 18。但是，它不能进入方格 [35,38] ，因为 3+5+3+8 = 19 。请问该机器人能够达到多少个格子？
数据范围： \($0 \le threshold \le 15$\) ， \($1 \le rows,cols \le 100$\) Solutions # func movingCount( threshold int , rows int , cols int ) int { // write code here if rows &amp;lt;= 0 || cols &amp;lt;= 0 || threshold &amp;lt; 0 { return 0 } visited := make([][]bool, rows) for idx, _ := range visited { visited[idx] = make([]bool, cols) } return helper(threshold, rows, cols, 0, 0, &amp;amp;visited) } func helper(threshold int, rows int,cols int, row int, col int, visited *[][]bool) int { t := pathSum(row) + pathSum(col) if row &amp;lt; 0 || row &amp;gt;= rows || col &amp;lt; 0 || col &amp;gt;= cols || (*visited)[row][col] || t &amp;gt; threshold { return 0 } (*visited)[row][col] = true return 1 + helper(threshold, rows, cols, row+1, col, visited) + helper(threshold, rows, cols, row-1, col, visited) + helper(threshold, rows, cols, row, col+1, visited) + helper(threshold, rows, cols, row, col-1, visited) } func pathSum(num int) int { var sum int for num !</description></item><item><title>14. 剪绳子</title><link>https://example.com/docs/algs/codingInterviews/14_%E5%89%AA%E7%BB%B3%E5%AD%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/14_%E5%89%AA%E7%BB%B3%E5%AD%90/</guid><description>Description # 给你一根长度为 n 的绳子，请把绳子剪成整数长的 m 段（ m 、 n 都是整数， n &amp;gt; 1 并且 m &amp;gt; 1 ， m &amp;lt;= n ），每段绳子的长度记为 k[1],&amp;hellip;,k[m] 。请问 k[1]k[2]&amp;hellip;*k[m] 可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18 。
数据范围： \($2 \le n \le 60$\) 进阶：空间复杂度 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n)$\) Solutions # Recursive # 我们可以发现，当我们求某一个数字的时候，我们只需要将这个数字分解出1,2,3。对于3以上的数字，其实也可以分解成这三个数字，比如4=2x2,5=2x3。对于分解出1的情况，我们发现这个是对答案没有贡献的。所以直接忽略。我们只需要讨论2和3的情况。所以，我们只需要将数字分为2和3组成的就行了。
func cutRope( n int ) int { // write code here if n &amp;lt;= 3 { return n } return max(2*cutRope(n-2), 3*cutRope(n-3)) } func max(a,b int) int { if a &amp;lt; b { return b } return a } Dynamic Programming # 对于一个长度为 n 的绳子，如何确定其分出的最大乘积呢？我们可以尝试其中一段不可分的为 j，那么如果另一段 n-j 最大乘积已知，那么我们就可以遍历所有 j 找到这个最大乘积。因此用 dp[i] 表示长度为 i 的绳子可以被剪出来的最大乘积，那么后续遍历每个 j 的时候，我们取最大 dp[i] = max(dp[i], j *dp[i-j])即可。也就是:</description></item><item><title>15. 二进制中 1 的个数</title><link>https://example.com/docs/algs/codingInterviews/15_%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD-1-%E7%9A%84%E4%B8%AA%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/15_%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD-1-%E7%9A%84%E4%B8%AA%E6%95%B0/</guid><description> Description # 输入一个整数 n ，输出该数32位二进制表示中1的个数。其中负数用补码表示。
Solutions # Bit Manipulation # 这里需要注意的是，因为负数用补码表示，而负数补码右移会导致高位补 1，所以对负数不能直接进行右移。
func NumberOf1( n int ) int { // write code here var count int t := 0x80000000 for n != 0 { count += (n &amp;amp; t) &amp;gt;&amp;gt; 31 n &amp;lt;&amp;lt;= 1 } return count }</description></item><item><title>16. 数值的整数次方</title><link>https://example.com/docs/algs/codingInterviews/16_%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/16_%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</guid><description> Description # 实现函数 double Power(double base, int exponent)，求base的exponent次方。
注意： 1.保证base和exponent不同时为0。 2.不得使用库函数，同时不需要考虑大数问题 3.有特殊判题，不用考虑小数点后面0的位数。
数据范围： \($|base| \le 100$\) ， \($|exponent| \le 100$\) ,保证最终结果一定满足 \($|val| \le 10^4$\) 进阶：空间复杂度 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n)$\) 快速幂 # func Power( base float64 , exponent int ) float64 { // write code here if base == 0 { return 0 } var negative bool if exponent &amp;lt; 0 { negative = true exponent = -exponent } res := helper(base, exponent) if negative { res = 1 / res } return res } func helper(base float64, exponent int) float64 { if base == 0 { return 0 } if exponent == 0 { return 1 } if exponent == 1 { return base } return helper(base, exponent/2) * helper(base, exponent/2) * helper(base, exponent%2) }</description></item><item><title>17. 打印从 1 到最大的 n 位数</title><link>https://example.com/docs/algs/codingInterviews/17_%E6%89%93%E5%8D%B0%E4%BB%8E-1-%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84-n-%E4%BD%8D%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/17_%E6%89%93%E5%8D%B0%E4%BB%8E-1-%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84-n-%E4%BD%8D%E6%95%B0/</guid><description> Description # 输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。
用返回一个整数列表来代替打印 n 为正整数，0 &amp;lt; n &amp;lt;= 5 Solutions # func printNumbers( n int ) []int { // write code here var res []int if n == 0 { return res } curMax := 0 for n &amp;gt; 0 { curMax *= 10 curMax += 9 n-- } for i := 1; i &amp;lt;= curMax; i++ { res = append(res, i) } return res }</description></item><item><title>18. 删除链表的节点</title><link>https://example.com/docs/algs/codingInterviews/18_%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/18_%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</guid><description> Description # 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。
1.此题对比原题有改动 2.题目保证链表中节点的值互不相同 3.该题只会输出返回的链表和结果做对比，所以若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点
Solutions # 这里一个非常需要注意的点就是，如果头结点也要被删除的话怎么办？如果头结点的也要被删除的话，那么判断条件就会变得比较复杂，这里的一个解决办法就是，增加一个虚拟的头结点，然后让这个虚拟的头结点指向真正的头结点，遍历的时候就从这个虚拟的头结点开始遍历，这样就能够应付真实头结点也要被删除的情况。
不多说，直接上代码。
func deleteNode( head *ListNode , val int ) *ListNode { // write code here dummpy := new(ListNode) dummpy.Next = head pre, cur := dummpy, head for cur != nil { if cur.Val == val { pre.Next = cur.Next break } pre = cur cur = cur.Next } return dummpy.Next }</description></item><item><title>21. 调整数组顺序使奇数位于偶数前面</title><link>https://example.com/docs/algs/codingInterviews/21_%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/21_%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</guid><description>Description # 输入一个长度为 n 整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前面部分，所有的偶数位于数组的后面部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。
数据范围： \($0 \le n \le 5000$\) ，数组中每个数的值 \($0 \le val \le 10000$\) 要求：时间复杂度 \($\Omicron(n)$\) ，空间复杂度 \($\Omicron(n)$\) 进阶：时间复杂度 \($\Omicron(n^2)$\) ，空间复杂度 \($\Omicron(1)$\) Solutions # Array # 分别创建两个数组，一个用于存储奇数，一个用于存储偶数，然后扫描一次原数组，将奇数放入奇数数组，将偶数放入偶数数组，最后再将这两个数组拼接在一起即可。
func reOrderArray( array []int ) []int { // write code here size := len(array) if size == 0 { return nil } var odd, even []int for _, num := range array { if num %2 == 0 { even = append(even, num) } else { odd = append(odd, num) } } return append(odd, even.</description></item><item><title>22. 链表中倒数最后 k 个节点</title><link>https://example.com/docs/algs/codingInterviews/22_%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E6%9C%80%E5%90%8E-k-%E4%B8%AA%E8%8A%82%E7%82%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/22_%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E6%9C%80%E5%90%8E-k-%E4%B8%AA%E8%8A%82%E7%82%B9/</guid><description>Description # 输入一个长度为 n 的链表，设链表中的元素的值为 ai ，返回该链表中倒数第k个节点。 如果该链表长度小于k，请返回一个长度为 0 的链表。
数据范围： \($0 \leq n \leq 10^5$\) , \($0 \leq a_i \leq 10^9$\) ， \($0 \leq k \leq 10^9$\) 要求：空间复杂度 \($\Omicron(n)$\) ，时间复杂度 \($\Omicron(n)$\) 进阶：空间复杂度 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n)$\) Solutions # 快慢指针 # 简答题目，不多说，直接上代码。
func FindKthToTail( pHead *ListNode , k int ) *ListNode { // write code here fast, slow := pHead, pHead for k != 0 { if fast == nil { return nil } fast = fast.</description></item><item><title>23. 链表中环的入口节点</title><link>https://example.com/docs/algs/codingInterviews/23_%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/23_%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9/</guid><description>Description # 给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。
数据范围： \($n\le10000$\) ， \($1&amp;lt;=结点值&amp;lt;=10000$\) 要求：空间复杂度 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n)$\) Solutions # 哈希表 # 最简单的做法是， 从头到尾遍历链表，然后一个哈希表来记录已经遍历过的节点。第一个被重复遍历的节点就是我们所求的结果（前提是链表中存在环）。
func EntryNodeOfLoop(pHead *ListNode) *ListNode { if pHead == nil { return nil } cur := pHead dict := make(map[*ListNode]bool) for cur != nil { if _, ok := dict[cur]; ok { return cur } dict[cur] = true cur = cur.Next } return nil } 双指针 # 通过快慢指针来解。 func EntryNodeOfLoop(pHead *ListNode) *ListNode { if pHead == nil { return nil } // 找到相遇节点 slow, fast := pHead, pHead for fast !</description></item><item><title>24. 反转链表</title><link>https://example.com/docs/algs/codingInterviews/24_%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/24_%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid><description> Description # 给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。
数据范围： \($0\leq n\leq1000$\) 要求：空间复杂度 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n)$\) 。
Solutions # 参考链表插入中的头插法。下面的递归反转解法中连接各个节点的方式需要注意一下：
func ReverseList( pHead *ListNode ) *ListNode { // write code here return reverseListSolution3(pHead) } func reverseListSolution3(pHead *ListNode) *ListNode { // 到最后一个节点则返回 if pHead == nil || pHead.Next == nil { return pHead } // 继续反转下一个节点 newHead := reverseListSolution3(pHead.Next) // 逆转当前节点的（注意画图理解） pHead.Next.Next = pHead // 断开当前节点与下一个节点的关系 pHead.Next = nil // 返回最后一个节点作为头结点 return newHead }</description></item><item><title>25. 合并两个排序的链表</title><link>https://example.com/docs/algs/codingInterviews/25_%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/25_%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</guid><description>Description # 输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。 数据范围： \($0 \le n \le 1000$\) ， \($-1000 \le 节点值 \le 1000$\) 要求：空间复杂度 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n)$\) Solutions # 参考归并排序，很简单。
func Merge( pHead1 *ListNode , pHead2 *ListNode ) *ListNode { // write code here if pHead1 == nil { return pHead2 } if pHead2 == nil { return pHead1 } head := new(ListNode) cur := head h1, h2 := pHead1, pHead2 for h1 != nil &amp;amp;&amp;amp; h2 !</description></item><item><title>26. 树的子结构</title><link>https://example.com/docs/algs/codingInterviews/26_%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/26_%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</guid><description>Description # 输入两棵二叉树A，B，判断B是不是A的子结构。（我们约定空树不是任意一个树的子结构）
Solutions # 这里需要注意如何将左右节点又作为一个子问题来求解的方法。
func HasSubtree( pRoot1 *TreeNode , pRoot2 *TreeNode ) bool { // write code here // 空树不是任意一个树的子结构 if pRoot2 == nil { return false } if pRoot1 == nil &amp;amp;&amp;amp; pRoot2 != nil { return false } // 判断是否是子结构 if sameTree(pRoot1, pRoot2) { return true } // 将左右节点又分别作为一个子问题 return HasSubtree(pRoot1.Left, pRoot2) || HasSubtree(pRoot1.Right, pRoot2) } func sameTree(p, q *TreeNode) bool { if p == nil &amp;amp;&amp;amp; q == nil { return true } if p !</description></item><item><title>27. 二叉树的镜像</title><link>https://example.com/docs/algs/codingInterviews/27_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/27_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</guid><description> Description # 操作给定的二叉树，将其变换为源二叉树的镜像。 数据范围：二叉树的节点数 \($0 \le n \le 1000$\) ， 二叉树每个节点的值 \($0\le val \le 1000$\) 。 要求： 空间复杂度 \($\Omicron(n)$\) 。本题也有原地操作，即空间复杂度 \($\Omicron(1)$\) 的解法，时间复杂度 \($\Omicron(n)$\) Solutions # 简单题，左右节点交换即可，直接上代码。
func Mirror( pRoot *TreeNode ) *TreeNode { // write code here if pRoot == nil { return nil } pRoot.Right, pRoot.Left = Mirror(pRoot.Left), Mirror(pRoot.Right) return pRoot }</description></item><item><title>28. 对称的二叉树</title><link>https://example.com/docs/algs/codingInterviews/28_%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/28_%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>Description # 给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）
Solutions # Recursive # func isSymmetrical( pRoot *TreeNode ) bool { // write code here if pRoot == nil { return true } return isSameTree(pRoot.Left, pRoot.Right) } func isSameTree(root1, root2 *TreeNode) bool { if root1 == nil &amp;amp;&amp;amp; root2 == nil { return true } if root1 == nil || root2 == nil { return false } if root1.Val != root2.Val { return false } return isSameTree(root1.</description></item><item><title>29. 顺时针打印矩阵</title><link>https://example.com/docs/algs/codingInterviews/29_%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/29_%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</guid><description> Description # 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： [[1,2,3,4], [5,6,7,8], [9,10,11,12], [13,14,15,16]] 则依次打印出数字 [1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10]
数据范围: \($0 \le matrix.length \le 100$\) \($0 \le matrix[i].length \le 100$\) Solutions # 老面孔了，不多介绍。
func printMatrix( matrix [][]int ) []int { // write code here var res []int m, n := len(matrix), len(matrix[0]) top, down, left, right := 0, m-1, 0, n-1 for top &amp;lt;= down &amp;amp;&amp;amp; left &amp;lt;= right { // 注意这里是等号，从而让只有一行/列的时候也能进入循环 for i := left; i &amp;lt;= right; i++ { res = append(res, matrix[top][i]) } // 避免上下重合 top++ if top &amp;gt; down { break } for i := top; i &amp;lt;= down; i++ { res = append(res, matrix[i][right]) } // 避免左右重合 right-- if right &amp;lt; left { break } for i := right; i &amp;gt;= left; i-- { res = append(res, matrix[down][i]) } // 避免上下重合 down-- if down &amp;lt; top { break } for i := down; i &amp;gt;= top; i-- { res = append(res, matrix[i][left]) } // 避免左右重合 left++ if left &amp;gt; right { break } } return res }</description></item><item><title>30. 包含 min 函数的栈</title><link>https://example.com/docs/algs/codingInterviews/30_%E5%8C%85%E5%90%AB-min-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/30_%E5%8C%85%E5%90%AB-min-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</guid><description> Description # 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数，输入操作时保证 pop、top 和 min 函数操作时，栈中一定有元素。
此栈包含的方法有： push(value):将value压入栈中 pop():弹出栈顶元素 top():获取栈顶元素 min():获取栈中最小元素
数据范围：操作数量满足 \($0 \le n \le 300$\) ，输入的元素满足 \($|val| \le 10000$\) 进阶：栈的各个操作的时间复杂度是 \($\Omicron(1)$\) ，空间复杂度是 \($\Omicron(n)$\) 。
Solutions # Stack # 使用两个栈，一个栈stack1用于正常压入和弹出，另一个栈stack2用于实现单调栈。当压入一个元素时，如果当前元素比 stack2 的栈顶元素还要大，则将当前元素压入 stack1 的同时，还将当前元素压入 stack2，如果当前元素不比 stack2 的栈顶元素要大，则将 stack2 的栈顶元素重复入栈。当弹出元素时，将 stack1 和 stack2 的栈顶元素同步弹出。当获取最小值时，只需要取出 stack2 的栈顶元素即可。
// 用于实现正常的 push 与 pop 操作 var stack1 []int // 用于存储最小值 var stack2 []int func Push(node int) { // write code here stack1 = append(stack1, node) size := len(stack2) if size == 0 || stack2[size-1] &amp;gt; node { stack2 = append(stack2, node) } else { stack2 = append(stack2, stack2[size-1]) } } func Pop() { // write code here size := len(stack1) stack1 = stack1[:size-1] stack2 = stack2[:size-1] } func Top() int { // write code here size := len(stack1) return stack1[size-1] } func Min() int { // write code here size := len(stack2) return stack2[size-1] }</description></item><item><title>31. 栈的压入弹出序列</title><link>https://example.com/docs/algs/codingInterviews/31_%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/31_%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</guid><description>Description # 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。
Solutions # 栈模拟 # 新建一个栈来模拟出栈序列。使用一个指针 inPos 指向当前入栈序列的单签入栈元素，使用另一个指针 outPos 指向出栈序列当前应该出栈的元素，然后开始模拟出入栈。
首先，如果当前栈顶元素和出栈序列匹配，则出栈栈顶元素，并且将 outPos 右移，直到二者不匹配或者栈为空 将 inPos 指针指向的入栈序列的元素入栈，然后将 inPos 右移。 不断循环上述过程，直到入栈序列中的所有元素都入栈。 最后判断是否出栈序列中的所有元素都已经匹配完成即可。 func IsPopOrder( pushV []int , popV []int ) bool { // write code here size := len(pushV) if size == 0 { return true } var stack []int stack = append(stack, pushV[0]) inPos, outPos := 1, 0 // 为什么这里的循环用的是 &amp;lt;= ，而不是 &amp;lt; ？ // 因为有可能我们一直从入栈序列中入栈的操作，直到所有元素都已经入栈。如果只使用 &amp;lt; 符号的话， // 我们就无法判断出栈序列是否和栈顶元素匹配（当然你也可以在 for 循环之后再加上这一步，只不过加 // 上这个=号之后可以少写一点代码）.</description></item><item><title>32. 从上往下打印二叉树</title><link>https://example.com/docs/algs/codingInterviews/32_%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/32_%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>Description # 不分行从上往下打印出二叉树的每个节点，同层节点从左至右打印
Solutions # 层次遍历即可，直接上代码。
func PrintFromTopToBottom( root *TreeNode ) []int { // write code here var res []int if root == nil { return res } var queue []*TreeNode queue = append(queue, root) for len(queue) != 0 { size := len(queue) for i := 0; i &amp;lt; size; i++ { node := queue[i] if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.</description></item><item><title>33. 二叉搜索树的后序遍历序列</title><link>https://example.com/docs/algs/codingInterviews/33_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/33_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</guid><description> Description # 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回 true ,否则返回 false。假设输入的数组的任意两个数字都互不相同。
数据范围： 节点数量 \($0 \le n \le 1000$\) ，节点上的值满足 \($1 \le val \le 10^{5}$\) ，保证节点上的值各不相同 要求：空间复杂度 O(n)O(n) ，时间时间复杂度 \($\Omicron(n^2)$\) Solutions # 后序遍历具有“左右根”的结构，而因为这里是二叉搜索树，那么必然有左子树所有元素比根小，右子树所有元素比根大，那么我们只需要确定根所在的位置，然后从该位置向左查找，直到第一个比根小的元素，然后从该元素往左都是左子树，从该元素下一个位置到根元素的前一个位置都是右子树的元素，然后只需要检查左子树是否比根元素小，右子树是否比根元素大，然后递归检查左子树和有右子树即可。
func VerifySquenceOfBST(sequence []int ) bool { // write code here size := len(sequence) if size == 0 { return false } return helper(sequence, 0, size-1) } func helper(sequence []int, left, right int) bool { if left &amp;gt;= right { return true } root := sequence[right] sep := right-1 for sep &amp;gt;= 0 &amp;amp;&amp;amp; sequence[sep] &amp;gt; root { sep-- } for i := 0; i &amp;lt;= sep; i++ { if sequence[i] &amp;gt; root { return false } } return helper(sequence, left, sep) &amp;amp;&amp;amp; helper(sequence, sep+1, right-1) }</description></item><item><title>34. 二叉树中和为某一值的路径（二）</title><link>https://example.com/docs/algs/codingInterviews/34_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E4%BA%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/34_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E4%BA%8C/</guid><description>Description # 输入一颗二叉树的根节点root和一个整数expectNumber，找出二叉树中结点值的和为expectNumber的所有路径。 1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点 2.叶子节点是指没有子节点的节点 3.路径只能从父节点到子节点，不能从子节点到父节点 4.总节点数目为n
Solutions # 因为这里的路径要求是从根节点到叶子节点的，所以也很简单，直接回溯即可。但是需要注意的是，下面这种通过 expectedNum - root.Val 的方式能够减少额外维护一个当前路径上的元素组成的数组的开销，很值得推荐。
func FindPath( root *TreeNode , expectNumber int ) [][]int { // write code here var res [][]int if root == nil { return res } var nums []int findPathHelper(root, expectNumber, nums, &amp;amp;res) return res } func findPathHelper(root *TreeNode, expecteNumber int, nums []int, res *[][]int) { if root == nil { return } // 这里能够减少单独再维护一个数组的开销，很值得推荐 nums = append(nums, root.</description></item><item><title>35. 复杂链表的复制</title><link>https://example.com/docs/algs/codingInterviews/35_%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/35_%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</guid><description> Description # 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）。 下图是一个含有5个结点的复杂链表。图中实线箭头表示next指针，虚线箭头表示random指针。为简单起见，指向null的指针没有画出。
Solutions # 链表或者图的复制非常适合用哈希表来做。
func Clone( head *RandomListNode ) *RandomListNode { //write your code here if head == nil { return nil } dict := make(map[*RandomListNode]*RandomListNode) p := head for p != nil { node := new(RandomListNode) node.Label = p.Label dict[p] = node p = p.Next } p = head for p != nil { dict[p].Next = dict[p.Next] dict[p].Random = dict[p.Random] p = p.Next } return dict[head] }</description></item><item><title>36. 二叉搜索树与双向链表</title><link>https://example.com/docs/algs/codingInterviews/36_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/36_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid><description>Description # 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。 注意: 1.要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继 2.返回链表中的第一个节点的指针 3.函数返回的TreeNode，有左右指针，其实可以看成一个双向链表的数据结构 4.你不用输出双向链表，程序会根据你的返回值自动打印输出
Solutions # 这里的解法还是很巧妙的，需要多多注意。
var head, pre *TreeNode func Convert( pRootOfTree *TreeNode ) *TreeNode { // write code here if pRootOfTree == nil { return pRootOfTree } convertHelper(pRootOfTree) return head } // 这里就是一个中序遍历 func convertHelper(cur *TreeNode) { if cur == nil { return } convertHelper(cur.Left) // 如果 pre 为空，说明已经遍历到了最左节点，那么这个节点很明显就是头结点。 // 如果 pre 不为空，说明此时遍历到的不是最左节点，而是其他的一般节点，那么此时就需要做一个连接 if pre == nil { head = cur } else { pre.</description></item><item><title>37. 序列化二叉树</title><link>https://example.com/docs/algs/codingInterviews/37_%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/37_%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>Description # 请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树。
二叉树的序列化(Serialize)是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树等遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#）
二叉树的反序列化(Deserialize)是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。
Solutions # PreOrder Traversal # 采用先序遍历的方式进行序列化，同样采用先序遍历的方式进行反序列化。
var emptyNode string = &amp;#34;#&amp;#34; var seperator string = &amp;#34; &amp;#34; func Serialize( root *TreeNode ) string { // write code here if root == nil { return &amp;#34;&amp;#34; } var res []string _serialize(root, &amp;amp;res) return strings.Join(res, seperator) } func _serialize(root *TreeNode, res *[]string) { if root != nil { v := strconv.Itoa(root.Val) *res = append(*res, v) _serialize(root.</description></item><item><title>38. 字符串的排列</title><link>https://example.com/docs/algs/codingInterviews/38_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/38_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</guid><description>Description # 输入一个长度为 n 字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组。
例如输入字符串ABC,则输出由字符A,B,C所能排列出来的所有字符串ABC,ACB,BAC,BCA,CBA和CAB。
Solutions # 使用全排列的思想来做。
func Permutation( str string ) []string { // write code here var res []string size := len(str) if size == 0 { return res } dict := make(map[string]bool) permutate([]rune(str), 0, size, &amp;amp;dict) for key, _ := range dict { res = append(res, key) } return res } func permutate(str []rune, start int, size int, dict *map[string]bool) { if start == size { s := string(str) if _, ok := (*dict)[s]; !</description></item><item><title>39. 数组中出现次数超过一半的数字</title><link>https://example.com/docs/algs/codingInterviews/39_%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/39_%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</guid><description>Description # 给一个长度为 n 的数组，数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。
数据范围： \($n \le 50000$\) ，数组中元素的值 \($0 \le val \le 10000$\) 要求：空间复杂度： \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n)$\) Solutions # 使用一个数字 cur 表示当前已经遍历到的元素，使用 cnt 表示当前 cur 出现次数。遍历一次数组，每当 cnt &amp;lt;= 0 时，则将 cur 更新为当前扫描到的元素，如果当前扫描的元素 num 不等于 cur， 那么 cnt &amp;ndash;，如果相等，则 cnt++，最后剩下的这个 cur 必然是多数元素。
因为多数元素出现次数超过一半，所以扫描时，少数元素会把多数元素的出现次数给抵消掉，但是无论怎么抵消，多数元素的出现次数还是比所有少数元素的出现次数要少，所以最后剩下的元素一定是那个多数元素。
func MoreThanHalfNum_Solution( numbers []int ) int { // write code here var cnt int cur := -1 for _, num := range numbers { if cnt &amp;lt;= 0 { cur = num cnt = 1 } else if num == cur { cnt++ } else if num !</description></item><item><title>40. 最小的 k 个数</title><link>https://example.com/docs/algs/codingInterviews/40_%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E4%B8%AA%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/40_%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E4%B8%AA%E6%95%B0/</guid><description>Description # 给定一个长度为 n 的可能有重复值的数组，找出其中不去重的最小的 k 个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4(任意顺序皆可)。 数据范围： \($0\le k,n \le 10000$\) ，数组中每个数的大小 \($0 \le val \le 1000$\) 要求：空间复杂度 \($\Omicron(n)$\) ，时间复杂度 \($\Omicron(n\log n)$\) Solutions # Min Heap # 使用最小堆的思想来做。把元素不断地压入堆中，然后再将前 k 个元素出堆即可。
import &amp;#34;container/heap&amp;#34; /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * @param input int整型一维数组 * @param k int整型 * @return int整型一维数组 */ func GetLeastNumbers_Solution( input []int , k int ) []int { // write code here var minHeap MinHeap var res []int heap.</description></item><item><title>41. 数据流中的中位数</title><link>https://example.com/docs/algs/codingInterviews/41_%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/41_%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</guid><description>Description # 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。
数据范围：数据流中数个数满足 \($1 \le n \le 1000$\) ，大小满足 \($1 \le val \le 1000$\) 进阶： 空间复杂度 \($\Omicron(n)$\) ， 时间复杂度 \($\Omicron(n\log n)$\) Solutions # Heap # 分别维持一个大根堆和小根堆，大根堆存储 median 左边的元素，小根堆存储 median 右边的元素，每当新来一个元素，优先放在右边小根堆，然后将小根堆堆顶元素放入大根堆。如果右边小根堆元素数量小于左边大根堆元素数量，那么将右边小根堆堆顶元素弹出并压入左边大根堆中，这样就能维持左边大根堆数量至多比右边小根堆数量多一个。
type MedianFinder struct { minHeap MinHeapArr maxHeap MaxHeap } func Constructor() MedianFinder { var minHeap MinHeapArr var maxHeap MaxHeap heap.Init(&amp;amp;minHeap) heap.Init(&amp;amp;maxHeap) return MedianFinder{ minHeap: minHeap, maxHeap: maxHeap, } } func (this *MedianFinder) AddNum(num int) { // 关键还是在这里的调整，这里的调整保证了左边大根堆的元素数量至多比右边小根堆的数量多一个：当元素总数为偶数时，二者相等；为奇数时，左边比右边大 1 heap.</description></item><item><title>42. 连续子数组的最大和</title><link>https://example.com/docs/algs/codingInterviews/42_%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/42_%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</guid><description> Description # 输入一个长度为n的整型数组array，数组中的一个或连续多个整数组成一个子数组，子数组最小长度为1。求所有子数组的和的最大值。
Solutions # Kadane 方法 # 参见这个 链接， 已经有现成的 \($\Omicron(n)$\) 方法。
package main import &amp;#34;math&amp;#34; /** * * @param array int整型一维数组 * @return int整型 */ func FindGreatestSumOfSubArray( array []int ) int { // write code here size := len(array) if size == 0 { return 0 } sum := int(math.MinInt32) res := sum for i := 0; i &amp;lt; size; i++ { sum = max(array[i], sum+array[i]) res = max(res, sum) } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a } 动态规划 # 定义 dp[i] 表示以 i 为结尾的连续子数组的最大和，则很明显，dp[i] 的值受到 dp[i-1] 和 array[i] 的影响，稍微一想即可得到转态转移方程： \($dp[i] = \max (dp[i-1] &amp;#43; array[i], array[i])$\) func FindGreatestSumOfSubArray( array []int ) int { // write code here size := len(array) if size == 0 { return 0 } res := array[0] dp := make([]int, size) dp[0] = array[0] for i := 1; i &amp;lt; size; i++ { dp[i] = max(dp[i-1]+array[i], array[i]) res = max(res, dp[i]) } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a }</description></item><item><title>43. 整数中 1 出现的次数</title><link>https://example.com/docs/algs/codingInterviews/43_%E6%95%B4%E6%95%B0%E4%B8%AD-1-%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/43_%E6%95%B4%E6%95%B0%E4%B8%AD-1-%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</guid><description>Description # 输入一个整数 n ，求 1～n 这 n 个整数的十进制表示中 1 出现的次数 例如， 1~13 中包含 1 的数字有 1 、 10 、 11 、 12 、 13 因此共出现 6 次
注意：11 这种情况算两次
数据范围： \($1 \le n \le 30000$\) 进阶：空间复杂度 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n\log n)$\) Solutions # TODO</description></item><item><title>45. 把数组排成最小的数</title><link>https://example.com/docs/algs/codingInterviews/45_%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/45_%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</guid><description>Description # 输入一个非负整数数组numbers，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 例如输入数组[3，32，321]，则打印出这三个数字能排成的最小数字为321323。 1.输出结果可能非常大，所以你需要返回一个字符串而不是整数 2.拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0
数据范围: \($0&amp;lt;=len(numbers)&amp;lt;=100$\) Solutions # 这里的解法比较巧妙，如果没有做过这个题目的话，第一次碰到应该很难做出来。在 golang 中，我们对数组排序的时候可以指定一个 less 函数，来表明我们希望的排序策略，比如说 4 &amp;lt; 5， 那么 4 应该排在 5 前面。而这里涉及到的是字符串拼接，对于 &amp;ldquo;bc&amp;rdquo; 和 &amp;ldquo;bca&amp;rdquo; 这两个字符串，一般的排序方法会把 bc 排到 bca 前面，这样就会出现 &amp;ldquo;bcbca&amp;rdquo; 这个字符，很明显这不是最小的。这里单独排序一个字符显然是不行的，我们的解决办法是对两个字符的不同拼接进行比较，这样就可以确定什么样的拼接能够放在前面，这样的拼接导致的整体字符串的字典序更小一些。
func PrintMinNumber( numbers []int ) string { // write code here var res string size := len(numbers) if size == 0 { return res } var strs []string for _, value := range numbers { s := strconv.</description></item><item><title>46. 把数字翻译成字符串</title><link>https://example.com/docs/algs/codingInterviews/46_%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/46_%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description> Description # 有一种将字母编码成数字的方式：&amp;lsquo;a&amp;rsquo;-&amp;gt;1, &amp;lsquo;b-&amp;gt;2&amp;rsquo;, &amp;hellip; , &amp;lsquo;z-&amp;gt;26&amp;rsquo;。 我们把一个字符串编码成一串数字，再考虑逆向编译成字符串。 由于没有分隔符，数字编码成字母可能有多种编译结果，例如 11 既可以看做是两个 &amp;lsquo;a&amp;rsquo; 也可以看做是一个 &amp;lsquo;k&amp;rsquo; 。但 10 只可能是 &amp;lsquo;j&amp;rsquo; ，因为 0 不能编译成任何结果。 现在给一串数字，返回有多少种可能的译码结果
Solutions # Recursive # func solve( nums string ) int { // write code here var res int size := len(nums) if size == 0 { return 0 } helper(nums, &amp;amp;res) return res } func helper(nums string, res *int) { size := len(nums) if size == 0 { *res += 1 return } // 如果开头字符是 0， 那么说明只是一次不合法的拆分在，直接返回即可 if nums[0] == &amp;#39;0&amp;#39; { return } // 如果可能将连个字符放在一起，则将两个字符放在一起 if size &amp;gt;= 2 &amp;amp;&amp;amp; nums[:2] &amp;gt;= &amp;#34;10&amp;#34; &amp;amp;&amp;amp; nums[:2] &amp;lt;= &amp;#34;26&amp;#34; { helper(nums[2:], res) } // 永远可以拆分为单个字符 helper(nums[1:], res) } Dynamic Programming # 定义 dp(i) 表示以第 i 位结尾的前缀串翻译的方案数，初始化 dp[0] = dp[1] = 1, 可以得出递推方程： \(dp[i]=\begin{cases} dp[i-2] &amp;#43; dp[i-1], &amp;amp; 10 \le nums[i-2: i] \le 25 \\ dp[i-1], &amp;amp; else \end{cases}\)</description></item><item><title>47. 礼物的最大价值</title><link>https://example.com/docs/algs/codingInterviews/47_%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/47_%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</guid><description> Description # 在一个m\times nm×n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？ 如输入这样的一个二维数组， [ [1,3,1], [1,5,1], [4,2,1] ] 那么路径 1→3→5→2→1 可以拿到最多价值的礼物，价值为12
Solutions # Dynamic Programming # 定义 dp[i][j] 表示在 grid[i][j] 所能得到的最大礼物值，则很明显，dp[i][j]的值要么是从左边转移得到的，要么是从上侧转移得到的，则可以得到递推方程 dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1])。base case 的话，很明显，第一行的数据只能从左边得到，第一列数据只能从上侧得到。我们可以直接复用原数组，这样还能节省一下空间开销。
func maxValue( grid [][]int ) int { // write code here m,n := len(grid), len(grid[0]) // 如果我们开辟一个 (m+1) * (n+1) 的数组，那么下面这两个 for 语句就不需要了，代码可以更加简洁。 // 第一列只能来自上方 for i := 1; i &amp;lt; m; i++ { grid[i][0] += grid[i-1][0] } // 第一行只能来自左边 for i := 1; i &amp;lt; n; i++ { grid[0][i] += grid[0][i-1] } for i := 1; i &amp;lt; m; i++ { for j := 1; j &amp;lt; n; j++ { grid[i][j] = grid[i][j] + max(grid[i-1][j], grid[i][j-1]) } } return grid[m-1][n-1] }</description></item><item><title>48. 最长不含重复字符的子字符串</title><link>https://example.com/docs/algs/codingInterviews/48_%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/48_%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description>Description # 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。 数据范围: \($\text{s.length}\le 40000$\) Solutions # 滑动窗口 # func lengthOfLongestSubstring( s string ) int { // write code here size := len(s) if size &amp;lt;= 1 { return size } res, start := 1, -1 dict := make(map[byte]int) // 这里用等号主要是因为当最后几个字符串都不重复时，如果不在这里加上一个等号，则可能会缺少一次计算，从而导致结果不准确。 // 下面的第一个 if 也是为了跟这种情况搭配才加上的。 for i := 0; i &amp;lt;= size; i++ { if i == size { res = max(res, i - start - 1) break } if index, ok := dict[s[i]]; ok &amp;amp;&amp;amp; index &amp;gt; start { res = max(res, i - start - 1) start = index } dict[s[i]] = i } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a } 下面是上面这种解法的更简介写法：</description></item><item><title>49. 丑数</title><link>https://example.com/docs/algs/codingInterviews/49_%E4%B8%91%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/49_%E4%B8%91%E6%95%B0/</guid><description> Description # 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第 n个丑数。
数据范围： \($0 \le n \le 2000$\) 要求：空间复杂度 \($\Omicron(n)$\) ， 时间复杂度 \($\Omicron(n)$\) Solutions # 很明显丑数只会是可以用 \($2^x*3^y*5^z$\) 表示的一个数字。分别表示从 1 开始乘 2、3、5 的三条丑数队列，每次从这三个丑数队列中取出最小的数字来作为我们当前得到的最小丑数，然后更新那个贡献了这个数字的丑数队列的下一个值。更精简的做法是，我们可以直接维护三个指针 i2、i3、 i5, 来表示这个三个队列。
func GetUglyNumber_Solution( index int ) int { // write code here if index == 0 { return 0 } var i2, i3, i5 int res := make([]int, index) res[0] = 1 for i := 1; i &amp;lt; index; i++ { // 取出当前队列的最小值 res[i] = min(res[i2]*2, min(res[i3]*3, res[i5]*5)) // 如果是这个队列贡献了这个值，那么更新队列元素 if res[i] == res[i2]*2 { i2++ } if res[i] == res[i3] * 3 { i3++ } if res[i] == res[i5] * 5 { i5++ } } return res[index-1] } func min(a,b int) int { if a &amp;lt; b { return a } return b }</description></item><item><title>50. 第一个只出现一次的字符</title><link>https://example.com/docs/algs/codingInterviews/50_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/50_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</guid><description> Description # 在一个长为 字符串中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）
数据范围： \($0 \le n \le 10000$\) ，且字符串只有字母组成。 要求：空间复杂度 \($\Omicron(n)$\) ，时间复杂度 \($\Omicron(n)$\) Solutions # Hash Table # 使用一个 hash table 记录每个字符出现的次数，然后再从头扫描一次 str，遇到第一个出现次数为 1 的字符则返回其下标；否则返回-1.
func FirstNotRepeatingChar( str string ) int { // write code here size := len(str) if size == 0 { return -1 } dict := make(map[byte]int) for idx, _ := range str { dict[str[idx]]++ } for idx, _ := range str { if cnt, _ := dict[str[idx]]; cnt == 1 { return idx } } return -1 }</description></item><item><title>51. 数组中的逆序对</title><link>https://example.com/docs/algs/codingInterviews/51_%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/51_%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</guid><description> Description # 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P mod 1000000007
数据范围： 对于 \($50\%$\) 的数据, \($size \leq 10^4$\) 对于 \($100\%$\) 的数据, \($size\leq 10^5$\) 数组中所有数字的值满足 \($0 \le val \le 1000000$\) 要求：空间复杂度 \($\Omicron(n)$\) ，时间复杂度 \($\Omicron(n \log n)$\) Solutions # 如果两个区间为[4, 3] 和[1, 2], 那么逆序数为(4,1),(4,2),(3,1),(3,2)，同样的如果区间变为有序，比如[3,4] 和 [1,2], 那么逆序数也是一样的，也就是说区间有序和无序结果是一样的。但是区间有序带来的好处是，比如[3,4] 和 [1,2]，如果3 &amp;gt; 1, 显然3后面的所有数都大于1，那么逆序对计算就会方便很多。
Merge Sort # const MOD int = 1000000007 func InversePairs( data []int ) int { // write code here var res int size := len(data) if size &amp;lt;= 1 { return res } tmp := make([]int, size) mergeSort(data, tmp, 0, size-1, &amp;amp;res) return res } func mergeSort(nums,tmp []int, start, end int, res *int) { if start &amp;gt;= end { return } mid := (start + end)/2 mergeSort(nums, tmp, start, mid, res) mergeSort(nums, tmp, mid+1, end, res) merge(nums, tmp, start, mid, end, res) } func merge(nums,tmp []int, start, mid, end int, res *int) { left, right := start, mid+1 var idx int for left &amp;lt;= mid &amp;amp;&amp;amp; right &amp;lt;= end { if nums[left] &amp;gt; nums[right] { tmp[idx] = nums[right] right++ *res += mid - left + 1 *res %= MOD } else { tmp[idx] = nums[left] left++ } idx++ } for left &amp;lt;= mid { tmp[idx] = nums[left] idx++ left++ } for right &amp;lt;= end { tmp[idx] = nums[right] idx++ right++ } for i,k := start, 0; i &amp;lt;= end; i,k = i+1, k+1 { nums[i] = tmp[k] } }</description></item><item><title>52. 两个链表的第一个公共节点</title><link>https://example.com/docs/algs/codingInterviews/52_%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/52_%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</guid><description>Description # 输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）
数据范围： \($n \le 1000$\) 要求：空间复杂度 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n)$\) Solutions # 从两个链表的头节点 pHead1 和 pHead2 开始不断向后遍历，如果 pHead1 遍历到末尾，则从 pHead2 开始继续进行遍历，如果 pHead2 遍历到末尾，则从 pHead1 开始继续进行遍历。这样的话，如果存在公共节点，那么它们就会在第一个公共节点处相遇，此时他们都走过了相同的路程，返回这个节点即可。
func FindFirstCommonNode( pHead1 *ListNode , pHead2 *ListNode ) *ListNode { // write code here p1, p2 := pHead1, pHead2 for p1 != p2 { if p1 == nil { p1 = pHead2 }else { p1 = p1.Next } if p2 == nil { p2 = pHead1 } else { p2 = p2.</description></item><item><title>53. 数字在升序数组中出现的次数</title><link>https://example.com/docs/algs/codingInterviews/53_%E6%95%B0%E5%AD%97%E5%9C%A8%E5%8D%87%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/53_%E6%95%B0%E5%AD%97%E5%9C%A8%E5%8D%87%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</guid><description> Description # 给定一个长度为 n 的非降序数组和一个非负数整数 k ，要求统计 k 在数组中出现的次数
数据范围： \($0 \le n \le 1000 $\) , \($0 \le k \le 100$\) ，数组中每个元素的值满足 \($0 \le val \le 100$\) . 要求：空间复杂度 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(\log n)$\) Solutions # Binary Search # func GetNumberOfK( data []int , k int ) int { // write code here var res int size := len(data) if size &amp;lt; 1 { return res } left, right := 0, size - 1 for left &amp;lt;= right { mid := (left +right)/2 if data[mid] &amp;gt; k { right = mid - 1 } else if data[mid] &amp;lt; k { left = mid + 1 } else if data[mid] == k { l,r := mid, mid for l &amp;gt;= 0 &amp;amp;&amp;amp; data[l] == k { l-- } for r &amp;lt; size &amp;amp;&amp;amp; data[r] == k { r++ } res = r - l - 1 break } } return res }</description></item><item><title>54. 二叉搜索树的第 k 个节点</title><link>https://example.com/docs/algs/codingInterviews/54_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/54_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9/</guid><description>Description # 给定一棵结点数为n 二叉搜索树，请找出其中的第 k 小的TreeNode结点值。 1.返回第k小的节点值即可 2.不能查找的情况，如二叉树为空，则返回-1，或者k大于n等等，也返回-1 3.保证n个节点的值不一样
数据范围： \($0 \le n \le1000$\) ， \($0 \le k \le1000$\) ，树上每个结点的值满足 \($0 \le val \le 1000$\) 进阶：空间复杂度 \($\Omicron(n)$\) ，时间复杂度 \($\Omicron(n)$\) Solutions # 很简单，中序遍历求第 k 个节点即可。
func KthNode( proot *TreeNode , k int ) int { // write code here if proot == nil { return -1 } var stack []*TreeNode cur := proot for cur != nil || len(stack) != 0 { for cur !</description></item><item><title>55. 二叉树的深度</title><link>https://example.com/docs/algs/codingInterviews/55_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/55_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</guid><description> Description # 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度，根节点的深度视为 1 。
数据范围：节点的数量满足 \($0 \le n \le 100$\) ，节点上的值满足 \($0 \le val \le 100$\) 进阶：空间复杂度 \($\Omciron(1)$\) ，时间复杂度 \($\Omicron(n)$\) Solutions # 简单题，不多说直接上代码。
func TreeDepth( pRoot *TreeNode ) int { // write code here if pRoot == nil { return 0 } return max(TreeDepth(pRoot.Left), TreeDepth(pRoot.Right)) + 1 } func max(a, b int) int { if a &amp;lt; b { return b } return a }</description></item><item><title>56. 数组中只出现一次的两个数字</title><link>https://example.com/docs/algs/codingInterviews/56_%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/56_%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</guid><description>Description # 一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
数据范围：数组长度 \($2\le n \le 1000$\) ，数组中每个数的大小 \($0 &amp;lt; val \le 1000000$\) 要求：空间复杂度 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n)$\) 提示：输出时按非降序排列。
Solutions # Hash Table # 建立一个哈希表，对每个出现的数字计数，最后将只出现一次的数字返回即可。
// 使用哈希表 func FindNumsAppearOnce( array []int ) []int { dict := make(map[int]int) for _, value := range nums { dict[value]++ } var res []int for value, count := range dict { if count == 1 { res = append(res, value) } } if len(res) == 2 &amp;amp;&amp;amp; res[1] &amp;lt; res[0] { res[0], res[1] = res[1], res[0] } return res } 位运算 # 如果只要一个数字是不同的，那么很容易计算，只需要直接对整个数组计算异或值即可，这个异或值即为我们所求。但是这里有两个不同值，那么怎么办呢？方法就是对他们进行分组（这里不需要两个组的元素数量相同），将两个不同的值分到不同的组里面，而且还要把相同的值分到同一个组里面，这样分别对两个不同的组进行异或计算，得到的两个值就是我们所求的两个数。</description></item><item><title>57. 和为 S 的两个数字</title><link>https://example.com/docs/algs/codingInterviews/57_%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/57_%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</guid><description> Description # 输入一个升序数组 array 和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，返回任意一组即可，如果无法找出这样的数字，返回一个空数组即可。
数据范围: \($0 \le len(array) \le 10^5$\) , \($1 \le array[i] \le 10^6$\) Solutions # func FindNumbersWithSum( array []int , sum int ) []int { // write code here size := len(array) if size &amp;lt;= 1 { return nil } left, right := 0, size -1 for left &amp;lt; right { if array[left] + array[right] == sum { return []int{array[left], array[right]} } else if array[left] + array[right] &amp;lt; sum { left++ } else if array[left] + array[right] &amp;gt; sum { right-- } } return nil }</description></item><item><title>58. 左旋转字符串</title><link>https://example.com/docs/algs/codingInterviews/58_%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/58_%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description>Description # 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列 S ，请你把其循环左移 K 位后的序列输出。例如，字符序列 S = ”abcXYZdef” , 要求输出循环左移 3 位后的结果，即 “XYZdefabc”
数据范围：输入的字符串长度满足 \($0 \le len \le 100$\) ， \($0 \le n \le 100$\) 进阶：空间复杂度 \($\Omicron(n)$\) ，时间复杂度 \($\Omicron(n)$\) Solutions # 字符串拼接 # func LeftRotateString( str string , n int ) string { // write code here size := len(str) if size == 0 || n%size == 0 { return str } n %= size // n 可能会大于 size，所以需要取余 left, right := str[:n], str[n:] return right+left } 字符串翻转 # 先将整个字符串翻转一次，然后再将从左边开始数的 size - n 个字符翻转一次，最后再将右边剩余的 n 个字符翻转一次。</description></item><item><title>59. 滑动窗口的最大值</title><link>https://example.com/docs/algs/codingInterviews/59_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/59_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</guid><description> Description # 给定一个长度为 n 的数组 nums 和滑动窗口的大小 size ，找出所有滑动窗口里数值的最大值。
例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。
Solutions # Dequeue # 使用一个单调递减的单调队列来做。维持一个最大长度为 size 的单调队列，每当遍历到当前元素 i，如果当前元素 nums[i] 比队列尾部元素要大，则不断将队列尾部元素出队，直到队列为空或者当前元素 nums[i] 比队尾元素要小，然后将当前元素入队。这样的话，队列中要么维持着一个最大值，要么顶多维持着 size 个相对递减的连续值。然后检查队首元素是否过期，如果过期，则将队首元素出队，因为我们每次顶多入队一个，所以每次遍历也顶多只会有一个元素过期。最后检查当前窗口长度是否达到 size，如果达到了，则将队列首部元素入队即可。
// 可以使用单调递减的单调队列来实现 func maxInWindows( num []int , size int ) []int { // write code here var res []int n := len(num) if size &amp;lt; 1 || n &amp;lt; 1 { return res } var queue []int for i := 0; i &amp;lt; n; i++ { // 如果当前遍历到的元素比队尾元素要大，则不断将队尾元素出队 curLen := len(queue) for curLen &amp;gt; 0 &amp;amp;&amp;amp; num[i] &amp;gt; num[queue[curLen-1]] { curLen-- queue = queue[:curLen] } queue = append(queue, i) // 如果当前队首元素滑出左边界，则将其删除 if queue[0] + size &amp;lt;= i { queue = queue[1:] } // 如果当前已经构成了一个有效的滑动窗口，则将当前最大值存入结果 if size &amp;lt;= i+1 { res = append(res, num[queue[0]]) } } return res }</description></item><item><title>61. 扑克牌顺子</title><link>https://example.com/docs/algs/codingInterviews/61_%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/61_%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/</guid><description> Description # 现在有2副扑克牌，从扑克牌中随机五张扑克牌，我们需要来判断一下是不是顺子。 有如下规则：
A为1，J为11，Q为12，K为13，A不能视为14 大、小王为 0，0可以看作任意牌 如果给出的五张牌能组成顺子（即这五张牌是连续的）就输出true，否则就输出false。 4.数据保证每组5个数字，每组最多含有4个零，数组的数取值为 [0, 13] 要求：空间复杂度 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n \log n)$\) ，本题也有时间复杂度 \($\Omicron(n)$\) 的解法
Solutions # 建立一个大小为14 的数组，记录每只牌出现的次数。然后从 1 开始遍历这个数组直到第一只计数值为 1 的牌，如果任意一只牌的计数值大于 1，则返回 false；然后从这只牌开始模拟，如果以这只牌开始的五只牌都能构成顺子，则返回 true；否则
func IsContinuous( numbers []int ) bool { // write code here // 记录每只牌出现的次数 emu := make([]int, 14) for _, value := range numbers { emu[value]++ } for i := 1; i &amp;lt; 14; i++ { // 任意一只牌的出现次数大于 1，则无法构成顺子 if emu[i] &amp;gt; 1 { return false } // 如果这只牌只出现了一次，那么检查能不能构成顺子 if emu[i] == 1 { // 顶多检查五只牌 for j := i; i+5 &amp;lt; 14 &amp;amp;&amp;amp; j &amp;lt; i+5; j++ { // 任何一只牌出现次数大于 1，则返回 false if emu[j] &amp;gt; 1 { return false } // 如果当前牌只出现了一次，则继续遍历 if emu[j] == 1 { continue } // 如果当前牌没有出现，则看 0 是否还有剩余，如果有，则继续遍历；如果没有，则返回 false if emu[j] == 0 { if emu[0] &amp;gt; 0 { emu[0]-- continue } else { return false } } } // 以 i 开头的牌组可以成为顺子，返回 true return true } } // 没有找到任何一个顺子，返回 false return false }</description></item><item><title>62. 圆圈中最后剩下的数</title><link>https://example.com/docs/algs/codingInterviews/62_%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/62_%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0/</guid><description>Description # 每年六一儿童节，牛客都会准备一些小礼物和小游戏去看望孤儿院的孩子们。其中，有个游戏是这样的：首先，让 n 个小朋友们围成一个大圈，小朋友们的编号是0~n-1。然后，随机指定一个数 m ，让编号为0的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始，继续0&amp;hellip; m-1报数&amp;hellip;.这样下去&amp;hellip;.直到剩下最后一个小朋友，可以不用表演，并且拿到牛客礼品，请你试着想下，哪个小朋友会得到这份礼品呢？
Solutions # 循环链表模拟 # 可以将元素串成一个循环链表，然后进行遍历即可。
使用数组模拟 # 用数组求解的基本思想就是用一个一维数组去标识这 n 个人的状态，默认全为 1 ，也就是都在圈子内，当数到 m 的人出圈之后，标识置为 0（就是出圈了），同时报数器清 0，下一个人要从 1 开始。在每次报数之前要判断他是否在圈子内（也就是他的标识是否为 1 ），如果在圈子里面才会继续报数。定义一个变量记录出圈的人数， 出圈的人数等于 n-1 时，则游戏结束。</description></item><item><title>63. 买卖股票的最好时机</title><link>https://example.com/docs/algs/codingInterviews/63_%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A5%BD%E6%97%B6%E6%9C%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/63_%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A5%BD%E6%97%B6%E6%9C%BA/</guid><description> Description # 假设你有一个数组prices，长度为n，其中prices[i]是股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益 1.你可以买入一次股票和卖出一次股票，并非每天都可以买入或卖出一次，总共只能买入和卖出一次，且买入必须在卖出的前面的某一天 2.如果不能获取到任何利润，请返回0 3.假设买入卖出均无手续费
Solutions # 一次扫描，扫描过程中维护当前扫描到的数字的最小值，然后不断的用当前扫描到的数字减去这个最小得到一个差，取这个差的最大值即可。
func maxProfit( prices []int ) int { // write code here var res int size := len(prices) if size == 0 { return res } curMin := prices[0] for _, price := range prices { if price &amp;lt; curMin { curMin = price } res = max(res, price-curMin) } return res }</description></item><item><title>65. 不用加减乘除做加法</title><link>https://example.com/docs/algs/codingInterviews/65_%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/65_%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</guid><description> Description # 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。
数据范围：两个数都满足 \($-10 \le n \le 1000$\) 进阶：空间复杂度 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(1)$\) Solutions # Bit Manipulation # 使用位与操作表示两数相加的进位（需要左移一位）， 使用异或操作表示两数相加的和，这样就可以递归计算，递归终止条件是进位为 0.
func Add( num1 int , num2 int ) int { // write code here if num1 == 0 { return num2 } carry := (num1 &amp;amp; num2) &amp;lt;&amp;lt; 1 sum := num1 ^ num2 return Add(carry, sum) }</description></item><item><title>67. 把字符串转成整数(atoi)</title><link>https://example.com/docs/algs/codingInterviews/67_%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%88%90%E6%95%B4%E6%95%B0atoi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/67_%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%88%90%E6%95%B4%E6%95%B0atoi/</guid><description> Description # 写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。传入的字符串可能有以下部分组成: 1.若干空格 2.（可选）一个符号字符（&amp;rsquo;+&amp;rsquo; 或 &amp;lsquo;-&amp;rsquo;） 3. 数字，字母，符号，空格组成的字符串表达式 4. 若干空格
转换算法如下: 1.去掉无用的前导空格 2.第一个非空字符为+或者-号时，作为该整数的正负号，如果没有符号，默认为正数 3.判断整数的有效部分： 3.1 确定符号位之后，与之后面尽可能多的连续数字组合起来成为有效整数数字，如果没有有效的整数部分，那么直接返回0 3.2 将字符串前面的整数部分取出，后面可能会存在存在多余的字符(字母，符号，空格等)，这些字符可以被忽略，它们对于函数不应该造成影响 3.3 整数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231的整数应该被调整为 −231 ，大于 231 − 1 的整数应该被调整为 231 − 1 4.去掉无用的后导空格
Solutions #</description></item><item><title>67. 构建乘积数组</title><link>https://example.com/docs/algs/codingInterviews/66_%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/66_%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</guid><description> Description # 给定一个数组 A[0,1,&amp;hellip;,n-1] ,请构建一个数组 B[0,1,&amp;hellip;,n-1] ,其中 B 的元素 B[i]=A[0]A[1]&amp;hellip;*A[i-1]A[i+1]&amp;hellip;*A[n-1]（除 A[i] 以外的全部元素的的乘积）。程序中不能使用除法。（注意：规定 B[0] = A[1] * A[2] * &amp;hellip; * A[n-1]，B[n-1] = A[0] * A[1] * &amp;hellip; * A[n-2]） 对于 A 长度为 1 的情况，B 无意义，故而无法构建，用例中不包括这种情况。
数据范围： \($1 \le n \le 10$\) ，数组中元素满足 \($|val| \le 10$\) Solutions # Array # 使用两个数组，一个数组left从左到右扫描，left[i] 表示从 A 数组开始位置到 i 位置之前的元素的累乘；一个数组 right 从右向左扫描， right[i] 表示从数组最后一个位置到 i 位置的累乘。最后复用 left ，left[i] *= right[i]， left 即为所求。
func multiply( A []int ) []int { // write code here size := len(A) if size &amp;lt;= 1 { return nil } left, right := make([]int, size), make([]int, size) left[0], right[size-1] = 1, 1 for i := 1; i &amp;lt; size; i++ { left[i] = A[i-1] * left[i-1] } for i := size-2; i &amp;gt;= 0; i-- { right[i] = A[i+1] * right[i+1] } for i := 0; i &amp;lt; size; i++ { left[i] *= right[i] } return left }</description></item><item><title>68. 二叉搜索树的最近公共祖先</title><link>https://example.com/docs/algs/codingInterviews/68_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/68_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid><description>Description # 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
Solutions # Recursive # 如果当前节点的值比要查找的值的最小值还要小，说明应该往当前节点的右节点进行查找；如果当前节点的值比要查找的值的最大值还要大，说明应该往当前节点的左子树进行查找。否则说明当前节点处于要查找的值之间，那么当前节点就是我们要查找的最近公共祖先。
func lowestCommonAncestor( root *TreeNode , p int , q int ) int { // write code here if root == nil { return -1 } // 保持 p 比 q 要小 if p &amp;gt; q { p,q = q, p } res := lcaHelper(root, p, q) return res.Val } func lcaHelper(root *TreeNode, mn,mx int) *TreeNode { if root.Val &amp;gt; mx { return lcaHelper(root.</description></item><item><title>70. 矩形覆盖</title><link>https://example.com/docs/algs/codingInterviews/70_%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/70_%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/</guid><description> Description # 我们可以用 21 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 21 的小矩形无重叠地覆盖一个 2*n 的大矩形，从同一个方向看总共有多少种不同的方法？
数据范围： \($0 \le n \le 38$\) 进阶：空间复杂度 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n)$\) 注意：约定 n == 0 时，输出 0
Solutions # 举例可以发现这其实也是个斐波那契数列问题。
func rectCover( number int ) int { // write code here if number &amp;lt;= 3 { return number } NMinusTwo, NMinusOne := 2, 3 for i := 4; i &amp;lt;= number; i++ { N := NMinusOne + NMinusTwo NMinusTwo = NMinusOne NMinusOne = N } return NMinusOne }</description></item><item><title>70. 跳台阶</title><link>https://example.com/docs/algs/codingInterviews/69_%E8%B7%B3%E5%8F%B0%E9%98%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/69_%E8%B7%B3%E5%8F%B0%E9%98%B6/</guid><description> Description # 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
数据范围： \($1 \leq n \leq 40$\) 要求：时间复杂度： \($\Omicron(n)$\) ，空间复杂度： \($\Omicron(1)$\) Solutions # 动态规划 # func jumpFloor( number int ) int { // write code here if number &amp;lt;= 1 { return number } NMinusTwo, NMinusOne := 0, 1 for i := 1; i &amp;lt;= number; i++ { n := NMinusOne + NMinusTwo NMinusTwo = NMinusOne NMinusOne = n } return NMinusOne }</description></item><item><title>71. 跳台阶扩展问题</title><link>https://example.com/docs/algs/codingInterviews/71_%E8%B7%B3%E5%8F%B0%E9%98%B6%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/71_%E8%B7%B3%E5%8F%B0%E9%98%B6%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98/</guid><description> Description # 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶(n为正整数)总共有多少种跳法。
Solutions # Math # 其实可以通过举例来发现规律: \($f(n) = 2 * f(n-1) (n &amp;gt; 2)$\) ，如果 \($0 \le n \le 2$\) ，则直接返回 n 即可。
func jumpFloorII( number int ) int { // write code here if number &amp;lt;= 2 { return number } return int(math.Pow(2, float64(number-1))) }</description></item><item><title>73. 翻转单词序列</title><link>https://example.com/docs/algs/codingInterviews/73_%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/73_%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97/</guid><description>Description # 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“nowcoder. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a nowcoder.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？
Solutions # 先翻转整个句子，然后再针对每个空格分割的单词单独翻转。
func ReverseSentence( str string ) string { // write code here size := len(str) if size &amp;lt;= 1 { return str } runes := []rune(str) size = len(runes) // 先翻转整个字符串 for left,right := 0, size-1; left &amp;lt; right; left,right = left+1, right-1 { runes[left],runes[right] = runes[right], runes[left] } // 再翻转这个字符串里的每个单词 var left, right int for right &amp;lt;= size { for right &amp;lt; size &amp;amp;&amp;amp; runes[right] !</description></item><item><title>74. 和为 S 的连续正数序列</title><link>https://example.com/docs/algs/codingInterviews/74_%E5%92%8C%E4%B8%BA-S-%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/74_%E5%92%8C%E4%B8%BA-S-%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</guid><description> Description # 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列?
数据范围： \($0 &amp;lt; n \le 100$\) 进阶：时间复杂度 \($\Omicron(n)$\) Solutions # Sliding Window # 从某一个数字开始的连续序列和等于目标数如果有，只能有一个，于是我们可以用这个性质来使区间滑动。
使用滑动窗口，left 指向窗口左边，right 指向窗口右边，初始时 left 和 right 分别等于 1 和 2.然后计算 [left, right] 这个区间的数字的和，如果和刚好等于 sum，则将这些数字存入 res；如果和大于 sum，说明窗口中元素太多了，需要收缩左窗口；如果和小于 sum，说明窗口中元素太少了，需要收缩右窗口。
func FindContinuousSequence( sum int ) [][]int { // write code here var res [][]int left, right := 1, 2 for left &amp;lt; right { s := (left+right) * (right - left+1)/2 if s == sum { var tmp []int for i := left; i &amp;lt;= right; i++ { tmp = append(tmp, i) } res = append(res, tmp) left++ } else if s &amp;gt; sum { left++ } else if s &amp;lt; sum { right++ } } return res }</description></item><item><title>75. 字符流中第一个不重复出现的字符</title><link>https://example.com/docs/algs/codingInterviews/75_%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/75_%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/</guid><description> Description # 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 &amp;ldquo;go&amp;rdquo; 时，第一个只出现一次的字符是 &amp;ldquo;g&amp;rdquo; 。当从该字符流中读出前六个字符 “google&amp;quot; 时，第一个只出现一次的字符是&amp;quot;l&amp;quot;。
数据范围：字符串长度满足 \($1 \le n \le 1000$\) ，字符串中出现的字符一定在 ASCII 码内。 进阶：空间复杂度 \($\Omicron(n)$\) ，时间复杂度 \($\Omicron(n)$\) Solutions # var dict = make(map[byte]int) var bs []byte func Insert(ch byte) { bs = append(bs, ch) dict[ch]++ } func FirstAppearingOnce() byte { for _, ch := range bs { if cnt, _ := dict[ch]; cnt == 1 { return ch } } return byte(&amp;#39;#&amp;#39;) }</description></item><item><title>76. 删除链表中重复的节点</title><link>https://example.com/docs/algs/codingInterviews/76_%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/76_%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9/</guid><description>Description # 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表 1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5 处理后为 1-&amp;gt;2-&amp;gt;5
数据范围：链表长度满足 \($0 \le n \le 1000$\) ，链表中的值满足 \($1 \le val \le 1000$\) 进阶：空间复杂度 \($\Omicron(n)$\) ，时间复杂度 \($\Omicron(n)$\) Solutions # 并不难，但是要注意虚拟头结点的使用。
func deleteDuplication( pHead *ListNode ) *ListNode { // write code here if pHead == nil { return nil } // 增加一个虚拟头结点，方便头结点的删除 dummyHead := new(ListNode) dummyHead.Next = pHead pre , cur := dummyHead, pHead for cur != nil { if cur.Next != nil &amp;amp;&amp;amp; cur.</description></item><item><title>77. 按之字形顺序打印二叉树</title><link>https://example.com/docs/algs/codingInterviews/77_%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/77_%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>Description # 给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）
数据范围： \($0 \le n \le 1500$\) ,树上每个节点的val满足 \($|val| \le 1500$\) 要求：空间复杂度： \($\Omicron(n)$\) ，时间复杂度： \($\Omicron(n)$\) Solutions # 就是一个树的层次遍历，不多说。
func Print( pRoot *TreeNode ) [][]int { // write code here var res [][]int if pRoot == nil { return res } var queue []*TreeNode queue = append(queue, pRoot) var reverse bool for len(queue) != 0 { size := len(queue) var arr []int for i := 0; i &amp;lt; size; i++ { top := queue[i] arr = append(arr, top.</description></item><item><title>78. 把二叉树打印成多行</title><link>https://example.com/docs/algs/codingInterviews/78_%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/78_%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/</guid><description>Description # 给定一个节点数为 n 二叉树，要求从上到下按层打印二叉树的 val 值，同一层结点从左至右输出，每一层输出一行，将输出的结果存放到一个二维数组中返回。
Solutions # Level Order Traversal # 简单题，只需要进行一次层次遍历即可。
func Print( pRoot *TreeNode ) [][]int { // write code here var res [][]int if pRoot == nil { return res } var queue []*TreeNode queue = append(queue, pRoot) for len(queue) != 0 { size := len(queue) var level []int for i := 0; i &amp;lt; size; i++ { node := queue[i] level = append(level, node.</description></item><item><title>79. 判断是不是平衡二叉树</title><link>https://example.com/docs/algs/codingInterviews/79_%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/79_%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>Description # 输入一棵节点数为 n 二叉树，判断该二叉树是否是平衡二叉树。 在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树 平衡二叉树（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
Solutions # 这里需要注意，光判断根节点是否是平衡二叉树是不够的，还需要对每个子树都做相应的判断。注意这里的解法跟 26 题的相似性。
func IsBalanced_Solution( pRoot *TreeNode ) bool { // write code here if pRoot == nil { return true } if !isBalanced(getTreeHeight(pRoot.Left), getTreeHeight(pRoot.Right)) { return false } return IsBalanced_Solution(pRoot.Left) &amp;amp;&amp;amp; IsBalanced_Solution(pRoot.Right) } func isBalanced(a, b int) bool { if a &amp;gt;b { a, b = b, a } return b - a &amp;lt;= 1 } func getTreeHeight(root *TreeNode) int { if root == nil { return 0 } return max(getTreeHeight(root.</description></item><item><title>81. 调整数组顺序使奇数位于偶数前面 II</title><link>https://example.com/docs/algs/codingInterviews/81_%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/81_%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2II/</guid><description> Description # 输入一个长度为 n 整数数组，数组里面可能含有相同的元素，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前面部分，所有的偶数位于数组的后面部分，对奇数和奇数，偶数和偶数之间的相对位置不做要求，但是时间复杂度和空间复杂度必须如下要求。
数据范围： \($0 \le n \le 50000$\) ，数组中每个数的值 \($0 \le val \le 10000$\) 要求：时间复杂度 \($\Omicron(n)$\) ，空间复杂度 \($\Omicron(1)$\) Solutions # 参考快速排序将小于 pivot 的元素放在左侧，将大于 pivot 的元素放在右侧的做法。这里使用两个指针left和 right，分别指向数组开头和末尾，然后 left 不断向右遍历，直到查找到偶数元素停止，然后 right 不断向左遍历，直到查找到奇数元素停止，然后交换 left 和 right 指向的元素，这样就把奇数放在了左侧，偶数放在了右侧，然后继续遍历，直到 left 和 right 重叠为止。
func reOrderArrayTwo( array []int ) []int { // write code here size := len(array) if size &amp;lt;= 1 { return array } left, right := 0, size -1 for left &amp;lt; right { for left &amp;lt; right &amp;amp;&amp;amp; array[left] % 2 == 1 { left++ } for left &amp;lt; right &amp;amp;&amp;amp; array[right] % 2 == 0 { right-- } array[left], array[right] = array[right], array[left] left++ right-- } return array }</description></item><item><title>82. 二叉树中和为某一值的路径（一）</title><link>https://example.com/docs/algs/codingInterviews/82_%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E4%B8%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/82_%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E4%B8%80/</guid><description>Description # 给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。 1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点 2.叶子节点是指没有子节点的节点 3.路径只能从父节点到子节点，不能从子节点到父节点 4.总节点数目为n
Solutions # 因为这里的路径是从根节点开始的，所以也很简单，直接递归回溯即可。
func hasPathSum( root *TreeNode , sum int ) bool { // write code here if root == nil { return false } var stack []*TreeNode var num int cur := root for cur != nil || len(stack) != 0 { for cur != nil { num += cur.Val stack = append(stack, cur) cur = cur.Left } if num == sum &amp;amp;&amp;amp; cur == nil { return true } size := len(stack) cur = stack[size-1] stack = stack[:size-1] if cur.</description></item><item><title>84. 二叉树中和为某一值的路径 III</title><link>https://example.com/docs/algs/codingInterviews/84_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84III/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/84_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84III/</guid><description>Description # 给定一个二叉树root和一个整数值 sum ，求该树有多少路径的的节点值之和等于 sum 。 1.该题路径定义不需要从根节点开始，也不需要在叶子节点结束，但是一定是从父亲节点往下到孩子节点 2.总节点数目为n 3.保证最后返回的路径个数在整形范围内(即路径个数小于 \($2^{31}$\) -1)
Solutions # 注意，这里的路径不一定需要从根节点开始，也不一定需要在叶节点结束。
Recursice # 核心思想就是，每个节点都可能是一条路径的起始节点，所以每个节点都需要作为根节点来遍历一次。
var res int func FindPath( root *TreeNode , sum int ) int { // write code here if root == nil { return res } findPathHelper(root, sum) // 每个节点都需要作为根节点来进行一次查找 FindPath(root.Left, sum) FindPath(root.Right, sum) return res } func findPathHelper(root *TreeNode, sum int) { if root == nil { return } // 注意这里的小技巧 if sum == root.</description></item><item><title>85. 连续子数组的最大和 II</title><link>https://example.com/docs/algs/codingInterviews/85_%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/85_%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C-II/</guid><description>Description # 输入一个长度为n的整型数组array，数组中的一个或连续多个整数组成一个子数组，找到一个具有最大和的连续子数组。 1.子数组是连续的，比如[1,3,5,7,9]的子数组有[1,3]，[3,5,7]等等，但是[1,3,7]不是子数组 2.如果存在多个最大和的连续子数组，那么返回其中长度最长的，该题数据保证这个最长的只存在一个 3.该题定义的子数组的最小长度为1，不存在为空的子数组，即不存在[]是某个数组的子数组 4.返回的数组不计入空间复杂度计算
Solutions # Kadane 方法 # 详情参见 42 题的 「连续子数组的最大和」，这个方法跟那个方法是同一个思路。
func FindGreatestSumOfSubArray( array []int ) []int { // write code here size := len(array) if size == 0 { return nil } var start, end int res, sum := array[0],array[0] for i := 1; i &amp;lt; size; i++ { // 这里的 start 可能会在不断的向右扩张，而 end 只有在 sum 比 res 大的时候才会扩展，所以可能会出现 start 比 end 大的情况。 if array[i] &amp;gt; sum + array[i] { start = i } sum = max(array[i], sum+array[i]) if sum &amp;gt;= res { res = sum end = i } } // 当 start 不断向前推进时，可能会出现 start 大于 end 的情况，这个时候需要重置 start 的值 if start &amp;gt; end { start = end } return array[start: end+1] } func max(a,b int) int { if a &amp;lt; b { return b } return a } 上面的这个解法的优化, 这个方法其实也可以改成动态规划的方法，只需要将 sum 替换成 dp[i] 即可。</description></item><item><title>86. 二叉树中两个节点的最近公共祖先</title><link>https://example.com/docs/algs/codingInterviews/86_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/86_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid><description>Description # 给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。
数据范围：树上节点数满足 \($1 \le n \le 10^5$\) , 节点值val满足区间 [0,n) 要求：时间复杂度 \($\Omicron(n)$\) Solutions # Recursive # 具体解释看注释即可。
func lowestCommonAncestor( root *TreeNode , o1 int , o2 int ) int { // write code here if root == nil { return -1 } res := lcaHelper(root, o1, o2) return res.Val } func lcaHelper(root *TreeNode, o1, o2 int) *TreeNode { // 如果已经遍历到空节点或者已经找到其中一个节点，则返回该节点 if root == nil || root.</description></item></channel></rss>