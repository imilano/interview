<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Interview</title><link>https://example.com/docs/algs/codingInterviews/</link><description>Recent content on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/docs/algs/codingInterviews/index.xml" rel="self" type="application/rss+xml"/><item><title>10. 斐波那契数列</title><link>https://example.com/docs/algs/codingInterviews/10_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/10_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</guid><description>Description # 输入一个正整数 n ，请你输出斐波那契数列的第 n 项
Solutions # 简单题，简单的动态规划。
func Fibonacci( n int ) int { // write code here if n &amp;lt;= 2 { return 1 } NMinusOne, NMinusTwo := 1, 1 for i := 3; i &amp;lt;= n; i++ { N := NMinusOne + NMinusTwo NMinusTwo = NMinusOne NMinusOne = N } return NMinusOne }</description></item><item><title>11. 旋转数组的最小数字</title><link>https://example.com/docs/algs/codingInterviews/11_%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/11_%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</guid><description>Descriptioin # 有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。
数据范围：$1 \le n \le 10000$，数组中任意元素的值: $0 \le val \le 10000$。 要求：空间复杂度：$\Omicron(1)$ ，时间复杂度：$\Omicron(\log n)$
Solutions # Binary Search # 二分查找，使用两个指针 left 和 right 分别指向数组的待查找序列的左侧和右侧，则：
如果中间元素比右侧元素小，那么向左查找，即 right = mid 如果中间元素比右侧元素大，那么向右查找， 即 left = mid + 1 如果中间元素等于右侧元素，那么最小元素即可能在左边，也可能在右边，则可以搜索右边界 最后返回 left 指向的元素即可。 func minNumberInRotateArray( nums []int ) int { // write code here var res int size := len(nums) if size == 0 { return res } left, right := 0, size -1 for left &amp;lt; right { mid := (left+right)/2 if nums[mid] &amp;gt; nums[right] { left = mid + 1 } else if nums[mid] &amp;lt; nums[right] { right = mid } else if nums[mid] == nums[right] { right = right -1 } } return nums[left] }</description></item><item><title>12. 矩阵中的路径</title><link>https://example.com/docs/algs/codingInterviews/12_%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/12_%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</guid><description>Description # 请设计一个函数，用来判断在一个n乘m的矩阵中是否存在一条包含某长度为len的字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如: $\begin{bmatrix} a &amp;amp; b &amp;amp; c &amp;amp;e \ s &amp;amp; f &amp;amp; c &amp;amp; s \ a &amp;amp; d &amp;amp; e&amp;amp; e\ \end{bmatrix}\quad$
矩阵中包含一条字符串&amp;quot;bcced&amp;quot;的路径，但是矩阵中不包含&amp;quot;abcb&amp;quot;路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 数据范围：$0 \le n,m \le 20$ ,$1\le len \le 25$
Solutions # Backtracing # func hasPath( matrix [][]byte , word string ) bool { // write code here n,m := len(matrix), len(matrix[0]) for i := 0; i &amp;lt; n; i++ { for j := 0; j &amp;lt; m; j++ { // 剪枝 if word[0] == matrix[i][j] &amp;amp;&amp;amp; helper(matrix, word, i, j, n, m) { return true } } } return false } func helper(matrix [][]byte, word string, x,y,n,m int) bool { size := len(word) // 这里之所以可以直接取 word[0] 而不用判断数组越界，主要是因为下面第二个 if 语句会保证进入递归的 word 一定不是空串 if x &amp;lt; 0 || x &amp;gt;= n || y &amp;lt; 0 || y &amp;gt;= m || matrix[x][y] == &amp;#39;.</description></item><item><title>13. 机器人的运动范围</title><link>https://example.com/docs/algs/codingInterviews/13_%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/13_%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</guid><description>Description # 地上有一个 rows 行和 cols 列的方格。坐标从 [0,0] 到 [rows-1,cols-1] 。一个机器人从坐标 [0,0] 的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 threshold 的格子。 例如，当 threshold 为 18 时，机器人能够进入方格 [35,37] ，因为 3+5+3+7 = 18。但是，它不能进入方格 [35,38] ，因为 3+5+3+8 = 19 。请问该机器人能够达到多少个格子？
数据范围： $0 \le threshold \le 15$，$1 \le rows,cols \le 100$
Solutions # func movingCount( threshold int , rows int , cols int ) int { // write code here if rows &amp;lt;= 0 || cols &amp;lt;= 0 || threshold &amp;lt; 0 { return 0 } visited := make([][]bool, rows) for idx, _ := range visited { visited[idx] = make([]bool, cols) } return helper(threshold, rows, cols, 0, 0, &amp;amp;visited) } func helper(threshold int, rows int,cols int, row int, col int, visited *[][]bool) int { t := pathSum(row) + pathSum(col) if row &amp;lt; 0 || row &amp;gt;= rows || col &amp;lt; 0 || col &amp;gt;= cols || (*visited)[row][col] || t &amp;gt; threshold { return 0 } (*visited)[row][col] = true return 1 + helper(threshold, rows, cols, row+1, col, visited) + helper(threshold, rows, cols, row-1, col, visited) + helper(threshold, rows, cols, row, col+1, visited) + helper(threshold, rows, cols, row, col-1, visited) } func pathSum(num int) int { var sum int for num !</description></item><item><title>28. 对称的二叉树</title><link>https://example.com/docs/algs/codingInterviews/28_%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/28_%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>Description # 给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）
Solutions # Recursive # func isSymmetrical( pRoot *TreeNode ) bool { // write code here if pRoot == nil { return true } return isSameTree(pRoot.Left, pRoot.Right) } func isSameTree(root1, root2 *TreeNode) bool { if root1 == nil &amp;amp;&amp;amp; root2 == nil { return true } if root1 == nil || root2 == nil { return false } if root1.</description></item><item><title>30. 包含 min 函数的栈</title><link>https://example.com/docs/algs/codingInterviews/30_%E5%8C%85%E5%90%AB-min-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/30_%E5%8C%85%E5%90%AB-min-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</guid><description>Description # 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数，输入操作时保证 pop、top 和 min 函数操作时，栈中一定有元素。
此栈包含的方法有： push(value):将value压入栈中 pop():弹出栈顶元素 top():获取栈顶元素 min():获取栈中最小元素
数据范围：操作数量满足 $0 \le n \le 300$ ，输入的元素满足 $|val| \le 10000$ 进阶：栈的各个操作的时间复杂度是 $\Omicron(1)$ ，空间复杂度是 $\Omicron(n)$。
Solutions # Stack # 使用两个栈，一个栈stack1用于正常压入和弹出，另一个栈stack2用于实现单调栈。当压入一个元素时，如果当前元素比 stack2 的栈顶元素还要大，则将当前元素压入 stack1 的同时，还将当前元素压入 stack2，如果当前元素不比 stack2 的栈顶元素要大，则将 stack2 的栈顶元素重复入栈。当弹出元素时，将 stack1 和 stack2 的栈顶元素同步弹出。当获取最小值时，只需要取出 stack2 的栈顶元素即可。
// 用于实现正常的 push 与 pop 操作 var stack1 []int // 用于存储最小值 var stack2 []int func Push(node int) { // write code here stack1 = append(stack1, node) size := len(stack2) if size == 0 || stack2[size-1] &amp;gt; node { stack2 = append(stack2, node) } else { stack2 = append(stack2, stack2[size-1]) } } func Pop() { // write code here size := len(stack1) stack1 = stack1[:size-1] stack2 = stack2[:size-1] } func Top() int { // write code here size := len(stack1) return stack1[size-1] } func Min() int { // write code here size := len(stack2) return stack2[size-1] }</description></item><item><title>31. 栈的压入弹出序列</title><link>https://example.com/docs/algs/codingInterviews/31_%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/31_%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</guid><description>Description # 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。
Solutions # 栈模拟 # 新建一个栈来模拟出栈序列。使用一个指针 inPos 指向当前入栈序列的单签入栈元素，使用另一个指针 outPos 指向出栈序列当前应该出栈的元素，然后开始模拟出入栈。
首先，如果当前栈顶元素和出栈序列匹配，则出栈栈顶元素，并且将 outPos 右移，直到二者不匹配或者栈为空 将 inPos 指针指向的入栈序列的元素入栈，然后将 inPos 右移。 不断循环上述过程，直到入栈序列中的所有元素都入栈。 最后判断是否出栈序列中的所有元素都已经匹配完成即可。 func IsPopOrder( pushV []int , popV []int ) bool { // write code here size := len(pushV) if size == 0 { return true } var stack []int stack = append(stack, pushV[0]) inPos, outPos := 1, 0 // 为什么这里的循环用的是 &amp;lt;= ，而不是 &amp;lt; ？ // 因为有可能我们一直从入栈序列中入栈的操作，直到所有元素都已经入栈。如果只使用 &amp;lt; 符号的话， // 我们就无法判断出栈序列是否和栈顶元素匹配（当然你也可以在 for 循环之后再加上这一步，只不过加 // 上这个=号之后可以少写一点代码）.</description></item><item><title>37. 序列化二叉树</title><link>https://example.com/docs/algs/codingInterviews/37_%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/37_%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>Description # 请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树。
二叉树的序列化(Serialize)是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树等遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#）
二叉树的反序列化(Deserialize)是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。
Solutions # PreOrder Traversal # 采用先序遍历的方式进行序列化，同样采用先序遍历的方式进行反序列化。
var emptyNode string = &amp;#34;#&amp;#34; var seperator string = &amp;#34; &amp;#34; func Serialize( root *TreeNode ) string { // write code here if root == nil { return &amp;#34;&amp;#34; } var res []string _serialize(root, &amp;amp;res) return strings.Join(res, seperator) } func _serialize(root *TreeNode, res *[]string) { if root !</description></item><item><title>38. 字符串的排列</title><link>https://example.com/docs/algs/codingInterviews/38_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/38_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</guid><description>Description # 输入一个长度为 n 字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组。
例如输入字符串ABC,则输出由字符A,B,C所能排列出来的所有字符串ABC,ACB,BAC,BCA,CBA和CAB。
Solutions # 使用全排列的思想来做。
func Permutation( str string ) []string { // write code here var res []string size := len(str) if size == 0 { return res } dict := make(map[string]bool) permutate([]rune(str), 0, size, &amp;amp;dict) for key, _ := range dict { res = append(res, key) } return res } func permutate(str []rune, start int, size int, dict *map[string]bool) { if start == size { s := string(str) if _, ok := (*dict)[s]; !</description></item><item><title>4. 二维数组中的查找</title><link>https://example.com/docs/algs/codingInterviews/4_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/4_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</guid><description>Description # 在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
数据范围：矩阵的长宽满足 $0 \le n$,$m \le 500$ ， 矩阵中的值满足 $0 \le val \le 10^9$。
进阶：空间复杂度 O(1)O(1) ，时间复杂度 O(n+m)O(n+m)
Solutions # 从左下角开始进行遍历，因为数组维持了从左到右递增，从上到下递增的性质，那么如果当前元素比 target 要大， target 一定位于当前元素的右边；如果当前元素比 target 要小，那么 target 一定位于当前元素的上侧。
func Find( target int , array [][]int ) bool { // write code here var res bool m, n := len(array), len(array[0]) x, y := m-1, 0 for { if x &amp;lt; 0 || y &amp;gt;= n { break } if array[x][y] == target { res = true break } if target &amp;gt; array[x][y] { y++ } // 这里要加上一个 y &amp;lt; n, 因为上一个 if 对 y 进行了自增，导致这里的 y 不一定合法 if y &amp;lt; n &amp;amp;&amp;amp; target &amp;lt; array[x][y] { x-- } } return res }</description></item><item><title>42. 连续子数组的最大和</title><link>https://example.com/docs/algs/codingInterviews/42_%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/42_%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</guid><description>Description # 输入一个长度为n的整型数组array，数组中的一个或连续多个整数组成一个子数组，子数组最小长度为1。求所有子数组的和的最大值。
Solutions # Kadane 方法 # 参见这个 链接， 已经有现成的 $\Omicron(n)$ 方法。
package main import &amp;#34;math&amp;#34; /** * * @param array int整型一维数组 * @return int整型 */ func FindGreatestSumOfSubArray( array []int ) int { // write code here size := len(array) if size == 0 { return 0 } sum := int(math.MinInt32) res := sum for i := 0; i &amp;lt; size; i++ { sum = max(array[i], sum+array[i]) res = max(res, sum) } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a } 动态规划 # 定义 dp[i] 表示以 i 为结尾的连续子数组的最大和，则很明显，dp[i] 的值受到 dp[i-1] 和 array[i] 的影响，稍微一想即可得到转态转移方程：$dp[i] = \max (dp[i-1] + array[i], array[i])$</description></item><item><title>46. 把数字翻译成字符串</title><link>https://example.com/docs/algs/codingInterviews/46_%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/46_%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description>Description # 有一种将字母编码成数字的方式：&amp;lsquo;a&amp;rsquo;-&amp;gt;1, &amp;lsquo;b-&amp;gt;2&amp;rsquo;, &amp;hellip; , &amp;lsquo;z-&amp;gt;26&amp;rsquo;。 我们把一个字符串编码成一串数字，再考虑逆向编译成字符串。 由于没有分隔符，数字编码成字母可能有多种编译结果，例如 11 既可以看做是两个 &amp;lsquo;a&amp;rsquo; 也可以看做是一个 &amp;lsquo;k&amp;rsquo; 。但 10 只可能是 &amp;lsquo;j&amp;rsquo; ，因为 0 不能编译成任何结果。 现在给一串数字，返回有多少种可能的译码结果
Solutions # Recursive # func solve( nums string ) int { // write code here var res int size := len(nums) if size == 0 { return 0 } helper(nums, &amp;amp;res) return res } func helper(nums string, res *int) { size := len(nums) if size == 0 { *res += 1 return } // 如果开头字符是 0， 那么说明只是一次不合法的拆分在，直接返回即可 if nums[0] == &amp;#39;0&amp;#39; { return } // 如果可能将连个字符放在一起，则将两个字符放在一起 if size &amp;gt;= 2 &amp;amp;&amp;amp; nums[:2] &amp;gt;= &amp;#34;10&amp;#34; &amp;amp;&amp;amp; nums[:2] &amp;lt;= &amp;#34;26&amp;#34; { helper(nums[2:], res) } // 永远可以拆分为单个字符 helper(nums[1:], res) } Dynamic Programming # 定义 dp(i) 表示以第 i 位结尾的前缀串翻译的方案数，初始化 dp[0] = dp[1] = 1, 可以得出递推方程： $$ dp[i]=\begin{cases} dp[i-2] + dp[i-1], &amp;amp; 10 \le nums[i-2: i] \le 25 \ dp[i-1], &amp;amp; else \end{cases} $$</description></item><item><title>47. 礼物的最大价值</title><link>https://example.com/docs/algs/codingInterviews/47_%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/47_%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</guid><description>Description # 在一个m\times nm×n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？ 如输入这样的一个二维数组， [ [1,3,1], [1,5,1], [4,2,1] ] 那么路径 1→3→5→2→1 可以拿到最多价值的礼物，价值为12
Solutions # Dynamic Programming # 定义 dp[i][j] 表示在 grid[i][j] 所能得到的最大礼物值，则很明显，dp[i][j]的值要么是从左边转移得到的，要么是从上侧转移得到的，则可以得到递推方程 dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1])。base case 的话，很明显，第一行的数据只能从左边得到，第一列数据只能从上侧得到。我们可以直接复用原数组，这样还能节省一下空间开销。
func maxValue( grid [][]int ) int { // write code here m,n := len(grid), len(grid[0]) // 如果我们开辟一个 (m+1) * (n+1) 的数组，那么下面这两个 for 语句就不需要了，代码可以更加简洁。 // 第一列只能来自上方 for i := 1; i &amp;lt; m; i++ { grid[i][0] += grid[i-1][0] } // 第一行只能来自左边 for i := 1; i &amp;lt; n; i++ { grid[0][i] += grid[0][i-1] } for i := 1; i &amp;lt; m; i++ { for j := 1; j &amp;lt; n; j++ { grid[i][j] = grid[i][j] + max(grid[i-1][j], grid[i][j-1]) } } return grid[m-1][n-1] }</description></item><item><title>53. 数字在升序数组中出现的次数</title><link>https://example.com/docs/algs/codingInterviews/53_%E6%95%B0%E5%AD%97%E5%9C%A8%E5%8D%87%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/53_%E6%95%B0%E5%AD%97%E5%9C%A8%E5%8D%87%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</guid><description>Description # 给定一个长度为 n 的非降序数组和一个非负数整数 k ，要求统计 k 在数组中出现的次数
数据范围：$0 \le n \le 1000 $, $0 \le k \le 100$ ，数组中每个元素的值满足 $0 \le val \le 100$. 要求：空间复杂度 $\Omicron(1)$，时间复杂度 $\Omicron(\log n)$
Solutions # Binary Search # func GetNumberOfK( data []int , k int ) int { // write code here var res int size := len(data) if size &amp;lt; 1 { return res } left, right := 0, size - 1 for left &amp;lt;= right { mid := (left +right)/2 if data[mid] &amp;gt; k { right = mid - 1 } else if data[mid] &amp;lt; k { left = mid + 1 } else if data[mid] == k { l,r := mid, mid for l &amp;gt;= 0 &amp;amp;&amp;amp; data[l] == k { l-- } for r &amp;lt; size &amp;amp;&amp;amp; data[r] == k { r++ } res = r - l - 1 break } } return res }</description></item><item><title>59. 滑动窗口的最大值</title><link>https://example.com/docs/algs/codingInterviews/59_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/59_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</guid><description>Description # 给定一个长度为 n 的数组 nums 和滑动窗口的大小 size ，找出所有滑动窗口里数值的最大值。
例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。
Solutions # Dequeue # 使用一个单调递减的单调队列来做。维持一个最大长度为 size 的单调队列，每当遍历到当前元素 i，如果当前元素 nums[i] 比队列尾部元素要大，则不断将队列尾部元素出队，直到队列为空或者当前元素 nums[i] 比队尾元素要小，然后将当前元素入队。这样的话，队列中要么维持着一个最大值，要么顶多维持着 size 个相对递减的连续值。然后检查队首元素是否过期，如果过期，则将队首元素出队，因为我们每次顶多入队一个，所以每次遍历也顶多只会有一个元素过期。最后检查当前窗口长度是否达到 size，如果达到了，则将队列首部元素入队即可。
// 可以使用单调递减的单调队列来实现 func maxInWindows( num []int , size int ) []int { // write code here var res []int n := len(num) if size &amp;lt; 1 || n &amp;lt; 1 { return res } var queue []int for i := 0; i &amp;lt; n; i++ { // 如果当前遍历到的元素比队尾元素要大，则不断将队尾元素出队 curLen := len(queue) for curLen &amp;gt; 0 &amp;amp;&amp;amp; num[i] &amp;gt; num[queue[curLen-1]] { curLen-- queue = queue[:curLen] } queue = append(queue, i) // 如果当前队首元素滑出左边界，则将其删除 if queue[0] + size &amp;lt;= i { queue = queue[1:] } // 如果当前已经构成了一个有效的滑动窗口，则将当前最大值存入结果 if size &amp;lt;= i+1 { res = append(res, num[queue[0]]) } } return res }</description></item><item><title>63. 买卖股票的最好时机</title><link>https://example.com/docs/algs/codingInterviews/63_%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A5%BD%E6%97%B6%E6%9C%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/63_%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A5%BD%E6%97%B6%E6%9C%BA/</guid><description>Description # 假设你有一个数组prices，长度为n，其中prices[i]是股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益 1.你可以买入一次股票和卖出一次股票，并非每天都可以买入或卖出一次，总共只能买入和卖出一次，且买入必须在卖出的前面的某一天 2.如果不能获取到任何利润，请返回0 3.假设买入卖出均无手续费
Solutions # 一次扫描，扫描过程中维护当前扫描到的数字的最小值，然后不断的用当前扫描到的数字减去这个最小得到一个差，取这个差的最大值即可。
func maxProfit( prices []int ) int { // write code here var res int size := len(prices) if size == 0 { return res } curMin := prices[0] for _, price := range prices { if price &amp;lt; curMin { curMin = price } res = max(res, price-curMin) } return res }</description></item><item><title>68. 二叉搜索树的最近公共祖先</title><link>https://example.com/docs/algs/codingInterviews/68_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/68_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid><description>Description # 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
Solutions # Recursive # 如果当前节点的值比要查找的值的最小值还要小，说明应该往当前节点的右节点进行查找；如果当前节点的值比要查找的值的最大值还要大，说明应该往当前节点的左子树进行查找。否则说明当前节点处于要查找的值之间，那么当前节点就是我们要查找的最近公共祖先。
func lowestCommonAncestor( root *TreeNode , p int , q int ) int { // write code here if root == nil { return -1 } // 保持 p 比 q 要小 if p &amp;gt; q { p,q = q, p } res := lcaHelper(root, p, q) return res.</description></item><item><title>70. 矩形覆盖</title><link>https://example.com/docs/algs/codingInterviews/70_%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/70_%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/</guid><description>Description # 我们可以用 21 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 21 的小矩形无重叠地覆盖一个 2*n 的大矩形，从同一个方向看总共有多少种不同的方法？
数据范围：$0 \le n \le 38$ 进阶：空间复杂度 $\Omicron(1)$ ，时间复杂度 $\Omicron(n)$
注意：约定 n == 0 时，输出 0
Solutions # 举例可以发现这其实也是个斐波那契数列问题。
func rectCover( number int ) int { // write code here if number &amp;lt;= 3 { return number } NMinusTwo, NMinusOne := 2, 3 for i := 4; i &amp;lt;= number; i++ { N := NMinusOne + NMinusTwo NMinusTwo = NMinusOne NMinusOne = N } return NMinusOne }</description></item><item><title>70. 跳台阶</title><link>https://example.com/docs/algs/codingInterviews/69_%E8%B7%B3%E5%8F%B0%E9%98%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/69_%E8%B7%B3%E5%8F%B0%E9%98%B6/</guid><description>Description # 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
数据范围：$1 \leq n \leq 40$ 要求：时间复杂度：$\Omicron(n)$ ，空间复杂度： $\Omicron(1)$
Solutions # 动态规划 # func jumpFloor( number int ) int { // write code here if number &amp;lt;= 1 { return number } NMinusTwo, NMinusOne := 0, 1 for i := 1; i &amp;lt;= number; i++ { n := NMinusOne + NMinusTwo NMinusTwo = NMinusOne NMinusOne = n } return NMinusOne }</description></item><item><title>71. 跳台阶扩展问题</title><link>https://example.com/docs/algs/codingInterviews/71_%E8%B7%B3%E5%8F%B0%E9%98%B6%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/71_%E8%B7%B3%E5%8F%B0%E9%98%B6%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98/</guid><description>Description # 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶(n为正整数)总共有多少种跳法。
Solutions # Math # 其实可以通过举例来发现规律: $f(n) = 2 * f(n-1) (n &amp;gt; 2)$，如果 $0 \le n \le 2$，则直接返回 n 即可。
func jumpFloorII( number int ) int { // write code here if number &amp;lt;= 2 { return number } return int(math.Pow(2, float64(number-1))) }</description></item><item><title>73. 翻转单词序列</title><link>https://example.com/docs/algs/codingInterviews/73_%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/73_%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97/</guid><description>Description # 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“nowcoder. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a nowcoder.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？
Solutions # 先翻转整个句子，然后再针对每个空格分割的单词单独翻转。
func ReverseSentence( str string ) string { // write code here size := len(str) if size &amp;lt;= 1 { return str } runes := []rune(str) size = len(runes) // 先翻转整个字符串 for left,right := 0, size-1; left &amp;lt; right; left,right = left+1, right-1 { runes[left],runes[right] = runes[right], runes[left] } // 再翻转这个字符串里的每个单词 var left, right int for right &amp;lt;= size { for right &amp;lt; size &amp;amp;&amp;amp; runes[right] !</description></item><item><title>78. 把二叉树打印成多行</title><link>https://example.com/docs/algs/codingInterviews/78_%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/78_%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/</guid><description>Description # 给定一个节点数为 n 二叉树，要求从上到下按层打印二叉树的 val 值，同一层结点从左至右输出，每一层输出一行，将输出的结果存放到一个二维数组中返回。
Solutions # Level Order Traversal # 简单题，只需要进行一次层次遍历即可。
func Print( pRoot *TreeNode ) [][]int { // write code here var res [][]int if pRoot == nil { return res } var queue []*TreeNode queue = append(queue, pRoot) for len(queue) != 0 { size := len(queue) var level []int for i := 0; i &amp;lt; size; i++ { node := queue[i] level = append(level, node.</description></item><item><title>84. 二叉树中和为某一值的路径 III</title><link>https://example.com/docs/algs/codingInterviews/84_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84III/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/84_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84III/</guid><description>Description # 给定一个二叉树root和一个整数值 sum ，求该树有多少路径的的节点值之和等于 sum 。 1.该题路径定义不需要从根节点开始，也不需要在叶子节点结束，但是一定是从父亲节点往下到孩子节点 2.总节点数目为n 3.保证最后返回的路径个数在整形范围内(即路径个数小于$2^{31}$-1)
Solutions # 注意，这里的路径不一定需要从根节点开始，也不一定需要在叶节点结束。
Recursice # 核心思想就是，每个节点都可能是一条路径的起始节点，所以每个节点都需要作为根节点来遍历一次。
var res int func FindPath( root *TreeNode , sum int ) int { // write code here if root == nil { return res } findPathHelper(root, sum) // 每个节点都需要作为根节点来进行一次查找 FindPath(root.Left, sum) FindPath(root.Right, sum) return res } func findPathHelper(root *TreeNode, sum int) { if root == nil { return } // 注意这里的小技巧 if sum == root.</description></item><item><title>85. 连续子数组的最大和 II</title><link>https://example.com/docs/algs/codingInterviews/85_%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/85_%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C-II/</guid><description>Description # 输入一个长度为n的整型数组array，数组中的一个或连续多个整数组成一个子数组，找到一个具有最大和的连续子数组。 1.子数组是连续的，比如[1,3,5,7,9]的子数组有[1,3]，[3,5,7]等等，但是[1,3,7]不是子数组 2.如果存在多个最大和的连续子数组，那么返回其中长度最长的，该题数据保证这个最长的只存在一个 3.该题定义的子数组的最小长度为1，不存在为空的子数组，即不存在[]是某个数组的子数组 4.返回的数组不计入空间复杂度计算
Solutions # Kadane 方法 # 详情参见 42 题的 「连续子数组的最大和」，这个方法跟那个方法是同一个思路。
func FindGreatestSumOfSubArray( array []int ) []int { // write code here size := len(array) if size == 0 { return nil } var start, end int res, sum := array[0],array[0] for i := 1; i &amp;lt; size; i++ { // 这里的 start 可能会在不断的向右扩张，而 end 只有在 sum 比 res 大的时候才会扩展，所以可能会出现 start 比 end 大的情况。 if array[i] &amp;gt; sum + array[i] { start = i } sum = max(array[i], sum+array[i]) if sum &amp;gt;= res { res = sum end = i } } // 当 start 不断向前推进时，可能会出现 start 大于 end 的情况，这个时候需要重置 start 的值 if start &amp;gt; end { start = end } return array[start: end+1] } func max(a,b int) int { if a &amp;lt; b { return b } return a } 上面的这个解法的优化, 这个方法其实也可以改成动态规划的方法，只需要将 sum 替换成 dp[i] 即可。</description></item><item><title>86. 二叉树中两个节点的最近公共祖先</title><link>https://example.com/docs/algs/codingInterviews/86_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/86_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid><description>Description # 给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。
数据范围：树上节点数满足$1 \le n \le 10^5$, 节点值val满足区间 [0,n) 要求：时间复杂度 $\Omicron(n)$
Solutions # Recursive # 具体解释看注释即可。
func lowestCommonAncestor( root *TreeNode , o1 int , o2 int ) int { // write code here if root == nil { return -1 } res := lcaHelper(root, o1, o2) return res.Val } func lcaHelper(root *TreeNode, o1, o2 int) *TreeNode { // 如果已经遍历到空节点或者已经找到其中一个节点，则返回该节点 if root == nil || root.</description></item><item><title>9. 双栈实现队列</title><link>https://example.com/docs/algs/codingInterviews/9_%E5%8F%8C%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/9_%E5%8F%8C%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</guid><description>Description # 用两个栈来实现一个队列，使用n个元素来完成 n 次在队列尾部插入整数(push)和n次在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。
数据范围： $n \le 1000$ 要求：存储n个元素的空间复杂度为 $\Omicron(n)$ ，插入与删除的时间复杂度都是 $\Omicron(1)$
Solutions # 使用两个队列，队列1专用于push，队列用专用于pop 和 peek。push 时，入队 stack1； pop 时，如果 stack2 不为空，则弹出 stack2 栈顶即可，若 stack2 为空，则将 stack1 的所有元素压入 stack2， 然后将 stack2 的栈顶元素弹出。
type MyQueue struct { stack1 []int stack2 []int } func Constructor() MyQueue { return MyQueue{ stack1: make([]int, 0), stack2: make([]int, 0), } } func (this *MyQueue) Push(x int) { this.</description></item><item><title>48. 最长不含重复字符的子字符串</title><link>https://example.com/docs/algs/codingInterviews/48_%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/48_%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description>Description # Solutions # 滑动窗口 # func lengthOfLongestSubstring( s string ) int { // write code here size := len(s) if size &amp;lt;= 1 { return size } res, start := 1, -1 dict := make(map[byte]int) // 这里用等号主要是因为当最后几个字符串都不重复时，如果不在这里加上一个等号，则可能会缺少一次计算，从而导致结果不准确。 // 下面的第一个 if 也是为了跟这种情况搭配才加上的。 for i := 0; i &amp;lt;= size; i++ { if i == size { res = max(res, i - start - 1) break } if index, ok := dict[s[i]]; ok &amp;amp;&amp;amp; index &amp;gt; start { res = max(res, i - start - 1) start = index } dict[s[i]] = i } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a } 下面是上面这种解法的更简介写法：</description></item></channel></rss>