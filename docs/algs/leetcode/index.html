<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="这里是一些 LeetCode 的刷题题解。
Data structure # Stack # Problem Difficulty Method Redo Comment 155. Min Stack easy Stack、Monotone Stack No 150. Evalute Reverse Polish Notation medium Stack No 简单题，无需多看 224. Basic Calculator hard Stack YES 题目为难题，暂时跳过。注意这里是如何将中缀表达式转换为后缀表达式的 227. Basic Calculator medium Stack YES 稍微有点耗时，先跳过 20. Valid Parentheses easy Stack No 1472. Design Browser History medium Stack No 1047. Remove All Adjacent Duplicates in String easy Stack No 1249. Minimum Remove to Make Valid Parentheses medium Stack Yes 735."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://example.com/docs/algs/leetcode/"><title>Leetcode | Interview</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.5954932b5698cae1cf8daaa8b7674e53ab8e603b739c6931070c683afa9f978b.js integrity="sha256-WVSTK1aYyuHPjaqot2dOU6uOYDtznGkxBwxoOvqfl4s=" crossorigin=anonymous></script>
<script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script>
<link rel=alternate type=application/rss+xml href=https://example.com/docs/algs/leetcode/index.xml title=Interview></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Interview</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
English</a></label><ul><li><a href=https://example.com/zh/>Chinese</a></li></ul></li></ul><ul><li class=book-section-flat><a href=/docs/algs/>Algorithms</a><ul><li><input type=checkbox id=section-ec39d6c4dfca0e3515aa7444ac59cae3 class=toggle>
<label for=section-ec39d6c4dfca0e3515aa7444ac59cae3 class="flex justify-between"><a href=/docs/algs/basic/>Basic</a></label><ul><li><a href=/docs/algs/basic/msort/notes/>排序算法笔记</a></li></ul></li><li><input type=checkbox id=section-b3f8feb2880d46b98f249cd838034ef8 class=toggle>
<label for=section-b3f8feb2880d46b98f249cd838034ef8 class="flex justify-between"><a href=/docs/algs/codingInterviews/>Coding Interviews</a></label><ul><li><a href=/docs/algs/codingInterviews/03_%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E7%BB%84/>03. 数组中重复的数字</a></li><li><a href=/docs/algs/codingInterviews/04_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/>04. 二维数组中的查找</a></li><li><a href=/docs/algs/codingInterviews/05_%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/>05. 替换空格</a></li><li><a href=/docs/algs/codingInterviews/06_%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/>06. 从尾到头打印链表</a></li><li><a href=/docs/algs/codingInterviews/07_%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/>07. 重建二叉树</a></li><li><a href=/docs/algs/codingInterviews/08_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/>08. 二叉树的下一个节点</a></li><li><a href=/docs/algs/codingInterviews/09_%E5%8F%8C%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/>09. 双栈实现队列</a></li><li><a href=/docs/algs/codingInterviews/10_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/>10. 斐波那契数列</a></li><li><a href=/docs/algs/codingInterviews/11_%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/>11. 旋转数组的最小数字</a></li><li><a href=/docs/algs/codingInterviews/12_%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/>12. 矩阵中的路径</a></li><li><a href=/docs/algs/codingInterviews/13_%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/>13. 机器人的运动范围</a></li><li><a href=/docs/algs/codingInterviews/14_%E5%89%AA%E7%BB%B3%E5%AD%90/>14. 剪绳子</a></li><li><a href=/docs/algs/codingInterviews/15_%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD-1-%E7%9A%84%E4%B8%AA%E6%95%B0/>15. 二进制中 1 的个数</a></li><li><a href=/docs/algs/codingInterviews/16_%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/>16. 数值的整数次方</a></li><li><a href=/docs/algs/codingInterviews/17_%E6%89%93%E5%8D%B0%E4%BB%8E-1-%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84-n-%E4%BD%8D%E6%95%B0/>17. 打印从 1 到最大的 n 位数</a></li><li><a href=/docs/algs/codingInterviews/18_%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/>18. 删除链表的节点</a></li><li><a href=/docs/algs/codingInterviews/21_%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/>21. 调整数组顺序使奇数位于偶数前面</a></li><li><a href=/docs/algs/codingInterviews/22_%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E6%9C%80%E5%90%8E-k-%E4%B8%AA%E8%8A%82%E7%82%B9/>22. 链表中倒数最后 k 个节点</a></li><li><a href=/docs/algs/codingInterviews/23_%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9/>23. 链表中环的入口节点</a></li><li><a href=/docs/algs/codingInterviews/24_%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/>24. 反转链表</a></li><li><a href=/docs/algs/codingInterviews/25_%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/>25. 合并两个排序的链表</a></li><li><a href=/docs/algs/codingInterviews/26_%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/>26. 树的子结构</a></li><li><a href=/docs/algs/codingInterviews/27_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/>27. 二叉树的镜像</a></li><li><a href=/docs/algs/codingInterviews/28_%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/>28. 对称的二叉树</a></li><li><a href=/docs/algs/codingInterviews/29_%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/>29. 顺时针打印矩阵</a></li><li><a href=/docs/algs/codingInterviews/30_%E5%8C%85%E5%90%AB-min-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/>30. 包含 min 函数的栈</a></li><li><a href=/docs/algs/codingInterviews/31_%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/>31. 栈的压入弹出序列</a></li><li><a href=/docs/algs/codingInterviews/32_%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/>32. 从上往下打印二叉树</a></li><li><a href=/docs/algs/codingInterviews/33_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/>33. 二叉搜索树的后序遍历序列</a></li><li><a href=/docs/algs/codingInterviews/34_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E4%BA%8C/>34. 二叉树中和为某一值的路径（二）</a></li><li><a href=/docs/algs/codingInterviews/35_%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/>35. 复杂链表的复制</a></li><li><a href=/docs/algs/codingInterviews/36_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/>36. 二叉搜索树与双向链表</a></li><li><a href=/docs/algs/codingInterviews/37_%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/>37. 序列化二叉树</a></li><li><a href=/docs/algs/codingInterviews/38_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/>38. 字符串的排列</a></li><li><a href=/docs/algs/codingInterviews/39_%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/>39. 数组中出现次数超过一半的数字</a></li><li><a href=/docs/algs/codingInterviews/40_%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E4%B8%AA%E6%95%B0/>40. 最小的 k 个数</a></li><li><a href=/docs/algs/codingInterviews/41_%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/>41. 数据流中的中位数</a></li><li><a href=/docs/algs/codingInterviews/42_%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/>42. 连续子数组的最大和</a></li><li><a href=/docs/algs/codingInterviews/43_%E6%95%B4%E6%95%B0%E4%B8%AD-1-%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/>43. 整数中 1 出现的次数</a></li><li><a href=/docs/algs/codingInterviews/45_%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/>45. 把数组排成最小的数</a></li><li><a href=/docs/algs/codingInterviews/46_%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/>46. 把数字翻译成字符串</a></li><li><a href=/docs/algs/codingInterviews/47_%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/>47. 礼物的最大价值</a></li><li><a href=/docs/algs/codingInterviews/48_%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/>48. 最长不含重复字符的子字符串</a></li><li><a href=/docs/algs/codingInterviews/49_%E4%B8%91%E6%95%B0/>49. 丑数</a></li><li><a href=/docs/algs/codingInterviews/50_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/>50. 第一个只出现一次的字符</a></li><li><a href=/docs/algs/codingInterviews/51_%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/>51. 数组中的逆序对</a></li><li><a href=/docs/algs/codingInterviews/52_%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/>52. 两个链表的第一个公共节点</a></li><li><a href=/docs/algs/codingInterviews/53_%E6%95%B0%E5%AD%97%E5%9C%A8%E5%8D%87%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/>53. 数字在升序数组中出现的次数</a></li><li><a href=/docs/algs/codingInterviews/54_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9/>54. 二叉搜索树的第 k 个节点</a></li><li><a href=/docs/algs/codingInterviews/55_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/>55. 二叉树的深度</a></li><li><a href=/docs/algs/codingInterviews/56_%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/>56. 数组中只出现一次的两个数字</a></li><li><a href=/docs/algs/codingInterviews/57_%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/>57. 和为 S 的两个数字</a></li><li><a href=/docs/algs/codingInterviews/58_%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/>58. 左旋转字符串</a></li><li><a href=/docs/algs/codingInterviews/59_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/>59. 滑动窗口的最大值</a></li><li><a href=/docs/algs/codingInterviews/61_%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/>61. 扑克牌顺子</a></li><li><a href=/docs/algs/codingInterviews/62_%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0/>62. 圆圈中最后剩下的数</a></li><li><a href=/docs/algs/codingInterviews/63_%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A5%BD%E6%97%B6%E6%9C%BA/>63. 买卖股票的最好时机</a></li><li><a href=/docs/algs/codingInterviews/65_%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/>65. 不用加减乘除做加法</a></li><li><a href=/docs/algs/codingInterviews/67_%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%88%90%E6%95%B4%E6%95%B0atoi/>67. 把字符串转成整数(atoi)</a></li><li><a href=/docs/algs/codingInterviews/66_%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/>67. 构建乘积数组</a></li><li><a href=/docs/algs/codingInterviews/68_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/>68. 二叉搜索树的最近公共祖先</a></li><li><a href=/docs/algs/codingInterviews/70_%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/>70. 矩形覆盖</a></li><li><a href=/docs/algs/codingInterviews/69_%E8%B7%B3%E5%8F%B0%E9%98%B6/>70. 跳台阶</a></li><li><a href=/docs/algs/codingInterviews/71_%E8%B7%B3%E5%8F%B0%E9%98%B6%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98/>71. 跳台阶扩展问题</a></li><li><a href=/docs/algs/codingInterviews/73_%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97/>73. 翻转单词序列</a></li><li><a href=/docs/algs/codingInterviews/74_%E5%92%8C%E4%B8%BA-S-%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/>74. 和为 S 的连续正数序列</a></li><li><a href=/docs/algs/codingInterviews/75_%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/>75. 字符流中第一个不重复出现的字符</a></li><li><a href=/docs/algs/codingInterviews/76_%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9/>76. 删除链表中重复的节点</a></li><li><a href=/docs/algs/codingInterviews/77_%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/>77. 按之字形顺序打印二叉树</a></li><li><a href=/docs/algs/codingInterviews/78_%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/>78. 把二叉树打印成多行</a></li><li><a href=/docs/algs/codingInterviews/79_%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/>79. 判断是不是平衡二叉树</a></li><li><a href=/docs/algs/codingInterviews/81_%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2II/>81. 调整数组顺序使奇数位于偶数前面 II</a></li><li><a href=/docs/algs/codingInterviews/82_%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E4%B8%80/>82. 二叉树中和为某一值的路径（一）</a></li><li><a href=/docs/algs/codingInterviews/84_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84III/>84. 二叉树中和为某一值的路径 III</a></li><li><a href=/docs/algs/codingInterviews/85_%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C-II/>85. 连续子数组的最大和 II</a></li><li><a href=/docs/algs/codingInterviews/86_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/>86. 二叉树中两个节点的最近公共祖先</a></li></ul></li><li><input type=checkbox id=section-06eaa3875e3efa3930db94c14aa47d12 class=toggle checked>
<label for=section-06eaa3875e3efa3930db94c14aa47d12 class="flex justify-between"><a href=/docs/algs/leetcode/ class=active>Leetcode</a></label><ul><li><a href=/docs/algs/leetcode/01_two_sum/>0001. Two Sum</a></li><li><a href=/docs/algs/leetcode/03_longest_substring_without_repeatng_characters/>0003. Longest Substring Without Repeating Characters</a></li><li><a href=/docs/algs/leetcode/05_longest_palindrome_substring/>0005. Longest Palindrome Substring</a></li><li><a href=/docs/algs/leetcode/11_container_with_most_water/>0011. Container with Most Water</a></li><li><a href=/docs/algs/leetcode/15_3sum/>0015. 3 Sum</a></li><li><a href=/docs/algs/leetcode/16_3sum_closest/>0016. 3Sum Closest</a></li><li><a href=/docs/algs/leetcode/18_4sum/>0018. 4 Sum</a></li><li><a href=/docs/algs/leetcode/20_valid_parentheses/>0020. Valid Parentheses</a></li><li><a href=/docs/algs/leetcode/21_merge_two_sorted_list/>0021. Merge Two Sorted List</a></li><li><a href=/docs/algs/leetcode/22_generate_parentheses/>0022. Generate Parentheses</a></li><li><a href=/docs/algs/leetcode/23_merge_k_sorted_list/>0023. Merge K Sorted List</a></li><li><a href=/docs/algs/leetcode/26_remove_duplicates_from_sorted_array/>0026. remove duplicated from sorted array</a></li><li><a href=/docs/algs/leetcode/27_remove_element/>0027. Remove Element</a></li><li><a href=/docs/algs/leetcode/28_implement_strStr/>0028. Implement strStr</a></li><li><a href=/docs/algs/leetcode/29_divide_two_integers/>0029. Divide Two Integers</a></li><li><a href=/docs/algs/leetcode/33_search_in_rotated_array/>0033. Search in Rotated Sorted Array</a></li><li><a href=/docs/algs/leetcode/34_find_first_and_last_position_of_element_in_sorted_array/>0034. Find First and Last Position of Element in Sorted Array</a></li><li><a href=/docs/algs/leetcode/36_valid_sudoku/>0036. Valid Sudoku</a></li><li><a href=/docs/algs/leetcode/38_count_and_say/>0038. Count and Say</a></li><li><a href=/docs/algs/leetcode/41_first_msssing_positive/>0041. First Missing Positive</a></li><li><a href=/docs/algs/leetcode/42_traping_rain_water/>0042. Traping Rain Water</a></li><li><a href=/docs/algs/leetcode/44_wildcard_matching/>0044. Wildcard Matching</a></li><li><a href=/docs/algs/leetcode/46_permutations/>0046. Permutations</a></li><li><a href=/docs/algs/leetcode/48_rotate_image/>0048. Rotate Image</a></li><li><a href=/docs/algs/leetcode/49_group_anagrams/>0049. Group Anagrams</a></li><li><a href=/docs/algs/leetcode/50_powxn/>0050. Pow(x, n)</a></li><li><a href=/docs/algs/leetcode/51_n_queens/>0051. N Queens</a></li><li><a href=/docs/algs/leetcode/52_n_queens_ii/>0052. N Queens II</a></li><li><a href=/docs/algs/leetcode/53_maximum_subarray/>0053. Maximum Subarray</a></li><li><a href=/docs/algs/leetcode/54_spiral_matrix/>0054. Spiral Matrix</a></li><li><a href=/docs/algs/leetcode/55_jump_game/>0055. Jump Game</a></li><li><a href=/docs/algs/leetcode/56_merge_intervals/>0056. Merge Intervals</a></li><li><a href=/docs/algs/leetcode/62_unique_paths/>0062. Unique Paths</a></li><li><a href=/docs/algs/leetcode/64_minimum_path_sum/>0064. Minimum Path Sum</a></li><li><a href=/docs/algs/leetcode/66_plus_one/>0066. Plus One</a></li><li><a href=/docs/algs/leetcode/69_sqrtx/>0069. Sqrt(x)</a></li><li><a href=/docs/algs/leetcode/70_climing_stairs/>0070. Climbing Stairs</a></li><li><a href=/docs/algs/leetcode/73_set_matrix_zeroes/>0073. Set Matrix Zeroes</a></li><li><a href=/docs/algs/leetcode/74_search_a_2d_matrix/>0074. Search a 2D Matrix</a></li><li><a href=/docs/algs/leetcode/75_sort_colors/>0075. Sort Colors</a></li><li><a href=/docs/algs/leetcode/76_minimum_window_substring/>0076. Minimum Window Substring</a></li><li><a href=/docs/algs/leetcode/78_subsets/>0078. Subsets</a></li><li><a href=/docs/algs/leetcode/79_word_search/>0079. Word Search</a></li><li><a href=/docs/algs/leetcode/84_largest_rectangle_in_histogram/>0084. Largest Rectangle in Histogram</a></li><li><a href=/docs/algs/leetcode/88_merge_sorted_array/>0088. Merge Sorted Array</a></li><li><a href=/docs/algs/leetcode/91_decode_ways/>0091. Decode Ways</a></li><li><a href=/docs/algs/leetcode/92_reverse_linked_list_ii/>0092. Reverse Linked List II</a></li><li><a href=/docs/algs/leetcode/94_binary_tree_inorder_traversal/>0094. Bianry Tree Inorder Traversal</a></li><li><a href=/docs/algs/leetcode/98_validate_binary_search_tree/>0098. Validate Bianry Search Tree</a></li><li><a href=/docs/algs/leetcode/101_symmetric_tree/>0101. Symmetric Tree</a></li><li><a href=/docs/algs/leetcode/102_binary_tree_level_order_traversal/>0102. Binary Tree Level Order Traversal</a></li><li><a href=/docs/algs/leetcode/103_binary_tree_zigzag_level_order_traversal/>0103. Binary Tree ZigZag Level Order Traversal</a></li><li><a href=/docs/algs/leetcode/104_maximum_depth_of_binary_tree/>0104. Maximum Depth of Binary Tree</a></li><li><a href=/docs/algs/leetcode/105_construct_binary_tree_from_preorder_and_inorder_traversal/>0105. Construct Bianry Tree From Preorder and Inorder Traversal</a></li><li><a href=/docs/algs/leetcode/108_convert_sorted_array_to_binary_search_tree/>0108. Convert Sorted Array to Binary Search Tree</a></li><li><a href=/docs/algs/leetcode/111_minimum_depth_of_binary_tree/>0111. Minimum Depth of Binary Tree</a></li><li><a href=/docs/algs/leetcode/116_populating_next_right_pointers_in_each_node/>0116. Populating Next Right Pointers in Eech Node</a></li><li><a href=/docs/algs/leetcode/118_pascals_triangle/>0118. Pascal's Triangle</a></li><li><a href=/docs/algs/leetcode/120_triangle/>0120. Triangle</a></li><li><a href=/docs/algs/leetcode/121_best_time_to_buy_and_sell_stock/>0121. Best Time to But And Sell Stock</a></li><li><a href=/docs/algs/leetcode/122_best_time_to_buy_and_sell_stock_ii/>0122. Best Time to But And Sell Stock II</a></li><li><a href=/docs/algs/leetcode/124_binary_tree_maximum_path_sum/>0124. Binary Tree Maximum Path Sum</a></li><li><a href=/docs/algs/leetcode/125_valid_palindrome/>0125. Valid Palindrome</a></li><li><a href=/docs/algs/leetcode/127_word_ladder/>0127. Word Ladder</a></li><li><a href=/docs/algs/leetcode/128_longest_consecutive_sequence/>0128. Longest Consecurive Sequence</a></li><li><a href=/docs/algs/leetcode/130_surrounded_regions/>0130. Surrounded Regions</a></li><li><a href=/docs/algs/leetcode/131_palindrome_partitioning/>0131. Palindrome Partitioning</a></li><li><a href=/docs/algs/leetcode/133_clone_graph/>0133. Clone Graph</a></li><li><a href=/docs/algs/leetcode/134_gas_station/>0134. Gas Station</a></li><li><a href=/docs/algs/leetcode/136_single_number/>0136. Single Number</a></li><li><a href=/docs/algs/leetcode/138_copy_list_with_random_pointer/>0138. Copy List With Random Pointer</a></li><li><a href=/docs/algs/leetcode/141_Linked-List-Cycle/>0141. Linked List Cycle</a></li><li><a href=/docs/algs/leetcode/142_linked_list_cycle_ii/>0142. Linked List Cycle II</a></li><li><a href=/docs/algs/leetcode/146_lru_cache/>0146. LRU Cache</a></li><li><a href=/docs/algs/leetcode/148_sort_list/>0148. Sort List</a></li><li><a href=/docs/algs/leetcode/150_evaluate_reverse_polish_notation/>0150. Evaluate Reverse Polish Notation</a></li><li><a href=/docs/algs/leetcode/155_min_stack/>0155. Min Stack</a></li><li><a href=/docs/algs/leetcode/160_intersection_of_two_linked_lists/>0160. Intersection of Two Linked Lists</a></li><li><a href=/docs/algs/leetcode/162_find_peak_element/>0162. Find Peak Element</a></li><li><a href=/docs/algs/leetcode/167_two_sum_ii_input_array_is_sorted/>0167. Two Sum II - Input Array Is Sorted</a></li><li><a href=/docs/algs/leetcode/179_largest_numbe/>0179. Largest Number</a></li><li><a href=/docs/algs/leetcode/191_number_of_1_bits/>0191. Number of 1 Bits</a></li><li><a href=/docs/algs/leetcode/200_number_of_islands/>0200. Number of Islands</a></li><li><a href=/docs/algs/leetcode/206_reverse_linked_list/>0206. Reverse Linked List</a></li><li><a href=/docs/algs/leetcode/207_course_scheduler/>0207. Course Scheduler</a></li><li><a href=/docs/algs/leetcode/210_course_scheduler_ii/>0210. Course Scheduler II</a></li><li><a href=/docs/algs/leetcode/215_kth_largest_element_in_an_array/>0215. Kth Largest Element in an Array</a></li><li><a href=/docs/algs/leetcode/224_basic_calculator/>0224. Basic Calculator</a></li><li><a href=/docs/algs/leetcode/225_implement_stack_using_queues/>0225. Implement Stack using Queues</a></li><li><a href=/docs/algs/leetcode/226_invert_binary_tree/>0226. Invert Binary Tree</a></li><li><a href=/docs/algs/leetcode/227_basic_calculator_ii/>0227. Basic Calculator II</a></li><li><a href=/docs/algs/leetcode/230_kth_smallest_element_in_a_bst/>0230. Kth Smallest Element in a BST</a></li><li><a href=/docs/algs/leetcode/232_implement_queue_using_stacks/>0232. Implement Queue using Stacks</a></li><li><a href=/docs/algs/leetcode/235_lowest_common_ancestor_of_a_binary_tree/>0235. Lowest Common Ancestor of Binary Search Tree</a></li><li><a href=/docs/algs/leetcode/236_lowest_common_ancestor_of_binary_tree/>0236. Lowest Common Ancestor of Binary Tree</a></li><li><a href=/docs/algs/leetcode/240_search_a_2d_matrix_ii/>0240. Search a 2D Matrix II</a></li><li><a href=/docs/algs/leetcode/263_ugly_number/>0263. Ugly Number</a></li><li><a href=/docs/algs/leetcode/264_ugly_number_ii/>0264. Ugly Number II</a></li><li><a href=/docs/algs/leetcode/268_missing_number/>0268. Missing Number</a></li><li><a href=/docs/algs/leetcode/277_find_the_celebrity/>0277. Find the Celebrity</a></li><li><a href=/docs/algs/leetcode/278_first_bad_version/>0278. First Bad Version</a></li><li><a href=/docs/algs/leetcode/281_zigzag_iterator/>0281. Zigzag Iterator</a></li><li><a href=/docs/algs/leetcode/283_moving_zeroes/>0283. Moving Zeroes</a></li><li><a href=/docs/algs/leetcode/290_word_pattern/>0290. Word Pattern</a></li><li><a href=/docs/algs/leetcode/303_range_sum_query_immutable/>0303. Range Sum Query - Immutable</a></li><li><a href=/docs/algs/leetcode/307_range_sum_query_mutable/>0304. Range Sum Query - Mutable</a></li><li><a href=/docs/algs/leetcode/304_range_sum_query_2d_immutable/>0304. Range Sum Query 2D - Immutable</a></li><li><a href=/docs/algs/leetcode/310_minimum_height_trees/>0310. Minimum Height Tree</a></li><li><a href=/docs/algs/leetcode/313_super_ugly_number/>0313. Super Ugly Number</a></li><li><a href=/docs/algs/leetcode/314_binary_tree_vertical_order_traversal/>0314. Binary Tree Vertical Order Traversal</a></li><li><a href=/docs/algs/leetcode/318_maximum_product_of_word_lengths/>0318. Maximum Product of Word Lengths</a></li><li><a href=/docs/algs/leetcode/328_odd_even_linked_list/>0328. Odd Even Linked List</a></li><li><a href=/docs/algs/leetcode/346_moving_average_from_data_stream/>0346. Moving Average from Data Stream</a></li><li><a href=/docs/algs/leetcode/347_top_k_frequent_elements/>0347. Top K Frequent Elements</a></li><li><a href=/docs/algs/leetcode/349_intersection_of_two_arrays/>0349. Intersection of Two Arrays</a></li><li><a href=/docs/algs/leetcode/350_intersection_of_two_arrays_ii/>0350. Intersection of Two Arrays II</a></li><li><a href=/docs/algs/leetcode/354_russian_doll_envelopes/>0354. Russian Doll Envelopes</a></li><li><a href=/docs/algs/leetcode/362_design_hit_counter/>0362. Design Hit Counter</a></li><li><a href=/docs/algs/leetcode/367_valid_perfect_square/>0362. Design Hit Counter</a></li><li><a href=/docs/algs/leetcode/366_find_leaves_of_binary_tree/>0366. Find Leaves of Binary Tree</a></li><li><a href=/docs/algs/leetcode/378_kth_smallest_element_in_a_sorted_matrix/>0378. Kth Smallest Element in a Sorted Matrix</a></li><li><a href=/docs/algs/leetcode/380_insert_delete_getrandom_O1/>0380. Insert Delete GetRandom O(1)</a></li><li><a href=/docs/algs/leetcode/409_longest_palindrome/>0409. Longest Palindrome</a></li><li><a href=/docs/algs/leetcode/417_pacific_atlantic_water_flow/>0417. Pacific Atlantic Water Flow</a></li><li><a href=/docs/algs/leetcode/424_longest_repeating_character_replacement/>0424. Longest Repeating Character Replacement</a></li><li><a href=/docs/algs/leetcode/453_minimum_moves_to_equal_array_elements/>0453. Minimum Moves to Equal Array Elements</a></li><li><a href=/docs/algs/leetcode/454_4sum_ii/>0454. 4 Sum II</a></li><li><a href=/docs/algs/leetcode/462_minimum_moves_to_equal_array_elements/>0462. Minimum Moves to Equal Array Elements</a></li><li><a href=/docs/algs/leetcode/474_ones_and_zeroes/>0474. Ones and Zeroes</a></li><li><a href=/docs/algs/leetcode/485_max_consecutive_ones/>0485. Max Consecutive Ones</a></li><li><a href=/docs/algs/leetcode/487_max_consecutive_ones_ii/>0487. Max Consecutive Ones II</a></li><li><a href=/docs/algs/leetcode/490_the_maze/>0490. The Maze</a></li><li><a href=/docs/algs/leetcode/528_random_pick_with_weight/>0528. Random Pick with Weight</a></li><li><a href=/docs/algs/leetcode/540_single_element_in_a_sorted_array/>0540. Single Element in a Sorted Array</a></li><li><a href=/docs/algs/leetcode/542_01_matrix/>0542. 01 Matrix</a></li><li><a href=/docs/algs/leetcode/543_diameter_of_binary_tree/>0543. Diameter of Binary Tree</a></li><li><a href=/docs/algs/leetcode/559_maximum_dpeth_of_n-ary_tree/>0559. Maximum Depth of N-ary Tree</a></li><li><a href=/docs/algs/leetcode/560_subarray_sum_equals_k/>0560. Subarray Sum Equals K</a></li><li><a href=/docs/algs/leetcode/572_subtree_of_another_tree/>0572. Subtree of Another Tree</a></li><li><a href=/docs/algs/leetcode/583_delete_operation_for_two_strings/>0583. Delete Operations for Two Strings</a></li><li><a href=/docs/algs/leetcode/630_course_schedule_iii/>0630. Course Schedule III</a></li><li><a href=/docs/algs/leetcode/643_maximum_average_subarray_i_/>0643. Maximum Average Subarray I</a></li><li><a href=/docs/algs/leetcode/647_palindromic_substrings/>0647. Palindromic Substrings</a></li><li><a href=/docs/algs/leetcode/665_non_decreasing_array/>0665. Non-decreasing Array</a></li><li><a href=/docs/algs/leetcode/669_trim_a_binary_search_tree/>0669. Trim a Binary Search Tree</a></li><li><a href=/docs/algs/leetcode/700_search_in_a_binary_search_tree/>0700. Search In a Binary Search Tree</a></li><li><a href=/docs/algs/leetcode/718_maximum_length_of_repeated_subarray/>0718. Maximum Length of Repeated Subarray</a></li><li><a href=/docs/algs/leetcode/735_asteroid_collision/>0735. Asteroid Collisiion</a></li><li><a href=/docs/algs/leetcode/745_prefix_and_suffix_search/>0745. Prefix and Suffix Search</a></li><li><a href=/docs/algs/leetcode/752_open_the_lock/>0752. Open the Lock</a></li><li><a href=/docs/algs/leetcode/767_reorganizing_string/>0767. Reorganize String</a></li><li><a href=/docs/algs/leetcode/820_short_encoding_of_words/>0820. Short Encoding of Words</a></li><li><a href=/docs/algs/leetcode/867_transpose_matrix/>0867. Transpose Matrix</a></li><li><a href=/docs/algs/leetcode/876_median_of_the_linked_list/>0876. Median of the Linked List</a></li><li><a href=/docs/algs/leetcode/895_max_frequency_stack/>0895. Max Frequency Stack</a></li><li><a href=/docs/algs/leetcode/968_binary_tree_cameras/>0968. Binary Tree Cameras</a></li><li><a href=/docs/algs/leetcode/973_k_closest_points_to_origin/>0973. K Closest Points to Origin</a></li><li><a href=/docs/algs/leetcode/1004_max_consecutive_ones_iii/>1004. Max Consecutive Ones III</a></li><li><a href=/docs/algs/leetcode/1047_remove_all_duplicated_in_string/>1047. Remove All Adjacent Duplicates in String</a></li><li><a href=/docs/algs/leetcode/1048_longest_string_chain/>1048. Longest String Chain</a></li><li><a href=/docs/algs/leetcode/1060_missing_element_in_sorted_array/>1060. Missing Element in Sorted Array</a></li><li><a href=/docs/algs/leetcode/1062_longest_repeating_substring/>1062. Longest Repeating Substring</a></li><li><a href=/docs/algs/leetcode/1086_high_five/>1086. High Five</a></li><li><a href=/docs/algs/leetcode/1091_shortest_path_in_binary_matrix/>1091. Shortest Path in Binary Matrix</a></li><li><a href=/docs/algs/leetcode/1095_find_in_mountain_array/>1095. Find in Mountain Array</a></li><li><a href=/docs/algs/leetcode/1209_remove_all_adjacent_duplicates_in_string_ii/>1209. Remove All Adjacent Duplicates in String</a></li><li><a href=/docs/algs/leetcode/1249_minimum_remove_to_make_valid_parentheses/>1249. Minimum Remove to Make Valid Parentheses</a></li><li><a href=/docs/algs/leetcode/1268_search_suggestions_system/>1268. Search Suggestions System</a></li><li><a href=/docs/algs/leetcode/1300_sum_of_mutated_array_closest_to_target/>1300. Sum of Mutated Array Closest to Target</a></li><li><a href=/docs/algs/leetcode/1332_remove_palindromic_subsequence/>1332. Remove Palindromic Subsequences</a></li><li><a href=/docs/algs/leetcode/1342_number_of_steps_to_reduce_a_number_to_zero/>1342. Number of Steps to Reduce a Number to Zero</a></li><li><a href=/docs/algs/leetcode/1423_maximum_points_you_can_obtain_from_cards/>1423. Maximum Points You Can Obrain fron Cards</a></li><li><a href=/docs/algs/leetcode/1429_first_unique_number/>1429. First Unique Number</a></li><li><a href=/docs/algs/leetcode/1438_longest_continuous_subarray_with_absolute_diff_less_than_or_equal_to_limit/>1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit</a></li><li><a href=/docs/algs/leetcode/1461_check_if_a_string_contains_all_binary_codes_of_size_k/>1461. Check If a String Contains All Binary Codes of Size K</a></li><li><a href=/docs/algs/leetcode/1472_design_browser_history/>1472. Design Browser History</a></li><li><a href=/docs/algs/leetcode/1480_running_sum_of_1d_array/>1480. Running Sum of 1d Array</a></li><li><a href=/docs/algs/leetcode/1642_furthest_building_you_can_reach/>1642. Furthest Building you Can Reach</a></li><li><a href=/docs/algs/leetcode/1647_minimum_deletions_to_make_character_frequencies_unique/>1647. Minimum Deletions to Make Character Frequencies Unique</a></li><li><a href=/docs/algs/leetcode/1658_minimum_operations_to_reduce_x_to_zero/>1658. Minimum Operations to Reduce X to Zero</a></li><li><a href=/docs/algs/leetcode/1689_partitioning_into_minimum_number_of_deci-binary_numbers/>1689. Partitioning Into Minimum Number of Deci-Binary Numbers</a></li><li><a href=/docs/algs/leetcode/1695_maximum_erasure_value/>1695. Maximum Erasure Value</a></li><li><a href=/docs/algs/leetcode/Blind-75-list/>Blind 75 List</a></li><li><a href=/docs/algs/leetcode/Top-Leetcode-Interview-Questions/>Top Interview Questions</a></li><li><a href=/docs/algs/leetcode/14-patterns-to-ace-any-coding-interview-questions/>14 Patterns to Ace Any Coding Interview Questions</a></li><li><a href=/docs/algs/leetcode/692_top_k_frequent_words/>692 Top K Frequent Words</a></li></ul></li><li><input type=checkbox id=section-2135572cc1c37157e360bfb0e28edc10 class=toggle>
<label for=section-2135572cc1c37157e360bfb0e28edc10 class="flex justify-between"><a href=/docs/algs/others/>Others</a></label><ul><li><a href=/docs/algs/others/2.-%E7%AD%89%E6%A6%82%E7%8E%87%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E4%B8%AD-k-%E4%B8%AA%E5%85%83%E7%B4%A0/>等概率返回数组中 k 个元素</a></li></ul></li></ul></li></ul><ul><li><a href=/posts/>Blog</a></li><li><a href=https://github.com/alex-shpak/hugo-book target=_blank rel=noopener>Github</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Hugo Themes</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Leetcode</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#data-structure>Data structure</a><ul><li><a href=#stack>Stack</a></li><li><a href=#heap>Heap</a></li><li><a href=#queue>Queue</a></li><li><a href=#hash-table>Hash Table</a></li><li><a href=#graph>Graph</a></li><li><a href=#linked-list>Linked List</a></li><li><a href=#string>String</a></li><li><a href=#array>Array</a></li><li><a href=#tree>Tree</a></li></ul></li><li><a href=#search>Search</a><ul><li><a href=#bianry-search>Bianry Search</a></li></ul></li><li><a href=#math>Math</a><ul><li><a href=#bit-manipulation>Bit Manipulation</a></li><li><a href=#math-computation>Math Computation</a></li></ul></li><li><a href=#dynamic-programming>Dynamic Programming</a></li><li><a href=#prefix-sum>Prefix Sum</a></li><li><a href=#sort>Sort</a></li><li><a href=#two-pointers>Two Pointers</a></li><li><a href=#backtrace>Backtrace</a></li><li><a href=#sliding-window>Sliding Window</a></li><li><a href=#greedy-algorithms>Greedy Algorithms</a></li><li><a href=#divide-and-conquer>Divide and Conquer</a></li></ul></li></ul></nav></aside></header><article class=markdown><p>这里是一些 LeetCode 的刷题题解。</p><h2 id=data-structure>Data structure
<a class=anchor href=#data-structure>#</a></h2><h3 id=stack>Stack
<a class=anchor href=#stack>#</a></h3><table><thead><tr><th style=text-align:left>Problem</th><th style=text-align:left>Difficulty</th><th style=text-align:left>Method</th><th style=text-align:left>Redo</th><th style=text-align:left>Comment</th></tr></thead><tbody><tr><td style=text-align:left>155. Min Stack</td><td style=text-align:left>easy</td><td style=text-align:left>Stack、Monotone Stack</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>150. Evalute Reverse Polish Notation</td><td style=text-align:left>medium</td><td style=text-align:left>Stack</td><td style=text-align:left>No</td><td style=text-align:left>简单题，无需多看</td></tr><tr><td style=text-align:left>224. Basic Calculator</td><td style=text-align:left>hard</td><td style=text-align:left>Stack</td><td style=text-align:left>YES</td><td style=text-align:left>题目为难题，暂时跳过。注意这里是如何将中缀表达式转换为后缀表达式的</td></tr><tr><td style=text-align:left>227. Basic Calculator</td><td style=text-align:left>medium</td><td style=text-align:left>Stack</td><td style=text-align:left>YES</td><td style=text-align:left>稍微有点耗时，先跳过</td></tr><tr><td style=text-align:left>20. Valid Parentheses</td><td style=text-align:left>easy</td><td style=text-align:left>Stack</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>1472. Design Browser History</td><td style=text-align:left>medium</td><td style=text-align:left>Stack</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>1047. Remove All Adjacent Duplicates in String</td><td style=text-align:left>easy</td><td style=text-align:left>Stack</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>1249. Minimum Remove to Make Valid Parentheses</td><td style=text-align:left>medium</td><td style=text-align:left>Stack</td><td style=text-align:left>Yes</td><td style=text-align:left></td></tr><tr><td style=text-align:left>735. Asteroid Collision</td><td style=text-align:left>medium</td><td style=text-align:left>Stack</td><td style=text-align:left>Yes</td><td style=text-align:left></td></tr></tbody></table><h3 id=heap>Heap
<a class=anchor href=#heap>#</a></h3><table><thead><tr><th style=text-align:left>Problem</th><th style=text-align:left>Difficulty</th><th style=text-align:left>Method</th><th style=text-align:left>Redo</th><th style=text-align:left>Comment</th></tr></thead><tbody><tr><td style=text-align:left>973. K Closest Points to Origin</td><td style=text-align:left>medium</td><td style=text-align:left>Sort、 Heap</td><td style=text-align:left>No</td><td style=text-align:left>要看到本质问题，然后解决本质问题。</td></tr><tr><td style=text-align:left>347. Top K Frequent Elements</td><td style=text-align:left>medium</td><td style=text-align:left>Sort、 Hash Table、Heap</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>23. Merge K Sorted Lists</td><td style=text-align:left>medium</td><td style=text-align:left>Sort、 Heap</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>378. Kth Smallest Element in a Sorted Matrix</td><td style=text-align:left>medium</td><td style=text-align:left>Heap、Max Heap</td><td style=text-align:left>YES</td><td style=text-align:left>这个题一开始没有想到堆的解法，还是需要注意一下</td></tr><tr><td style=text-align:left>767. Reorganize String</td><td style=text-align:left>medium</td><td style=text-align:left>Heap、Sort</td><td style=text-align:left>YES</td><td style=text-align:left>这里的解法还是比较巧妙的，需要多注意一下</td></tr><tr><td style=text-align:left>1642.Furthest Building you can Reach</td><td style=text-align:left>medium</td><td style=text-align:left>Heap、Priority Queue</td><td style=text-align:left>YES</td><td style=text-align:left>这里的解法很巧妙，需要注意一下</td></tr><tr><td style=text-align:left>215. Kth Largest Element in an Array</td><td style=text-align:left>medium</td><td style=text-align:left>Heap、Quick Select</td><td style=text-align:left>YES</td><td style=text-align:left>这里的 Quick Select 算法需要熟练一下</td></tr></tbody></table><h3 id=queue>Queue
<a class=anchor href=#queue>#</a></h3><table><thead><tr><th style=text-align:left>Problem</th><th style=text-align:left>Difficulty</th><th style=text-align:left>Method</th><th style=text-align:left>Redo</th><th style=text-align:left>Comment</th></tr></thead><tbody><tr><td style=text-align:left>225. Implement Stack using Queues</td><td style=text-align:left>easy</td><td style=text-align:left>Queue</td><td style=text-align:left>No</td><td style=text-align:left>简单题，不需要多看</td></tr><tr><td style=text-align:left>346. Moving Average from Data Stream</td><td style=text-align:left>easy</td><td style=text-align:left>Queue</td><td style=text-align:left>No</td><td style=text-align:left>简单题，不需要多看</td></tr><tr><td style=text-align:left>281. ZigZag Iterator</td><td style=text-align:left>medium</td><td style=text-align:left>Queue</td><td style=text-align:left>YES</td><td style=text-align:left>注意这里的队列的使用，还是挺妙的</td></tr><tr><td style=text-align:left>1429. First Unique Number</td><td style=text-align:left>unknown</td><td style=text-align:left>Queue、 Hash Table</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>362. Design Hit Counter</td><td style=text-align:left>unknown</td><td style=text-align:left>Queue</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>264. Ugly Number II</td><td style=text-align:left>medium</td><td style=text-align:left>Queue</td><td style=text-align:left>YES</td><td style=text-align:left>第一次做的时候做了一个错误解法，还是要注意丑数是怎么推出来的</td></tr><tr><td style=text-align:left>1642.Furthest Building you can Reach</td><td style=text-align:left>medium</td><td style=text-align:left>Heap、Priority Queue</td><td style=text-align:left>YES</td><td style=text-align:left>这里的解法很巧妙，需要注意一下</td></tr><tr><td style=text-align:left>542. 01 Matrix</td><td style=text-align:left>medium</td><td style=text-align:left>BFS</td><td style=text-align:left>YES</td><td style=text-align:left>一个复杂的 case 完全可以让正确的算法不能 AC，所以就解题而言，先要把复杂的 case 给进行优先处理，或者算法的实现要考虑复杂 case 的情况</td></tr></tbody></table><h3 id=hash-table>Hash Table
<a class=anchor href=#hash-table>#</a></h3><table><thead><tr><th style=text-align:left>Problem</th><th style=text-align:left>Difficulty</th><th style=text-align:left>Method</th><th style=text-align:left>Redo</th><th style=text-align:left>Comment</th></tr></thead><tbody><tr><td style=text-align:left>1. Two Sum</td><td style=text-align:left>easy</td><td style=text-align:left>Hash Table、Sort、Two Pointer</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>146. LRU Cache</td><td style=text-align:left>medium</td><td style=text-align:left>Double Linked List、Hash Table</td><td style=text-align:left>YES</td><td style=text-align:left>在双向链表中添加 dummyHead 和 dummyTail 能够避免很多条件判断</td></tr><tr><td style=text-align:left>128. Longest Consecutive Sequence</td><td style=text-align:left>medium</td><td style=text-align:left>Hash Table</td><td style=text-align:left>YES</td><td style=text-align:left>注意考虑为什么这里可以把遍历过的元素删除掉</td></tr><tr><td style=text-align:left>380. Insert Delete GetRandom O(1)</td><td style=text-align:left>medium</td><td style=text-align:left>Hash Table、Array</td><td style=text-align:left>YES</td><td style=text-align:left>注意这里删除元素的 tricky 部分</td></tr><tr><td style=text-align:left>1461. Check If a String Contans All Binary Codes of Size K</td><td style=text-align:left>medium</td><td style=text-align:left>Hash Table、String</td><td style=text-align:left>YES</td><td style=text-align:left>这里首先要注意怎么一步一步从暴力算法开始进行优化，然后逐渐过渡到使用 map 来做记忆化的；另外还需要注意 golang 的格式化字符串 padding 方法</td></tr><tr><td style=text-align:left>349. Intersection of Two Arrays</td><td style=text-align:left>easy</td><td style=text-align:left>Hash Table</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>350. Intersection of Two Arrays II</td><td style=text-align:left>easy</td><td style=text-align:left>Hash Table</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>1086. High Five</td><td style=text-align:left>easy</td><td style=text-align:left>Hash Table、Sort</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>692. Top K Frequent Words</td><td style=text-align:left>medium</td><td style=text-align:left>Sort、 Hash Table</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>895. Max Frequency Stack</td><td style=text-align:left>hard</td><td style=text-align:left>Hash Table、Stack</td><td style=text-align:left>YES</td><td style=text-align:left>这里的解法很巧妙，需要注意一下</td></tr><tr><td style=text-align:left>745. Prefix and Suffix Search</td><td style=text-align:left>hard</td><td style=text-align:left>Hash Table、String</td><td style=text-align:left>YES</td><td style=text-align:left>有时间暴力解法也是没问题的</td></tr><tr><td style=text-align:left>1268. Search Suggestions System</td><td style=text-align:left>medium</td><td style=text-align:left>Hash Table、String、Trie Tree</td><td style=text-align:left>YES</td><td style=text-align:left>这里的剪枝算法需要注意一下</td></tr><tr><td style=text-align:left>409. Longest Palindrome</td><td style=text-align:left>easy</td><td style=text-align:left>Hash Table、String</td><td style=text-align:left>YES</td><td style=text-align:left>这里的解法，要注意一下</td></tr><tr><td style=text-align:left>820. Short Encoding of Words</td><td style=text-align:left>medium</td><td style=text-align:left>Hash Table、String</td><td style=text-align:left>YES</td><td style=text-align:left>这里的思路比较巧妙</td></tr><tr><td style=text-align:left>454. 4Sum II</td><td style=text-align:left>medium</td><td style=text-align:left>Hash Table、Divide</td><td style=text-align:left>YES</td><td style=text-align:left>这里降低时间复杂度的思想比较巧妙，值得学习</td></tr><tr><td style=text-align:left>277. Find the Celebrity</td><td style=text-align:left>medium</td><td style=text-align:left>Hash Table、Graph</td><td style=text-align:left>YES</td><td style=text-align:left>这里的图论思想很值得思考</td></tr><tr><td style=text-align:left>138. Copy List With Random Pointer</td><td style=text-align:left>medium</td><td style=text-align:left>Hash Table、List</td><td style=text-align:left>YES</td><td style=text-align:left>列表、图拷贝都需要结合哈希表来做</td></tr><tr><td style=text-align:left>290. Word Patten</td><td style=text-align:left>easy</td><td style=text-align:left>Hash Table</td><td style=text-align:left>YES</td><td style=text-align:left>注意这里是个双射</td></tr></tbody></table><h3 id=graph>Graph
<a class=anchor href=#graph>#</a></h3><table><thead><tr><th style=text-align:left>Problem</th><th style=text-align:left>Difficulty</th><th style=text-align:left>Method</th><th style=text-align:left>Redo</th><th style=text-align:left>Comment</th></tr></thead><tbody><tr><td style=text-align:left>277. Find the Celebrity</td><td style=text-align:left>medium</td><td style=text-align:left>Hash Table、Graph</td><td style=text-align:left>YES</td><td style=text-align:left>这里的图论思想很值得思考</td></tr><tr><td style=text-align:left>200. Number of Islands</td><td style=text-align:left>medium</td><td style=text-align:left>DFS、Graph</td><td style=text-align:left>YES</td><td style=text-align:left></td></tr><tr><td style=text-align:left>133. Clone Graph</td><td style=text-align:left>medium</td><td style=text-align:left>DFS、BFS</td><td style=text-align:left>YES</td><td style=text-align:left>这里 map 的用法很巧妙</td></tr><tr><td style=text-align:left>490. The Maze</td><td style=text-align:left>medium</td><td style=text-align:left>BFS、DFS</td><td style=text-align:left>YES</td><td style=text-align:left>这也算是 BFS 的变体应用，也可以从这里总结出一个 pattern 出来</td></tr><tr><td style=text-align:left>130. Surrounding Regions</td><td style=text-align:left>medium</td><td style=text-align:left>DFS、BFS</td><td style=text-align:left>YES</td><td style=text-align:left>反向思考</td></tr><tr><td style=text-align:left>1091. Shortest Path in Binary Matrix</td><td style=text-align:left>medium</td><td style=text-align:left>DFS、BFS</td><td style=text-align:left>YES</td><td style=text-align:left>这个题有很多注意点需要看：一个是迷宫遍历的变体，另一个是数字转换为字符串的坑</td></tr><tr><td style=text-align:left>417. Pacific Atlantic Water Flow</td><td style=text-align:left>medium</td><td style=text-align:left>DFS</td><td style=text-align:left>YES</td><td style=text-align:left>这个题的思路很有用，另外也有几个遍历技巧值得注意</td></tr><tr><td style=text-align:left>207. Course Scheduler</td><td style=text-align:left>medium</td><td style=text-align:left>BFS、DFS、Topological Sorting</td><td style=text-align:left>YES</td><td style=text-align:left>这里是典型的拓扑排序的解法</td></tr><tr><td style=text-align:left>210. Course Scheduler II</td><td style=text-align:left>medium</td><td style=text-align:left>BFS、DFS、Topological Sorting</td><td style=text-align:left>YES</td><td style=text-align:left>注意拓扑排序中是什么时候需要加入节点</td></tr><tr><td style=text-align:left>51. N-Queens</td><td style=text-align:left>hard</td><td style=text-align:left>DFS、Brute Force</td><td style=text-align:left>YES</td><td style=text-align:left>N 皇后问题，当前行、列以及主/副对角线都不能有皇后</td></tr></tbody></table><h3 id=linked-list>Linked List
<a class=anchor href=#linked-list>#</a></h3><table><thead><tr><th style=text-align:left>Problem</th><th style=text-align:left>Difficulty</th><th style=text-align:left>Method</th><th style=text-align:left>Redo</th><th style=text-align:left>Comment</th></tr></thead><tbody><tr><td style=text-align:left>160. Intersection of Two Linked Lists</td><td style=text-align:left>easy</td><td style=text-align:left>Two Pointer、 Hash Table</td><td style=text-align:left>YES</td><td style=text-align:left>注意可能会出现无交点的情况</td></tr><tr><td style=text-align:left>206. Reverse Linked List</td><td style=text-align:left>easy</td><td style=text-align:left>Stack、Recursive</td><td style=text-align:left>YES</td><td style=text-align:left>注意这里的递归法中，如何反转节点</td></tr><tr><td style=text-align:left>876. Middle of the Linked List</td><td style=text-align:left>easy</td><td style=text-align:left>Two Pointer</td><td style=text-align:left>YES</td><td style=text-align:left>注意这里是如何判断中间节点的</td></tr><tr><td style=text-align:left>141. Linked List Cycle</td><td style=text-align:left>easy</td><td style=text-align:left>Hash Table、 Two Pointer</td><td style=text-align:left>YES</td><td style=text-align:left>注意这里的快慢指针解法</td></tr><tr><td style=text-align:left>142. Linked List Cycle II</td><td style=text-align:left>medium</td><td style=text-align:left>Linked List、Hash Table、Two Pointer</td><td style=text-align:left>YES</td><td style=text-align:left>注意这里的快慢指针解法</td></tr><tr><td style=text-align:left>92. Reverse Linked List II</td><td style=text-align:left>medium</td><td style=text-align:left>Linked List、 Stack</td><td style=text-align:left>YES</td><td style=text-align:left>注意这里是如何使用指针来进行翻转的</td></tr><tr><td style=text-align:left>328. Odd Even Linked List</td><td style=text-align:left>medium</td><td style=text-align:left>Linked List、 Two Pointer</td><td style=text-align:left>YES</td><td style=text-align:left>注意这里是如何连接节点的</td></tr><tr><td style=text-align:left>146. LRU Cache</td><td style=text-align:left>medium</td><td style=text-align:left>Double Linked List、Hash Table</td><td style=text-align:left>YES</td><td style=text-align:left>在双向链表中添加 dummyHead 和 dummyTail 能够避免很多条件判断</td></tr></tbody></table><h3 id=string>String
<a class=anchor href=#string>#</a></h3><table><thead><tr><th style=text-align:left>Problem</th><th style=text-align:left>Difficulty</th><th style=text-align:left>Method</th><th style=text-align:left>Redo</th><th style=text-align:left>Comment</th></tr></thead><tbody><tr><td style=text-align:left>28. Implement strStr</td><td style=text-align:left>easy</td><td style=text-align:left>None</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>44. Wildcard Matching</td><td style=text-align:left>hard</td><td style=text-align:left>Recusive</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>318. Maximum Product of Word Lengths</td><td style=text-align:left>medium</td><td style=text-align:left>Hash Table</td><td style=text-align:left>Yes</td><td style=text-align:left>这里的解法很精妙，使用了一个 int 来做记录，提升了性能</td></tr><tr><td style=text-align:left>1332. Remove Palindromic Subsequences</td><td style=text-align:left>easy</td><td style=text-align:left>String、Palindrome</td><td style=text-align:left>YES</td><td style=text-align:left>这里是一个脑筋急转弯</td></tr><tr><td style=text-align:left>1689. Partitioning Into Minimum Number Of Deci-Binary Numbers</td><td style=text-align:left>medium</td><td style=text-align:left>String、 Math</td><td style=text-align:left>YES</td><td style=text-align:left>这里的解法很巧妙，如果没有答案里的特殊方法，肯定是很难解出来的</td></tr></tbody></table><h3 id=array>Array
<a class=anchor href=#array>#</a></h3><table><thead><tr><th style=text-align:left>Problem</th><th style=text-align:left>Difficulty</th><th style=text-align:left>Method</th><th style=text-align:left>Redo</th><th style=text-align:left>Comment</th></tr></thead><tbody><tr><td style=text-align:left>36. Valid Sudoku</td><td style=text-align:left>medium</td><td style=text-align:left>None</td><td style=text-align:left>YES</td><td style=text-align:left>注意这里如何创建三维数组，以及坐标的转换</td></tr><tr><td style=text-align:left>41. First Missing Positive</td><td style=text-align:left>Hard</td><td style=text-align:left>HashTable, Array</td><td style=text-align:left>YES</td><td style=text-align:left>注意 while 循环是如何交换元素的，以及 while 循环为什么不能用 if 语句代替</td></tr><tr><td style=text-align:left>54. Spiral Matrix</td><td style=text-align:left>medium</td><td style=text-align:left></td><td style=text-align:left>Array</td><td style=text-align:left>YES</td></tr><tr><td style=text-align:left>73. Set Matrix Zeroes</td><td style=text-align:left>medium</td><td style=text-align:left>记忆化方法</td><td style=text-align:left>YES</td><td style=text-align:left>注意这里是如何复用原数组以及采用的记忆化方法</td></tr><tr><td style=text-align:left>1480. Running Sum of 1d Array</td><td style=text-align:left>easy</td><td style=text-align:left>Array</td><td style=text-align:left>No</td><td style=text-align:left>简单题，不用再多看了</td></tr><tr><td style=text-align:left>867. Transpose Matrix</td><td style=text-align:left>easy</td><td style=text-align:left>Array、Matrix</td><td style=text-align:left>No</td><td style=text-align:left>简单题，不需要多看了</td></tr><tr><td style=text-align:left>167. Two Sum II - Input Array Is Sorted</td><td style=text-align:left>medium</td><td style=text-align:left>Array、Two Pointer</td><td style=text-align:left>No</td><td style=text-align:left>简单题，无需多看</td></tr></tbody></table><h3 id=tree>Tree
<a class=anchor href=#tree>#</a></h3><table><thead><tr><th style=text-align:left>Problem</th><th style=text-align:left>Difficulty</th><th style=text-align:left>Method</th><th style=text-align:left>Redo</th><th style=text-align:left>Comment</th></tr></thead><tbody><tr><td style=text-align:left>102. Binary Tree Level Order Traversal</td><td style=text-align:left>medium</td><td style=text-align:left>Binary Tree、BFS</td><td style=text-align:left>No</td><td style=text-align:left>基础题，必须要会做</td></tr><tr><td style=text-align:left>103. Binary Tree ZigZag Level Order Traversal</td><td style=text-align:left>medium</td><td style=text-align:left>Binary Tree、BFS</td><td style=text-align:left>NO</td><td style=text-align:left>简单题，解法跟 102 题一致</td></tr><tr><td style=text-align:left>314. Binary Tree Vertical Order Traversal</td><td style=text-align:left>medium</td><td style=text-align:left>Binary Tree、BFS</td><td style=text-align:left>YES</td><td style=text-align:left>这里是 BFS 的应用之一，这里我一开始没想出编号的方法</td></tr><tr><td style=text-align:left>752. Open the Lock</td><td style=text-align:left>medium</td><td style=text-align:left>BFS</td><td style=text-align:left>YES</td><td style=text-align:left>这里是迷宫遍历的变体，用到的几个 trick 需要注意一下</td></tr><tr><td style=text-align:left>543. Diameter of Binary Tree</td><td style=text-align:left>easy</td><td style=text-align:left>Recursive</td><td style=text-align:left>NO</td><td style=text-align:left></td></tr><tr><td style=text-align:left>310. Minimum Height Tree</td><td style=text-align:left>medium</td><td style=text-align:left>BFS</td><td style=text-align:left>YES</td><td style=text-align:left>这里首先注意 BFS 的终止条件，这里与一般的 BFS 不太相同；第二注意如何将 BFS 应用到无向图</td></tr><tr><td style=text-align:left>366. Find Leaves of Binary Tree</td><td style=text-align:left>medium</td><td style=text-align:left>BFS</td><td style=text-align:left>YES</td><td style=text-align:left>这个题的解法与 310 题差不多，其实都是图的拓扑排序的问题，而且 310 和 366 都是针对无向图进行的拓扑排序，还是很值得关注的</td></tr><tr><td style=text-align:left>124. Binary Tree Maximum Path Sum</td><td style=text-align:left>hard</td><td style=text-align:left>Tree、Branch Pruning</td><td style=text-align:left>YES</td><td style=text-align:left>这里的剪枝过程比较值得关注</td></tr><tr><td style=text-align:left>226. Invert Binary Tree</td><td style=text-align:left>easy</td><td style=text-align:left>Recursive</td><td style=text-align:left>NO</td><td style=text-align:left></td></tr><tr><td style=text-align:left>101. Symmetic Tree</td><td style=text-align:left>easy</td><td style=text-align:left>Recursive</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>236. Lowest Common Ancestor of Binary Tree</td><td style=text-align:left>medium</td><td style=text-align:left>Recursive、Binary Tree</td><td style=text-align:left>YES</td><td style=text-align:left>这里的分析过程需要注意</td></tr><tr><td style=text-align:left>235. Lowest Common Ancestor of Binary Search Tree</td><td style=text-align:left>medium</td><td style=text-align:left>Recursive、Iterative</td><td style=text-align:left>YES</td><td style=text-align:left>这里需要注意的是如何将递归思路转换为迭代的思路</td></tr><tr><td style=text-align:left>104. Max Depth of Binary Tree</td><td style=text-align:left>easy</td><td style=text-align:left>Recursive、Iterative</td><td style=text-align:left>YES</td><td style=text-align:left>这里的迭代解法需要注意一下</td></tr><tr><td style=text-align:left>559. Maximum Depth of N-ary Tree</td><td style=text-align:left>easy</td><td style=text-align:left>Iterative</td><td style=text-align:left>No</td><td style=text-align:left>这里实际上就是 104 题的扩展版</td></tr><tr><td style=text-align:left>111. Minimum Depth of Binary Tree</td><td style=text-align:left>easy</td><td style=text-align:left>Recursive、Iterative</td><td style=text-align:left>No</td><td style=text-align:left>这里需要注意递归解法的遍历终止条件</td></tr><tr><td style=text-align:left>572. Subtree of Another Tree</td><td style=text-align:left>easy</td><td style=text-align:left>Recursive</td><td style=text-align:left>Yes</td><td style=text-align:left>注意这里 SameTree 的写法</td></tr><tr><td style=text-align:left>230. Kth Smallest Element in a BST</td><td style=text-align:left>medium</td><td style=text-align:left>BST、 Inorder Traversal</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>98. Validate Binary Search Tree</td><td style=text-align:left>medium</td><td style=text-align:left>BST、Recursive</td><td style=text-align:left>YES</td><td style=text-align:left></td></tr><tr><td style=text-align:left>669. Trim a Binary Search Tree</td><td style=text-align:left>medium</td><td style=text-align:left>Recursive</td><td style=text-align:left>YES</td><td style=text-align:left>这里跟最小公共子节点的解法一致，但是在对子节点进行处理上不太一致。</td></tr><tr><td style=text-align:left>700. Search In a Binary Search Tree</td><td style=text-align:left>easy</td><td style=text-align:left>Recursive、Iterative、BST</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>108. Convert Sorted Array to Binary Search Tree</td><td style=text-align:left>easy</td><td style=text-align:left>Recursive、BST</td><td style=text-align:left>No</td><td style=text-align:left></td></tr></tbody></table><h2 id=search>Search
<a class=anchor href=#search>#</a></h2><h3 id=bianry-search>Bianry Search
<a class=anchor href=#bianry-search>#</a></h3><table><thead><tr><th style=text-align:left>Problem</th><th style=text-align:left>Difficulty</th><th style=text-align:left>Method</th><th style=text-align:left>Redo</th><th style=text-align:left>Comment</th></tr></thead><tbody><tr><td style=text-align:left>33. Search in Rotated Sorted Array</td><td style=text-align:left>medium</td><td style=text-align:left>binary search</td><td style=text-align:left>YES</td><td style=text-align:left></td></tr><tr><td style=text-align:left>34. Find First and Last Position of Element in Sorted Array</td><td style=text-align:left>medium</td><td style=text-align:left>binary search</td><td style=text-align:left>YES</td><td style=text-align:left>注意这里的第二种解法，也就是二分查找中如何确定边界的问题</td></tr><tr><td style=text-align:left>162. Find Peak Element</td><td style=text-align:left>medium</td><td style=text-align:left>Binary search、Monotone Stack、Array</td><td style=text-align:left>YES</td><td style=text-align:left>这里二分的解法还是太 tricky 了</td></tr><tr><td style=text-align:left>278. First Bad Version</td><td style=text-align:left>easy</td><td style=text-align:left>Binary Search</td><td style=text-align:left>No</td><td style=text-align:left>简单题，直接过</td></tr><tr><td style=text-align:left>74. Search a 2D Matrix</td><td style=text-align:left>medium</td><td style=text-align:left>Binary Search、Matrix</td><td style=text-align:left>YES</td><td style=text-align:left>这题的二分解法很巧妙</td></tr><tr><td style=text-align:left>240. Search a 2D Matrix II</td><td style=text-align:left>medium</td><td style=text-align:left>Binary Search、Matrix</td><td style=text-align:left>YES</td><td style=text-align:left>这个题的解法跟 74 题完全一致</td></tr><tr><td style=text-align:left>540. Single Element in a Sorted Array</td><td style=text-align:left>medium</td><td style=text-align:left>Binary Search、Array</td><td style=text-align:left>YES</td><td style=text-align:left>这里的隐式二分真的太巧妙了，需要注意一下</td></tr><tr><td style=text-align:left>69. Sqrt(x)</td><td style=text-align:left>easy</td><td style=text-align:left>Binary Search</td><td style=text-align:left>YES</td><td style=text-align:left>注意这里的边界是如何区分的；开头去掉一些 corner case的话，会让主逻辑更清晰一些</td></tr><tr><td style=text-align:left>367. Valid Perfect Square</td><td style=text-align:left>easy</td><td style=text-align:left>Binary Search</td><td style=text-align:left>YES</td><td style=text-align:left>注意这里的边界是如何区分的，以及这里与 69 题的相似性</td></tr><tr><td style=text-align:left>528. Random Pick with Weight</td><td style=text-align:left>medium</td><td style=text-align:left>Binary Search</td><td style=text-align:left>YES</td><td style=text-align:left>这里首先需要注意的是随机数的选择方法；其次需要注意的是，sum 数组的下标需要与原数组下标匹配（针对本题答案而言）</td></tr></tbody></table><table><thead><tr><th style=text-align:left>Problem</th><th style=text-align:left>Difficulty</th><th style=text-align:left>Method</th><th style=text-align:left>Redo</th></tr></thead><tbody><tr><td style=text-align:left>21. Merge Two Sorted List</td><td style=text-align:left>medium</td><td style=text-align:left>Merge Sort</td><td style=text-align:left>No</td></tr><tr><td style=text-align:left>22. Generate Parentheses</td><td style=text-align:left>medium</td><td style=text-align:left>Prune, Recursive</td><td style=text-align:left>YES</td></tr><tr><td style=text-align:left>26. Remove Duplicates from Sorted Array</td><td style=text-align:left>easy</td><td style=text-align:left></td><td style=text-align:left>No</td></tr></tbody></table><h2 id=math>Math
<a class=anchor href=#math>#</a></h2><h3 id=bit-manipulation>Bit Manipulation
<a class=anchor href=#bit-manipulation>#</a></h3><table><thead><tr><th style=text-align:left>Problem</th><th style=text-align:left>Difficulty</th><th style=text-align:left>Method</th><th style=text-align:left>Redo</th><th style=text-align:left>Comment</th></tr></thead><tbody><tr><td style=text-align:left>29. Divide Two Integers</td><td style=text-align:left>medium</td><td style=text-align:left>Bit manipulation</td><td style=text-align:left>YES</td><td style=text-align:left></td></tr><tr><td style=text-align:left>191. Number of 1 Bits</td><td style=text-align:left>easy</td><td style=text-align:left>Bit manipulation</td><td style=text-align:left>No</td><td style=text-align:left>这题太简单了，没什么好说的</td></tr><tr><td style=text-align:left>1342. Number of Steps to Reduce a Number to Zero</td><td style=text-align:left>easy</td><td style=text-align:left>Bit manipulation</td><td style=text-align:left>No</td><td style=text-align:left>太简单了，不用再看</td></tr><tr><td style=text-align:left>1060. Missing Number in Sorted Array</td><td style=text-align:left>easy</td><td style=text-align:left>Bit manipulation、Math、Binary Search</td><td style=text-align:left>YES</td><td style=text-align:left></td></tr></tbody></table><h3 id=math-computation>Math Computation
<a class=anchor href=#math-computation>#</a></h3><table><thead><tr><th style=text-align:left>Problem</th><th style=text-align:left>Difficulty</th><th style=text-align:left>Method</th><th style=text-align:left>Redo</th><th style=text-align:left>Comment</th></tr></thead><tbody><tr><td style=text-align:left>268. Missing Number</td><td style=text-align:left>easy</td><td style=text-align:left>Math</td><td style=text-align:left>No</td><td style=text-align:left>简单题，直接略过</td></tr><tr><td style=text-align:left>263. Ugly Number</td><td style=text-align:left>easy</td><td style=text-align:left>Math</td><td style=text-align:left>YES</td><td style=text-align:left>这里还是需要稍微注意一下n 的范围是怎么一步步缩小的</td></tr><tr><td style=text-align:left>453. Minimum Moves to Equal Array Elements</td><td style=text-align:left>medium</td><td style=text-align:left>Math</td><td style=text-align:left>YES</td><td style=text-align:left>这里的解法比较 tricky，比较难想得是如何从与 n-1 个数打交道转换为只需要与一个数打交道</td></tr><tr><td style=text-align:left>462. Minimum Moves to Equal Array Elements</td><td style=text-align:left>medium</td><td style=text-align:left>Math</td><td style=text-align:left>YES</td><td style=text-align:left>这里为什么使用中位数就行，而使用平均数就不可以呢</td></tr></tbody></table><h2 id=dynamic-programming>Dynamic Programming
<a class=anchor href=#dynamic-programming>#</a></h2><table><thead><tr><th style=text-align:left>Problem</th><th style=text-align:left>Difficulty</th><th style=text-align:left>Method</th><th style=text-align:left>Redo</th><th style=text-align:left>Comment</th></tr></thead><tbody><tr><td style=text-align:left>42. Traping Rain Water</td><td style=text-align:left>medium</td><td style=text-align:left>DP, Stack</td><td style=text-align:left>YES</td><td style=text-align:left></td></tr><tr><td style=text-align:left>474. Ones and Zeroes</td><td style=text-align:left>medium</td><td style=text-align:left>DP</td><td style=text-align:left>YES</td><td style=text-align:left>这里的递推式还是想不太出来，注意遍历的方向</td></tr><tr><td style=text-align:left>354. Russian Doll Envelopes</td><td style=text-align:left>hard</td><td style=text-align:left>DP</td><td style=text-align:left>YES</td><td style=text-align:left>注意这里更最长递增子序列问题的相似性</td></tr><tr><td style=text-align:left>303. Range Sum Query - Immutable</td><td style=text-align:left>easy</td><td style=text-align:left>DP、Prefix Sum</td><td style=text-align:left>YES</td><td style=text-align:left>注意这里前缀和的解法</td></tr><tr><td style=text-align:left>304. Range Sum Query 2D - Immutable</td><td style=text-align:left>medium</td><td style=text-align:left>DP、Prefix Sum</td><td style=text-align:left>YES</td><td style=text-align:left>注意这里的坐标变换是如何进行的</td></tr><tr><td style=text-align:left>120. Triangle</td><td style=text-align:left>medium</td><td style=text-align:left>DP</td><td style=text-align:left>YES</td><td style=text-align:left>注意这里 DP 方法中复用原数组的技巧</td></tr><tr><td style=text-align:left>64. Minimum Path Sum</td><td style=text-align:left>medium</td><td style=text-align:left>DP</td><td style=text-align:left>YES</td><td style=text-align:left>这个题跟 120 题的解法几乎完全一致 ，注意这里使用到的套路</td></tr><tr><td style=text-align:left>583. Delete Operations for Two Strings</td><td style=text-align:left>medium</td><td style=text-align:left>DP</td><td style=text-align:left>YES</td><td style=text-align:left>这题的 DP 解法跟 1143 题是完全一致的，都是求解最长公共子序列</td></tr><tr><td style=text-align:left>1048. Longest String Chain</td><td style=text-align:left>medium</td><td style=text-align:left>DP</td><td style=text-align:left>YES</td><td style=text-align:left></td></tr><tr><td style=text-align:left>5. Longest Palindrome Substring</td><td style=text-align:left>medium</td><td style=text-align:left>DP</td><td style=text-align:left>YES</td><td style=text-align:left>要注意这里的 DP 解法；另外，单个字符串的最长的公共串/序列问题，尝试看看能不能转换为两个字符串的公共子串/序列问题</td></tr><tr><td style=text-align:left>718. Maximum Length of Repeated Subarray</td><td style=text-align:left>medium</td><td style=text-align:left>DP</td><td style=text-align:left>YES</td><td style=text-align:left>注意如何将这里的解法用到第5 题中</td></tr><tr><td style=text-align:left>1062. Longest Repeating Substring</td><td style=text-align:left>medium</td><td style=text-align:left>DP</td><td style=text-align:left>YES</td><td style=text-align:left>这个题的递推式跟 718 题完全一致</td></tr></tbody></table><h2 id=prefix-sum>Prefix Sum
<a class=anchor href=#prefix-sum>#</a></h2><table><thead><tr><th style=text-align:left>Problem</th><th style=text-align:left>Difficulty</th><th style=text-align:left>Method</th><th style=text-align:left>Redo</th><th style=text-align:left>Comment</th></tr></thead><tbody><tr><td style=text-align:left>303. Range Sum Query - Immutable</td><td style=text-align:left>easy</td><td style=text-align:left>DP、Prefix Sum</td><td style=text-align:left>YES</td><td style=text-align:left>注意这里前缀和的解法</td></tr><tr><td style=text-align:left>304. Range Sum Query 2D - Immutable</td><td style=text-align:left>medium</td><td style=text-align:left>DP、Prefix Sum</td><td style=text-align:left>YES</td><td style=text-align:left>注意这里的坐标变换是如何进行的</td></tr><tr><td style=text-align:left>560. Subarray Sum Equals K</td><td style=text-align:left>medium</td><td style=text-align:left>Prefix Sum</td><td style=text-align:left>No</td><td style=text-align:left>主要会前缀和的技巧，那么这里就不是很难</td></tr><tr><td style=text-align:left>307. Range Query Sum - Mutable</td><td style=text-align:left>medium</td><td style=text-align:left>Prefix Sum</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>1423. Maximum Points You Can Obrain from Cards</td><td style=text-align:left>medium</td><td style=text-align:left>Prefix Sum、DP</td><td style=text-align:left>YES</td><td style=text-align:left>注意这个题怎么转换为前缀和来做，并且要注意 res 的初始值</td></tr></tbody></table><h2 id=sort>Sort
<a class=anchor href=#sort>#</a></h2><table><thead><tr><th style=text-align:left>Problem</th><th style=text-align:left>Difficulty</th><th style=text-align:left>Method</th><th style=text-align:left>Redo</th><th style=text-align:left>Comment</th></tr></thead><tbody><tr><td style=text-align:left>21. Merge Two Sorted List</td><td style=text-align:left>medium</td><td style=text-align:left>Merge Sort</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>148. Sort List</td><td style=text-align:left>medium</td><td style=text-align:left>Merge Sort</td><td style=text-align:left>YES</td><td style=text-align:left>注意这里的自底向上方法；以及自顶向下方法中，要注意断开 middle 和它之前节点的连接</td></tr><tr><td style=text-align:left>56. Merge Intervals</td><td style=text-align:left>medium</td><td style=text-align:left>Sort</td><td style=text-align:left>YES</td><td style=text-align:left></td></tr><tr><td style=text-align:left>179. Largest Number</td><td style=text-align:left>Medium</td><td style=text-align:left>Sort</td><td style=text-align:left>YES</td><td style=text-align:left>这里的做法需要十分注意，一般可能注意不到</td></tr><tr><td style=text-align:left>75. Sort Colors</td><td style=text-align:left>medium</td><td style=text-align:left>Bubble Sort、 Count Sort</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>215. Kth Largest Element</td><td style=text-align:left>medium</td><td style=text-align:left>Heap、Quick Select</td><td style=text-align:left>YES</td><td style=text-align:left>这里要非常注意快速选择算法</td></tr><tr><td style=text-align:left>4. Median of Two Sorted Arrays</td><td style=text-align:left>hard</td><td style=text-align:left>Heap</td><td style=text-align:left>YES</td><td style=text-align:left>这个题太难了</td></tr><tr><td style=text-align:left>973. K Closest Points to Origin</td><td style=text-align:left>medium</td><td style=text-align:left>Sort、 Heap</td><td style=text-align:left>No</td><td style=text-align:left>要看到本质问题，然后解决本质问题。</td></tr><tr><td style=text-align:left>88. Merge Sorted Array</td><td style=text-align:left>easy</td><td style=text-align:left>Sort、 Merge Sort</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>692. Top K Frequent Words</td><td style=text-align:left>medium</td><td style=text-align:left>Sort、 Hash Table</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>1647. Minimum Deletions to Make Character Frequencies Unique</td><td style=text-align:left>medium</td><td style=text-align:left>Greedy algorithm、Sort</td><td style=text-align:left>YES</td><td style=text-align:left>这里的贪心会比价隐晦一些</td></tr></tbody></table><h2 id=two-pointers>Two Pointers
<a class=anchor href=#two-pointers>#</a></h2><table><thead><tr><th style=text-align:left>Problem</th><th style=text-align:left>Difficulty</th><th style=text-align:left>Method</th><th style=text-align:left>Redo</th><th style=text-align:left>Comment</th></tr></thead><tbody><tr><td style=text-align:left>876. Middle of the Linked List</td><td style=text-align:left>easy</td><td style=text-align:left>Two Pointer</td><td style=text-align:left>No</td><td style=text-align:left>注意这里 for 循环结束遍历的终止条件</td></tr><tr><td style=text-align:left>27. Remove Elements</td><td style=text-align:left>easy</td><td style=text-align:left>Two Pointer</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>125. Valid Palindrome</td><td style=text-align:left>easy</td><td style=text-align:left>Two Pointer</td><td style=text-align:left>No</td><td style=text-align:left>简单题，直接跳过即可</td></tr><tr><td style=text-align:left>1. Two Sum</td><td style=text-align:left>easy</td><td style=text-align:left>Two Pointer、Hash Table</td><td style=text-align:left>No</td><td style=text-align:left>注意一下这里的哈希表的解法</td></tr><tr><td style=text-align:left>167. Two Sum II</td><td style=text-align:left>medium</td><td style=text-align:left>Two Pointer</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>15. 3Sum</td><td style=text-align:left>medium</td><td style=text-align:left>Two Pointer、Hash Table</td><td style=text-align:left>Yes</td><td style=text-align:left>注意这里是如何进行减枝的</td></tr><tr><td style=text-align:left>16. 3Sum Closest</td><td style=text-align:left>medium</td><td style=text-align:left>Two Pointer</td><td style=text-align:left>Yes</td><td style=text-align:left>注意这里如何进行减枝</td></tr><tr><td style=text-align:left>18. 4Sum</td><td style=text-align:left>medium</td><td style=text-align:left>Two Pointer</td><td style=text-align:left>YES</td><td style=text-align:left>注意这里是如何去重的，在最后两个 for 循环中对重复元素去重的技巧要注意一下</td></tr><tr><td style=text-align:left>11. Container with Most Water</td><td style=text-align:left>medium</td><td style=text-align:left>Yes</td><td style=text-align:left>这里移动指针的方式有一点贪心的味道</td><td></td></tr><tr><td style=text-align:left>283. Moving Zeroes</td><td style=text-align:left>easy</td><td style=text-align:left>Two Pointer</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>26. Remove Duplicates from Sorted Array</td><td style=text-align:left>easy</td><td style=text-align:left>Two Pointer</td><td style=text-align:left>No</td><td style=text-align:left></td></tr><tr><td style=text-align:left>395. Longest Substring with At Least K Repeating Characters</td><td style=text-align:left>medium</td><td style=text-align:left>Two Pointer</td><td style=text-align:left>YES</td><td style=text-align:left>这个题暂时跳过一下</td></tr><tr><td style=text-align:left>424. Longest Repeating Character Replacement</td><td style=text-align:left>medium</td><td style=text-align:left>Two Pointer、 Sliding Window</td><td style=text-align:left>YES</td><td style=text-align:left>这里的滑动窗口/双指针的解法是非常巧妙的，值得好好学习 ，尤其是怎么来做类推，来把问题细化</td></tr><tr><td style=text-align:left>76. Minimum Window Substring</td><td style=text-align:left>hard</td><td style=text-align:left>Sliding Window、Two Pointer</td><td style=text-align:left>YES</td><td style=text-align:left>这里的滑动窗口解法比较巧妙，尤其是 hash table 的使用；还有这里的分析方法也需要注意一下</td></tr><tr><td style=text-align:left>485. Max Consecutive Ones</td><td style=text-align:left>easy</td><td style=text-align:left>Two Pointer</td><td style=text-align:left>No</td><td style=text-align:left>简答题，很快就能有思路</td></tr></tbody></table><h2 id=backtrace>Backtrace
<a class=anchor href=#backtrace>#</a></h2><table><thead><tr><th style=text-align:left>Problem</th><th style=text-align:left>Difficulty</th><th style=text-align:left>Method</th><th style=text-align:left>Redo</th><th style=text-align:left>Comment</th></tr></thead><tbody><tr><td style=text-align:left>51. N-Queens</td><td style=text-align:left>hard</td><td style=text-align:left>Backtrace</td><td style=text-align:left>YES</td><td style=text-align:left>惭愧，这个经典的问题自己已经忘了它的解法了</td></tr><tr><td style=text-align:left>52. N-Queues II</td><td style=text-align:left>hard</td><td style=text-align:left>Backtrace</td><td style=text-align:left>YES</td><td style=text-align:left>这个题跟 51 题的解法是完全一致的。51 题中因为是从上到下对每一行进行的回溯，所以已经做了一个去重的操作</td></tr></tbody></table><h2 id=sliding-window>Sliding Window
<a class=anchor href=#sliding-window>#</a></h2><table><thead><tr><th style=text-align:left>Problem</th><th style=text-align:left>Difficulty</th><th style=text-align:left>Method</th><th style=text-align:left>Redo</th><th style=text-align:left>Comment</th></tr></thead><tbody><tr><td style=text-align:left>3. Longest Substring Without Repeating Character</td><td style=text-align:left>medium</td><td style=text-align:left>sliding window、Hash Table、String</td><td style=text-align:left>YES</td><td style=text-align:left>注意这里滑动窗口中左边界的确定，以及左边界 left 的初值和移动方向</td></tr><tr><td style=text-align:left>1658. Minimum Operations to Reduce X to Zero</td><td style=text-align:left>medium</td><td style=text-align:left>Sliding window、Prefix Sum、Backtrace</td><td style=text-align:left>YES</td><td style=text-align:left>首先要注意这里是怎么逐步对前缀和方法进行优化的；其次要注意这里的滑动窗口解法，也算是滑动窗口中的一中 pattern 了</td></tr><tr><td style=text-align:left>1695. Maximum Erasure Value</td><td style=text-align:left>medium</td><td style=text-align:left>Sliding Window、 Hash Table</td><td style=text-align:left>YES</td><td style=text-align:left>这里其实跟第 3 题是一样的</td></tr><tr><td style=text-align:left>643. Maximum Average Subarray I</td><td style=text-align:left>easy</td><td style=text-align:left>Sliding Window</td><td style=text-align:left>YES</td><td style=text-align:left>这题没什么难度，但是要注意两个 if 语句的顺序，不能颠倒</td></tr><tr><td style=text-align:left>424. Longest Repeating Character Replacement</td><td style=text-align:left>medium</td><td style=text-align:left>Two Pointer、 Sliding Window</td><td style=text-align:left>YES</td><td style=text-align:left>这里的滑动窗口/双指针的解法是非常巧妙的，值得好好学习 ，尤其是怎么来做类推，来把问题细化</td></tr><tr><td style=text-align:left>76. Minimum Window Substring</td><td style=text-align:left>hard</td><td style=text-align:left>Sliding Window、Two Pointer</td><td style=text-align:left>YES</td><td style=text-align:left>这里的滑动窗口解法比较巧妙，尤其是 hash table 的使用；还有这里的分析方法也需要注意一下</td></tr><tr><td style=text-align:left>487. Max Consecutive Ones II</td><td style=text-align:left>medium</td><td style=text-align:left>Sliding Window、Two Pointer</td><td style=text-align:left>YES</td><td style=text-align:left>这里的解法跟 1004 题是一样的</td></tr><tr><td style=text-align:left>1004. Max Consecutive Ones III</td><td style=text-align:left>medium</td><td style=text-align:left>Sliding Window、Two Pointer</td><td style=text-align:left>YES</td><td></td></tr></tbody></table><h2 id=greedy-algorithms>Greedy Algorithms
<a class=anchor href=#greedy-algorithms>#</a></h2><table><thead><tr><th style=text-align:left>Problem</th><th style=text-align:left>Difficulty</th><th style=text-align:left>Method</th><th style=text-align:left>Redo</th><th style=text-align:left>Comment</th></tr></thead><tbody><tr><td style=text-align:left>968. Binary Tree Cameras</td><td style=text-align:left>hard</td><td style=text-align:left>greedy algorithm</td><td style=text-align:left>YES</td><td style=text-align:left>这里其实就有点像是一个递归再配合上状态机的转移</td></tr><tr><td style=text-align:left>630. Course Schedule III</td><td style=text-align:left>hard</td><td style=text-align:left>Greedy algorithm</td><td style=text-align:left>YES</td><td style=text-align:left>这里的关键其实还是在于最大堆与贪心算法的结合</td></tr><tr><td style=text-align:left>665. Non-decreasing Array</td><td style=text-align:left>medium</td><td style=text-align:left>Greedy algorithm</td><td style=text-align:left>YES</td><td style=text-align:left>这里的贪心有些隐晦，不易发现</td></tr><tr><td style=text-align:left>1647. Minimum Deletions to Make Character Frequencies Unique</td><td style=text-align:left>medium</td><td style=text-align:left>Greedy algorithm、Sort</td><td style=text-align:left>YES</td><td style=text-align:left>这里的贪心会比价隐晦一些</td></tr></tbody></table><h2 id=divide-and-conquer>Divide and Conquer
<a class=anchor href=#divide-and-conquer>#</a></h2><table><thead><tr><th style=text-align:left>Problem</th><th style=text-align:left>Difficulty</th><th style=text-align:left>Method</th><th style=text-align:left>Redo</th><th style=text-align:left>Comment</th></tr></thead><tbody><tr><td style=text-align:left>454. 4Sum II</td><td style=text-align:left>medium</td><td style=text-align:left>Hash Table、Divide</td><td style=text-align:left>YES</td><td style=text-align:left>这里降低时间复杂度的思想比较巧妙，值得学习</td></tr></tbody></table></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/alex-shpak/hugo-book/commit/2a06fe0a39d8abd7dd6a9d71ce72e1cf3d905d9e title='Last modified by imilano | July 24, 2022' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>July 24, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/alex-shpak/hugo-book/edit/main/exampleSite/content/docs/algs/leetcode/_index.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#data-structure>Data structure</a><ul><li><a href=#stack>Stack</a></li><li><a href=#heap>Heap</a></li><li><a href=#queue>Queue</a></li><li><a href=#hash-table>Hash Table</a></li><li><a href=#graph>Graph</a></li><li><a href=#linked-list>Linked List</a></li><li><a href=#string>String</a></li><li><a href=#array>Array</a></li><li><a href=#tree>Tree</a></li></ul></li><li><a href=#search>Search</a><ul><li><a href=#bianry-search>Bianry Search</a></li></ul></li><li><a href=#math>Math</a><ul><li><a href=#bit-manipulation>Bit Manipulation</a></li><li><a href=#math-computation>Math Computation</a></li></ul></li><li><a href=#dynamic-programming>Dynamic Programming</a></li><li><a href=#prefix-sum>Prefix Sum</a></li><li><a href=#sort>Sort</a></li><li><a href=#two-pointers>Two Pointers</a></li><li><a href=#backtrace>Backtrace</a></li><li><a href=#sliding-window>Sliding Window</a></li><li><a href=#greedy-algorithms>Greedy Algorithms</a></li><li><a href=#divide-and-conquer>Divide and Conquer</a></li></ul></li></ul></nav></div></aside></main></body></html>