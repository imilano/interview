<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Interview</title><link>https://example.com/docs/algs/leetcode/</link><description>Recent content on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/docs/algs/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>10. First Missing Positive</title><link>https://example.com/docs/algs/leetcode/41_first_msssing_positive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/41_first_msssing_positive/</guid><description>Description # Given an unsorted integer array nums, return the smallest missing positive integer.
You must implement an algorithm that runs in O(n) time and uses constant extra space.
Solutions # Hash Table # 可以使用一个 hash table 记录所以出现的值，然后找出当前值中的最大值。然后从 1 到最大值开始遍历，如果出现一个不在 hash table 中的数，则将该数返回即可。如果所有数都出现在了 hash table 中，那么返回最大值加 1 即可。但是最后这里需要注意的是，有可能整个数组都是负数，这样的话会导致前面的判断失效，所以返回值应该最小要返回 1.
func firstMissingPositive(nums []int) int { dict := make(map[int]bool) curMax := nums[0] for _, num := range nums { dict[num] = true if num &amp;gt; curMax { curMax = num } } for i := 1; i &amp;lt;= curMax; i++ { if _, ok := dict[i]; !</description></item><item><title>21. Merge Two Sorted List</title><link>https://example.com/docs/algs/leetcode/21_merge_two_sorted_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/21_merge_two_sorted_list/</guid><description>Description # You are given the heads of two sorted linked lists list1 and list2.
Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.
Return the head of the merged linked list.
Solutions # Merge Sort # func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode { res := new(ListNode) node := res dummyHead1, dummyHead2 := list1, list2 for dummyHead1 !</description></item><item><title>22. Generate Parentheses</title><link>https://example.com/docs/algs/leetcode/22_generate_parentheses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/22_generate_parentheses/</guid><description>Description # Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
Solutions # Recursive # 参见： https://leetcode-cn.com/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/
使用两个变量 left 和 right 来表示「左括号使用了集合」和「右括号使用了几个」，通过分析可以得到以下结论： - 只有当left 和 right 都比 n 小的时候，才产生分支。 - 产生左分支的时候，只看当前还有左括号可用 - 产生右分支的时候，还受到左括号数量的限制，left 要大于 right 的时候，才可以产生分支。否则就是无效分支，可以直接返回。 - 在左边和右边的括号数都等于 n 的时候结算。
func generateParenthesis(n int) []string { var res []string if n == 0 { return res } generateParenthesisHelper(n, 0,0,&amp;#34;&amp;#34;, &amp;amp;res) return res } func generateParenthesisHelper(n, left, right int, cur string, res *[]string) { if left == n &amp;amp;&amp;amp; right == n { *res = append(*res, cur) return } // 剪枝 if left &amp;lt; right { return } if left &amp;lt; n { generateParenthesisHelper(n, left+1, right, cur + &amp;#34;(&amp;#34;, res) } if right &amp;lt; n { generateParenthesisHelper(n, left, right+1, cur + &amp;#34;)&amp;#34;, res) } }</description></item><item><title>23. Merge K Sorted List</title><link>https://example.com/docs/algs/leetcode/23_merge_k_sorted_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/23_merge_k_sorted_list/</guid><description>Description # You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.
Merge all the linked-lists into one sorted linked-list and return it.
Solutions # Min Heap # 很简单的想法，使用最小堆即可。
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeKLists(lists []*ListNode) *ListNode { return mergeKListsSolution1(lists) } // 使用最小堆，将所有的节点数据都插入到最小堆中，然后再把所有元素从最小堆中弹出 func mergeKListsSolution1(lists []*ListNode) *ListNode { var minHeap MinHeapArr heap.</description></item><item><title>26. remove duplicated from sorted array</title><link>https://example.com/docs/algs/leetcode/26_remove_duplicates_from_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/26_remove_duplicates_from_sorted_array/</guid><description>Description # Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.
Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result.</description></item><item><title>28. Implement strStr</title><link>https://example.com/docs/algs/leetcode/28_implement_strStr/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/28_implement_strStr/</guid><description>Description # Implement strStr().
Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Solutions # 太简单了在，直接看代码即可。
func strStr(haystack string, needle string) int { var pos int size := len(haystack) targetSize := len(needle) if size == 0 || targetSize == 0 { return pos } var start int pos = -1 for start &amp;lt; size { if haystack[start] !</description></item><item><title>29. Divide Two Integers</title><link>https://example.com/docs/algs/leetcode/29_divide_two_integers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/29_divide_two_integers/</guid><description>Description # Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.
The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.
Return the quotient after dividing dividend by divisor.
Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1].</description></item><item><title>33. Search in Rotated Sorted Array</title><link>https://example.com/docs/algs/leetcode/33_search_in_rotated_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/33_search_in_rotated_array/</guid><description>Description # There is an integer array nums sorted in ascending order (with distinct values).
Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], &amp;hellip;, nums[n-1], nums[0], nums[1], &amp;hellip;, nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].
Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.</description></item><item><title>34. Find First and Last Position of Element in Sorted Array</title><link>https://example.com/docs/algs/leetcode/34_find_first_and_last_position_of_element_in_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/34_find_first_and_last_position_of_element_in_sorted_array/</guid><description>Description # Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.
If target is not found in the array, return [-1, -1].
You must write an algorithm with O(log n) runtime complexity.
Solutions # Binary Search # 二分查找再加上中间扩散，很容易想出来。
func searchRange(nums []int, target int) []int { res := []int{-1, -1} size := len(nums) if size == 0 { return res } left, right := 0, size -1 for left &amp;lt;= right { mid := (left+right)/2 if nums[mid] == target { l,r := mid, mid res[0] = l res[1] = r for l &amp;gt;= 0 &amp;amp;&amp;amp; nums[l] == target { res[0] = l l-- } for r &amp;lt; size &amp;amp;&amp;amp; nums[r] == target { res[1] = r r++ } break } else if nums[mid] &amp;gt; target { right = mid -1 } else if nums[mid] &amp;lt; target { left = mid + 1 } } return res }</description></item><item><title>36. Valid Sudoku</title><link>https://example.com/docs/algs/leetcode/36_valid_sudoku/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/36_valid_sudoku/</guid><description>Description # Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Solutions # 一个是要注意如何快速创建三维数组，另一个是要注意如何进行坐标转换。</description></item><item><title>38. Count and Say</title><link>https://example.com/docs/algs/leetcode/38_count_and_say/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/38_count_and_say/</guid><description>Descrition # The count-and-say sequence is a sequence of digit strings defined by the recursive formula:
countAndSay(1) = &amp;ldquo;1&amp;rdquo; countAndSay(n) is the way you would &amp;ldquo;say&amp;rdquo; the digit string from countAndSay(n-1), which is then converted into a different digit string. To determine how you &amp;ldquo;say&amp;rdquo; a digit string, split it into the minimal number of groups so that each group is a contiguous section all of the same character.</description></item><item><title>42. Traping Rain Water</title><link>https://example.com/docs/algs/leetcode/04_traping_rain_water/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/04_traping_rain_water/</guid><description>Description # Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.
detail see: https://leetcode.com/problems/trapping-rain-water/
Solutions # Array # 使用两个数组扫描两趟，第一个数组 fromLeft 从左到右扫描，记录到目前为止遇到的最大值，第二个数组fromRight 从右向左扫描，记录当前为止遇到的最大值。最后扫描一下这两个数组，对于每个位置 i，取 fromLeft 和 fromRight 二者中的较小者与当前 height[i] 的差值作为当前格子所能盛水量。
func trap(nums []int) int { var res int size := len(nums) if size &amp;lt;= 1 { return res } curMax := nums[0] fromLeft := make([]int, size) for idx, num := range nums { curMax = max(num, curMax) fromLeft[idx] = curMax } curMax = nums[size-1] fromRight := make([]int, size) for i := size-1; i &amp;gt;= 0; i-- { curMax = max(nums[i], curMax) fromRight[i] = curMax } for i := 0; i &amp;lt; size; i++ { res += min(fromLeft[i], fromRight[i]) - nums[i] } return res } func min(a,b int) int { if a &amp;lt; b { return a } return b } func max(a,b int) int { if a &amp;lt; b { return b } return a } 还有一种解法，就是先找出整个数组的最大值，这个最大值将整个数组切分为两部分，然后分别处理左半边和右半边。处理单边的时候，记录自己当前遇到的历史最大值，如果当前值比历史最大值要大，则更新历史最大值为当前值；否则的话说明历史最大值比当前值要大，那么当前值是可以盛水的，则更新结果盛水量。为什么只需要记录当前历史最大值就可以了呢，毕竟能不能盛水其实要靠两边而不是一边啊？答案是我我们已经找出了整个数组的最大值，那么当前的历史最大值只会比整个数组的最大值要小，能盛多少水完全取决于较短的一方（参考短板理论），所以只需要维持一个最大值即可。</description></item><item><title>44. Wildcard Matching</title><link>https://example.com/docs/algs/leetcode/44_wildcard_matching/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/44_wildcard_matching/</guid><description>Description # Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for &amp;lsquo;?&amp;rsquo; and &amp;lsquo;*&amp;rsquo; where:
&amp;lsquo;?&amp;rsquo; Matches any single character. &amp;lsquo;*&amp;rsquo; Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial).
Solutions # TODO</description></item><item><title>46. Permutations</title><link>https://example.com/docs/algs/leetcode/46_permutations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/46_permutations/</guid><description>Description # Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.
Solutions # Array(swap) # 基于交换进行 permutate 即可。
func permute(nums []int) [][]int { var res [][]int size := len(nums) helper(0, size, nums, &amp;amp;res) return res } func helper(start,size int, nums []int, res *[][]int) { if start &amp;gt;= size { tmp := make([]int, size) copy(tmp, nums) *res = append(*res, tmp) return } for i := start; i &amp;lt; size; i++ { nums[i], nums[start] = nums[start], nums[i] // 注意这里是 start + 1， 而不是 i helper(start+1, size, nums, res) nums[i], nums[start] = nums[start], nums[i] } }</description></item><item><title>48. Rotate Image</title><link>https://example.com/docs/algs/leetcode/48_rotate_image/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/48_rotate_image/</guid><description>Description # You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.
Solutions # 补充几个矩阵变换公式： - 主对角线对折： arr[i][j] = arr[j][i] - 副对角线对折： arr[i][j] = arr[n-j-1][n-i-1] go for i := 0; i &amp;lt; n; i++ { for j := 0; j &amp;lt; n-i; j++ { matrix[i][j], matrix[n-j-1][n-i-1] = matrix[n-j-1][n-i-1], matrix[i][j] } } - 横向对折： arr[i][j] = arr[n-i-1][j] - 纵向对折： arr[i][j] = arr[i][n-j-1]</description></item><item><title>49. Group Anagrams</title><link>https://example.com/docs/algs/leetcode/49_group_anagrams/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/49_group_anagrams/</guid><description>Description # Given an array of strings strs, group the anagrams together. You can return the answer in any order.
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
Solutions # 简单的方法就是，对具有相同字母以及字母出现次数也相同的字符串进行排序时，其排序结果都是一样的。所以可以创建一个 map，其中 key 为字符串的排序，value 为具有这样一个排序结果的字符串数组。
func groupAnagrams(strs []string) [][]string { var res [][]string m := make(map[string][]string) for _, str := range strs { str_splited := strings.</description></item><item><title>50. Pow(x, n)</title><link>https://example.com/docs/algs/leetcode/50_powxn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/50_powxn/</guid><description>Description # Implement pow(x, n), which calculates x raised to the power n (i.e., xn).
Solutions # Map # 可以使用快速幂以及记忆化数组，单独使用快速幂会导致超时，所以需要配合记忆化数组使用。
func myPow(x float64, n int) float64 { if x == 0 { return 0 } if n == 0 { return 1 } var negative bool if n &amp;lt; 0 { negative = true n = -n } dict := make(map[int]float64) dict[0], dict[1] = 1, x res := helper(x, n, &amp;amp;dict) if negative { return 1 / res } return res } func helper(x float64, n int, dict *map[int]float64) float64 { if value, ok := (*dict)[n]; ok { return value } res := helper(x, n/2, dict) * helper(x, n/2, dict) * helper(x, n%2, dict) (*dict)[n] = res return res }</description></item><item><title>53. Maximum Subarray</title><link>https://example.com/docs/algs/leetcode/53_maximum_subarray/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/53_maximum_subarray/</guid><description>Description # Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.
A subarray is a contiguous part of an array.
Solutions # Kadane # Kadane 算法，最优子结构性质，当前位置的和取决于前一个位置的子数组和以及当前元素。
def max_subarray(arr): max_sum_so_far, sum_ending_here = arr[0], arr[0] for e in range(arr[1:]): sum_ending_here = max(e, sum_ending_here + e) max_sum_so_far = max(max_sum_so_far, sum_ending_here) return max_sum_so_far 如果数组中有负数，并且允许返回长度为 0 的子数列，则该问题可以改为：</description></item><item><title>54. Spiral Matrix</title><link>https://example.com/docs/algs/leetcode/54_spiral_matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/54_spiral_matrix/</guid><description>Description # Given an m x n matrix, return all elements of the matrix in spiral order.
Solutions # 其实就是顺时针旋转打印数组。
func spiralOrder(matrix [][]int) []int { var res []int m, n := len(matrix), len(matrix[0]) up, bottom, left, right := 0, m-1, 0, n - 1 for up &amp;lt;= bottom &amp;amp;&amp;amp; left &amp;lt;= right { for i := left; i &amp;lt;= right; i++ { res = append(res, matrix[up][i]) } up++ if up &amp;gt; bottom { break } for i := up; i &amp;lt;= bottom; i++ { res = append(res, matrix[i][right]) } right-- if right &amp;lt; left { break } for i := right; i &amp;gt;= left; i-- { res = append(res, matrix[bottom][i]) } bottom-- if bottom &amp;lt; up { break } for i := bottom; i &amp;gt;= up;i-- { res = append(res, matrix[i][left]) } left++ if left &amp;gt; right { break } } return res }</description></item><item><title>55. Jump Game</title><link>https://example.com/docs/algs/leetcode/55_jump_game/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/55_jump_game/</guid><description>Description # You are given an integer array nums. You are initially positioned at the array&amp;rsquo;s first index, and each element in the array represents your maximum jump length at that position.
Return true if you can reach the last index, or false otherwise.
Solutions # Recursive # 很容易想到递归的办法，但是也很容易就超时了 :)
func canJump(nums []int) bool { size := len(nums) if helper(0, size, nums) { return true } return false } func helper(start int, size int, nums []int) bool { if start &amp;gt;= size -1 { return true } for i := 1; i &amp;lt;= nums[start]; i++ { if helper(start+i, size, nums) { return true } } return false } Greedy # 使用一个变量 remianed 表示当前剩余的跳力（指从当前节点最多还可以跳几步），然后使用一个值 maxDst 表示当前能够跳到的最远距离。每遍历到一个节点，判断是否能跳到当前节点，也就是 i 是否大于 Dst，如果大于，则说明跳不到当前节点，则可以直接返回 false； 否则说明能跳到当前节点，然后根据当前节点的跳力更新当前节点的最大跳力以及能跳到的最远距离。</description></item><item><title>56. Merge Intervals</title><link>https://example.com/docs/algs/leetcode/56_merge_intervals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/56_merge_intervals/</guid><description>Description # Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.
Solutions # 典型的区间合并问题。
首先先对区间按照开始时间从小到大进行排序，然后使用一个指针 cur 指向当前 intervals 数组遍历到的位置，使用一个指针 tail 指向 res 数组最后一个元素。然后开始对 intervals 数组进行遍历，如果当前遍历到的区间跟 res 数组的最后一个区间没有重叠，则直接将这个区间插入 res 数组，然后 tail 自增；否则的话就合并区间，更新 res[tail] 的结束时间；每次遍历结束，cur 自增。
func merge(intervals [][]int) [][]int { var res [][]int size := len(intervals) if size &amp;lt;= 1 { return intervals } sort.</description></item><item><title>62. Unique Paths</title><link>https://example.com/docs/algs/leetcode/62_unique_paths/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/62_unique_paths/</guid><description>Description # There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.
Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.</description></item><item><title>66. Plus One</title><link>https://example.com/docs/algs/leetcode/66_plus_one/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/66_plus_one/</guid><description>Description # You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0&amp;rsquo;s.
Increment the large integer by one and return the resulting array of digits.
Solutions # 简单题，直接计算即可。
func plusOne(digits []int) []int { size := len(digits) if size == 0 { return digits } carry := 1 for i := size-1; i &amp;gt;= 0; i-- { sum := digits[i] + carry carry = sum / 10 digits[i] = sum % 10 } if carry &amp;gt; 0 { digits = append([]int{carry}, digits.</description></item><item><title>69. Sqrt(x)</title><link>https://example.com/docs/algs/leetcode/69_sqrtx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/69_sqrtx/</guid><description>Description # Given a non-negative integer x, compute and return the square root of x.
Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.
Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.
Solutions # 使用二分法快速进行快速查找：
func mySqrt(x int) int { if x &amp;lt;= 1 { return x } low, high := 0, x for low &amp;lt; high { mid := (low+high)/2 if mid * mid == x { return mid } else if mid * mid &amp;gt; x { high = mid } else { low = mid + 1 } } return high - 1 }</description></item><item><title>70. Climbing Stairs</title><link>https://example.com/docs/algs/leetcode/70_climing_stairs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/70_climing_stairs/</guid><description>Descriptioin # You are climbing a staircase. It takes n steps to reach the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
Solutions # 斐波那契数列问题，不多说。
func climbStairs(n int) int { if n &amp;lt;= 2 { return n } FMinusOne, FMinusTwo := 2, 1 for i := 3; i &amp;lt;= n; i++ { fn := FMinusOne + FMinusTwo FMinusTwo = FMinusOne FMinusOne = fn } return FMinusOne }</description></item><item><title>73. Set Matrix Zeroes</title><link>https://example.com/docs/algs/leetcode/73_set_matrix_zeroes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/73_set_matrix_zeroes/</guid><description>Descriptioin # Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0&amp;rsquo;s.
You must do it in place.
Solutions # 这里需要注意的是，因为要求不使用额外的内存空间，所以我们就要有这种充分利用原有空间的觉悟。这里的思想是，先检查第一行第一列是否有 0，如果有，则将相应的标志设置为 true，然后使用第一行和第一列来做标记。从第二行第二列开始遍历数组，当 matrix[i][j] = 0 时，则将该行对应的第一个数设置为 0，将该列对应的第一个数设置为 0。遍历结束之后再遍历一次数组，也是从第一行和第一列开始，如果改行或者该列的第一个元素为 0， 则将相应的相应的格子设置为 0.遍历结束后，再根据刚开始设置的行 flag 和列 flag 判断是否应该将第一行和第一列设置为 0.
func setZeroes(matrix [][]int) { m, n := len(matrix), len(matrix[0]) var rowZero, colZero bool // 检查第一列是否包含 0 for i := 0; i &amp;lt; m ;i++ { if matrix[i][0] == 0 { colZero = true break } } // 检查第一行是否包含 0 for i := 0; i &amp;lt; n; i++ { if matrix[0][i] == 0 { rowZero = true break } } // 检查剩余行和列是否包含 0，如果包含，则将相应的第一行位置设为 0，第一列位置设为 0 for i := 1; i &amp;lt; m ;i++ { for j := 1; j &amp;lt; n; j++ { if matrix[i][j] == 0 { matrix[i][0] = 0 matrix[0][j] = 0 } } } // 根据第一行第一列的检测结果，将相应的行和列设置为 0 for i := 1; i &amp;lt; m; i++ { for j := 1; j &amp;lt; n; j++ { if matrix[i][0] == 0 || matrix[0][j] == 0 { matrix[i][j] = 0 } } } // 如果第一行有 0， 则将第一行设置为 0 if rowZero { for i := 0; i &amp;lt; n; i++ { matrix[0][i] = 0 } } // 如果第一列有 0， 则将第一列设置为 0 if colZero { for i := 0; i &amp;lt; m ;i++ { matrix[i][0] = 0 } } }</description></item><item><title>75. Sort Colors</title><link>https://example.com/docs/algs/leetcode/75_sort_colors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/75_sort_colors/</guid><description>Description # Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.
We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.
You must solve this problem without using the library&amp;rsquo;s sort function.
Solutions # 其实这里应该用任意的一个排序算法都可以。</description></item><item><title>76. Minimum Window Substring</title><link>https://example.com/docs/algs/leetcode/76_minimum_window_substring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/76_minimum_window_substring/</guid><description>Description # Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string &amp;ldquo;&amp;rdquo;.
The testcases will be generated such that the answer is unique.
A substring is a contiguous sequence of characters within the string.
Solutions # Sliding Window # 这里应该很容易可以看出需要使用滑动窗口来做，但是与一般的滑动窗口不同的是，这里的滑动窗口中可以包含一些不在字符串 t 中的字符。另外还需要注意的是，窗口中字符的出现顺序不需要和 t 一致，但是出现次数需要一致。</description></item><item><title>78. Subsets</title><link>https://example.com/docs/algs/leetcode/78_subsets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/78_subsets/</guid><description>Descrition # Given an integer array nums of unique elements, return all possible subsets (the power set).
The solution set must not contain duplicate subsets. Return the solution in any order.
Solutions # 观察一下可以发现，其实子集合就是一个追加操作。你只需要把新元素不断的追加到就有的集合上构成一个新的集合，然后再将这个新集合添加到结果数组中即可。重复上述操作，直到你把原数组中的所有元素都遍历完一次即可。
func subsets(nums []int) [][]int { res := [][]int{{}} size := len(nums) for i := 0; i &amp;lt; size; i++ { n := len(res) for j := 0; j &amp;lt; n; j++ { t := make([]int, len(res[j])) copy(t, res[j]) t = append(t, nums[i]) res = append(res, t) // 注意不能用下面这样的方式。 // 因为 golang 中切片其实底层是一个指向实际数组的指针，所以下面的添加可能会旧元素上进行添加，而不是在新元素上进行添加。 // t := res[j] // t = append(t, nums[i]) // res = append(res, t) } } return res }</description></item><item><title>79. Word Search</title><link>https://example.com/docs/algs/leetcode/79_word_search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/79_word_search/</guid><description>Description # Given an m x n grid of characters board and a string word, return true if word exists in the grid.
The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.
Solutions # 递归回溯即可。
func exist(board [][]byte, word string) bool { m, n := len(board), len(board[0]) for i := 0; i &amp;lt; m; i++ { for j := 0; j &amp;lt; n; j++ { if board[i][j] == word[0] { visited := make([][]bool, m) for i, _ := range visited { visited[i] = make([]bool, n) } if existBacktrace(board, word, i, j, m, n, &amp;amp;visited) { return true } } } } return false } func existBacktrace(board [][]byte, word string, si, sj, m, n int, visited *[][]bool) bool { if len(word) == 0 { return true } if si &amp;lt; 0 || sj &amp;lt; 0 || si &amp;gt;= m || sj &amp;gt;= n || (*visited)[si][sj] || board[si][sj] !</description></item><item><title>84. Largest Rectangle in Histogram</title><link>https://example.com/docs/algs/leetcode/84_largest_rectangle_in_histogram/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/84_largest_rectangle_in_histogram/</guid><description>Description # Given an array of integers heights representing the histogram&amp;rsquo;s bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.
Solutions # 寻找每一个局部峰值 i (heights[i] &amp;gt; heights[i+1])，然后从这个局部峰值 i 开始向前遍历所有的值，算出共同的矩形面积，每次对比保留最大值。 很不幸，超时了 :)
func largestRectangleArea(heights []int) int { var res int size := len(heights) if size == 0 { return res } for i := 0; i &amp;lt; size; i++ { if i+1 &amp;lt; size &amp;amp;&amp;amp; heights[i] &amp;lt;= heights[i+1] { continue } curMin := heights[i] for j := i; j &amp;gt;= 0; j-- { if heights[j] &amp;lt; curMin { curMin = heights[j] } res = max(res, curMin * (i-j+1)) } } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a }</description></item><item><title>88. Merge Sorted Array</title><link>https://example.com/docs/algs/leetcode/88_merge_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/88_merge_sorted_array/</guid><description>Description # You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.
Merge nums1 and nums2 into a single array sorted in non-decreasing order.
The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored.</description></item><item><title>94. Bianry Tree Inorder Traversal</title><link>https://example.com/docs/algs/leetcode/94_binary_tree_inorder_traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/94_binary_tree_inorder_traversal/</guid><description>Description # Given the root of a binary tree, return the inorder traversal of its nodes&amp;rsquo; values.
Solutions # 二叉树中序遍历，又分为迭代和递归两种方式。
Recursive # func inorderTraversal(root *TreeNode) []int { var res []int if root == nil { return res } helper(root, &amp;amp;res) return res } func helper(root *TreeNode, res *[]int) { if root == nil { return } helper(root.</description></item><item><title>98. Validate Bianry Search Tree</title><link>https://example.com/docs/algs/leetcode/98_validate_binary_search_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/98_validate_binary_search_tree/</guid><description>Description # Given the root of a binary tree, determine if it is a valid binary search tree (BST).
A valid BST is defined as follows:
The left subtree of a node contains only nodes with keys less than the node&amp;rsquo;s key. The right subtree of a node contains only nodes with keys greater than the node&amp;rsquo;s key. Both the left and right subtrees must also be binary search trees.</description></item><item><title>Blind 75 List</title><link>https://example.com/docs/algs/leetcode/Blind-75-list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/Blind-75-list/</guid><description>Blind 75 # Sequence # Two Sum
使用一个 map 记录元素值与元素下标的映射，只需要一次扫描数组，检查 target - value 是否在 map 中，同时将 value 和其下标放到 map 中 。
Best Time to Buy and Sell Stock
使用一个值记录当前扫描到的最小值，然后扫描一次数组，每扫描到一个值，用当前值减去当前得到的最小值，然后得到结果，取结果的最大值。如果当前值小于最小值，则更新最小值为当前值。只需要一次扫描。
Contains Duplicate
简单题，只需要一个 map 就可以了，扫描一次即可。
Product of Array Except Self 创建两个数组left 和 right，数组 left[i] 表示 i 位置前的元素的累积，数组 right[i]表示 i 位置后的元素的累积。然后创建一个数组 res， res[i] = left[i] * right[i]。
Maximum Subarray
Kadane 算法，最优子结构性质，当前位置的和取决于前一个位置的子数组和以及当前元素。</description></item><item><title>Top Interview Questions</title><link>https://example.com/docs/algs/leetcode/Top-Leetcode-Interview-Questions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/Top-Leetcode-Interview-Questions/</guid><description>Two Sum 简单题，可跳过。
Add Two Numbers 不难，注意 dummyHead 的使用
Longest Substring Without Repeating Character 滑动窗口，不难。
Median of Two Sorted Arrays TODO 难题， 暂时跳过
Longest Palindromic Substring 不难
Reverse Integer NOTE 注意这里对溢出的处理技巧，以及对负数的处理
String to Integer(atoi) 不难，只是繁琐
Regular Expression Matching TODO 暂时跳过
Container With Most Water 不难，但是要注意一题多解
Roman to Integer 不难
Longest Common Prefix 不难</description></item><item><title/><link>https://example.com/docs/algs/leetcode/14-patterns-to-ace-any-coding-interview-questions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/14-patterns-to-ace-any-coding-interview-questions/</guid><description>关于算法笔试的常见的十四中模式。
1. 滑动窗口 # 特征 # 问题输入是线性的数据结构 目的是找出最长/短子字符串、子数组或者指定期望值 2. 双指针 # 特征 # 对有序序列或者链表进行操作，目的是找到满足特定条件的一串元素 目标是一对元素或者三个元素，甚至是一个子数组 3. 快慢指针 # 特征 # 问题是处理链表或者数组中的循环 当你需要知道某个元素在整个链表中的位置 4. 区间合并 # 区间合并的几种情况： 。
特征 # 对互斥区间生成一个链表 出现关键词“overlaping intervals” 5. 循环排序(cyclic sort) # 6. 链表就地翻转 # 7. 树的深度优先遍历 # 8. 树的广度优先遍历 # 9. 双堆 # 10. 子集 # 11.</description></item></channel></rss>