<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Interview</title><link>https://example.com/docs/algs/leetcode/</link><description>Recent content on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/docs/algs/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>0001. Two Sum</title><link>https://example.com/docs/algs/leetcode/01_two_sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/01_two_sum/</guid><description>Description # Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.
Solutions # Hash Table # 这里因为答案唯一，那么也就意味着数组里的元素是唯一的，所以可以使用 map 来做，只需要一次遍历即可，具体看下面代码就好。
func twoSum(nums []int, target int) []int { dict := make(map[int]int) for idx, num := range nums{ t := target - num if exist(dict, t) { return []int{idx, dict[t]} } dict[num] = idx } return nil } func exist(dict map[int]int, target int) bool { if _, ok := dict[target]; ok { return true } return false } Sort &amp;amp;&amp;amp; Two Pointer # 这里也可以使用排序来做，根据值进行排序，但是需要保存该值对应的下标。排好序之后可以使用双指针，一个 left 指向开头，一个 right 指向结尾，计算二者和，如果小于 target，则 left++，否则 right++，直到二者之和等于 target 即可。思路大概就这样，代码就不写了。</description></item><item><title>0003. Longest Substring Without Repeating Characters</title><link>https://example.com/docs/algs/leetcode/03_longest_substring_without_repeatng_characters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/03_longest_substring_without_repeatng_characters/</guid><description>Description # Given a string s, find the length of the longest substring without repeating characters.
Solutions # Hash Table # 中间扩散法，时间复杂度会比较高，因为会有很多的重复扫描。核心思想是，遍历一次字符串，然后对于每个遍历到的位置，从中心向两侧进行扫描，扫描时使用一个 map 来记录那些已经出现过的字符；在一侧扫描过程中，如果发现该字符已经出现过，则停止扫描该侧。最后 map 的长度即为以该字符为中心的不重复字符的长度。
// 对于每个位置的字符，从中间向两侧扫描；使用一个 map 记录已经出现过的字符。在一侧扫描过程中，如果该字符已经出现过，则停止扫描该侧。 // 最后 map 的长度即为以该字符为中心的不重复字符的长度 func lengthOfLongestSubstringSolution1(s string) int { // handle empty string var res int if len(s) &amp;lt;= 1 { return len(s) } for i := 0; i &amp;lt; len(s); i++ { res = max(res, helper(s, i)) } return res } func helper(s string, mid int) int { left, right := mid-1, mid+1 dict := make(map[byte]bool) dict[s[mid]] = true for left &amp;gt; 0 { _, ok := dict[s[left]] if ok { break } dict[s[left]] = true left-- } for right &amp;lt; len(s) { _, ok := dict[s[right]] if ok { break } dict[s[right]] = true right++ } return len(dict) } Sliding Window &amp;amp; Hash Table # 很明显也可以使用滑动窗口配合 Hash Table 的方式来解题。首先固定滑动窗口的左边界，然后将滑动窗口的右边界向右滑动，每滑动一个位置，就检查该位置的字符是否有在当前滑动窗口中出现过(也就是说，既要检查该字符是否在 Hash Table 中出现过，还要检查最近一次出现的下标是否位于滑动窗口之内)，如果出现过，则更新滑动串口左边界。另外，每次遍历都需要更新当前滑动窗口的最大长度。</description></item><item><title>0005. Longest Palindrome Substring</title><link>https://example.com/docs/algs/leetcode/05_longest_palindrome_substring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/05_longest_palindrome_substring/</guid><description>Description # Given a string s, return the longest palindromic substring in s.
Solutions # 中心扩散 # 题主首先想到的是中心扩散方法。核心思想就是遍历以此字符串，然后对于遍历到的每个位置，找出以这个位置为中心能找到的最长回文串。需要注意的是，一个回文串可能是偶数长度，也可能是奇数长度。如果是奇数长度，那么就需要以 i 为中心来对左右进行扩散；而如果是偶数长度，那么就需要以 i 和 i-1 为中心来进行扩散。
func longestPalindrome(s string) string { size := len(s) if size &amp;lt;= 1 { return s } var res string for i := 0; i &amp;lt; size; i++ { // 最长回文串可能会出现在以 i 为中心对称的子串上，也可能出现在以 i 和 i - 1 为中心的子串上 r1 := longestPalindromeHelper(s, i, i, size) r2 := longestPalindromeHelper(s, i-1, i, size) res = getMaxString(r1, r2, res) } return res } func longestPalindromeHelper(s string, left, right, size int) string { var res string for left &amp;gt;= 0 &amp;amp;&amp;amp; right &amp;lt; size { if s[left] == s[right] { // res 放在这里更新，这样的话，就不用写判断 left 和 right 是否有效的逻辑了 res = s[left : right+1] left-- right++ } else { break } } return res } func getMaxString(a, b, s string) string { if len(a) &amp;lt; len(b) { if len(b) &amp;lt; len(s) { return s } else { return b } } else { if len(a) &amp;lt; len(s) { return s } else { return a } } } Longest Common Stirng # 将输入字符串逆转之后，原问题就可以转换为求最长公共子串(leetcode 第 718 题)的问题。</description></item><item><title>0011. Container with Most Water</title><link>https://example.com/docs/algs/leetcode/11_container_with_most_water/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/11_container_with_most_water/</guid><description>Description # You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).
Find two lines that together with the x-axis form a container, such that the container contains the most water.
Return the maximum amount of water a container can store.
Notice that you may not slant the container.</description></item><item><title>0015. 3 Sum</title><link>https://example.com/docs/algs/leetcode/15_3sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/15_3sum/</guid><description>Description # Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
Notice that the solution set must not contain duplicate triplets.
Solutions # Two Pointer # 注意这里其实并没有说不能更改原数组，那么我们可以对原数组先排个序，然后遍历数组，每次遍历到数 x，从 x 的后面的子数组找出两个和为-x 的数即可。 这里可以注意到右以下几个优化技巧：
遍历的时候只需要遍历到倒数第三个即可。 由于限制了不能重复，那么遍历时候对于重复出现的数字需要跳过，策略是，从第二个数字开始，如果这个数字和前一个数字相同，则跳过这个数字，继续遍历下一个。 如果当前固定的数 x 是个正数，那么也可以直接跳过这个数，因为既然数组已经排好序了，那么后面的数都只会比 x 大，他们的和也比 x 大 那么如何在子数组中查找-x 呢，可以在子数组中使用双指针，假设一个下标是 i 另一个是 j，那么如果二者之和大于 target，则 j 前移，否则 i 后移。 i 和 j 移动的过程中需要注意，二者均需要跳过重复数字 func threeSum(nums []int) [][]int { return solution(nums) } func solution(nums []int) [][]int { var res [][]int size := len(nums) if size &amp;lt; 3 { return res } sort.</description></item><item><title>0016. 3Sum Closest</title><link>https://example.com/docs/algs/leetcode/16_3sum_closest/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/16_3sum_closest/</guid><description>Description # Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.
Return the sum of the three integers.
You may assume that each input would have exactly one solution.
Solutions # Two Pointer # 这个解法是题主一开始想到的解法，时间复杂度比较高，提交的结果也不如人意，不过还是可以 AC 的。
func threeSumClosest(nums []int, target int) int { var res int sort.Ints(nums) size, diff := len(nums), math.MaxInt for idx, _ := range nums { left, right := idx + 1, size - 1 for left &amp;lt; right { sum := nums[left] + nums[right] + nums[idx] if sum == target { return target } // 注意这这里要使用绝对差 if abs(target - sum) &amp;lt; diff { diff = abs(target - sum) res = sum } if sum &amp;gt; target { right-- } else { left++ } } } return res } func abs(a int) int { if a &amp;lt; 0 { return -a } return a } 下面是上面的方法优化之后的版本：</description></item><item><title>0018. 4 Sum</title><link>https://example.com/docs/algs/leetcode/18_4sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/18_4sum/</guid><description>Description # Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:
0 &amp;lt;= a, b, c, d &amp;lt; n a, b, c, and d are distinct. nums[a] + nums[b] + nums[c] + nums[d] == target You may return the answer in any order. Solutions # Two Pointers # 这里也没有什么比较好的想法，只好使用跟 3Sum 差不多的解法：还是先将数组排个序，然后使用双指针来进行查找。不过需要注意的是，这里要求a、b、c 和 d都是不同的，那么也就意味着需要进行去重处理。怎么进行去重呢？这里因为要求四个数都不相同，所以去重策略也是相对比较简单的，直接跳过重复元素即可。
func fourSum(nums []int, target int) [][]int { var res [][]int size := len(nums) sort.</description></item><item><title>0020. Valid Parentheses</title><link>https://example.com/docs/algs/leetcode/20_valid_parentheses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/20_valid_parentheses/</guid><description> Description # Given a string s containing just the characters &amp;lsquo;(&amp;rsquo;, &amp;lsquo;)&amp;rsquo;, &amp;lsquo;{&amp;rsquo;, &amp;lsquo;}&amp;rsquo;, &amp;lsquo;[&amp;rsquo; and &amp;lsquo;]&amp;rsquo;, determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Solutions # 简单题，直接使用栈即可。
func isValid(s string) bool { var stack []byte size := len(s) for i := 0; i &amp;lt; size; i++ { if s[i] == &amp;#39;(&amp;#39; || s[i] == &amp;#39;[&amp;#39; || s[i] == &amp;#39;{&amp;#39; { stack = append(stack, s[i]) } else { cap := len(stack) if cap == 0 { return false } tail := stack[cap-1] if s[i] == &amp;#39;)&amp;#39; &amp;amp;&amp;amp; tail == &amp;#39;(&amp;#39; || s[i] ==&amp;#39;]&amp;#39; &amp;amp;&amp;amp; tail == &amp;#39;[&amp;#39; || s[i] == &amp;#39;}&amp;#39; &amp;amp;&amp;amp; tail == &amp;#39;{&amp;#39; { stack = stack[:cap-1] } else { return false } } } return len(stack) == 0 }</description></item><item><title>0021. Merge Two Sorted List</title><link>https://example.com/docs/algs/leetcode/21_merge_two_sorted_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/21_merge_two_sorted_list/</guid><description>Description # You are given the heads of two sorted linked lists list1 and list2.
Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.
Return the head of the merged linked list.
Solutions # 简单题，不多说了，参考归并排序思想。
Merge Sort # func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode { res := new(ListNode) node := res dummyHead1, dummyHead2 := list1, list2 for dummyHead1 !</description></item><item><title>0022. Generate Parentheses</title><link>https://example.com/docs/algs/leetcode/22_generate_parentheses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/22_generate_parentheses/</guid><description> Description # Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
Solutions # Recursive # 参见： https://leetcode-cn.com/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/
使用两个变量 left 和 right 来表示「左括号使用了集合」和「右括号使用了几个」，通过分析可以得到以下结论： - 只有当left 和 right 都比 n 小的时候，才产生分支。 - 产生左分支的时候，只看当前还有左括号可用 - 产生右分支的时候，还受到左括号数量的限制，left 要大于 right 的时候，才可以产生分支。否则就是无效分支，可以直接返回。 - 在左边和右边的括号数都等于 n 的时候结算。
func generateParenthesis(n int) []string { var res []string if n == 0 { return res } generateParenthesisHelper(n, 0,0,&amp;#34;&amp;#34;, &amp;amp;res) return res } func generateParenthesisHelper(n, left, right int, cur string, res *[]string) { if left == n &amp;amp;&amp;amp; right == n { *res = append(*res, cur) return } // 剪枝 if left &amp;lt; right { return } if left &amp;lt; n { generateParenthesisHelper(n, left+1, right, cur + &amp;#34;(&amp;#34;, res) } if right &amp;lt; n { generateParenthesisHelper(n, left, right+1, cur + &amp;#34;)&amp;#34;, res) } }</description></item><item><title>0023. Merge K Sorted List</title><link>https://example.com/docs/algs/leetcode/23_merge_k_sorted_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/23_merge_k_sorted_list/</guid><description>Description # You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.
Merge all the linked-lists into one sorted linked-list and return it.
Solutions # Min Heap # 很简单的想法，使用最小堆即可。
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeKLists(lists []*ListNode) *ListNode { return mergeKListsSolution1(lists) } // 使用最小堆，将所有的节点数据都插入到最小堆中，然后再把所有元素从最小堆中弹出 func mergeKListsSolution1(lists []*ListNode) *ListNode { var minHeap MinHeapArr heap.</description></item><item><title>0026. remove duplicated from sorted array</title><link>https://example.com/docs/algs/leetcode/26_remove_duplicates_from_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/26_remove_duplicates_from_sorted_array/</guid><description>Description # Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.
Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result.</description></item><item><title>0027. Remove Element</title><link>https://example.com/docs/algs/leetcode/27_remove_element/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/27_remove_element/</guid><description>Description # Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.
Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result.</description></item><item><title>0028. Implement strStr</title><link>https://example.com/docs/algs/leetcode/28_implement_strStr/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/28_implement_strStr/</guid><description>Description # Implement strStr().
Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Solutions # 太简单了在，直接看代码即可。
func strStr(haystack string, needle string) int { var pos int size := len(haystack) targetSize := len(needle) if size == 0 || targetSize == 0 { return pos } var start int pos = -1 for start &amp;lt; size { if haystack[start] !</description></item><item><title>0029. Divide Two Integers</title><link>https://example.com/docs/algs/leetcode/29_divide_two_integers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/29_divide_two_integers/</guid><description>Description # Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.
The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.
Return the quotient after dividing dividend by divisor.
Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1].</description></item><item><title>0033. Search in Rotated Sorted Array</title><link>https://example.com/docs/algs/leetcode/33_search_in_rotated_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/33_search_in_rotated_array/</guid><description>Description # There is an integer array nums sorted in ascending order (with distinct values).
Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], &amp;hellip;, nums[n-1], nums[0], nums[1], &amp;hellip;, nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].
Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.</description></item><item><title>0034. Find First and Last Position of Element in Sorted Array</title><link>https://example.com/docs/algs/leetcode/34_find_first_and_last_position_of_element_in_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/34_find_first_and_last_position_of_element_in_sorted_array/</guid><description>Description # Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.
If target is not found in the array, return [-1, -1].
You must write an algorithm with O(log n) runtime complexity.
Solutions # Binary Search # 二分查找再加上中间扩散，很容易想出来。
func searchRange(nums []int, target int) []int { res := []int{-1, -1} size := len(nums) if size == 0 { return res } left, right := 0, size -1 for left &amp;lt;= right { mid := (left+right)/2 if nums[mid] == target { l,r := mid, mid res[0] = l res[1] = r for l &amp;gt;= 0 &amp;amp;&amp;amp; nums[l] == target { res[0] = l l-- } for r &amp;lt; size &amp;amp;&amp;amp; nums[r] == target { res[1] = r r++ } break } else if nums[mid] &amp;gt; target { right = mid -1 } else if nums[mid] &amp;lt; target { left = mid + 1 } } return res } 在最坏情况下，比如数组中所有数字均相同，则时间复杂度会退化为 \( \Omircon(n) \) 。下面是优化之后的解法。</description></item><item><title>0036. Valid Sudoku</title><link>https://example.com/docs/algs/leetcode/36_valid_sudoku/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/36_valid_sudoku/</guid><description>Description # Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Solutions # 一个是要注意如何快速创建三维数组，另一个是要注意如何进行坐标转换。
func isValidSudoku(board [][]byte) bool { size := 9 // 一次性将所有行和列创建完毕 row, col := make([][]int, size), make([][]int, size) for i := 0; i &amp;lt; size; i++ { row[i], col[i] = make([]int, size), make([]int, size) } // 表示 9 个gird，么个 grid 有 9 个元素.</description></item><item><title>0038. Count and Say</title><link>https://example.com/docs/algs/leetcode/38_count_and_say/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/38_count_and_say/</guid><description>Descrition # The count-and-say sequence is a sequence of digit strings defined by the recursive formula:
countAndSay(1) = &amp;ldquo;1&amp;rdquo; countAndSay(n) is the way you would &amp;ldquo;say&amp;rdquo; the digit string from countAndSay(n-1), which is then converted into a different digit string. To determine how you &amp;ldquo;say&amp;rdquo; a digit string, split it into the minimal number of groups so that each group is a contiguous section all of the same character. Then for each group, say the number of characters, then say the character.</description></item><item><title>0041. First Missing Positive</title><link>https://example.com/docs/algs/leetcode/41_first_msssing_positive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/41_first_msssing_positive/</guid><description>Description # Given an unsorted integer array nums, return the smallest missing positive integer.
You must implement an algorithm that runs in O(n) time and uses constant extra space.
Solutions # Hash Table # 可以使用一个 hash table 记录所以出现的值，然后找出当前值中的最大值。然后从 1 到最大值开始遍历，如果出现一个不在 hash table 中的数，则将该数返回即可。如果所有数都出现在了 hash table 中，那么返回最大值加 1 即可。但是最后这里需要注意的是，有可能整个数组都是负数，这样的话会导致前面的判断失效，所以返回值应该最小要返回 1.
func firstMissingPositive(nums []int) int { dict := make(map[int]bool) curMax := nums[0] for _, num := range nums { dict[num] = true if num &amp;gt; curMax { curMax = num } } for i := 1; i &amp;lt;= curMax; i++ { if _, ok := dict[i]; !</description></item><item><title>0042. Traping Rain Water</title><link>https://example.com/docs/algs/leetcode/42_traping_rain_water/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/42_traping_rain_water/</guid><description>Description # Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.
detail see: https://leetcode.com/problems/trapping-rain-water/
Solutions # Array # 使用两个数组扫描两趟，第一个数组 fromLeft 从左到右扫描，记录到目前为止遇到的最大值，第二个数组fromRight 从右向左扫描，记录当前为止遇到的最大值。最后扫描一下这两个数组，对于每个位置 i，取 fromLeft 和 fromRight 二者中的较小者与当前 height[i] 的差值作为当前格子所能盛水量。
func trap(nums []int) int { var res int size := len(nums) if size &amp;lt;= 1 { return res } curMax := nums[0] fromLeft := make([]int, size) for idx, num := range nums { curMax = max(num, curMax) fromLeft[idx] = curMax } curMax = nums[size-1] fromRight := make([]int, size) for i := size-1; i &amp;gt;= 0; i-- { curMax = max(nums[i], curMax) fromRight[i] = curMax } for i := 0; i &amp;lt; size; i++ { res += min(fromLeft[i], fromRight[i]) - nums[i] } return res } func min(a,b int) int { if a &amp;lt; b { return a } return b } func max(a,b int) int { if a &amp;lt; b { return b } return a } 还有一种解法，就是先找出整个数组的最大值，这个最大值将整个数组切分为两部分，然后分别处理左半边和右半边。处理单边的时候，记录自己当前遇到的历史最大值，如果当前值比历史最大值要大，则更新历史最大值为当前值；否则的话说明历史最大值比当前值要大，那么当前值是可以盛水的，则更新结果盛水量。为什么只需要记录当前历史最大值就可以了呢，毕竟能不能盛水其实要靠两边而不是一边啊？答案是我我们已经找出了整个数组的最大值，那么当前的历史最大值只会比整个数组的最大值要小，能盛多少水完全取决于较短的一方（参考短板理论），所以只需要维持一个最大值即可。</description></item><item><title>0044. Wildcard Matching</title><link>https://example.com/docs/algs/leetcode/44_wildcard_matching/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/44_wildcard_matching/</guid><description>Description # Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for &amp;lsquo;?&amp;rsquo; and &amp;lsquo;*&amp;rsquo; where:
&amp;lsquo;?&amp;rsquo; Matches any single character. &amp;lsquo;*&amp;rsquo; Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial).
Solutions # TODO</description></item><item><title>0046. Permutations</title><link>https://example.com/docs/algs/leetcode/46_permutations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/46_permutations/</guid><description> Description # Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.
Solutions # Array(swap) # 基于交换进行 permutate 即可。
func permute(nums []int) [][]int { var res [][]int size := len(nums) helper(0, size, nums, &amp;amp;res) return res } func helper(start,size int, nums []int, res *[][]int) { if start &amp;gt;= size { tmp := make([]int, size) copy(tmp, nums) *res = append(*res, tmp) return } for i := start; i &amp;lt; size; i++ { nums[i], nums[start] = nums[start], nums[i] // 注意这里是 start + 1， 而不是 i helper(start+1, size, nums, res) nums[i], nums[start] = nums[start], nums[i] } }</description></item><item><title>0048. Rotate Image</title><link>https://example.com/docs/algs/leetcode/48_rotate_image/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/48_rotate_image/</guid><description>Description # You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.
Solutions # 补充几个矩阵变换公式： - 主对角线对折： arr[i][j] = arr[j][i] - 副对角线对折： arr[i][j] = arr[n-j-1][n-i-1] go for i := 0; i &amp;lt; n; i++ { for j := 0; j &amp;lt; n-i; j++ { matrix[i][j], matrix[n-j-1][n-i-1] = matrix[n-j-1][n-i-1], matrix[i][j] } } - 横向对折： arr[i][j] = arr[n-i-1][j] - 纵向对折： arr[i][j] = arr[i][n-j-1]</description></item><item><title>0049. Group Anagrams</title><link>https://example.com/docs/algs/leetcode/49_group_anagrams/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/49_group_anagrams/</guid><description>Description # Given an array of strings strs, group the anagrams together. You can return the answer in any order.
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
Solutions # 简单的方法就是，对具有相同字母以及字母出现次数也相同的字符串进行排序时，其排序结果都是一样的。所以可以创建一个 map，其中 key 为字符串的排序，value 为具有这样一个排序结果的字符串数组。
func groupAnagrams(strs []string) [][]string { var res [][]string m := make(map[string][]string) for _, str := range strs { str_splited := strings.</description></item><item><title>0050. Pow(x, n)</title><link>https://example.com/docs/algs/leetcode/50_powxn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/50_powxn/</guid><description> Description # Implement pow(x, n), which calculates x raised to the power n (i.e., xn).
Solutions # Map # 可以使用快速幂以及记忆化数组，单独使用快速幂会导致超时，所以需要配合记忆化数组使用。
func myPow(x float64, n int) float64 { if x == 0 { return 0 } if n == 0 { return 1 } var negative bool if n &amp;lt; 0 { negative = true n = -n } dict := make(map[int]float64) dict[0], dict[1] = 1, x res := helper(x, n, &amp;amp;dict) if negative { return 1 / res } return res } func helper(x float64, n int, dict *map[int]float64) float64 { if value, ok := (*dict)[n]; ok { return value } res := helper(x, n/2, dict) * helper(x, n/2, dict) * helper(x, n%2, dict) (*dict)[n] = res return res }</description></item><item><title>0051. N Queens</title><link>https://example.com/docs/algs/leetcode/51_n_queens/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/51_n_queens/</guid><description>Description # The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.
Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.
Each solution contains a distinct board configuration of the n-queens&amp;rsquo; placement, where &amp;lsquo;Q&amp;rsquo; and &amp;lsquo;.&amp;rsquo; both indicate a queen and an empty space, respectively.</description></item><item><title>0052. N Queens II</title><link>https://example.com/docs/algs/leetcode/52_n_queens_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/52_n_queens_ii/</guid><description>Description # The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.
Given an integer n, return the number of distinct solutions to the n-queens puzzle.
Solutions # 这题跟 51 题的解法其实是一致的，区别只是这里求的是一个计数值。
func totalNQueens(n int) int { // 将棋盘全部初始化为点 var res int board := make([][]string, n) for idx, _ := range board { board[idx] = make([]string, n) } for i := 0; i &amp;lt; n ;i++ { for j := 0; j &amp;lt; n; j++ { board[i][j] = &amp;#34;.</description></item><item><title>0053. Maximum Subarray</title><link>https://example.com/docs/algs/leetcode/53_maximum_subarray/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/53_maximum_subarray/</guid><description>Description # Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.
A subarray is a contiguous part of an array.
Solutions # Kadane # Kadane 算法，最优子结构性质，当前位置的和取决于前一个位置的子数组和以及当前元素。
def max_subarray(arr): max_sum_so_far, sum_ending_here = arr[0], arr[0] for e in range(arr[1:]): sum_ending_here = max(e, sum_ending_here + e) max_sum_so_far = max(max_sum_so_far, sum_ending_here) return max_sum_so_far 如果数组中有负数，并且允许返回长度为 0 的子数列，则该问题可以改为：
def max_subarray(arr): max_sum_so_far, sum_ending_here = 0, 0 for e in range(arr): sum_ending_here = max(sum_ending_here + e, e) max_sum_so_far = max(max_sum_so_far, sum_ending_here) return max_sum_so_far 完整代码是：</description></item><item><title>0054. Spiral Matrix</title><link>https://example.com/docs/algs/leetcode/54_spiral_matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/54_spiral_matrix/</guid><description> Description # Given an m x n matrix, return all elements of the matrix in spiral order.
Solutions # 其实就是顺时针旋转打印数组。
func spiralOrder(matrix [][]int) []int { var res []int m, n := len(matrix), len(matrix[0]) up, bottom, left, right := 0, m-1, 0, n - 1 for up &amp;lt;= bottom &amp;amp;&amp;amp; left &amp;lt;= right { for i := left; i &amp;lt;= right; i++ { res = append(res, matrix[up][i]) } up++ if up &amp;gt; bottom { break } for i := up; i &amp;lt;= bottom; i++ { res = append(res, matrix[i][right]) } right-- if right &amp;lt; left { break } for i := right; i &amp;gt;= left; i-- { res = append(res, matrix[bottom][i]) } bottom-- if bottom &amp;lt; up { break } for i := bottom; i &amp;gt;= up;i-- { res = append(res, matrix[i][left]) } left++ if left &amp;gt; right { break } } return res }</description></item><item><title>0055. Jump Game</title><link>https://example.com/docs/algs/leetcode/55_jump_game/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/55_jump_game/</guid><description>Description # You are given an integer array nums. You are initially positioned at the array&amp;rsquo;s first index, and each element in the array represents your maximum jump length at that position.
Return true if you can reach the last index, or false otherwise.
Solutions # Recursive # 很容易想到递归的办法，但是也很容易就超时了 :)
func canJump(nums []int) bool { size := len(nums) if helper(0, size, nums) { return true } return false } func helper(start int, size int, nums []int) bool { if start &amp;gt;= size -1 { return true } for i := 1; i &amp;lt;= nums[start]; i++ { if helper(start+i, size, nums) { return true } } return false } Greedy # 使用一个变量 remianed 表示当前剩余的跳力（指从当前节点最多还可以跳几步），然后使用一个值 maxDst 表示当前能够跳到的最远距离。每遍历到一个节点，判断是否能跳到当前节点，也就是 i 是否大于 Dst，如果大于，则说明跳不到当前节点，则可以直接返回 false； 否则说明能跳到当前节点，然后根据当前节点的跳力更新当前节点的最大跳力以及能跳到的最远距离。</description></item><item><title>0056. Merge Intervals</title><link>https://example.com/docs/algs/leetcode/56_merge_intervals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/56_merge_intervals/</guid><description>Description # Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.
Solutions # 典型的区间合并问题。
首先先对区间按照开始时间从小到大进行排序，然后使用一个指针 cur 指向当前 intervals 数组遍历到的位置，使用一个指针 tail 指向 res 数组最后一个元素。然后开始对 intervals 数组进行遍历，如果当前遍历到的区间跟 res 数组的最后一个区间没有重叠，则直接将这个区间插入 res 数组，然后 tail 自增；否则的话就合并区间，更新 res[tail] 的结束时间；每次遍历结束，cur 自增。
func merge(intervals [][]int) [][]int { var res [][]int size := len(intervals) if size &amp;lt;= 1 { return intervals } sort.</description></item><item><title>0062. Unique Paths</title><link>https://example.com/docs/algs/leetcode/62_unique_paths/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/62_unique_paths/</guid><description>Description # There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.
Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.</description></item><item><title>0064. Minimum Path Sum</title><link>https://example.com/docs/algs/leetcode/64_minimum_path_sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/64_minimum_path_sum/</guid><description>Description # Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.
Note: You can only move either down or right at any point in time.
Solutions # DP # 这题跟第 120. Triangle 解法几乎一样。相比之下，这题要简单一些。这里很明显需要使用 DP，并且状态转移方程也是很明确的 dp[i][j] += min(dp[i-1][j], dp[i][j-1])，也就是说，当前位置的值只能从左边移动过来或者上边移动过来。特例情况就是第一行跟第一列，这个地方只有一种移动方向，所以需要特别处理一下。
func minPathSum(grid [][]int) int { m, n := len(grid), len(grid[0]) // corner case for i := 1; i &amp;lt; m ;i++ { grid[i][0] += grid[i-1][0] } for i := 1; i &amp;lt; n; i++ { grid[0][i] += grid[0][i-1] } for i := 1; i &amp;lt; m; i++ { for j := 1; j &amp;lt; n; j++ { grid[i][j] += min(grid[i-1][j], grid[i][j-1]) } } return grid[m-1][n-1] } func min(a,b int) int { if a &amp;lt; b { return a } return b } 当然，如果你不想污染原数组，那么也可以创建一个新的二维数组来做 DP 数组。</description></item><item><title>0066. Plus One</title><link>https://example.com/docs/algs/leetcode/66_plus_one/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/66_plus_one/</guid><description>Description # You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0&amp;rsquo;s.
Increment the large integer by one and return the resulting array of digits.
Solutions # 简单题，直接计算即可。
func plusOne(digits []int) []int { size := len(digits) if size == 0 { return digits } carry := 1 for i := size-1; i &amp;gt;= 0; i-- { sum := digits[i] + carry carry = sum / 10 digits[i] = sum % 10 } if carry &amp;gt; 0 { digits = append([]int{carry}, digits.</description></item><item><title>0069. Sqrt(x)</title><link>https://example.com/docs/algs/leetcode/69_sqrtx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/69_sqrtx/</guid><description> Description # Given a non-negative integer x, compute and return the square root of x.
Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.
Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.
Solutions # Binary Search # 使用二分法进行快速查找。开头就去除掉一些 corner case 的话，后面整体逻辑写起来就会更加的清晰。
func mySqrt(x int) int { if x &amp;lt;= 1 { return x } low, high := 0, x for low &amp;lt; high { mid := (low+high)/2 if mid * mid == x { return mid } else if mid * mid &amp;gt; x { high = mid } else { low = mid + 1 } } // 注意这里为什么返回的是 high - 1 return high - 1 }</description></item><item><title>0070. Climbing Stairs</title><link>https://example.com/docs/algs/leetcode/70_climing_stairs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/70_climing_stairs/</guid><description> Descriptioin # You are climbing a staircase. It takes n steps to reach the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
Solutions # 斐波那契数列问题，不多说。
func climbStairs(n int) int { if n &amp;lt;= 2 { return n } FMinusOne, FMinusTwo := 2, 1 for i := 3; i &amp;lt;= n; i++ { fn := FMinusOne + FMinusTwo FMinusTwo = FMinusOne FMinusOne = fn } return FMinusOne }</description></item><item><title>0073. Set Matrix Zeroes</title><link>https://example.com/docs/algs/leetcode/73_set_matrix_zeroes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/73_set_matrix_zeroes/</guid><description> Descriptioin # Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0&amp;rsquo;s.
You must do it in place.
Solutions # 这里需要注意的是，因为要求不使用额外的内存空间，所以我们就要有这种充分利用原有空间的觉悟。这里的思想是，先检查第一行第一列是否有 0，如果有，则将相应的标志设置为 true，然后使用第一行和第一列来做标记。从第二行第二列开始遍历数组，当 matrix[i][j] = 0 时，则将该行对应的第一个数设置为 0，将该列对应的第一个数设置为 0。遍历结束之后再遍历一次数组，也是从第一行和第一列开始，如果改行或者该列的第一个元素为 0， 则将相应的相应的格子设置为 0.遍历结束后，再根据刚开始设置的行 flag 和列 flag 判断是否应该将第一行和第一列设置为 0.
func setZeroes(matrix [][]int) { m, n := len(matrix), len(matrix[0]) var rowZero, colZero bool // 检查第一列是否包含 0 for i := 0; i &amp;lt; m ;i++ { if matrix[i][0] == 0 { colZero = true break } } // 检查第一行是否包含 0 for i := 0; i &amp;lt; n; i++ { if matrix[0][i] == 0 { rowZero = true break } } // 检查剩余行和列是否包含 0，如果包含，则将相应的第一行位置设为 0，第一列位置设为 0 for i := 1; i &amp;lt; m ;i++ { for j := 1; j &amp;lt; n; j++ { if matrix[i][j] == 0 { matrix[i][0] = 0 matrix[0][j] = 0 } } } // 根据第一行第一列的检测结果，将相应的行和列设置为 0 for i := 1; i &amp;lt; m; i++ { for j := 1; j &amp;lt; n; j++ { if matrix[i][0] == 0 || matrix[0][j] == 0 { matrix[i][j] = 0 } } } // 如果第一行有 0， 则将第一行设置为 0 if rowZero { for i := 0; i &amp;lt; n; i++ { matrix[0][i] = 0 } } // 如果第一列有 0， 则将第一列设置为 0 if colZero { for i := 0; i &amp;lt; m ;i++ { matrix[i][0] = 0 } } }</description></item><item><title>0074. Search a 2D Matrix</title><link>https://example.com/docs/algs/leetcode/74_search_a_2d_matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/74_search_a_2d_matrix/</guid><description> Description # Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:
Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.
Solutions # Binary Search # 这题的二分解法真的比较巧妙。这里首先具备了两个特征：每一行从左向右递增，每一列从上到下递增。那么我们可以从第一列最后一个元素开始进行搜索，如果target 比当前元素要小，那么如果target 要存在，就只能在当前行上边，于是row-1；如果target比当前元素要大，那么如果该元素存在的话，智能在当前列右侧，于是col+1。按照以上规则进行遍历即可。
func searchMatrix(matrix [][]int, target int) bool { m, n := len(matrix), len(matrix[0]) row, col := m-1, 0 for row &amp;gt;= 0 &amp;amp;&amp;amp; col &amp;lt; n { if matrix[row][col] == target { return true } if matrix[row][col] &amp;lt; target { col++ } // 上面的 if 语句可能会导致这里出现越界访问，所以要加上 col &amp;lt; n if col &amp;lt; n &amp;amp;&amp;amp; matrix[row][col] &amp;gt; target { row-- } } return false }</description></item><item><title>0075. Sort Colors</title><link>https://example.com/docs/algs/leetcode/75_sort_colors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/75_sort_colors/</guid><description>Description # Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.
We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.
You must solve this problem without using the library&amp;rsquo;s sort function.
Solutions # 其实这里应该用任意的一个排序算法都可以。
冒泡排序的思路 # 参考冒泡排序算法。</description></item><item><title>0076. Minimum Window Substring</title><link>https://example.com/docs/algs/leetcode/76_minimum_window_substring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/76_minimum_window_substring/</guid><description>Description # Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string &amp;ldquo;&amp;rdquo;.
The testcases will be generated such that the answer is unique.
A substring is a contiguous sequence of characters within the string.
Solutions # Sliding Window # 这里应该很容易可以看出需要使用滑动窗口来做，但是与一般的滑动窗口不同的是，这里的滑动窗口中可以包含一些不在字符串 t 中的字符。另外还需要注意的是，窗口中字符的出现顺序不需要和 t 一致，但是出现次数需要一致。</description></item><item><title>0078. Subsets</title><link>https://example.com/docs/algs/leetcode/78_subsets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/78_subsets/</guid><description> Descrition # Given an integer array nums of unique elements, return all possible subsets (the power set).
The solution set must not contain duplicate subsets. Return the solution in any order.
Solutions # 观察一下可以发现，其实子集合就是一个追加操作。你只需要把新元素不断的追加到就有的集合上构成一个新的集合，然后再将这个新集合添加到结果数组中即可。重复上述操作，直到你把原数组中的所有元素都遍历完一次即可。
func subsets(nums []int) [][]int { res := [][]int{{}} size := len(nums) for i := 0; i &amp;lt; size; i++ { n := len(res) for j := 0; j &amp;lt; n; j++ { t := make([]int, len(res[j])) copy(t, res[j]) t = append(t, nums[i]) res = append(res, t) // 注意不能用下面这样的方式。 // 因为 golang 中切片其实底层是一个指向实际数组的指针，所以下面的添加可能会旧元素上进行添加，而不是在新元素上进行添加。 // t := res[j] // t = append(t, nums[i]) // res = append(res, t) } } return res }</description></item><item><title>0079. Word Search</title><link>https://example.com/docs/algs/leetcode/79_word_search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/79_word_search/</guid><description>Description # Given an m x n grid of characters board and a string word, return true if word exists in the grid.
The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.
Solutions # 递归回溯即可。
func exist(board [][]byte, word string) bool { m, n := len(board), len(board[0]) for i := 0; i &amp;lt; m; i++ { for j := 0; j &amp;lt; n; j++ { if board[i][j] == word[0] { visited := make([][]bool, m) for i, _ := range visited { visited[i] = make([]bool, n) } if existBacktrace(board, word, i, j, m, n, &amp;amp;visited) { return true } } } } return false } func existBacktrace(board [][]byte, word string, si, sj, m, n int, visited *[][]bool) bool { if len(word) == 0 { return true } if si &amp;lt; 0 || sj &amp;lt; 0 || si &amp;gt;= m || sj &amp;gt;= n || (*visited)[si][sj] || board[si][sj] !</description></item><item><title>0084. Largest Rectangle in Histogram</title><link>https://example.com/docs/algs/leetcode/84_largest_rectangle_in_histogram/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/84_largest_rectangle_in_histogram/</guid><description> Description # Given an array of integers heights representing the histogram&amp;rsquo;s bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.
Solutions # 寻找每一个局部峰值 i (heights[i] &amp;gt; heights[i+1])，然后从这个局部峰值 i 开始向前遍历所有的值，算出共同的矩形面积，每次对比保留最大值。 很不幸，超时了 :)
func largestRectangleArea(heights []int) int { var res int size := len(heights) if size == 0 { return res } for i := 0; i &amp;lt; size; i++ { if i+1 &amp;lt; size &amp;amp;&amp;amp; heights[i] &amp;lt;= heights[i+1] { continue } curMin := heights[i] for j := i; j &amp;gt;= 0; j-- { if heights[j] &amp;lt; curMin { curMin = heights[j] } res = max(res, curMin * (i-j+1)) } } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a }</description></item><item><title>0088. Merge Sorted Array</title><link>https://example.com/docs/algs/leetcode/88_merge_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/88_merge_sorted_array/</guid><description>Description # You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.
Merge nums1 and nums2 into a single array sorted in non-decreasing order.
The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored.</description></item><item><title>0091. Decode Ways</title><link>https://example.com/docs/algs/leetcode/91_decode_ways/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/91_decode_ways/</guid><description>Description # A message containing letters from A-Z can be encoded into numbers using the following mapping:
&amp;lsquo;A&amp;rsquo; -&amp;gt; &amp;ldquo;1&amp;rdquo; &amp;lsquo;B&amp;rsquo; -&amp;gt; &amp;ldquo;2&amp;rdquo; &amp;hellip; &amp;lsquo;Z&amp;rsquo; -&amp;gt; &amp;ldquo;26&amp;rdquo; To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, &amp;ldquo;11106&amp;rdquo; can be mapped into:
&amp;ldquo;AAJF&amp;rdquo; with the grouping (1 1 10 6) &amp;ldquo;KJF&amp;rdquo; with the grouping (11 10 6) Note that the grouping (1 11 06) is invalid because &amp;ldquo;06&amp;rdquo; cannot be mapped into &amp;lsquo;F&amp;rsquo; since &amp;ldquo;6&amp;rdquo; is different from &amp;ldquo;06&amp;rdquo;.</description></item><item><title>0092. Reverse Linked List II</title><link>https://example.com/docs/algs/leetcode/92_reverse_linked_list_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/92_reverse_linked_list_ii/</guid><description>Description # Given the head of a singly linked list and two integers left and right where left &amp;lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list.
Solutions # 使用头插法来翻转节点：先找到待翻转节点的前一个节点pre，pre 的下一个几点就是要翻转的第一个节点 cur，使用一个节点 t 表示 cur 的下一个节点，防止断链。然后将 cur 连接到 t 的下一个节点上，然后将 t 的下一个节点设置为 cur，然后再将 pre 指向 t，这样就完成了一个节点的翻转，然后继续翻转下面的节点即可。
func reverseBetween(head *ListNode, left int, right int) *ListNode { if head == nil || right &amp;lt; left { return nil } // 试用 dummy 防止出现需要翻转第一个节点的情况 dummy := new(ListNode) dummy.</description></item><item><title>0094. Bianry Tree Inorder Traversal</title><link>https://example.com/docs/algs/leetcode/94_binary_tree_inorder_traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/94_binary_tree_inorder_traversal/</guid><description>Description # Given the root of a binary tree, return the inorder traversal of its nodes&amp;rsquo; values.
Solutions # 二叉树中序遍历，又分为迭代和递归两种方式。
Recursive # func inorderTraversal(root *TreeNode) []int { var res []int if root == nil { return res } helper(root, &amp;amp;res) return res } func helper(root *TreeNode, res *[]int) { if root == nil { return } helper(root.Left, res) *res = append(*res, root.Val) helper(root.Right, res) } Iterative # 中序遍历需要借助栈来实现。
func inorderTraversal(root *TreeNode) []int { var res []int if root == nil { return res } var stack []*TreeNode cur := root for cur !</description></item><item><title>0098. Validate Bianry Search Tree</title><link>https://example.com/docs/algs/leetcode/98_validate_binary_search_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/98_validate_binary_search_tree/</guid><description>Description # Given the root of a binary tree, determine if it is a valid binary search tree (BST).
A valid BST is defined as follows:
The left subtree of a node contains only nodes with keys less than the node&amp;rsquo;s key. The right subtree of a node contains only nodes with keys greater than the node&amp;rsquo;s key. Both the left and right subtrees must also be binary search trees.</description></item><item><title>0101. Symmetric Tree</title><link>https://example.com/docs/algs/leetcode/101_symmetric_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/101_symmetric_tree/</guid><description>Description # Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).
Solutions # 简单题，左子树的左节点的值要等于右子树的右子树的右节点的值，左子树的右节点的值要等于右子树的左节点的值。
func isSymmetric(root *TreeNode) bool { return helper(root, root) } func helper(root1, root2 *TreeNode) bool { if root1 == nil &amp;amp;&amp;amp; root2 == nil { return true } if root1 == nil || root2 == nil { return false } if root1.Val != root2.Val { return false } return helper(root1.</description></item><item><title>0102. Binary Tree Level Order Traversal</title><link>https://example.com/docs/algs/leetcode/102_binary_tree_level_order_traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/102_binary_tree_level_order_traversal/</guid><description>Description # Given the root of a binary tree, return the level order traversal of its nodes&amp;rsquo; values. (i.e., from left to right, level by level).
Solutions # 层次遍历，使用队列来做即可。
func levelOrder(root *TreeNode) [][]int { var res [][]int if root == nil { return res } queue := new(Queue) queue.Push(root) for queue.Len() != 0 { size := queue.Len() var arr []int for size != 0 { ele := queue.Pop().(*TreeNode) size -= 1 if ele == nil { continue } arr = append(arr, ele.</description></item><item><title>0103. Binary Tree ZigZag Level Order Traversal</title><link>https://example.com/docs/algs/leetcode/103_binary_tree_zigzag_level_order_traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/103_binary_tree_zigzag_level_order_traversal/</guid><description>Description # Given the root of a binary tree, return the zigzag level order traversal of its nodes&amp;rsquo; values. (i.e., from left to right, then right to left for the next level and alternate between).
Solutions # 简单题，使用队列进行层次遍历即可。
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func zigzagLevelOrder(root *TreeNode) [][]int { var res [][]int if root == nil { return res } var queue []*TreeNode queue = append(queue, root) var flag bool for len(queue) !</description></item><item><title>0104. Maximum Depth of Binary Tree</title><link>https://example.com/docs/algs/leetcode/104_maximum_depth_of_binary_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/104_maximum_depth_of_binary_tree/</guid><description> Description # Given the root of a binary tree, return its maximum depth.
A binary tree&amp;rsquo;s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
Solutions # 简单题，无需多说。
func maxDepth(root *TreeNode) int { if root == nil { return 0 } return max(maxDepth(root.Left), maxDepth(root.Right)) + 1 } func max(a,b int) int { if a &amp;lt; b { return b } return a }</description></item><item><title>0105. Construct Bianry Tree From Preorder and Inorder Traversal</title><link>https://example.com/docs/algs/leetcode/105_construct_binary_tree_from_preorder_and_inorder_traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/105_construct_binary_tree_from_preorder_and_inorder_traversal/</guid><description>Description # Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.
Solutions # func buildTree(preorder []int, inorder []int) *TreeNode { pre_size, in_size := len(preorder), len(inorder) return buildTreeSolution(preorder, 0, pre_size-1, inorder, 0, in_size -1) } func buildTreeSolution(preorder []int, pleft, pright int, inorder []int, ileft, iright int) *TreeNode { if pleft &amp;gt; pright || ileft &amp;gt; iright { return nil } var rootIndex int for i := ileft; i &amp;lt;= iright; i++ { if inorder[i] == preorder[pleft] { rootIndex = i break } } root := new(TreeNode) root.</description></item><item><title>0108. Convert Sorted Array to Binary Search Tree</title><link>https://example.com/docs/algs/leetcode/108_convert_sorted_array_to_binary_search_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/108_convert_sorted_array_to_binary_search_tree/</guid><description>Description # Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.
A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.
Solutions # 简单题，直接递归构建即可。
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func sortedArrayToBST(nums []int) *TreeNode { size := len(nums) if size == 0 { return nil } return helper(nums, 0, size-1) } func helper(nums []int, start, end int) *TreeNode { if start &amp;gt; end { return nil } mid := (start+end)/2 node := new(TreeNode) node.</description></item><item><title>0116. Populating Next Right Pointers in Eech Node</title><link>https://example.com/docs/algs/leetcode/116_populating_next_right_pointers_in_each_node/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/116_populating_next_right_pointers_in_each_node/</guid><description>Description # You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:
struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.
Initially, all next pointers are set to NULL.</description></item><item><title>0118. Pascal's Triangle</title><link>https://example.com/docs/algs/leetcode/118_pascals_triangle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/118_pascals_triangle/</guid><description> Description # Given an integer numRows, return the first numRows of Pascal&amp;rsquo;s triangle.
In Pascal&amp;rsquo;s triangle, each number is the sum of the two numbers directly above it
Solutions # 这里有很多 trick，还是需要注意一下。
func generate(numRows int) [][]int { var res [][]int for i := 0; i &amp;lt; numRows; i++ { var cur []int for j := 0; j &amp;lt; i+1; j++ { cur = append(cur, 1) } res = append(res, cur) for j := 1; j &amp;lt; i; j++ { res[i][j] = res[i-1][j-1] + res[i-1][j] } } return res }</description></item><item><title>0120. Triangle</title><link>https://example.com/docs/algs/leetcode/120_triangle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/120_triangle/</guid><description>Description # Given a triangle array, return the minimum path sum from top to bottom.
For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.
Solutions # Brute Force # 题主首先想出了贪心的解法，但是因为”局部最优并不代表全局最优“，所以没能通过，不过还是贴一下代码：
func minimumTotal(triangle [][]int) int { size := len(triangle) arr := make([]int, size+1) var start int for i := 1; i &amp;lt;= size; i++ { if start + 1 &amp;lt; len(triangle[i-1]) &amp;amp;&amp;amp; triangle[i-1][start+1] &amp;lt; triangle[i-1][start] { start = start + 1 } arr[i] = dp[i-1] + triangle[i-1][start] } return arr[size] } 既然上面的贪心不行，那么使用递归来试试呢？于是楼主又写出了下面的解法：</description></item><item><title>0121. Best Time to But And Sell Stock</title><link>https://example.com/docs/algs/leetcode/121_best_time_to_buy_and_sell_stock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/121_best_time_to_buy_and_sell_stock/</guid><description>Description # You are given an array prices where prices[i] is the price of a given stock on the ith day.
You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.
Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.
Solutions # 首先可以直接暴力求解，但是会超时。</description></item><item><title>0122. Best Time to But And Sell Stock II</title><link>https://example.com/docs/algs/leetcode/122_best_time_to_buy_and_sell_stock_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/122_best_time_to_buy_and_sell_stock_ii/</guid><description>Description # You are given an integer array prices where prices[i] is the price of a given stock on the ith day.
On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.
Find and return the maximum profit you can achieve.</description></item><item><title>0124. Binary Tree Maximum Path Sum</title><link>https://example.com/docs/algs/leetcode/124_binary_tree_maximum_path_sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/124_binary_tree_maximum_path_sum/</guid><description>Description # A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.
The path sum of a path is the sum of the node&amp;rsquo;s values in the path.
Given the root of a binary tree, return the maximum path sum of any non-empty path.</description></item><item><title>0125. Valid Palindrome</title><link>https://example.com/docs/algs/leetcode/125_valid_palindrome/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/125_valid_palindrome/</guid><description>Description # A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.
Given a string s, return true if it is a palindrome, or false otherwise.
Solutions # Two Pointer # 简单题，去除非数字字母的字符之后直接判断即可。
func isPalindrome(s string) bool { var rs []rune for _, r := range s { // skip none-alphanumeric characters if !</description></item><item><title>0127. Word Ladder</title><link>https://example.com/docs/algs/leetcode/127_word_ladder/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/127_word_ladder/</guid><description>Description # A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -&amp;gt; s1 -&amp;gt; s2 -&amp;gt; &amp;hellip; -&amp;gt; sk such that:
Every adjacent pair of words differs by a single letter. Every si for 1 &amp;lt;= i &amp;lt;= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.</description></item><item><title>0128. Longest Consecurive Sequence</title><link>https://example.com/docs/algs/leetcode/128_longest_consecutive_sequence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/128_longest_consecutive_sequence/</guid><description> Description # Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.
You must write an algorithm that runs in O(n) time.
Solutions # 使用一个集合存入所有的数字，然后遍历数组中的每个数字，如果其在集合中存在，那么将其移除，然后 pre 再自减 1，直至pre 不在集合之中，对 next 采用同样的方法，那么 next - pre -1 就是当前数字的最长连续序列。之所以要移除数字，是为了避免重复计算。比如说对于 4、3、2，如果计算 4 的时候不把 3 和 2 移除掉，那么计算 3 和 2 的时候就会出现重复计算的情况。
func longestConsecutive(nums []int) int { var res int dict := make(map[int]bool) for _, num := range nums { dict[num] = true } for _, num := range nums { left, right := num -1, num + 1 for dict[left] == true { delete(dict, left) left-- } for dict[right] == true { delete(dict, right) right++ } res = max(res, right-left-1) } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a }</description></item><item><title>0130. Surrounded Regions</title><link>https://example.com/docs/algs/leetcode/130_surrounded_regions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/130_surrounded_regions/</guid><description>Description # Given an m x n matrix board containing &amp;lsquo;X&amp;rsquo; and &amp;lsquo;O&amp;rsquo;, capture all regions that are 4-directionally surrounded by &amp;lsquo;X&amp;rsquo;.
A region is captured by flipping all &amp;lsquo;O&amp;rsquo;s into &amp;lsquo;X&amp;rsquo;s in that surrounded region.</description></item><item><title>0131. Palindrome Partitioning</title><link>https://example.com/docs/algs/leetcode/131_palindrome_partitioning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/131_palindrome_partitioning/</guid><description>Description # Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.
A palindrome string is a string that reads the same backward as forward.
Solutions # 简单递归回溯即可。
func partition(s string) [][]string { var res [][]string size := len(s) if size == 0 { return res } var cur []string helper(s,0,size, cur, &amp;amp;res) return res } func helper(s string, start, size int, cur []string, res *[][]string) { if start &amp;gt;= size { tmp := make([]string, len(cur)) copy(tmp, cur) *res = append(*res, tmp) return } for i := start; i &amp;lt; size; i++ { if isPalindrome(s[start: i+1]) { cur = append(cur, s[start:i+1]) helper(s, i+1, size, cur, res) cur = cur[:len(cur)-1] } } } func isPalindrome(s string) bool { size := len(s) left, right := 0, size -1 for left &amp;lt; right { if s[left] !</description></item><item><title>0134. Gas Station</title><link>https://example.com/docs/algs/leetcode/134_gas_station/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/134_gas_station/</guid><description>Description # There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].
You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.
Given two integer arrays gas and cost, return the starting gas station&amp;rsquo;s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</description></item><item><title>0136. Single Number</title><link>https://example.com/docs/algs/leetcode/136_single_number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/136_single_number/</guid><description> Description # Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.
You must implement a solution with a linear runtime complexity and use only constant extra space.
Solutions # 简单题，直接使用异或运算符即可。注意 res 初始化应该为 0.
func singleNumber(nums []int) int { var res int for _, num := range nums { res ^= num } return res }</description></item><item><title>0141. Linked List Cycle</title><link>https://example.com/docs/algs/leetcode/141_Linked-List-Cycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/141_Linked-List-Cycle/</guid><description>Description # Given head, the head of a linked list, determine if the linked list has a cycle in it.
There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail&amp;rsquo;s next pointer is connected to. Note that pos is not passed as a parameter.</description></item><item><title>0142. Linked List Cycle II</title><link>https://example.com/docs/algs/leetcode/142_linked_list_cycle_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/142_linked_list_cycle_ii/</guid><description>Description # Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.
There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail&amp;rsquo;s next pointer is connected to (0-indexed). It is -1 if there is no cycle.</description></item><item><title>0146. LRU Cache</title><link>https://example.com/docs/algs/leetcode/146_lru_cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/146_lru_cache/</guid><description>Description # Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.
Implement the LRUCache class:
LRUCache(int capacity) Initialize the LRU cache with positive size capacity. int get(int key) Return the value of the key if the key exists, otherwise return -1. void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache.</description></item><item><title>0148. Sort List</title><link>https://example.com/docs/algs/leetcode/148_sort_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/148_sort_list/</guid><description>Description # Given the head of a linked list, return the list after sorting it in ascending order.
Solutions # 第一个想法很简单，先扫描一遍链表，把扫描到的值记录到数组，然后对数组进行排序，最后再把排序结果赋值给原链表即可。时间复杂度 \(\Omicron(n\log n)\) , 空间复杂度 \($\Omicron(n)$\) 。
方法二，可以用插入排序的思想。维持一个排好序的链表，从头结点开始扫描，每扫描到一个节点，就将其插入到这个有序链表中去。这样空间复杂度就是 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n^2)$\) 。
follow up 但是这里要求的是时间复杂度 \($\Omicron(n\log n)$\) ，空间复杂度 \($\Omicron(1)$\) ，那很明显上述解法都不满足。这里竟然可以用归并排序，归并排序的时间复杂度是 \($\Omicron(n\logn)$\) ，归并排序又分为自顶向下和自底向上两种，前者空间复杂度是 \($\Omicron(\log n)$\) （因为栈深度），后者可以达到 \($\Omicron(1)$\) 。
这里是自顶向下的解法，需要注意的是，在 getMiddle 函数中将 middle 节点和前一个节点断开是一个非常重要的操作。
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func sortList(head *ListNode) *ListNode { return mergeSortUpDown(head) } func mergeSortUpDown(head *ListNode) *ListNode { if head == nil || head.</description></item><item><title>0150. Evaluate Reverse Polish Notation</title><link>https://example.com/docs/algs/leetcode/150_evaluate_reverse_polish_notation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/150_evaluate_reverse_polish_notation/</guid><description>Description # Evaluate the value of an arithmetic expression in Reverse Polish Notation.
Valid operators are +, -, *, and /. Each operand may be an integer or another expression.
Note that division between two integers should truncate toward zero.
It is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.</description></item><item><title>0155. Min Stack</title><link>https://example.com/docs/algs/leetcode/155_min_stack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/155_min_stack/</guid><description>Desctiption # Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
Implement the MinStack class:
MinStack() initializes the stack object. void push(int val) pushes the element val onto the stack. void pop() removes the element on the top of the stack. int top() gets the top element of the stack. int getMin() retrieves the minimum element in the stack. Solutions # 除了维持一个正常的栈来维持压入的元素之外，还需要维持一个单调递减栈当前的最小数。具体做法是，当压入一个元素的时候，如果单调栈中元素为空，则直接压入元素到单调栈中；如果单调中元素不为空，那么又分为单调栈顶元素比当前压入元素大还是小两种情况，如果栈顶元素比当前压入元素大，那么将当前压入元素压入单调栈；如果栈顶元素比当前压入元素小，那么再次压入栈顶元素。弹出时，除了对正常栈进行弹出之外，还需要对单调栈进行弹出操作。getMin 函数直接返回单调栈顶元素即可。</description></item><item><title>0160. Intersection of Two Linked Lists</title><link>https://example.com/docs/algs/leetcode/160_intersection_of_two_linked_lists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/160_intersection_of_two_linked_lists/</guid><description>Description # Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.
Solutions # Hash Table # 首先很容易想到哈希表的解法。
func getIntersectionNode(headA, headB *ListNode) *ListNode { if headA == nil || headB == nil { return nil } dict := make(map[*ListNode]bool) dummyA , dummyB := headA, headB for dummyA != nil { dict[dummyA] = true dummyA = dummyA.</description></item><item><title>0162. Find Peak Element</title><link>https://example.com/docs/algs/leetcode/162_find_peak_element/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/162_find_peak_element/</guid><description>Description # A peak element is an element that is strictly greater than its neighbors.
Given an integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.
You may imagine that nums[-1] = nums[n] = -∞.
You must write an algorithm that runs in \( Omicron(\log n) \) time.
Solutions # One Pass Iteration # 这里可以通过一次数组的一次遍历来完成。为了方便，我们可以在头部和尾部分别添加上一个最小值，这样能够减少一些边界值判断。当然，这种方法并不符合题目要求的 \( \Omicron(n\log n) \) 的要求。</description></item><item><title>0167. Two Sum II - Input Array Is Sorted</title><link>https://example.com/docs/algs/leetcode/167_two_sum_ii_input_array_is_sorted/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/167_two_sum_ii_input_array_is_sorted/</guid><description>Description # Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &amp;lt;= index1 &amp;lt; index2 &amp;lt;= numbers.length.
Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.
The tests are generated such that there is exactly one solution.</description></item><item><title>0179. Largest Number</title><link>https://example.com/docs/algs/leetcode/179_largest_numbe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/179_largest_numbe/</guid><description>Description # Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.
Since the result may be very large, so you need to return a string instead of an integer.
Solutions # 这里的解法需要十分注意，跟一般的排序是有区别的。
import ( &amp;#34;strconv&amp;#34; &amp;#34;sort&amp;#34; &amp;#34;strings&amp;#34; ) func largestNumber(nums []int) string { var rs []string for _, num := range nums { rs = append(rs, strconv.Itoa(num)) } // 这里应该进行连接排序 sort.</description></item><item><title>0191. Number of 1 Bits</title><link>https://example.com/docs/algs/leetcode/191_number_of_1_bits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/191_number_of_1_bits/</guid><description> Description # Write a function that takes an unsigned integer and returns the number of &amp;lsquo;1&amp;rsquo; bits it has (also known as the Hamming weight).
Solutions # 太简单了，并且输入还是无符号数，没啥好说的，直接看代码。
func hammingWeight(num uint32) int { var res int for num != 0 { res += int(num&amp;amp;1) num &amp;gt;&amp;gt;= 1 } return res }</description></item><item><title>0206. Reverse Linked List</title><link>https://example.com/docs/algs/leetcode/206_reverse_linked_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/206_reverse_linked_list/</guid><description>Description # Given the head of a singly linked list, reverse the list, and return the reversed list.
Solutions # Iterative # 迭代法，但是要注意虚拟头节点的使用。
func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } dummy := new(ListNode) cur := head for cur != nil { tail := dummy.Next next := cur.Next dummy.Next = cur cur.Next = tail cur = next } return dummy.Next } Recursive # 这里递归法如何反转节点也是需要十分注意的。</description></item><item><title>0215. Kth Largest Element in an Array</title><link>https://example.com/docs/algs/leetcode/215_kth_largest_element_in_an_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/215_kth_largest_element_in_an_array/</guid><description>Description # Given an integer array nums and an integer k, return the kth largest element in the array.
Note that it is the kth largest element in the sorted order, not the kth distinct element.
Solutions # Heap # 创建一个 k 个大小的最小堆，首先先将前 k 个元素压入堆中，而后面的元素只有当其比堆顶元素要大的时候才可以入堆。最后堆顶元素即为所求。
import ( &amp;#34;container/heap&amp;#34; ) func findKthLargest(nums []int, k int) int { return findKthLargestUsingSort(nums, 0, len(nums)-1, k) } // 解法1， 使用最大堆来解 func findKthLargestUsingHeap(nums []int, k int) int { var maxHeap MaxHeap heap.</description></item><item><title>0224. Basic Calculator</title><link>https://example.com/docs/algs/leetcode/224_basic_calculator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/224_basic_calculator/</guid><description>Description # Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.
Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().
Solutions # 第一个想法就是，可以先把中缀表达式转换为后缀表达式，然后再对后缀表达式进行计算，这样就会简单很多。那么问题是，如果将一个带有括号的中缀表达式转换为后缀表达式呢？这里的精简版算法如下：
声明 Q：输出队列 声明 S：操作符栈 遍历中缀表达式中的每一个 token x： - 如果 x 是一个操作数，则直接将 x 追加到输出队列 Q 末尾，否则往下检查； - 如果 x 是一个左括号&amp;#34;(&amp;#34;，则将 x 压入操作符栈，否则往下检查； - 如果 x 是一个操作符： - 如果操作符栈 S 栈顶为一个优先级大于等于 x 的操作符，则将 S 栈顶的操作符弹出并且追加到输出队列 Q 末尾，最后将 x 压入栈顶； - 如果操作符栈 S 栈顶为一个优先级小于等于 x 的操作符，或者不为操作符（这里只可能是左括号&amp;#34;（&amp;#34;）,则直接将 x 压入栈顶即可。 - 如果 x 是一个右括号，则将操作符栈 S 栈顶往下到第一个左括号之间的元素以此弹出炳且追加到输出队列末尾，然后将左括号丢弃，右括号也不用入栈。注意，如果栈到底后仍然没有找到左括号，则说明表达式不合法，左右括号不匹配。 最后将栈 S 中得到的元素全部依次弹出并且入队 Q 即可。 TODO</description></item><item><title>0225. Implement Stack using Queues</title><link>https://example.com/docs/algs/leetcode/225_implement_stack_using_queues/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/225_implement_stack_using_queues/</guid><description>Description # Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).
Implement the MyStack class:
void push(int x) Pushes element x to the top of the stack. int pop() Removes the element on the top of the stack and returns it. int top() Returns the element on the top of the stack. boolean empty() Returns true if the stack is empty, false otherwise.</description></item><item><title>0227. Basic Calculator II</title><link>https://example.com/docs/algs/leetcode/227_basic_calculator_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/227_basic_calculator_ii/</guid><description>Description # Given a string s which represents an expression, evaluate this expression and return its value.
The integer division should truncate toward zero.
You may assume that the given expression is always valid. All intermediate results will be in the range of \([-2^31, 2^31 - 1]\) .
Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().
Solutions # 这个题目因为不涉及乘除法，相比第 224 题就简单很多了，老老实实使用栈来求值就好了。这里也可以先将中缀表达式转换为后缀表达式，然后再对后缀表达式进行求值。</description></item><item><title>0232. Implement Queue using Stacks</title><link>https://example.com/docs/algs/leetcode/232_implement_queue_using_stacks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/232_implement_queue_using_stacks/</guid><description>Description # Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).
Implement the MyQueue class:
void push(int x) Pushes element x to the back of the queue. int pop() Removes the element from the front of the queue and returns it. int peek() Returns the element at the front of the queue.</description></item><item><title>0240. Search a 2D Matrix II</title><link>https://example.com/docs/algs/leetcode/240_search_a_2d_matrix_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/240_search_a_2d_matrix_ii/</guid><description> Description # Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:
Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom.
Solutions # Binary Search # 这个题使用跟 74 题一样的解法完全可以解决。
这题的二分解法真的比较巧妙。这里首先具备了两个特征：每一行从左向右递增，每一列从上到下递增。那么我们可以从第一列最后一个元素开始进行搜索，如果target 比当前元素要小，那么如果target 要存在，就只能在当前行上边，于是row-1；如果target比当前元素要大，那么如果该元素存在的话，智能在当前列右侧，于是col+1。按照以上规则进行遍历即可。
func searchMatrix(matrix [][]int, target int) bool { m,n := len(matrix), len(matrix[0]) row, col := m - 1, 0 for row &amp;gt;= 0 &amp;amp;&amp;amp; col &amp;lt; n { if matrix[row][col] == target { return true } if matrix[row][col] &amp;lt; target { col++ } if col &amp;lt; n &amp;amp;&amp;amp; matrix[row][col] &amp;gt; target { row-- } } return false }</description></item><item><title>0263. Ugly Number</title><link>https://example.com/docs/algs/leetcode/263_ugly_number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/263_ugly_number/</guid><description> Description # An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.
Given an integer n, return true if n is an ugly number.
Solutions # 如果一个数是丑数，那么它的因子必然只有 2、3、5 这三个，那么如果 n 能够被它的这些因子整除，那就不断的缩小 n，最后检查 n 不断被整除后的 n 其是否等于 1 即可。
func isUgly(n int) bool { if n &amp;lt;= 0 { return false } if n &amp;lt;= 6 { return true } for n % 2 == 0 { n /= 2 } for n %3 == 0 { n /= 3 } for n % 5 == 0 { n /= 5 } return n == 1 }</description></item><item><title>0264. Ugly Number II</title><link>https://example.com/docs/algs/leetcode/264_ugly_number_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/264_ugly_number_ii/</guid><description>Description # An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.
Given an integer n, return the nth ugly number.
Solutions # 下面这种是错误的解法，下面的逻辑意味着丑数只能从 2 的幂、3 的幂以及 5 的幂中出现，但是 6 并不属于上述任何一种，但是 6 也是幂。
func nthUglyNumber(n int) int { if n &amp;lt;= 6 { return n } res := 1 i2,i3,i5 := 1,1,1 for i := 2; i &amp;lt; n; i++ { res = min(i2*2, min(i3*3, i5*5)) // 错误做法。按照下面的逻辑，丑数只能从 2 的幂，3 的幂以及 5 的幂中出现，这个逻辑是不对的。 if res /2 == i2 { i2 *= 2 } if res / 3 == i3 { i3 *= 3 } if res / 5 == i5 { i5 *= 5 } } return res } func min(a,b int) int { if a &amp;lt; b { return a } return b } 下面这个才是正确的解法，这个解法是从已有丑数中找出下一个最小的丑数。</description></item><item><title>0268. Missing Number</title><link>https://example.com/docs/algs/leetcode/268_missing_number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/268_missing_number/</guid><description> Description # Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.
Solutions # 这题很简单，只需要使用求和公式来进行计算就可以了。直接给出代码。
func missingNumber(nums []int) int { n := len(nums) sum := (0+n) * (n+1)/2 for _, num := range nums { sum -= num } return sum }</description></item><item><title>0277. Find the Celebrity</title><link>https://example.com/docs/algs/leetcode/277_find_the_celebrity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/277_find_the_celebrity/</guid><description>Description # Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.
Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: &amp;ldquo;Hi, A.</description></item><item><title>0278. First Bad Version</title><link>https://example.com/docs/algs/leetcode/278_first_bad_version/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/278_first_bad_version/</guid><description>Description # You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.
Suppose you have n versions [1, 2, &amp;hellip;, n] and you want to find out the first bad one, which causes all the following ones to be bad.</description></item><item><title>0281. Zigzag Iterator</title><link>https://example.com/docs/algs/leetcode/281_zigzag_iterator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/281_zigzag_iterator/</guid><description>Description # Given two 1d vectors, implement an iterator to return their elements alternately.
For example, given two 1d vectors:
v1 = [1, 2] v2 = [3, 4, 5, 6] By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1, 3, 2, 4, 5, 6].
Follow up: What if you are given k 1d vectors? How well can your code be extended to such cases?</description></item><item><title>0283. Moving Zeroes</title><link>https://example.com/docs/algs/leetcode/283_moving_zeroes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/283_moving_zeroes/</guid><description>Description # Given an integer array nums, move all 0&amp;rsquo;s to the end of it while maintaining the relative order of the non-zero elements.
Note that you must do this in-place without making a copy of the array.
Solutions # Two Pointer # 简单题，直接上代码：
func moveZeroes(nums []int) { size := len(nums) if size &amp;lt;= 1 { return } left, right := 0, 0 for right &amp;lt; size { if nums[right] !</description></item><item><title>0303. Range Sum Query - Immutable</title><link>https://example.com/docs/algs/leetcode/303_range_sum_query_immutable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/303_range_sum_query_immutable/</guid><description>Solutions # Brute Force &amp;amp; Memorial # 本来题主以为这里考的是使用记忆化数组来避免重复计算，结果一提交结果，发现自己还是太天真了&amp;hellip;
type NumArray struct { nums []int dict map[string]int } func Constructor(nums []int) NumArray { return NumArray{nums, make(map[string]int)} } func (this *NumArray) SumRange(left int, right int) int { if left == right { return (*this).nums[left] } if left &amp;gt; right { return 0 } target := string(left) + string(right) if _, ok := (*this).dict[target]; ok { return (*this).dict[target] } res := this.nums[left] + this.</description></item><item><title>0304. Range Sum Query - Mutable</title><link>https://example.com/docs/algs/leetcode/307_range_sum_query_mutable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/307_range_sum_query_mutable/</guid><description>Description # Given an integer array nums, handle multiple queries of the following types:
Update the value of an element in nums.
Calculate the sum of the elements of nums between indices left and right inclusive where left &amp;lt;= right. Implement the NumArray class:
NumArray(int[] nums) Initializes the object with the integer array nums.
void update(int index, int val) Updates the value of nums[index] to be val.
int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.</description></item><item><title>0304. Range Sum Query 2D - Immutable</title><link>https://example.com/docs/algs/leetcode/304_range_sum_query_2d_immutable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/304_range_sum_query_2d_immutable/</guid><description>Description # Given a 2D matrix matrix, handle multiple queries of the following type:
Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2). Implement the NumMatrix class:
NumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix. int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).</description></item><item><title>0313. Super Ugly Number</title><link>https://example.com/docs/algs/leetcode/313_super_ugly_number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/313_super_ugly_number/</guid><description>Description # A super ugly number is a positive integer whose prime factors are in the array primes.
Given an integer n and an array of integers primes, return the nth super ugly number.
The nth super ugly number is guaranteed to fit in a 32-bit signed integer.
Solutions # K Pointer # 这个题可以用第 264 题的解法来解。区别是，第 264 题中我们只有三个因子，但是这里的因子是不固定的，那么我们只需要使用一个 map 来充当 264 题中的多指针即可。
关于为什么使用多指针就可以，这里参见一个 LeetCode 上的 回答:
这道题一开始死活不明白三指针到底是怎么用的。后来突然就想明白了：
例如 n = 10， primes = [2, 3, 5]。 打印出丑数列表：1, 2, 3, 4, 5, 6, 8, 9, 10, 12 首先一定要知道，后面的丑数一定由前面的丑数乘以2，或者乘以3，或者乘以5得来。例如，8,9,10,12一定是1, 2, 3, 4, 5, 6乘以2,3,5三个质数中的某一个得到。</description></item><item><title>0318. Maximum Product of Word Lengths</title><link>https://example.com/docs/algs/leetcode/318_maximum_product_of_word_lengths/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/318_maximum_product_of_word_lengths/</guid><description> Description # Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0.
Solutions # \( \Omicron (n^2) \) 的解法，相当于暴力求解了，因为限定了字符串中只会出现小写字符，而小写字符只有 26 个，那么就可以一个 32 位的 int 值 mask 来记录每个字符是否出现过，然后不同字符的 mask 之间进行相与，如果与的结果为 0，说明这两个字符没有重叠字符，那么就更新结果。
func maxProduct(words []string) int { var res int size := len(words) dict := make(map[int]int, size) for i := 0; i &amp;lt; size; i++ { for _, r := range words[i] { dict[i] |= 1 &amp;lt;&amp;lt; (int(r) - int(&amp;#39;a&amp;#39;)) } for j := 0; j &amp;lt; i; j++ { if (dict[i] &amp;amp; dict[j]) == 0 { res = max(res, len(words[i]) * len(words[j])) } } } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a }</description></item><item><title>0328. Odd Even Linked List</title><link>https://example.com/docs/algs/leetcode/328_odd_even_linked_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/328_odd_even_linked_list/</guid><description>Description # Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.
The first node is considered odd, and the second node is even, and so on.
Note that the relative order inside both the even and odd groups should remain as it was in the input.
You must solve the problem in O(1) extra space complexity and O(n) time complexity.</description></item><item><title>0346. Moving Average from Data Stream</title><link>https://example.com/docs/algs/leetcode/346_moving_average_from_data_stream/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/346_moving_average_from_data_stream/</guid><description>Description # Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.
Example: &amp;rsquo;&amp;rsquo;&amp;rsquo; MovingAverage m = new MovingAverage(3); m.next(1) = 1 m.next(10) = (1 + 10) / 2 m.next(3) = (1 + 10 + 3) / 3 m.next(5) = (10 + 3 + 5) / 3 &amp;rsquo;''
Solutions # 很明显是使用队列啦。
type MovingAverage struct { nums []int size int sum int } /** Initialize your data structure here.</description></item><item><title>0347. Top K Frequent Elements</title><link>https://example.com/docs/algs/leetcode/347_top_k_frequent_elements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/347_top_k_frequent_elements/</guid><description>Description # Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.
Solutions # Hash Table &amp;amp; Sort # 这里首先使用 map 来统计每个元素出现的次数，然后将元素和其出现的次数组成一个 pair 对，根据每个 pair 对的元素出现次数对 pair 对进行排序，最后取前 k 个即可。
func topKFrequent(nums []int, k int) []int { dict := make(map[int]int) for _, num := range nums { dict[num]++ } type Pair struct { num int cnt int } var pairs []Pair for key, cnt := range dict { pairs = append(pairs, Pair{key, cnt}) } sort.</description></item><item><title>0349. Intersection of Two Arrays</title><link>https://example.com/docs/algs/leetcode/349_intersection_of_two_arrays/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/349_intersection_of_two_arrays/</guid><description> Description # Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.
Solutoins # 简单题，只需要使用 map 即可。
func intersection(nums1 []int, nums2 []int) []int { d1,d2 := make(map[int]int), make(map[int]int) for _, num := range nums1 { d1[num]++ } for _, num := range nums2 { d2[num]++ } var res []int for key, _ := range d1 { if _, ok := d2[key]; ok { res = append(res, key) } } return res }</description></item><item><title>0350. Intersection of Two Arrays II</title><link>https://example.com/docs/algs/leetcode/350_intersection_of_two_arrays_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/350_intersection_of_two_arrays_ii/</guid><description> Description # Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.
Solutions # 这里跟 349 题的区别是，一个元素可能会出现多次，所以我们在统计完两个书中的元素的出现次数之后，需要确定把该元素放几次到结果数组中，那么需要放几次呢？这个次数应该跟该元素在两个数组中出现的最小次数相等。
func intersect(nums1 []int, nums2 []int) []int { d1,d2 := make(map[int]int), make(map[int]int) for _, num := range nums1 { d1[num]++ } for _, num := range nums2 { d2[num]++ } var res []int for key, value := range d1 { if cnt, ok := d2[key]; ok { m := min(cnt, value) for i := 0; i &amp;lt; m; i++ { res = append(res, key) } } } return res } func min(a,b int) int { if a &amp;lt; b { return a } return b }</description></item><item><title>0354. Russian Doll Envelopes</title><link>https://example.com/docs/algs/leetcode/354_russian_doll_envelopes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/354_russian_doll_envelopes/</guid><description>Description # You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.
One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope&amp;rsquo;s width and height.
Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).
Note: You cannot rotate an envelope.</description></item><item><title>0362. Design Hit Counter</title><link>https://example.com/docs/algs/leetcode/362_design_hit_counter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/362_design_hit_counter/</guid><description>Description # Design a hit counter which counts the number of hits received in the past 5 minutes.
Each function accepts a timestamp parameter (in seconds granularity) and you may assume that calls are being made to the system in chronological order (ie, the timestamp is monotonically increasing). You may assume that the earliest timestamp starts at 1.
It is possible that several hits arrive roughly at the same time.</description></item><item><title>0362. Design Hit Counter</title><link>https://example.com/docs/algs/leetcode/367_valid_perfect_square/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/367_valid_perfect_square/</guid><description> Description # Given a positive integer num, write a function which returns True if num is a perfect square else False.
Follow up: Do not use any built-in library function such as sqrt.
Solutions # Binary Search # 这里跟 69 题其实是完全一样的解法，需要注意的是，在开始的时候去除掉一些 corner case 能够让后面的整体逻辑更清晰一些。
func isPerfectSquare(num int) bool { if num &amp;lt;= 1 { return true } left, right := 0, num for left &amp;lt; right { mid := left + (right - left)/2 res := mid * mid if res == num { return true } if res &amp;gt; num { right = mid } else { left = mid + 1 } } return false }</description></item><item><title>0378. Kth Smallest Element in a Sorted Matrix</title><link>https://example.com/docs/algs/leetcode/378_kth_smallest_element_in_a_sorted_matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/378_kth_smallest_element_in_a_sorted_matrix/</guid><description>Description # Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix.
Note that it is the kth smallest element in the sorted order, not the kth distinct element.
You must find a solution with a memory complexity better than \( \Omicron(n^2) \) Solutions # 这里可以使用最小堆，遍历矩阵，不断往堆中加入元素，遍历完之后，取堆中第 k 个元素就可。或者使用一个大小为 k 的最大堆，当堆中元素数量不足 k 时，将元素入堆，当堆中元素比 k 大时，将堆顶元素出堆即可。</description></item><item><title>0380. Insert Delete GetRandom O(1)</title><link>https://example.com/docs/algs/leetcode/380_insert_delete_getrandom_O1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/380_insert_delete_getrandom_O1/</guid><description>Description # Implement the RandomizedSet class:
RandomizedSet() Initializes the RandomizedSet object. bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise. bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise. int getRandom() Returns a random element from the current set of elements (it&amp;rsquo;s guaranteed that at least one element exists when this method is called).</description></item><item><title>0409. Longest Palindrome</title><link>https://example.com/docs/algs/leetcode/409_longest_palindrome/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/409_longest_palindrome/</guid><description> Description # Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.
Letters are case sensitive, for example, &amp;ldquo;Aa&amp;rdquo; is not considered a palindrome here.
Solutions # Hash Table # 回文串有两种形式，一种是xxyy，另一种是xxyzz，也就是说，两边的字符需要出现偶数次，那么这里就可以转换为统计出现偶数次的字符的数量。在统计的过程中，如果发现有一个字符出现了奇数次，那么这个奇数次的字符就可以放在回文串的中心，那么就需要记录一下，最后在结果上加上 1.
func longestPalindrome(s string) int { // 统计每个字符出现的次数 size := len(s) dict := make(map[byte]int) for i := 0; i &amp;lt; size; i++ { dict[s[i]]++ } var res int var addMid bool for _, num := range dict { res += num // 如果出现了奇数次，那么只取最大的偶数，也就是要减去 1 // 如果只是出现了一次的话，那么这里相当于没有加 if num % 2 == 1 { res -= 1 // 回文串有两种类型，一种是中间一个字符然后两边对称的形式， // 也就是说，如果有一个字符出现了奇数次，那么最后可以考虑把这个字符加上。 addMid = true } } if addMid { res += 1 } return res }</description></item><item><title>0424. Longest Repeating Character Replacement</title><link>https://example.com/docs/algs/leetcode/424_longest_repeating_character_replacement/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/424_longest_repeating_character_replacement/</guid><description>Description # You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.
Return the length of the longest substring containing the same letter you can get after performing the above operations.
Solutions # Sliding Window # 这个题题主又不会了，在网上看到可以使用滑动窗口来解。假设没有 k 的限制，也就是说可以替换任意多次，把一个字符串变为只有只有一个字符重复的字符串需要的最少置换次数是多少呢？其实就是扫描一遍字符串，记录出现次数最多的字符串的出现个数k，然后用总长度减去 k ，所得值即为最少置换次数。
而如果带上了 k，那么就要满足: 子字符串的长度减去该子字符串中出现次数最多的字符的长度要小于等于 k。具体做法：</description></item><item><title>0454. 4 Sum II</title><link>https://example.com/docs/algs/leetcode/454_4sum_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/454_4sum_ii/</guid><description> Description # Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:
0 &amp;lt;= i, j, k, l &amp;lt; n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0 Solutions # Hash Table &amp;amp;&amp;amp; Divide # 首先题主肯定是写了一个四重循环，提交上去然后不出意外的超时了（笑。
然后经过一波搜索，发现可以这么做：这里使用的也算是分治思想，与其直接写一个四重循环，那么我们可以写两个二重循环，这样就可以有效降低时间复杂度。首先使用一个 map 记录 A 数组和 B 数组中每个元素组合之和出现的次数，然后再遍历 C 和 D，求出 C 和 D 当前元素组合的和，然后判断其相反数有没有在 map 中出现，如果出现了，则在结果上加上其出现的次数即可。不得不说，这个解法还是很巧妙的。
func fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int { var res int dict := make(map[int]int) for _, num1 := range nums1 { for _, num2 := range nums2 { dict[num1+num2]++ } } for _, num1 := range nums3 { for _, num2 := range nums4 { if cnt,ok := dict[-num1-num2]; ok { res += cnt } } } return res }</description></item><item><title>0474. Ones and Zeroes</title><link>https://example.com/docs/algs/leetcode/474_ones_and_zeroes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/474_ones_and_zeroes/</guid><description>Description # You are given an array of binary strings strs and two integers m and n.
Return the size of the largest subset of strs such that there are at most m 0&amp;rsquo;s and n 1&amp;rsquo;s in the subset.
A set x is a subset of a set y if all elements of x are also elements of y.
Solutions # 这里很难想到要用动态规划吧。假设 dp[i][j] 表示一个能包含 i 个 0 和 j 个 1 的子集中的字符串个数。则当扫描到字符串str[i]时，统计其中出现0 位 zeros，1 为 ones。则 \(dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones]&amp;#43;1)\) 。</description></item><item><title>0528. Random Pick with Weight</title><link>https://example.com/docs/algs/leetcode/528_random_pick_with_weight/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/528_random_pick_with_weight/</guid><description>Description # You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith index.
You need to implement the function pickIndex(), which randomly picks an index in the range [0, w.length - 1] (inclusive) and returns it. The probability of picking an index i is w[i] / sum(w).
For example, if w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.</description></item><item><title>0540. Single Element in a Sorted Array</title><link>https://example.com/docs/algs/leetcode/540_single_element_in_a_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/540_single_element_in_a_sorted_array/</guid><description>Description # You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.
Return the single element that appears only once.
Your solution must run in \(\Omicron(\log n) {{ &amp;lt; /katex &amp;gt;}} time and {{ &amp;lt; katex &amp;gt; \Omicron(1) {{ &amp;lt; /katex &amp;gt; }}} space. ### Bit Manipulation 这个题一眼看到，首先想到的就是使用异或操作，因为异或会导致相同的元素相互抵消为零，所以最后只会剩下哪个只出现一次的元素。 ```go func singleNonDuplicate(nums []int) int { var res int for _, num := range nums { res ^= num } return res } ``` ### Binary Search 这里因为数组有序，并且题目也要求 &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;/katex/katex.</description></item><item><title>0560. Subarray Sum Equals K</title><link>https://example.com/docs/algs/leetcode/560_subarray_sum_equals_k/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/560_subarray_sum_equals_k/</guid><description> Description # Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.
A subarray is a contiguous non-empty sequence of elements within an array.
Solutions # Prefix Sum # 这个题可以使用前缀和的技巧来解决。前缀和相关的介绍可以看 这里。
func subarraySum(nums []int, k int) int { var res int size := len(nums) prefix := make([]int, size+1) // 计算前缀和 idx := 1 for _, num := range nums { prefix[idx] = prefix[idx-1] + num idx++ } // 计算子数组 for i := 1; i &amp;lt;= size; i++ { for j := 0; j &amp;lt; i; j++ { if prefix[i] - prefix[j] == k { res++ } } } return res }</description></item><item><title>0583. Delete Operations for Two Strings</title><link>https://example.com/docs/algs/leetcode/583_delete_operation_for_two_strings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/583_delete_operation_for_two_strings/</guid><description>Description # Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same.
In one step, you can delete exactly one character in either string.
Solutions # DP # 求最少的删除步数来使两个字符串一致，其实就是求两个字符串的最长公共子序列（注意，子序列意味着可以不连续），最少的步数就是二者的长度之和减去最长公共子序列的两倍。所以问题就是如何求两个字符串的最长公共子序列。定义 dp[i][j] 表示 str1（假设长度为m）的前i个字符和str2（假设长度为n）的前j个字符的最长公共子序列的长度，根据这个定义，我们最求所求的值就是dp[m][n]，那么我们应该申请的数组就是 (m+1) * (n+1)的二维数组。
当 str1[i] 和 str2[j] 相等时，dp[i][j] 的值取决于str1的前i-1个i个字符和str2的前j个字符的最长公共子序列，也就是说， dp[i][j] = dp[i-1][j-1] + 1; 当 str1[i] 和 str2[j] 不相等时， 由于所求的时最大长度，dp[i][j] 的值就继承于 dp[i-1][j] 和 dp[i][j-1]中的较大者。 而对于初始条件，可以轻松得到， dp[0][j] = dp[i][0] = 0。</description></item><item><title>0630. Course Schedule III</title><link>https://example.com/docs/algs/leetcode/630_course_schedule_iii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/630_course_schedule_iii/</guid><description>Description # There are n different online courses numbered from 1 to n. You are given an array courses where courses[i] = [durationi, lastDayi] indicate that the ith course should be taken continuously for durationi days and must be finished before or on lastDayi.
You will start on the 1st day and you cannot take two or more courses simultaneously.
Return the maximum number of courses that you can take.</description></item><item><title>0643. Maximum Average Subarray I</title><link>https://example.com/docs/algs/leetcode/643_maximum_average_subarray_i_/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/643_maximum_average_subarray_i_/</guid><description>Description # You are given an integer array nums consisting of n elements, and an integer k.
Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted.
Solutions # Sliding Window # 这题没什么难度，可以用一个固定长度的队列来模拟滑动窗口即可。
func findMaxAverage(nums []int, k int) float64 { var queue []int res, size, sum := math.</description></item><item><title>0647. Palindromic Substrings</title><link>https://example.com/docs/algs/leetcode/647_palindromic_substrings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/647_palindromic_substrings/</guid><description>Description # Given a string s, return the number of palindromic substrings in it.
A string is a palindrome when it reads the same backward as forward.
A substring is a contiguous sequence of characters within the string.
Solutions # Two Pointer # 回文串的解法都是相对比较单一的，这里还是沿用老套路：遍历字符串中的每个位置，检查以这个位置为中心，或者以这个位置和前一个位置为中心的字符是否能组成回文串，检查的时候把 res 传到子函数中去，这样就可以更新 res 。
func countSubstrings(s string) int { var res int size := len(s) for i := 0; i &amp;lt; size; i++ { findPalindrome(s, i,i,size,&amp;amp;res) findPalindrome(s,i-1,i,size,&amp;amp;res) } return res } func findPalindrome(s string, left,right,size int, res *int) { for left &amp;gt;= 0 &amp;amp;&amp;amp; right &amp;lt; size { if s[left] !</description></item><item><title>0665. Non-decreasing Array</title><link>https://example.com/docs/algs/leetcode/665_non_decreasing_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/665_non_decreasing_array/</guid><description>Description # Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element.
We define an array is non-decreasing if nums[i] &amp;lt;= nums[i + 1] holds for every i (0-based) such that (0 &amp;lt;= i &amp;lt;= n - 2).
Solution # Greedy # 题主这题做了好久，多次提交都不正确，只好上网上看各路大神们的解法。这里用的是贪心思想，这里你会发现，对于一个序列 abcd，如果 c 比 b 要小，那么你要么更改 c 的值，让当前元素等于前一个元素，要么更改 b 的值，让前一个元素（相对于 c 而言）小于等于当前元素，那改谁的值会让你受益更多呢？其实是改 b 的值，也就是 nums[i-1] 的值，因为减少值没有风险，但是增加值却可能会带来风险。但是，如果你发现 a &amp;gt; c 的时候，那么你就需要更改 c 的值，也就是 nums[i]，否则的话，你就需要同时更改 a 和 b 的值，而这显然是不被允许的。</description></item><item><title>0718. Maximum Length of Repeated Subarray</title><link>https://example.com/docs/algs/leetcode/718_maximum_length_of_repeated_subarray/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/718_maximum_length_of_repeated_subarray/</guid><description> Description # Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays.
Solutions # Dynamic Programming # 定义 dp[i][j]表示 nums1 中以 i 为结尾的子数组和 nums2 中以 j 为结尾的子数组当前的匹配的最长公共子数组的长度。如果 nums1[i] == num2[j]，说明当前两个数字相同，那么当前最长公共子数组的长度就是 nums1 以 i-1 为结尾的子数组和 nums2 以 j-1 为结尾的子数组的最长公共子数组的长度加 1，即 dp[i][j] = dp[i-1][j-1] + 1；否则说明二者当前无公共子子数组或者公共子数组在当前位置不连续，则dp[i][j] = 0。
func findLength(nums1 []int, nums2 []int) int { m,n := len(nums1), len(nums2) dp := make([][]int, m+1) for idx, _ := range dp { dp[idx] = make([]int, n + 1) } var res int for i := 1; i &amp;lt;= m;i++ { for j := 1; j &amp;lt;= n; j++ { if nums1[i-1] == nums2[j-1] { dp[i][j] = dp[i-1][j-1] + 1 res = max(res, dp[i][j]) } else { dp[i][j] = 0 } } } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a }</description></item><item><title>0735. Asteroid Collisiion</title><link>https://example.com/docs/algs/leetcode/735_asteroid_collision/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/735_asteroid_collision/</guid><description>Description # We are given an array asteroids of integers representing asteroids in a row.
For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.
Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode.</description></item><item><title>0745. Prefix and Suffix Search</title><link>https://example.com/docs/algs/leetcode/745_prefix_and_suffix_search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/745_prefix_and_suffix_search/</guid><description>Description # Design a special dictionary with some words that searchs the words in it by a prefix and a suffix.
Implement the WordFilter class:
WordFilter(string[] words) Initializes the object with the words in the dictionary. f(string prefix, string suffix) Returns the index of the word in the dictionary, which has the prefix prefix and the suffix suffix. If there is more than one valid index, return the largest of them.</description></item><item><title>0767. Reorganize String</title><link>https://example.com/docs/algs/leetcode/767_reorganizing_string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/767_reorganizing_string/</guid><description>Description # Given a string s, rearrange the characters of s so that any two adjacent characters are not the same.
Return any possible rearrangement of s or return &amp;quot;&amp;quot; if not possible.
Solutions # 这里的解法还是很巧妙的，需要注意一下。
type Pair struct { char byte cnt int } func reorganizeString(s string) string { dict := make(map[byte]int) for idx, _ := range s { dict[s[idx]]++ } var maxHeap MaxHeap heap.Init(&amp;amp;maxHeap) for char, cnt := range dict { if cnt &amp;gt; (len(s)+1)/2 { return &amp;#34;&amp;#34; } heap.</description></item><item><title>0820. Short Encoding of Words</title><link>https://example.com/docs/algs/leetcode/820_short_encoding_of_words/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/820_short_encoding_of_words/</guid><description> Description # Solutions # Hash Table # 这道题给了我们一个单词数组，让我们对其编码，不同的单词之间加入#号，每个单词的起点放在一个坐标数组内，终点就是#号，能合并的单词要进行合并，问输入字符串的最短长度。题意不难理解，难点在于如何合并单词，我们观察题目的那个例子，me和time是能够合并的，只要标清楚其实位置，time的起始位置是0，me的起始位置是2，那么根据#号位置的不同就可以顺利的取出me和time。需要注意的是，如果me换成im，或者tim的话，就不能合并了，因为我们是要从起始位置到#号之前所有的字符都要取出来。
这里使用 Hash Table 来做，将所有的单词先放到这个Hash Table 中。原理是对于每个单词，我们遍历其所有的后缀，比如time，那么就遍历ime，me，e，然后看 Hash Table 中是否存在这些后缀，有的话就删掉，那么 Hash Table 中的 me 就会被删掉，这样保证了留下来的单词不可能再合并了，最后再加上每个单词的长度到结果 res，并且同时要加上 # 号的长度。
func minimumLengthEncoding(words []string) int { // 先将每个单词放进 hash 表中 dict := make(map[string]bool) for _, word := range words { dict[word] = true } // 对于 words 中的每个单词，找到其每个后缀，查看该后缀是否在 dict 中，如果在的话，则从 dict 中将该后缀删除 for _, word := range words { size := len(word) for i := 1; i &amp;lt; size; i++ { if _, ok := dict[word[i:]]; ok { delete(dict, word[i:]) } } } // 最后 dict 中剩下来的字符串都是不能合并的字符串，因为每个字符串和周围的字符串都要有一个#分隔，最后一个位置也需要一个#分隔， // 所以可以遍历 dict 中剩下的每个字符串，将其长度加 1 放到 res 中 var res int for word, _ := range dict { res += len(word) + 1 } return res }</description></item><item><title>0867. Transpose Matrix</title><link>https://example.com/docs/algs/leetcode/867_transpose_matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/867_transpose_matrix/</guid><description> Description # Given a 2D integer array matrix, return the transpose of matrix.
The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix&amp;rsquo;s row and column indices.
Solutions # 简言之就是需要行列倒置。
func transpose(matrix [][]int) [][]int { m,n := len(matrix),len(matrix[0]) res := make([][]int, n) for idx, _ := range res { res[idx] = make([]int, m) } for i := 0; i &amp;lt; m; i++ { for j := 0; j &amp;lt; n; j++ { res[j][i] = matrix[i][j] } } return res }</description></item><item><title>0876. Median of the Linked List</title><link>https://example.com/docs/algs/leetcode/876_median_of_the_linked_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/876_median_of_the_linked_list/</guid><description>Description # Given the head of a singly linked list, return the middle node of the linked list.
If there are two middle nodes, return the second middle node.
Solutions # 使用快慢指针法，最后返回慢指针指向的节点即可。
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func middleNode(head *ListNode) *ListNode { slow, fast := head, head // 注意这里的判断条件 for fast != nil &amp;amp;&amp;amp; fast.</description></item><item><title>0895. Max Frequency Stack</title><link>https://example.com/docs/algs/leetcode/895_max_frequency_stack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/895_max_frequency_stack/</guid><description>Description # Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.
Implement the FreqStack class:
FreqStack() constructs an empty frequency stack. void push(int val) pushes an integer val onto the top of the stack. int pop() removes and returns the most frequent element in the stack. If there is a tie for the most frequent element, the element closest to the stack&amp;rsquo;s top is removed and returned.</description></item><item><title>0968. Binary Tree Cameras</title><link>https://example.com/docs/algs/leetcode/968_binary_tree_cameras/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/968_binary_tree_cameras/</guid><description>Description # You are given the root of a binary tree. We install cameras on the tree nodes where each camera at a node can monitor its parent, itself, and its immediate children.
Return the minimum number of cameras needed to monitor all nodes of the tree.
Solutions # Greedy Algorithms # 这种 hard 题，题主肯定是不会做的啦（囧�� ），所以只好求助于网上大神了：
这里先考虑把相机放在什么位置上能看到的节点最多（这样的话相机数量就会最少）？能放在叶节点吗？显然不能，叶节点最多只能看到两个节点；能放到根节点吗？根节点最多也只能看到 3 个。最优解是放在叶节点的父节点上，这样最多就可以看到四个节点。所以策略是先找到叶节点，然后在其父节点上放相机，同时标记父节点的父节点为被拍到了的状态。这样就有三种不同的状态，用 0 表示当前节点是叶节点，用 1 表示当前节点是叶节点的父节点并且放置了相机，用 2 表示当前节点是叶节点的爷爷节点，并且被相机拍到了。这里使用一个全局变量 res 记录相机个数。在递归过程中，若当前节点不存在，则返回 2，空节点也可以看做被相机拍到了。否则对相机左右节点递归调用，若二者中有一个返回 0，则当前节点至少有一个节点是叶节点，需要在当前位置放置一个相机，res 自增 1，并返回 1；如果左右节点的返回值中有一个为 1，说明左右节点中至少有一个已经放上了相机，当前节点已经被拍到了，返回 2。若都不是，则说明当前节点是叶节点，返回 0。在主函数中，若对根节点调用递归的返回值是 0，说明这个树只有一个节点或者根节点的左右节点没有子节点或者根节点就是叶节点，此时没有办法，只能在根节点上也放一个相机，否则不用加。</description></item><item><title>0973. K Closest Points to Origin</title><link>https://example.com/docs/algs/leetcode/973_k_closest_points_to_origin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/973_k_closest_points_to_origin/</guid><description>Description # Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).
The distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x1 - x2)2 + (y1 - y2)2).
You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).</description></item><item><title>1047. Remove All Adjacent Duplicates in String</title><link>https://example.com/docs/algs/leetcode/1047_remove_all_duplicated_in_string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1047_remove_all_duplicated_in_string/</guid><description>Description # You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.
We repeatedly make duplicate removals on s until we no longer can.
Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique.
Solutions # 很容易想到用栈。这里需要注意的是，对于&amp;quot;abbaca&amp;quot;这样的字符，移除之后的结果是 “ca”，而不是“abaca”喔，这里的删除是指一旦连续两个字符相同，那么把这两个字符都删去，而不是只保留一个。
func removeDuplicates(s string) string { size := len(s) if size &amp;lt;= 1 { return s } var stack []rune for _, r := range s { size = len(stack) if size == 0 || stack[size-1] !</description></item><item><title>1048. Longest String Chain</title><link>https://example.com/docs/algs/leetcode/1048_longest_string_chain/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1048_longest_string_chain/</guid><description>Description # You are given an array of words where each word consists of lowercase English letters.
wordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB.
For example, &amp;quot;abc&amp;quot; is a predecessor of &amp;quot;abac&amp;quot;, while &amp;quot;cba&amp;quot; is not a predecessor of &amp;quot;bcad&amp;quot;. A word chain is a sequence of words [word1, word2, .</description></item><item><title>1060. Missing Element in Sorted Array</title><link>https://example.com/docs/algs/leetcode/1060_missing_element_in_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1060_missing_element_in_sorted_array/</guid><description>Description # Given an array containing n distinct numbers taken from 0, 1, 2, &amp;hellip;, n, find the one that is missing from the array.
For example, Given nums = [0, 1, 3] return 2.
Note: Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?
Solutions # Math # 这个题还是很简单的，首先需要求出求出 [0,n] 的累和，然后用这个累和减去数组中出现的每个数，最后剩下的数就是结果。
func missingNumber(nums []int) int { size := len(nums) res := (1 + n)*n/2 for _, num := range nums { res -= num } return num } Bit Manipulation # 这个题也可以使用异或来做。既然从 0 到 n 中缺了一个，那么我们就可以使用从 0 到 n 的每个数字来跟数组中的数字进行异或操作，最后的那个数字肯定就是缺的那个数字啦。</description></item><item><title>1062. Longest Repeating Substring</title><link>https://example.com/docs/algs/leetcode/1062_longest_repeating_substring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1062_longest_repeating_substring/</guid><description> Description # Given a string S, find out the length of the longest repeating substring(s). Return 0 if no repeating substring exists.
Solutions # Dynamic Programming # 这种什么最长、最大的题目，当然是使用 DP 来解啦，不过题主想了好一会也没想到该怎么定义状态方程，只好上网去看各路大神怎么搞的：这里定了 dp[i][j] 表示 s 中以第 i 个字符为结尾的子串为和以第 j 个字符为结尾的子串的最大公共后缀的长度。当s[i] == s[j] 时，dp[i][j] = dp[i-1][j-1] + 1；否则，dp[i][j] = 0。在 dp 更新的过程中，不断保存最大值即可。
这里 DP 的递推式跟「718. Maximum Length of Repeated Subarray」是一致的。
func longestRepeatingSubstring(s string) int { res,size := math.MinInt, len(s) dp := make([]int, size + 1) for idx, _ := range dp { dp[idx] = make([]int, size + 1) } for i := 1; i &amp;lt;= size; i++ { for j := 1; j &amp;lt;i;j++ { if s[i-1] == s[j-1] { dp[i][j] = dp[i-1][j-1] + 1 } res = max(res, dp[i][j]) } } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a }</description></item><item><title>1086. High Five</title><link>https://example.com/docs/algs/leetcode/1086_high_five/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1086_high_five/</guid><description>Description # Given a list of the scores of different students, items, where items[i] = [IDi, scorei] represents one score from a student with IDi, calculate each student&amp;rsquo;s top five average.
Return the answer as an array of pairs result, where result[j] = [IDj, topFiveAveragej] represents the student with IDj and their top five average. Sort result by IDj in increasing order.
A student&amp;rsquo;s top five average is calculated by taking the sum of their top five scores and dividing it by 5 using integer division.</description></item><item><title>1095. Find in Mountain Array</title><link>https://example.com/docs/algs/leetcode/1095_find_in_mountain_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1095_find_in_mountain_array/</guid><description>Description # (This problem is an interactive problem.)
You may recall that an array arr is a mountain array if and only if:
arr.length &amp;gt;= 3 There exists some i with 0 &amp;lt; i &amp;lt; arr.length - 1 such that: arr[0] &amp;lt; arr[1] &amp;lt; &amp;hellip; &amp;lt; arr[i - 1] &amp;lt; arr[i] arr[i] &amp;gt; arr[i + 1] &amp;gt; &amp;hellip; &amp;gt; arr[arr.length - 1] Given a mountain array mountainArr, return the minimum index such that mountainArr.</description></item><item><title>1209. Remove All Adjacent Duplicates in String</title><link>https://example.com/docs/algs/leetcode/1209_remove_all_adjacent_duplicates_in_string_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1209_remove_all_adjacent_duplicates_in_string_ii/</guid><description>Description # You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, causing the left and the right side of the deleted substring to concatenate together.
We repeatedly make k duplicate removals on s until we no longer can.
Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.</description></item><item><title>1249. Minimum Remove to Make Valid Parentheses</title><link>https://example.com/docs/algs/leetcode/1249_minimum_remove_to_make_valid_parentheses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1249_minimum_remove_to_make_valid_parentheses/</guid><description>Description # Given a string s of &amp;lsquo;(&amp;rsquo; , &amp;lsquo;)&amp;rsquo; and lowercase English characters.
Your task is to remove the minimum number of parentheses ( &amp;lsquo;(&amp;rsquo; or &amp;lsquo;)&amp;rsquo;, in any positions ) so that the resulting parentheses string is valid and return any valid string.
Formally, a parentheses string is valid if and only if:
It is the empty string, contains only lowercase characters, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string.</description></item><item><title>1268. Search Suggestions System</title><link>https://example.com/docs/algs/leetcode/1268_search_suggestions_system/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1268_search_suggestions_system/</guid><description>Description # You are given an array of strings products and a string searchWord.
Design a system that suggests at most three product names from products after each character of searchWord is typed. Suggested products should have common prefix with searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products.
Return a list of lists of the suggested products after each character of searchWord is typed.</description></item><item><title>1300. Sum of Mutated Array Closest to Target</title><link>https://example.com/docs/algs/leetcode/1300_sum_of_mutated_array_closest_to_target/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1300_sum_of_mutated_array_closest_to_target/</guid><description>Description # Given an integer array arr and a target value target, return the integer value such that when we change all the integers larger than value in the given array to be equal to value, the sum of the array gets as close as possible (in absolute difference) to target.
In case of a tie, return the minimum such integer.
Notice that the answer is not neccesarilly a number from arr.</description></item><item><title>1332. Remove Palindromic Subsequences</title><link>https://example.com/docs/algs/leetcode/1332_remove_palindromic_subsequence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1332_remove_palindromic_subsequence/</guid><description>Description # You are given a string s consisting only of letters &amp;lsquo;a&amp;rsquo; and &amp;lsquo;b&amp;rsquo;. In a single step you can remove one palindromic subsequence from s.
Return the minimum number of steps to make the given string empty.
A string is a subsequence of a given string if it is generated by deleting some characters of a given string without changing its order. Note that a subsequence does not necessarily need to be contiguous.</description></item><item><title>1342. Number of Steps to Reduce a Number to Zero</title><link>https://example.com/docs/algs/leetcode/1342_number_of_steps_to_reduce_a_number_to_zero/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1342_number_of_steps_to_reduce_a_number_to_zero/</guid><description> Description # Given an integer num, return the number of steps to reduce it to zero.
In one step, if the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.
Solutions # 这题太简单了，没什么好说的，直接上代码。
func numberOfSteps(num int) int { var res int for num != 0 { if num%2 == 0 { num /= 2 } else { num -= 1 } res++ } return res }</description></item><item><title>1423. Maximum Points You Can Obrain fron Cards</title><link>https://example.com/docs/algs/leetcode/1423_maximum_points_you_can_obtain_from_cards/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1423_maximum_points_you_can_obtain_from_cards/</guid><description>Description # There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints.
In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards.
Your score is the sum of the points of the cards you have taken.
Given the integer array cardPoints and the integer k, return the maximum score you can obtain.</description></item><item><title>1429. First Unique Number</title><link>https://example.com/docs/algs/leetcode/1429_first_unique_number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1429_first_unique_number/</guid><description>Description # You have a queue of integers, you need to retrieve the first unique integer in the queue.
Implement the FirstUnique class:
FirstUnique(int[] nums) Initializes the object with the numbers in the queue. int showFirstUnique() returns the value of the first unique integer of the queue, and returns -1 if there is no such integer. void add(int value) insert value to the queue. Solutions # 可以这么做： 维护一个哈希表，哈希表的 key 为数字，value 为一个Pair， Pair 中存储 key 在数组中的下标以及该数字的出现次数。然后再创建一个 queue， 将所有出现次数为 1 的数字按照在队列中的出现顺序入队。 调用 showFirstUnique 的时候， 从队列中取出元素，检查在哈希表中该元素的出现次数是否为 1，如果不是，则持续出对队，直到找到第一个出现次数为 1 的元素，然后将该元素输出。add 的时候，将该元素在哈希表中的对应次数加 1，并检查队头元素是否为该元素，如果是， 则将该元素出队即可。</description></item><item><title>1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit</title><link>https://example.com/docs/algs/leetcode/1438_longest_continuous_subarray_with_absolute_diff_less_than_or_equal_to_limit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1438_longest_continuous_subarray_with_absolute_diff_less_than_or_equal_to_limit/</guid><description>Description # Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit.
Solutions # TODO</description></item><item><title>1461. Check If a String Contains All Binary Codes of Size K</title><link>https://example.com/docs/algs/leetcode/1461_check_if_a_string_contains_all_binary_codes_of_size_k/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1461_check_if_a_string_contains_all_binary_codes_of_size_k/</guid><description>Description # Given a binary string s and an integer k, return true if every binary code of length k is a substring of s. Otherwise, return false.
Solutions # Brute Force # 下面是题主一开始想出来的方法，可惜最后几个用例过于变态，所以超时了。
func hasAllCodes(s string, k int) bool { size := len(s) if size &amp;lt; k { return false } // golang 格式化打印字符串，%04b 这个格式化字符串能够将数字转换为二进制表示，并且当表示字符串长度小于 4 时，能够自动在前面增加 0 作为 padding。 fmtStr := &amp;#34;%0&amp;#34; + strconv.Itoa(k) + &amp;#34;b&amp;#34; maxEle := int(math.</description></item><item><title>1472. Design Browser History</title><link>https://example.com/docs/algs/leetcode/1472_design_browser_history/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1472_design_browser_history/</guid><description>Description # You have a browser of one tab where you start on the homepage and you can visit another url, get back in the history number of steps or move forward in the history number of steps.
Implement the BrowserHistory class:
BrowserHistory(string homepage) Initializes the object with the homepage of the browser. void visit(string url) Visits url from the current page. It clears up all the forward history. string back(int steps) Move steps back in history.</description></item><item><title>1480. Running Sum of 1d Array</title><link>https://example.com/docs/algs/leetcode/1480_running_sum_of_1d_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1480_running_sum_of_1d_array/</guid><description> Description # Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]).
Return the running sum of nums.
Solutions # 简单题，直接看代码就好了。
func runningSum(nums []int) []int { var res []int var pre int for _, num := range nums { pre += num res = append(res, pre) } return res }</description></item><item><title>1642. Furthest Building you Can Reach</title><link>https://example.com/docs/algs/leetcode/1642_furthest_building_you_can_reach/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1642_furthest_building_you_can_reach/</guid><description>Description # You are given an integer array heights representing the heights of buildings, some bricks, and some ladders.
You start your journey from building 0 and move to the next building by possibly using bricks or ladders.
While moving from building i to building i+1 (0-indexed),
If the current building&amp;rsquo;s height is greater than or equal to the next building&amp;rsquo;s height, you do not need a ladder or bricks.</description></item><item><title>1647. Minimum Deletions to Make Character Frequencies Unique</title><link>https://example.com/docs/algs/leetcode/1647_minimum_deletions_to_make_character_frequencies_unique/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1647_minimum_deletions_to_make_character_frequencies_unique/</guid><description>Description # A string s is called good if there are no two different characters in s that have the same frequency.
Given a string s, return the minimum number of characters you need to delete to make s good.
The frequency of a character in a string is the number of times it appears in the string. For example, in the string &amp;ldquo;aab&amp;rdquo;, the frequency of &amp;lsquo;a&amp;rsquo; is 2, while the frequency of &amp;lsquo;b&amp;rsquo; is 1.</description></item><item><title>1658. Minimum Operations to Reduce X to Zero</title><link>https://example.com/docs/algs/leetcode/1658_minimum_operations_to_reduce_x_to_zero/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1658_minimum_operations_to_reduce_x_to_zero/</guid><description>Description # You are given an integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x. Note that this modifies the array for future operations.
Return the minimum number of operations to reduce x to exactly 0 if it is possible, otherwise, return -1.
Solutions # Backtrace # 这是题主一开始想出来的解法，直接暴力回溯，但是超时了。仔细分析一下，发现时间复杂度确很高得离谱&amp;hellip;</description></item><item><title>1689. Partitioning Into Minimum Number of Deci-Binary Numbers</title><link>https://example.com/docs/algs/leetcode/1689_partitioning_into_minimum_number_of_deci-binary_numbers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1689_partitioning_into_minimum_number_of_deci-binary_numbers/</guid><description>Description # A decimal number is called deci-binary if each of its digits is either 0 or 1 without any leading zeros. For example, 101 and 1100 are deci-binary, while 112 and 3001 are not.
Given a string n that represents a positive decimal integer, return the minimum number of positive deci-binary numbers needed so that they sum up to n.
Solutions # 这题题主以为是要用动态规划之类的解法来做，结果想了好一会都没想出来，然后到网上去搜大神们答案，于是搜到了 这个。看完答案，我只想说，人和人真的，天壤之别&amp;hellip;
这里的解法浓缩成一句话就是：答案就是 n 这个字符串中最大的数字（指 0-9 之间）。翻译一下大佬的证明就是：</description></item><item><title>1695. Maximum Erasure Value</title><link>https://example.com/docs/algs/leetcode/1695_maximum_erasure_value/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1695_maximum_erasure_value/</guid><description>Description # You are given an array of positive integers nums and want to erase a subarray containing unique elements. The score you get by erasing the subarray is equal to the sum of its elements.
Return the maximum score you can get by erasing exactly one subarray.
An array b is called to be a subarray of a if it forms a contiguous subsequence of a, that is, if it is equal to a[l],a[l+1],&amp;hellip;,a[r] for some (l,r).</description></item><item><title>Blind 75 List</title><link>https://example.com/docs/algs/leetcode/Blind-75-list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/Blind-75-list/</guid><description>Blind 75 # Sequence # Two Sum
使用一个 map 记录元素值与元素下标的映射，只需要一次扫描数组，检查 target - value 是否在 map 中，同时将 value 和其下标放到 map 中 。
Best Time to Buy and Sell Stock
使用一个值记录当前扫描到的最小值，然后扫描一次数组，每扫描到一个值，用当前值减去当前得到的最小值，然后得到结果，取结果的最大值。如果当前值小于最小值，则更新最小值为当前值。只需要一次扫描。
Contains Duplicate
简单题，只需要一个 map 就可以了，扫描一次即可。
Product of Array Except Self 创建两个数组left 和 right，数组 left[i] 表示 i 位置前的元素的累积，数组 right[i]表示 i 位置后的元素的累积。然后创建一个数组 res， res[i] = left[i] * right[i]。
Maximum Subarray
Kadane 算法，最优子结构性质，当前位置的和取决于前一个位置的子数组和以及当前元素。
def max_subarray(arr): max_sum_so_far, sum_ending_here = arr[0], arr[0] for e in range(arr[1:]): sum_ending_here = max(e, sum_ending_here + e) max_sum_so_far = max(max_sum_so_far, sum_ending_here) return max_sum_so_far 如果数组中有负数，并且允许返回长度为 0 的子数列，则该问题可以改为：</description></item><item><title>Top Interview Questions</title><link>https://example.com/docs/algs/leetcode/Top-Leetcode-Interview-Questions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/Top-Leetcode-Interview-Questions/</guid><description>Two Sum 简单题，可跳过。
Add Two Numbers 不难，注意 dummyHead 的使用
Longest Substring Without Repeating Character 滑动窗口，不难。
Median of Two Sorted Arrays TODO 难题， 暂时跳过
Longest Palindromic Substring 不难
Reverse Integer NOTE 注意这里对溢出的处理技巧，以及对负数的处理
String to Integer(atoi) 不难，只是繁琐
Regular Expression Matching TODO 暂时跳过
Container With Most Water 不难，但是要注意一题多解
Roman to Integer 不难
Longest Common Prefix 不难
3Sum TODO 注意如何做优化，这里的优化技巧很值得学习学习
Letter Combinations of a Phone Number 简单题，不难
Remove Nth Node From End of List 不难</description></item><item><title/><link>https://example.com/docs/algs/leetcode/14-patterns-to-ace-any-coding-interview-questions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/14-patterns-to-ace-any-coding-interview-questions/</guid><description>关于算法笔试的常见的十四中模式。
1. 滑动窗口 # 特征 # 问题输入是线性的数据结构 目的是找出最长/短子字符串、子数组或者指定期望值 2. 双指针 # 特征 # 对有序序列或者链表进行操作，目的是找到满足特定条件的一串元素 目标是一对元素或者三个元素，甚至是一个子数组 3. 快慢指针 # 特征 # 问题是处理链表或者数组中的循环 当你需要知道某个元素在整个链表中的位置 4. 区间合并 # 区间合并的几种情况： 。
特征 # 对互斥区间生成一个链表 出现关键词“overlaping intervals” 5. 循环排序(cyclic sort) # 6. 链表就地翻转 # 7. 树的深度优先遍历 # 8. 树的广度优先遍历 # 9. 双堆 # 10. 子集 # 11. 改动的二分搜索 # 12. Top K 个元素 # 一般可以用最大/小堆来解决
13. K 路合并 # 可以使用最大/小堆来实现
14. 拓扑排序 # Refs # 14 Patterns to Ace Any Coding Interview Questions Blind 75 # Sequence # Two Sum</description></item><item><title/><link>https://example.com/docs/algs/leetcode/692_top_k_frequent_words/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/692_top_k_frequent_words/</guid><description>Description # Given an array of strings words and an integer k, return the k most frequent strings.
Return the answer sorted by the frequency from highest to lowest. Sort the words with the same frequency by their lexicographical order.
Solutions # Hash Table &amp;amp; Sort # 首先还是创建一个 dict 统计一下各个单词出现的次数， 然后用单词以及该单词出现的次数组成 pair 对，把这些 pair 对组成数组中，然后根据每个单词的出现频率对这个数组进行排序，如果单词频率相同，则根据单词的字母顺序进行排序。最后放回前 k 个即可。
func topKFrequent(words []string, k int) []string { dict := make(map[string]int) for _, word := range words { dict[word]++ } type Pair struct { str string cnt int } var pairs []Pair for word, cnt := range dict { pairs = append(pairs, Pair{word, cnt}) } sort.</description></item></channel></rss>