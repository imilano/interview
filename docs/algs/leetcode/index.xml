<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Interview</title><link>https://example.com/docs/algs/leetcode/</link><description>Recent content on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/docs/algs/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>10. First Missing Positive</title><link>https://example.com/docs/algs/leetcode/41_first_msssing_positive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/41_first_msssing_positive/</guid><description>Description # Given an unsorted integer array nums, return the smallest missing positive integer.
You must implement an algorithm that runs in O(n) time and uses constant extra space.
Solutions # Hash Table # 可以使用一个 hash table 记录所以出现的值，然后找出当前值中的最大值。然后从 1 到最大值开始遍历，如果出现一个不在 hash table 中的数，则将该数返回即可。如果所有数都出现在了 hash table 中，那么返回最大值加 1 即可。但是最后这里需要注意的是，有可能整个数组都是负数，这样的话会导致前面的判断失效，所以返回值应该最小要返回 1.
func firstMissingPositive(nums []int) int { dict := make(map[int]bool) curMax := nums[0] for _, num := range nums { dict[num] = true if num &amp;gt; curMax { curMax = num } } for i := 1; i &amp;lt;= curMax; i++ { if _, ok := dict[i]; !</description></item><item><title>21. Merge Two Sorted List</title><link>https://example.com/docs/algs/leetcode/21_merge_two_sorted_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/21_merge_two_sorted_list/</guid><description>Description # You are given the heads of two sorted linked lists list1 and list2.
Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.
Return the head of the merged linked list.
Solutions # Merge Sort # func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode { res := new(ListNode) node := res dummyHead1, dummyHead2 := list1, list2 for dummyHead1 !</description></item><item><title>22. Generate Parentheses</title><link>https://example.com/docs/algs/leetcode/22_generate_parentheses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/22_generate_parentheses/</guid><description>Description # Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
Solutions # Recursive # 参见： https://leetcode-cn.com/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/
使用两个变量 left 和 right 来表示「左括号使用了集合」和「右括号使用了几个」，通过分析可以得到以下结论： - 只有当left 和 right 都比 n 小的时候，才产生分支。 - 产生左分支的时候，只看当前还有左括号可用 - 产生右分支的时候，还受到左括号数量的限制，left 要大于 right 的时候，才可以产生分支。否则就是无效分支，可以直接返回。 - 在左边和右边的括号数都等于 n 的时候结算。
func generateParenthesis(n int) []string { var res []string if n == 0 { return res } generateParenthesisHelper(n, 0,0,&amp;#34;&amp;#34;, &amp;amp;res) return res } func generateParenthesisHelper(n, left, right int, cur string, res *[]string) { if left == n &amp;amp;&amp;amp; right == n { *res = append(*res, cur) return } // 剪枝 if left &amp;lt; right { return } if left &amp;lt; n { generateParenthesisHelper(n, left+1, right, cur + &amp;#34;(&amp;#34;, res) } if right &amp;lt; n { generateParenthesisHelper(n, left, right+1, cur + &amp;#34;)&amp;#34;, res) } }</description></item><item><title>23. Merge K Sorted List</title><link>https://example.com/docs/algs/leetcode/23_merge_k_sorted_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/23_merge_k_sorted_list/</guid><description>Description # You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.
Merge all the linked-lists into one sorted linked-list and return it.
Solutions # Min Heap # 很简单的想法，使用最小堆即可。
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeKLists(lists []*ListNode) *ListNode { return mergeKListsSolution1(lists) } // 使用最小堆，将所有的节点数据都插入到最小堆中，然后再把所有元素从最小堆中弹出 func mergeKListsSolution1(lists []*ListNode) *ListNode { var minHeap MinHeapArr heap.</description></item><item><title>26. remove duplicated from sorted array</title><link>https://example.com/docs/algs/leetcode/26_remove_duplicates_from_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/26_remove_duplicates_from_sorted_array/</guid><description>Description # Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.
Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result.</description></item><item><title>28. Implement strStr</title><link>https://example.com/docs/algs/leetcode/28_implement_strStr/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/28_implement_strStr/</guid><description>Description # Implement strStr().
Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Solutions # 太简单了在，直接看代码即可。
func strStr(haystack string, needle string) int { var pos int size := len(haystack) targetSize := len(needle) if size == 0 || targetSize == 0 { return pos } var start int pos = -1 for start &amp;lt; size { if haystack[start] !</description></item><item><title>29. Divide Two Integers</title><link>https://example.com/docs/algs/leetcode/29_divide_two_integers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/29_divide_two_integers/</guid><description>Description # Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.
The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.
Return the quotient after dividing dividend by divisor.
Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1].</description></item><item><title>33. Search in Rotated Sorted Array</title><link>https://example.com/docs/algs/leetcode/33_search_in_rotated_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/33_search_in_rotated_array/</guid><description>Description # There is an integer array nums sorted in ascending order (with distinct values).
Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], &amp;hellip;, nums[n-1], nums[0], nums[1], &amp;hellip;, nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].
Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.</description></item><item><title>34. Find First and Last Position of Element in Sorted Array</title><link>https://example.com/docs/algs/leetcode/34_find_first_and_last_position_of_element_in_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/34_find_first_and_last_position_of_element_in_sorted_array/</guid><description>Description # Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.
If target is not found in the array, return [-1, -1].
You must write an algorithm with O(log n) runtime complexity.
Solutions # Binary Search # 二分查找再加上中间扩散，很容易想出来。
func searchRange(nums []int, target int) []int { res := []int{-1, -1} size := len(nums) if size == 0 { return res } left, right := 0, size -1 for left &amp;lt;= right { mid := (left+right)/2 if nums[mid] == target { l,r := mid, mid res[0] = l res[1] = r for l &amp;gt;= 0 &amp;amp;&amp;amp; nums[l] == target { res[0] = l l-- } for r &amp;lt; size &amp;amp;&amp;amp; nums[r] == target { res[1] = r r++ } break } else if nums[mid] &amp;gt; target { right = mid -1 } else if nums[mid] &amp;lt; target { left = mid + 1 } } return res }</description></item><item><title>36. Valid Sudoku</title><link>https://example.com/docs/algs/leetcode/36_valid_sudoku/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/36_valid_sudoku/</guid><description>Description # Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Solutions # 一个是要注意如何快速创建三维数组，另一个是要注意如何进行坐标转换。</description></item><item><title>38. Count and Say</title><link>https://example.com/docs/algs/leetcode/38_count_and_say/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/38_count_and_say/</guid><description>Descrition # The count-and-say sequence is a sequence of digit strings defined by the recursive formula:
countAndSay(1) = &amp;ldquo;1&amp;rdquo; countAndSay(n) is the way you would &amp;ldquo;say&amp;rdquo; the digit string from countAndSay(n-1), which is then converted into a different digit string. To determine how you &amp;ldquo;say&amp;rdquo; a digit string, split it into the minimal number of groups so that each group is a contiguous section all of the same character.</description></item><item><title>42. Traping Rain Water</title><link>https://example.com/docs/algs/leetcode/04_traping_rain_water/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/04_traping_rain_water/</guid><description>Description # Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.
detail see: https://leetcode.com/problems/trapping-rain-water/
Solutions # Array # 使用两个数组扫描两趟，第一个数组 fromLeft 从左到右扫描，记录到目前为止遇到的最大值，第二个数组fromRight 从右向左扫描，记录当前为止遇到的最大值。最后扫描一下这两个数组，对于每个位置 i，取 fromLeft 和 fromRight 二者中的较小者与当前 height[i] 的差值作为当前格子所能盛水量。
func trap(nums []int) int { var res int size := len(nums) if size &amp;lt;= 1 { return res } curMax := nums[0] fromLeft := make([]int, size) for idx, num := range nums { curMax = max(num, curMax) fromLeft[idx] = curMax } curMax = nums[size-1] fromRight := make([]int, size) for i := size-1; i &amp;gt;= 0; i-- { curMax = max(nums[i], curMax) fromRight[i] = curMax } for i := 0; i &amp;lt; size; i++ { res += min(fromLeft[i], fromRight[i]) - nums[i] } return res } func min(a,b int) int { if a &amp;lt; b { return a } return b } func max(a,b int) int { if a &amp;lt; b { return b } return a } 还有一种解法，就是先找出整个数组的最大值，这个最大值将整个数组切分为两部分，然后分别处理左半边和右半边。处理单边的时候，记录自己当前遇到的历史最大值，如果当前值比历史最大值要大，则更新历史最大值为当前值；否则的话说明历史最大值比当前值要大，那么当前值是可以盛水的，则更新结果盛水量。为什么只需要记录当前历史最大值就可以了呢，毕竟能不能盛水其实要靠两边而不是一边啊？答案是我我们已经找出了整个数组的最大值，那么当前的历史最大值只会比整个数组的最大值要小，能盛多少水完全取决于较短的一方（参考短板理论），所以只需要维持一个最大值即可。</description></item><item><title>84. Largest Rectangle in Histogram</title><link>https://example.com/docs/algs/leetcode/84_largest_rectangle_in_histogram/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/84_largest_rectangle_in_histogram/</guid><description>Description # Given an array of integers heights representing the histogram&amp;rsquo;s bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.
Solutions # 寻找每一个局部峰值 i (heights[i] &amp;gt; heights[i+1])，然后从这个局部峰值 i 开始向前遍历所有的值，算出共同的矩形面积，每次对比保留最大值。 很不幸，超时了 :)
func largestRectangleArea(heights []int) int { var res int size := len(heights) if size == 0 { return res } for i := 0; i &amp;lt; size; i++ { if i+1 &amp;lt; size &amp;amp;&amp;amp; heights[i] &amp;lt;= heights[i+1] { continue } curMin := heights[i] for j := i; j &amp;gt;= 0; j-- { if heights[j] &amp;lt; curMin { curMin = heights[j] } res = max(res, curMin * (i-j+1)) } } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a }</description></item></channel></rss>