[{"id":0,"href":"/docs/algs/","title":"Algorithms","section":"Docs","content":"This is where I document some problems that I solved.\n"},{"id":1,"href":"/docs/algs/codingInterviews/","title":"Coding Interviews","section":"Algorithms","content":"这里是一些《剑指 Offer》的刷题题解。\n链表 #   反转链表\nTODO recheck 注意这里递归方法的反转思路。\n  两个链表的第一个公共节点\n  TODO recheck\n注意条件  链表中环的入口节点  TODO recheck\n首先需要注意如何进行环检测，如何判断环终止。其次需要注意的是，如何找到环中的入口节点。\n 复杂链表的复制\n链表的复制和图的复制都可以考虑 map。\n  删除链表中的重复节点\n这里一个非常需要注意的点就是，如果头结点也要被删除的话怎么办？如果头结点的也要被删除的话，那么判断条件就会变得比较复杂，这里的一个解决办法就是，增加一个虚拟的头结点，然后让这个虚拟的头结点指向真正的头结点，遍历的时候就从这个虚拟的头结点开始遍历，这样就能够应付真实头结点也要被删除的情况。 TODO rechck 增加虚拟头结点的技巧\n  从尾到头打印链表 简单题\n  合并两个排序的链表 简单题\n  链表中倒数最后 k 个节点 简单题\n  删除链表汇中重复的节点 TODO recheck\n  删除链表的节点 简单，注意虚拟头结点的使用\n  树 #   二叉树的深度 简单题\n  按之字形顺序打印二叉树 简单题\n  二叉搜索树的第 k 个节点 简单题\n  重建二叉树 TODO recheck\n  树的子结构 简单题\n  二叉树的镜像 简单题\n  从上往下打印二叉树 简单题\n  二叉搜索树的后序遍历序列 注意 corner case\n  二叉树和为某一值的路径 TODO 注意叶子节点的判断方式\n  二叉树中和为某一值的路径 II TODO 注意叶子节点的判断方式\n  二叉搜索树与双向链表 TODO recheck 这个题需要注意，尤其是怎么确定 head 节点，以及 pre 节点的选择，还有就是怎么将 pre 节点和当前节点做连接。题目本身其实并不算难，就是中序遍历，但是问题就是一些边界条件的考量，在这里尤其需要注意。\n  判断是不是平衡二叉树 TODO recheck 这里虽然是个简单题，但是还是要注意一些，要快速做出来。\n  二叉树的下一个节点 TODO recheck 这里需要好好注意一下问题是怎么分析的。\n  对称的二叉树 简单题\n  把二叉树打印成多行 简单题，其实就是一个二叉树的层次遍历。\n  序列化二叉树 TODO recheck 这个题需要重做\n  二叉树中和为某一值的路径 TODO recheck 这个题也很需要注意。首先需要注意如何将每个节点都视为根节点的操作方式，其次要注意结果的判断方式。\n  二叉树中两个节点的最近公共祖先 TODO recheck\n这题需要再做一次。\n  二叉搜索树的最近公共祖先 简单题。\n  "},{"id":2,"href":"/docs/algs/leetcode/","title":"Leetcode","section":"Algorithms","content":"这里是一些 LeetCode 的刷题题解。\n"},{"id":3,"href":"/docs/algs/codingInterviews/28_%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"28. 对称的二叉树","section":"Coding Interviews","content":"Description #   给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）\n Solutions #  Recursive #  func isSymmetrical( pRoot *TreeNode ) bool {  // write code here  if pRoot == nil {  return true  }   return isSameTree(pRoot.Left, pRoot.Right) }  func isSameTree(root1, root2 *TreeNode) bool {  if root1 == nil \u0026amp;\u0026amp; root2 == nil {  return true  }   if root1 == nil || root2 == nil {  return false  }   if root1.Val != root2.Val {  return false  }   return isSameTree(root1.Left, root2.Right) \u0026amp;\u0026amp; isSameTree(root1.Right, root2.Left) } "},{"id":4,"href":"/docs/algs/codingInterviews/37_%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"37. 序列化二叉树","section":"Coding Interviews","content":"Description #   请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树。\n二叉树的序列化(Serialize)是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树等遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#）\n二叉树的反序列化(Deserialize)是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。\n Solutions #  PreOrder Traversal #  采用先序遍历的方式进行序列化，同样采用先序遍历的方式进行反序列化。\nvar emptyNode string = \u0026#34;#\u0026#34; var seperator string = \u0026#34; \u0026#34; func Serialize( root *TreeNode ) string {  // write code here  if root == nil {  return \u0026#34;\u0026#34;  }   var res []string  _serialize(root, \u0026amp;res)  return strings.Join(res, seperator) }  func _serialize(root *TreeNode, res *[]string) {  if root != nil {  v := strconv.Itoa(root.Val)  *res = append(*res, v)   _serialize(root.Left, res)  _serialize(root.Right, res)  } else { \t// 递归是收敛的  *res = append(*res, emptyNode)  } }  func Deserialize( s string ) *TreeNode {  // write code here  if len(s) == 0 {  return nil  }   values := strings.Split(s, seperator)  return _deserialize(\u0026amp;values) }  func _deserialize(values *[]string) *TreeNode { \t// 注意这里，为什么这里不会出现数组越界访问呢，也就是说，你是如何保证数组里一定会有元素的呢？ \t// 其实在序列化的时候，对于每一条路径，我们最后会走到的节点不是叶子节点，而是该叶子节点的两个空子节点。 \t// 那么也就是说，序列化后的字符的最后一个字符一定是 \u0026#34;#\u0026#34; 符号，代表走到空节点，那么一定也会在下面的第一个 if 后即递归终止，那么肯定就不会出现数组越界访问的情况。  s := (*values)[0]  *values = (*values)[1:]  \t// 递归是收敛的  if s == emptyNode {  return nil  }   v, _ := strconv.Atoi(s)  root := new(TreeNode)  root.Val = v  root.Left = _deserialize(values)  root.Right = _deserialize(values)  return root } Level Order Traversal #  基于层次遍历的思想，但是需要将序列化的顺序和反序列化的顺序一一对应起来。序列化时，如果该节点非空，则将节点值序列化，然后将其左右子节点入队，如果节点为空，则用特定的字符来代替。反序列化时，也是使用层次遍历的方式，先是使用一个节点作为根节点，然后将其入队，然后不断从队列中取出节点来更新其子节点。从字符串中取值的时候，如果当前取到的值代表是一个空节点，则可以直接跳过。\n注意领会，这里序列化和反序列的顺序其实是一一对应的。\nfunc Serialize( root *TreeNode ) string {  // write code here  if root == nil {  return \u0026#34;\u0026#34;  }   var res []string  emptyNode := \u0026#34;#\u0026#34;  seperator := \u0026#34; \u0026#34;    var queue []*TreeNode  queue = append(queue, root)  for len(queue) != 0 {  size := len(queue)  for i := 0; i \u0026lt; size; i++ {  node := queue[i]  if node != nil {  s := strconv.Itoa(node.Val)  res = append(res, s)  queue = append(queue, node.Left)  queue = append(queue, node.Right)  } else {  res = append(res, emptyNode)  }  }   queue = queue[size:]  }   return strings.Join(res, seperator) }  func Deserialize( s string ) *TreeNode {  // write code here  if len(s) == 0 {  return nil  }  seperator := \u0026#34; \u0026#34;  emptyNode := \u0026#34;#\u0026#34;  nodes := strings.Split(s, seperator)   root := new(TreeNode)  root.Val,_ = strconv.Atoi(nodes[0])  nodes = nodes[1:]   var queue []*TreeNode  queue = append(queue, root)  for len(queue) != 0 {  size := len(queue)  for i := 0; i \u0026lt; size; i++ {  node := queue[i]  val := nodes[0]  nodes = nodes[1:]  if val != emptyNode {  v,_ := strconv.Atoi(val)  tmp := new(TreeNode)  tmp.Val = v  node.Left = tmp  queue = append(queue, tmp)  }   val = nodes[0]  nodes = nodes[1:]  if val != emptyNode {  v,_ := strconv.Atoi(val)  tmp := new(TreeNode)  tmp.Val = v  node.Right = tmp  queue = append(queue, tmp)  }  }   queue = queue[size:]  }   return root } "},{"id":5,"href":"/docs/algs/codingInterviews/78_%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/","title":"78. 把二叉树打印成多行","section":"Coding Interviews","content":"Description #   给定一个节点数为 n 二叉树，要求从上到下按层打印二叉树的 val 值，同一层结点从左至右输出，每一层输出一行，将输出的结果存放到一个二维数组中返回。\n Solutions #  Level Order Traversal #  简单题，只需要进行一次层次遍历即可。\nfunc Print( pRoot *TreeNode ) [][]int {  // write code here  var res [][]int  if pRoot == nil {  return res  }   var queue []*TreeNode  queue = append(queue, pRoot)   for len(queue) != 0 {  size := len(queue)  var level []int  for i := 0; i \u0026lt; size; i++ {  node := queue[i]  level = append(level, node.Val)  if node.Left != nil {  queue = append(queue, node.Left)  }  if node.Right != nil {  queue = append(queue, node.Right)  }  }   res = append(res, level)  queue = queue[size:]  }   return res } "},{"id":6,"href":"/docs/algs/codingInterviews/84_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84III/","title":"84. 二叉树中和为某一值的路径 III","section":"Coding Interviews","content":"Description #   给定一个二叉树root和一个整数值 sum ，求该树有多少路径的的节点值之和等于 sum 。 1.该题路径定义不需要从根节点开始，也不需要在叶子节点结束，但是一定是从父亲节点往下到孩子节点 2.总节点数目为n 3.保证最后返回的路径个数在整形范围内(即路径个数小于$2^{31}$-1)\n Solutions #  注意，这里的路径不一定需要从根节点开始，也不一定需要在叶节点结束。\nRecursice #  核心思想就是，每个节点都可能是一条路径的起始节点，所以每个节点都需要作为根节点来遍历一次。\nvar res int func FindPath( root *TreeNode , sum int ) int {  // write code here  if root == nil {  return res  }   findPathHelper(root, sum)  \t// 每个节点都需要作为根节点来进行一次查找  FindPath(root.Left, sum)  FindPath(root.Right, sum)  return res }  func findPathHelper(root *TreeNode, sum int) {  if root == nil {  return  }  // 注意这里的小技巧  if sum == root.Val {  res++  }   findPathHelper(root.Left, sum - root.Val)  findPathHelper(root.Right, sum - root.Val) } "},{"id":7,"href":"/docs/algs/codingInterviews/86_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","title":"86. 二叉树中两个节点的最近公共祖先","section":"Coding Interviews","content":"Description #   给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。\n数据范围：树上节点数满足$1 \\le n \\le 10^5$, 节点值val满足区间 [0,n) 要求：时间复杂度 $\\Omicron(n)$\n Solutions #  Recursive #  具体解释看注释即可。\nfunc lowestCommonAncestor( root *TreeNode , o1 int , o2 int ) int {  // write code here  if root == nil {  return -1  }   res := lcaHelper(root, o1, o2)  return res.Val }  func lcaHelper(root *TreeNode, o1, o2 int) *TreeNode {  // 如果已经遍历到空节点或者已经找到其中一个节点，则返回该节点  if root == nil || root.Val == o1 || root.Val == o2 {  return root  }   // 分别查找左子树和右子树  left := lcaHelper(root.Left, o1, o2)  right := lcaHelper(root.Right, o1, o2)   // 如果left 为空，说明这两个节点在 root 的右子树上，则返回右子树查找结果  if left == nil {  return right  }  // 如果 right 为空，说明这两个节点在 root 的左子树上，则返回左子树查找结果  if right == nil {  return left  }   // 如果 left 和 right 都不为空，则说明这两个节点一个在 root 的左子树上，一个在 root 的右子树上，则返回 root 即可  return root } "},{"id":8,"href":"/docs/algs/codingInterviews/68_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","title":"68 二叉搜索树的最近公共祖先","section":"Coding Interviews","content":"Description #   给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n Solutions #  Recursive #  如果当前节点的值比要查找的值的最小值还要小，说明应该往当前节点的右节点进行查找；如果当前节点的值比要查找的值的最大值还要大，说明应该往当前节点的左子树进行查找。否则说明当前节点处于要查找的值之间，那么当前节点就是我们要查找的最近公共祖先。\nfunc lowestCommonAncestor( root *TreeNode , p int , q int ) int {  // write code here  if root == nil {  return -1  }   // 保持 p 比 q 要小  if p \u0026gt; q {  p,q = q, p  }   res := lcaHelper(root, p, q)  return res.Val }  func lcaHelper(root *TreeNode, mn,mx int) *TreeNode {  if root.Val \u0026gt; mx {  return lcaHelper(root.Left, mn, mx)  } else if root.Val \u0026lt; mn {  return lcaHelper(root.Right, mn, mx)  } else {  return root  } } "}]