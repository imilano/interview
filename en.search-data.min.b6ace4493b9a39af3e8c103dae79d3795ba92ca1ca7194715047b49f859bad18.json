[{"id":0,"href":"/docs/algs/","title":"Algorithms","section":"Docs","content":"This is where I document some problems that I solved.\n"},{"id":1,"href":"/docs/algs/codingInterviews/","title":"Coding Interviews","section":"Algorithms","content":"这里是一些《剑指 Offer》的刷题题解。\n数据结构 #  链表 #   反转链表\nTODO recheck 注意这里递归方法的反转思路。\n  两个链表的第一个公共节点\n  TODO recheck\n注意条件  链表中环的入口节点  TODO recheck\n首先需要注意如何进行环检测，如何判断环终止。其次需要注意的是，如何找到环中的入口节点。\n 复杂链表的复制\n链表的复制和图的复制都可以考虑 map。\n  删除链表中的重复节点\n这里一个非常需要注意的点就是，如果头结点也要被删除的话怎么办？如果头结点的也要被删除的话，那么判断条件就会变得比较复杂，这里的一个解决办法就是，增加一个虚拟的头结点，然后让这个虚拟的头结点指向真正的头结点，遍历的时候就从这个虚拟的头结点开始遍历，这样就能够应付真实头结点也要被删除的情况。 TODO rechck 增加虚拟头结点的技巧\n  从尾到头打印链表 简单题\n  合并两个排序的链表 简单题\n  链表中倒数最后 k 个节点 简单题\n  删除链表汇中重复的节点 TODO recheck\n  删除链表的节点 简单，注意虚拟头结点的使用\n  树 #   二叉树的深度 简单题\n  按之字形顺序打印二叉树 简单题\n  二叉搜索树的第 k 个节点 简单题\n  重建二叉树 TODO recheck\n  树的子结构 简单题\n  二叉树的镜像 简单题\n  从上往下打印二叉树 简单题\n  二叉搜索树的后序遍历序列 注意 corner case\n  二叉树和为某一值的路径 TODO 注意叶子节点的判断方式\n  二叉树中和为某一值的路径 II TODO 注意叶子节点的判断方式\n  二叉搜索树与双向链表 TODO recheck 这个题需要注意，尤其是怎么确定 head 节点，以及 pre 节点的选择，还有就是怎么将 pre 节点和当前节点做连接。题目本身其实并不算难，就是中序遍历，但是问题就是一些边界条件的考量，在这里尤其需要注意。\n  判断是不是平衡二叉树 TODO recheck 这里虽然是个简单题，但是还是要注意一些，要快速做出来。\n  二叉树的下一个节点 TODO recheck 这里需要好好注意一下问题是怎么分析的。\n  对称的二叉树 简单题\n  把二叉树打印成多行 简单题，其实就是一个二叉树的层次遍历。\n  序列化二叉树 TODO recheck 这个题需要重做\n  二叉树中和为某一值的路径 TODO recheck 这个题也很需要注意。首先需要注意如何将每个节点都视为根节点的操作方式，其次要注意结果的判断方式。\n  二叉树中两个节点的最近公共祖先 TODO recheck\n这题需要再做一次。\n  二叉搜索树的最近公共祖先 简单题。\n  队列 \u0026amp; 栈 #   双栈实现队列 简单题\n  包含 Min 函数的栈 TODO recheck 这个题涉及到单调栈，需要多多注意。\n  栈的压入弹出序列。 简单题，只需要使用一个栈进行模拟即可。\n  翻转单词序列 思路比较巧妙。\n  滑动窗口的最大值 单调队列 TODO\n  算法 #  搜索算法 #     题目 难度 技巧 特别关注     53. 数字在升序数组中出现的次数 简单 二分查找、中心扩散 No   4. 二维数组中的查找 简单 剪枝 YES   11. 旋转数组中的最小数字 简单 二分 YES   38. 字符串的排列 中等 回溯 YES    动态规划 #     题目 难度 技巧 特别关注 注释     42. 连续子数组的最大值 简单 动态规划 YES Kadane 方法   85. 连续子数组的最大值II middle 动态规划 YES Kadane 方法   69. 跳台阶 简单 动态规划 YES 经典问题   10. 斐波那契数列 简单 动态规划 No 经典问题   19. 正则表达式匹配 难 动态规划 YES 暂时跳过   71. 跳台阶扩展问题 简单 动态规划 YES 其实也是一道找规律题   70. 矩形覆盖 中等 动态规划 YES 实际上是数学归纳法再加上找规律   63. 买卖股票的最好时机 简单 动态规划 YES    47. 礼物的最大价值 中等 动态规划 YES 注意几个技巧：复用原数组、开辟一个(m+1)*(n+1)的数组可以简化运算   48. 最长不含重复字符的子字符串 滑动窗口 YES 注意这里的滑动窗口解法以及涉及到的几个 corner case    46. 把数字翻译成字符串 中等 动态规划、递归 YES     回溯 #     题目 难度 技巧 特别关注 备注     12. 矩阵中的路径 中等 回溯 YES 注意这个技巧：直接使用原数组来标记特定点是否访问过，而不用再新开数组   13. 机器人的运动范围 难 回溯 YES     排序 #     题目 难度 技巧 特别关注 备注     3. 数组中重复的数字 简单 哈希表 No    51. 数组中的逆序对 中等 归并排序 YES 这里借助了归并排序的思想，核心是：两个无序或有序的区间的逆序对数是一致的，但是有序区间更贱方便计算。   40. 最小的 k 个数 中等 堆、快排 No    41. 数据流中的中位数 难 堆 YES 注意这里如果维持两个堆的元素数量，以让左边大根堆的元素数量至多比右边小根堆多 1    位运算 #     题目 难度 技巧 特别关注 备注     65. 不用加减乘除做加法 简单 位运算 YES 注意这里的位运算技巧   15. 二进制中 1 的个数 简单 位运算 No    16. 数值的整数次方 中等 递归 No    56. 数组中只出现一次的两个数字 中等 哈希表、位运算 YES 这里的分析很有意思，注意这个分组技巧    模拟 #     题目 难度 技巧 特别关注 备注     29. 顺时针打印矩阵 简单  YES 注意这里是如何判断重叠的   61. 扑克牌顺子 简单 数组 No    67. 把字符串转换成整数 中等 字符串 No 稍微有些繁杂，先跳过   20. 表示数值的字符串 难 字符串 No 稍微有些繁杂，先跳过    其他算法 #     题目 难度 技巧 特别关注 备注     66. 构建乘积数组 简单 数组 No    50. 第一个只出现一次的字符 简单 哈希表 No    5. 替换空格 简单 字符串 No    21. 调整数组顺序使奇数位于偶数前面 中等 Array No    39. 数组中出现次数超过一半的数字 简单  No    43. 整数中 1 出现的次数 中等 数学 Yes 繁杂，暂时先跳过   45. 把数组排成最小的数 中等 排序，字符串 YES 这里的排序思路很值得注意   49. 丑数 中等 三指针 YES 这里的三指针思想很值得注意   74. 和为 S 的连续整数序列 中等  YES    17. 打印从 1 到最大的 n 位数 简单  No    81. 调整数组顺序使奇数位于偶数前面 简单  No    57. 和为 S 的两个数字 简单 双指针 No    74. 和为 S 的连续正数序列 中等 滑动窗口、双指针 YES 注意这里的起始条件以及滑动技巧   58. 左旋转字符串 中等 字符串，多次翻转 YES 多注意字符串多次翻转的技巧   75. 字符流中第一个不重复的字符 中等 字符串、队列 YES 注意这里队列的使用   14. 剪绳子 中等 剪枝、DP YES 注意这里递归的使用以及 DP 的思想    "},{"id":2,"href":"/docs/algs/leetcode/","title":"Leetcode","section":"Algorithms","content":"这里是一些 LeetCode 的刷题题解。\nData structure #  String #     Problem Difficulty Method Redo     28. Implement strStr easy None No   44. Wildcard Matching hard Recusive No    Array #     Problem Difficulty Method Redo Comment     36. Valid Sudoku middle None YES 注意这里如何创建三维数组，以及坐标的转换   41. First Missing Positive Hard HashTable, Array YES 注意 while 循环是如何交换元素的，以及 while 循环为什么不能用 if 语句代替    Search #  Bianry Search #     Problem Difficulty Method Redo     33. Search in Rotated Sorted Array middle binary search YES   34. Find First and Last Position of Element in Sorted Array middle binary search No       Problem Difficulty Method Redo     21. Merge Two Sorted List middle Merge Sort No   22. Generate Parentheses middle Prune, Recursive YES   26. Remove Duplicates from Sorted Array easy  No    Math #  Bit Manipulation #     Problem Difficulty Method Redo     29. Divide Two Integers middle Bit manipulation YES    Dynamic Programming #     Problem Difficulty Method Redo Comment     42. Traping Rain Water middle DP, Stack YES     "},{"id":3,"href":"/docs/algs/others/","title":"Others","section":"Algorithms","content":"这里是一些在面试中碰到的其他的题目。\n"},{"id":4,"href":"/docs/algs/codingInterviews/03_%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E7%BB%84/","title":"03. 数组中重复的数字","section":"Coding Interviews","content":"Description #   在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组[2,3,1,0,2,5,3]，那么对应的输出是2或者3。存在不合法的输入的话输出-1\n数据范围：$0\\le n \\le 10000$ 进阶：时间复杂度$\\Omicron(n)$ ，空间复杂度$\\Omicron(n)$\n Solutions #  Hash table #  简单题，要么使用哈希表，要么就排一下序。\nfunc duplicate( numbers []int ) int {  // write code here // size := len(numbers)  dict := make(map[int]bool)  for _, value := range numbers {  if _, ok := dict[value]; ok {  return value  }   dict[value] = true  }   return -1 } "},{"id":5,"href":"/docs/algs/codingInterviews/04_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/","title":"04. 二维数组中的查找","section":"Coding Interviews","content":"Description #   在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n数据范围：矩阵的长宽满足 $0 \\le n$,$m \\le 500$ ， 矩阵中的值满足 $0 \\le val \\le 10^9$。\n进阶：空间复杂度 O(1)O(1) ，时间复杂度 O(n+m)O(n+m)\n Solutions #  从左下角开始进行遍历，因为数组维持了从左到右递增，从上到下递增的性质，那么如果当前元素比 target 要大， target 一定位于当前元素的右边；如果当前元素比 target 要小，那么 target 一定位于当前元素的上侧。\nfunc Find( target int , array [][]int ) bool {  // write code here  var res bool  m, n := len(array), len(array[0])  x, y := m-1, 0  for {  if x \u0026lt; 0 || y \u0026gt;= n {  break  }   if array[x][y] == target {  res = true  break  }   if target \u0026gt; array[x][y] {  y++  }  \t// 这里要加上一个 y \u0026lt; n, 因为上一个 if 对 y 进行了自增，导致这里的 y 不一定合法  if y \u0026lt; n \u0026amp;\u0026amp; target \u0026lt; array[x][y] {  x--  }  }   return res } "},{"id":6,"href":"/docs/algs/codingInterviews/05_%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/","title":"05. 替换空格","section":"Coding Interviews","content":"Description #   请实现一个函数，将一个字符串s中的每个空格替换成“%20”。 例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。\n数据范围:$0 \\le len(s) \\le 1000$ 。保证字符串中的字符为大写英文字母、小写英文字母和空格中的一种。\n Solutions #  func replaceSpace( s string ) string {  // write code here  var res string  size := len(s)  if size == 0 {  return res  }   for _, r := range s {  if r != \u0026#39; \u0026#39; {  res += string(r)  } else {  res += \u0026#34;%20\u0026#34;  }  }   return res } "},{"id":7,"href":"/docs/algs/codingInterviews/09_%E5%8F%8C%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/","title":"09. 双栈实现队列","section":"Coding Interviews","content":"Description #   用两个栈来实现一个队列，使用n个元素来完成 n 次在队列尾部插入整数(push)和n次在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。\n数据范围： $n \\le 1000$ 要求：存储n个元素的空间复杂度为 $\\Omicron(n)$ ，插入与删除的时间复杂度都是 $\\Omicron(1)$\n Solutions #  使用两个队列，队列1专用于push，队列用专用于pop 和 peek。push 时，入队 stack1； pop 时，如果 stack2 不为空，则弹出 stack2 栈顶即可，若 stack2 为空，则将 stack1 的所有元素压入 stack2， 然后将 stack2 的栈顶元素弹出。\ntype MyQueue struct { \tstack1 []int \tstack2 []int }  func Constructor() MyQueue {  return MyQueue{  stack1: make([]int, 0),  stack2: make([]int, 0),  } }   func (this *MyQueue) Push(x int) { \tthis.stack1 = append(this.stack1, x) }  func (this *MyQueue) Pop() int { \tvar res int \tlen1, len2 := len(this.stack1), len(this.stack2) \tif len2 != 0 { \tele := this.stack2[len2-1] \tres = ele \tthis.stack2 = this.stack2[:len2-1] \t} else { \tfor i := len1 - 1; i \u0026gt;= 0; i-- { \tthis.stack2 = append(this.stack2, this.stack1[i]) \t} \tthis.stack1 = this.stack1[:0] \tlen2 = len(this.stack2) \tres = this.stack2[len2-1] \tthis.stack2 = this.stack2[:len2-1] \t}  \treturn res }  func (this *MyQueue) Peek() int { \tvar res int \tlen1, len2 := len(this.stack1), len(this.stack2) \tif len2 != 0 { \tele := this.stack2[len2-1] \tres = ele \t} else { \tfor i := len1 - 1; i \u0026gt;= 0; i-- { \tthis.stack2 = append(this.stack2, this.stack1[i]) \t}  \tthis.stack1 = this.stack1[:0] \tlen2 = len(this.stack2) \tres = this.stack2[len2-1] \t}  \treturn res }  func (this *MyQueue) Empty() bool { \treturn len(this.stack1) == 0 \u0026amp;\u0026amp; len(this.stack2) == 0 } "},{"id":8,"href":"/docs/algs/leetcode/41_first_msssing_positive/","title":"10. First Missing Positive","section":"Leetcode","content":"Description #   Given an unsorted integer array nums, return the smallest missing positive integer.\nYou must implement an algorithm that runs in O(n) time and uses constant extra space.\n Solutions #  Hash Table #  可以使用一个 hash table 记录所以出现的值，然后找出当前值中的最大值。然后从 1 到最大值开始遍历，如果出现一个不在 hash table 中的数，则将该数返回即可。如果所有数都出现在了 hash table 中，那么返回最大值加 1 即可。但是最后这里需要注意的是，有可能整个数组都是负数，这样的话会导致前面的判断失效，所以返回值应该最小要返回 1.\nfunc firstMissingPositive(nums []int) int {  dict := make(map[int]bool)  curMax := nums[0]  for _, num := range nums {  dict[num] = true  if num \u0026gt; curMax {  curMax = num  }  }   for i := 1; i \u0026lt;= curMax; i++ {  if _, ok := dict[i]; !ok {  return i  }  }   return max(1, curMax + 1) }  func max(a, b int) int {  if a \u0026lt; b {  return b  }   return a } 进一步的，其实没必要遍历那么多数，只需要遍历 n 个数即可，n 为数组长度，上述改进版如下：\nfunc firstMissingPositive(nums []int) int {  dict := make(map[int]bool)  for _, num := range nums {  dict[num] = true  }   n := len(nums)  for i := 1; i \u0026lt;= n; i++ {  if _, ok := dict[i]; !ok {  return i  }  }   return max(1, n+1) }  func max(a, b int) int {  if a \u0026lt; b {  return b  }   return a } Array #  因为对空间复杂度有要求，所以上述的 hash table 的方法应该不能满足要求。这里的思路就是复用原数组，我们希望 nums[0]=1, nums[1] = 2, nums[i] = i+1。那么就需要遍历一次数组，遍历过程中如果发现 nums[i] != i+1, 也就是 nums[nums[i]-1] != nums[i]，那么我们就交换这两个元素。 最后扫描一遍数组，如果发现 nums[i] != i+1， 那么说明 i + 1 不在数组中，直接返回 i+1 即可。如果遍历完了发现从 1 到 n （为什么是 n，因为下标 0 存放的是 1，那么下标 n-1 存放的是 n）都在数组中，那么最后只需要返回 n+1 即可。\nfunc firstMissingPositive(nums []int) int {  n := len(nums)  for i := 0; i \u0026lt; n; i++ { \t// 注意这里是 while 循环，因为 nums[nums[i]-1] 和 nums[i] 交换的时候已经改变了 nums[i] 的值了 \t// 所以这个 while 循环不能简单的用 if 来代替  for nums[i] \u0026gt; 0 \u0026amp;\u0026amp; nums[i] \u0026lt;= n \u0026amp;\u0026amp; nums[nums[i]-1] != nums[i] {  nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]  }  }   for i := 0; i \u0026lt; n; i++ {  if nums[i] != i+1 {  return i+1  }  }   return n+1 } "},{"id":9,"href":"/docs/algs/codingInterviews/10_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/","title":"10. 斐波那契数列","section":"Coding Interviews","content":"Description #   输入一个正整数 n ，请你输出斐波那契数列的第 n 项\n Solutions #  简单题，简单的动态规划。\nfunc Fibonacci( n int ) int {  // write code here  if n \u0026lt;= 2 {  return 1  }   NMinusOne, NMinusTwo := 1, 1  for i := 3; i \u0026lt;= n; i++ {  N := NMinusOne + NMinusTwo  NMinusTwo = NMinusOne  NMinusOne = N  }   return NMinusOne } "},{"id":10,"href":"/docs/algs/codingInterviews/11_%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/","title":"11. 旋转数组的最小数字","section":"Coding Interviews","content":"Descriptioin #   有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。\n数据范围：$1 \\le n \\le 10000$，数组中任意元素的值: $0 \\le val \\le 10000$。 要求：空间复杂度：$\\Omicron(1)$ ，时间复杂度：$\\Omicron(\\log n)$\n Solutions #  Binary Search #  二分查找，使用两个指针 left 和 right 分别指向数组的待查找序列的左侧和右侧，则：\n 如果中间元素比右侧元素小，那么向左查找，即 right = mid 如果中间元素比右侧元素大，那么向右查找， 即 left = mid + 1 如果中间元素等于右侧元素，那么最小元素即可能在左边，也可能在右边，则可以搜索右边界 最后返回 left 指向的元素即可。  func minNumberInRotateArray( nums []int ) int {  // write code here  var res int  size := len(nums)  if size == 0 {  return res  }   left, right := 0, size -1  for left \u0026lt; right {  mid := (left+right)/2  if nums[mid] \u0026gt; nums[right] {  left = mid + 1  } else if nums[mid] \u0026lt; nums[right] {  right = mid  } else if nums[mid] == nums[right] {  right = right -1  }  }   return nums[left] } "},{"id":11,"href":"/docs/algs/codingInterviews/12_%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/","title":"12. 矩阵中的路径","section":"Coding Interviews","content":"Description #   请设计一个函数，用来判断在一个n乘m的矩阵中是否存在一条包含某长度为len的字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如: $\\begin{bmatrix} a \u0026amp; b \u0026amp; c \u0026amp;e \\ s \u0026amp; f \u0026amp; c \u0026amp; s \\ a \u0026amp; d \u0026amp; e\u0026amp; e\\ \\end{bmatrix}\\quad$\n矩阵中包含一条字符串\u0026quot;bcced\u0026quot;的路径，但是矩阵中不包含\u0026quot;abcb\u0026quot;路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 数据范围：$0 \\le n,m \\le 20$ ,$1\\le len \\le 25$\n Solutions #  Backtracing #  func hasPath( matrix [][]byte , word string ) bool {  // write code here  n,m := len(matrix), len(matrix[0])  for i := 0; i \u0026lt; n; i++ {  for j := 0; j \u0026lt; m; j++ { \t// 剪枝  if word[0] == matrix[i][j] \u0026amp;\u0026amp; helper(matrix, word, i, j, n, m) {  return true  }  }  }   return false }  func helper(matrix [][]byte, word string, x,y,n,m int) bool {  size := len(word) \t// 这里之所以可以直接取 word[0] 而不用判断数组越界，主要是因为下面第二个 if 语句会保证进入递归的 word 一定不是空串  if x \u0026lt; 0 || x \u0026gt;= n || y \u0026lt; 0 || y \u0026gt;= m || matrix[x][y] == \u0026#39;.\u0026#39; || word[0] != matrix[x][y] {  return false  }    if size == 1 \u0026amp;\u0026amp; matrix[x][y] == word[0] {  return true  }  \t// 这里可以直接使用原矩阵来判断特定点是否已经访问过，而不用再新开数组  tmp := matrix[x][y]  matrix[x][y] = \u0026#39;.\u0026#39;  res := helper(matrix, word[1:], x+1, y, n, m) ||  helper(matrix, word[1:], x-1, y, n, m) ||  helper(matrix, word[1:], x, y+1, n, m) ||  helper(matrix, word[1:], x, y-1, n, m) \t\t// 回溯结束之后要复原  matrix[x][y] = tmp  return res } "},{"id":12,"href":"/docs/algs/codingInterviews/13_%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/","title":"13. 机器人的运动范围","section":"Coding Interviews","content":"Description #   地上有一个 rows 行和 cols 列的方格。坐标从 [0,0] 到 [rows-1,cols-1] 。一个机器人从坐标 [0,0] 的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 threshold 的格子。 例如，当 threshold 为 18 时，机器人能够进入方格 [35,37] ，因为 3+5+3+7 = 18。但是，它不能进入方格 [35,38] ，因为 3+5+3+8 = 19 。请问该机器人能够达到多少个格子？\n数据范围： $0 \\le threshold \\le 15$，$1 \\le rows,cols \\le 100$\n Solutions #  func movingCount( threshold int , rows int , cols int ) int {  // write code here  if rows \u0026lt;= 0 || cols \u0026lt;= 0 || threshold \u0026lt; 0 {  return 0  }   visited := make([][]bool, rows)  for idx, _ := range visited {  visited[idx] = make([]bool, cols)  }  return helper(threshold, rows, cols, 0, 0, \u0026amp;visited) }  func helper(threshold int, rows int,cols int, row int, col int, visited *[][]bool) int {  t := pathSum(row) + pathSum(col)  if row \u0026lt; 0 || row \u0026gt;= rows || col \u0026lt; 0 || col \u0026gt;= cols || (*visited)[row][col] || t \u0026gt; threshold {  return 0  }   (*visited)[row][col] = true  return 1 + helper(threshold, rows, cols, row+1, col, visited) +  helper(threshold, rows, cols, row-1, col, visited) +  helper(threshold, rows, cols, row, col+1, visited) +  helper(threshold, rows, cols, row, col-1, visited) }  func pathSum(num int) int {  var sum int  for num != 0 {  sum += num%10  num /= 10  }   return sum } "},{"id":13,"href":"/docs/algs/codingInterviews/14_%E5%89%AA%E7%BB%B3%E5%AD%90/","title":"14. 剪绳子","section":"Coding Interviews","content":"Description #   给你一根长度为 n 的绳子，请把绳子剪成整数长的 m 段（ m 、 n 都是整数， n \u0026gt; 1 并且 m \u0026gt; 1 ， m \u0026lt;= n ），每段绳子的长度记为 k[1],\u0026hellip;,k[m] 。请问 k[1]k[2]\u0026hellip;*k[m] 可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18 。\n数据范围： $2 \\le n \\le 60$ 进阶：空间复杂度 $\\Omicron(1)$ ，时间复杂度 $\\Omicron(n)$\n Solutions #  Recursive #  我们可以发现，当我们求某一个数字的时候，我们只需要将这个数字分解出1,2,3。对于3以上的数字，其实也可以分解成这三个数字，比如4=2x2,5=2x3。对于分解出1的情况，我们发现这个是对答案没有贡献的。所以直接忽略。我们只需要讨论2和3的情况。所以，我们只需要将数字分为2和3组成的就行了。\nfunc cutRope( n int ) int {  // write code here  if n \u0026lt;= 3 {  return n  }   return max(2*cutRope(n-2), 3*cutRope(n-3)) }   func max(a,b int) int {  if a \u0026lt; b {  return b  }   return a } Dynamic Programming #  对于一个长度为 n 的绳子，如何确定其分出的最大乘积呢？我们可以尝试其中一段不可分的为 j，那么如果另一段 n-j 最大乘积已知，那么我们就可以遍历所有 j 找到这个最大乘积。因此用 dp[i] 表示长度为 i 的绳子可以被剪出来的最大乘积，那么后续遍历每个 j 的时候，我们取最大 dp[i] = max(dp[i], j *dp[i-j])即可。也就是:\nfor j := 1; j \u0026lt; i; j++ { \tdp[i] = max(dp[i], j * dp[i-j]) } 完整代码如下：\nfunc cutRope( n int ) int {  // write code here  // 不超过 3 的直接返回  if n \u0026lt;= 3 {  return n  }   // 初始化 dp 数组  dp := make([]int, n+1)  dp[1] = 1  dp[2] = 2  dp[3] = 3  dp[4] = 4  for i := 5; i \u0026lt;= n; i++ {  for j := 1; j \u0026lt; i; j++ {  dp[i] = max(dp[i], j * dp[i-j])  }  }   return dp[n] }   func max(a,b int) int {  if a \u0026lt; b {  return b  }   return a } "},{"id":14,"href":"/docs/algs/codingInterviews/15_%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD-1-%E7%9A%84%E4%B8%AA%E6%95%B0/","title":"15. 二进制中 1 的个数","section":"Coding Interviews","content":"Description #   输入一个整数 n ，输出该数32位二进制表示中1的个数。其中负数用补码表示。\n Solutions #  Bit Manipulation #  这里需要注意的是，因为负数用补码表示，而负数补码右移会导致高位补 1，所以对负数不能直接进行右移。\nfunc NumberOf1( n int ) int {  // write code here  var count int  t := 0x80000000  for n != 0 {  count += (n \u0026amp; t) \u0026gt;\u0026gt; 31  n \u0026lt;\u0026lt;= 1  }   return count } "},{"id":15,"href":"/docs/algs/codingInterviews/16_%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/","title":"16. 数值的整数次方","section":"Coding Interviews","content":"Description #   实现函数 double Power(double base, int exponent)，求base的exponent次方。\n注意： 1.保证base和exponent不同时为0。 2.不得使用库函数，同时不需要考虑大数问题 3.有特殊判题，不用考虑小数点后面0的位数。\n数据范围： $|base| \\le 100$ ， $|exponent| \\le 100$ ,保证最终结果一定满足 $|val| \\le 10^4$\n进阶：空间复杂度 $\\Omicron(1)$ ，时间复杂度 $\\Omicron(n)$\n 快速幂 #  func Power( base float64 , exponent int ) float64 {  // write code here  if base == 0 {  return 0  }  var negative bool  if exponent \u0026lt; 0 {  negative = true  exponent = -exponent  }   res := helper(base, exponent)  if negative {  res = 1 / res  }   return res }  func helper(base float64, exponent int) float64 {  if base == 0 {  return 0  }  if exponent == 0 {  return 1  }   if exponent == 1 {  return base  }   return helper(base, exponent/2) * helper(base, exponent/2) * helper(base, exponent%2) } "},{"id":16,"href":"/docs/algs/codingInterviews/17_%E6%89%93%E5%8D%B0%E4%BB%8E-1-%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84-n-%E4%BD%8D%E6%95%B0/","title":"17. 打印从 1 到最大的 n 位数","section":"Coding Interviews","content":"Description #   输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。\n 用返回一个整数列表来代替打印 n 为正整数，0 \u0026lt; n \u0026lt;= 5   Solutions #  func printNumbers( n int ) []int {  // write code here  var res []int  if n == 0 {  return res  }   curMax := 0  for n \u0026gt; 0 {  curMax *= 10  curMax += 9  n--  }   for i := 1; i \u0026lt;= curMax; i++ {  res = append(res, i)  }   return res } "},{"id":17,"href":"/docs/algs/leetcode/21_merge_two_sorted_list/","title":"21. Merge Two Sorted List","section":"Leetcode","content":"Description #   You are given the heads of two sorted linked lists list1 and list2.\nMerge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\nReturn the head of the merged linked list.\n Solutions #  Merge Sort #  func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode { \tres := new(ListNode) \tnode := res \tdummyHead1, dummyHead2 := list1, list2 \tfor dummyHead1 != nil \u0026amp;\u0026amp; dummyHead2 != nil { \tt := new(ListNode) \tif dummyHead1.Val \u0026lt;= dummyHead2.Val { \tt.Val = dummyHead1.Val \tdummyHead1 = dummyHead1.Next  \t} else { \tt.Val = dummyHead2.Val \tdummyHead2 = dummyHead2.Next \t} \tnode.Next = t \tnode = node.Next \t}  \tfor dummyHead1 != nil { \tt := new(ListNode) \tt.Val = dummyHead1.Val \tnode.Next = t \tnode = node.Next \tdummyHead1 = dummyHead1.Next \t}  \tfor dummyHead2 != nil { \tt := new(ListNode) \tt.Val = dummyHead2.Val \tnode.Next = t \tnode = node.Next \tdummyHead2 = dummyHead2.Next \t}  \treturn res.Next } "},{"id":18,"href":"/docs/algs/codingInterviews/21_%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/","title":"21. 调整数组顺序使奇数位于偶数前面","section":"Coding Interviews","content":"Description #   输入一个长度为 n 整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前面部分，所有的偶数位于数组的后面部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。\n数据范围：$0 \\le n \\le 5000$，数组中每个数的值 $0 \\le val \\le 10000$ 要求：时间复杂度 $\\Omicron(n)$，空间复杂度 $\\Omicron(n)$ 进阶：时间复杂度 $\\Omicron(n^2)$，空间复杂度 $\\Omicron(1)$\n Solutions #  Array #  分别创建两个数组，一个用于存储奇数，一个用于存储偶数，然后扫描一次原数组，将奇数放入奇数数组，将偶数放入偶数数组，最后再将这两个数组拼接在一起即可。\nfunc reOrderArray( array []int ) []int {  // write code here  size := len(array)  if size == 0 {  return nil  }   var odd, even []int  for _, num := range array {  if num %2 == 0 {  even = append(even, num)  } else {  odd = append(odd, num)  }  }   return append(odd, even...) } In-place #  上一个方法是使用了额外的数组空间，这里还要一种不需要使用额外空间的方法：使用一个指针 cur 表示当前已经遍历到的元素，使用一个指针 odd 表示当前奇数元素应该存储的位置，odd 和 cur 初始都为 0.扫描一遍数组，当前扫描到的元素为偶数时，则 cur++，继续遍历下一个，如果当前遍历到的元素为奇数，则先保存这个元素的值到 tmp，然后将 [odd, cur-1] 的元素都后移一个位置，然后再将tmp 放到 odd 指向 位置，然后 odd 自增，cur 自增，继续下一次扫描。\n"},{"id":19,"href":"/docs/algs/leetcode/22_generate_parentheses/","title":"22. Generate Parentheses","section":"Leetcode","content":"Description #   Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n Solutions #  Recursive #  参见： https://leetcode-cn.com/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/\n使用两个变量 left 和 right 来表示「左括号使用了集合」和「右括号使用了几个」，通过分析可以得到以下结论： - 只有当left 和 right 都比 n 小的时候，才产生分支。 - 产生左分支的时候，只看当前还有左括号可用 - 产生右分支的时候，还受到左括号数量的限制，left 要大于 right 的时候，才可以产生分支。否则就是无效分支，可以直接返回。 - 在左边和右边的括号数都等于 n 的时候结算。\nfunc generateParenthesis(n int) []string {  var res []string \tif n == 0 { \treturn res \t}  \tgenerateParenthesisHelper(n, 0,0,\u0026#34;\u0026#34;, \u0026amp;res) \treturn res }  func generateParenthesisHelper(n, left, right int, cur string, res *[]string) { \tif left == n \u0026amp;\u0026amp; right == n { \t*res = append(*res, cur) \treturn \t}  \t// 剪枝 \tif left \u0026lt; right { \treturn \t}  \tif left \u0026lt; n { \tgenerateParenthesisHelper(n, left+1, right, cur + \u0026#34;(\u0026#34;, res) \t} \tif right \u0026lt; n { \tgenerateParenthesisHelper(n, left, right+1, cur + \u0026#34;)\u0026#34;, res) \t} } "},{"id":20,"href":"/docs/algs/leetcode/23_merge_k_sorted_list/","title":"23. Merge K Sorted List","section":"Leetcode","content":"Description #   You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it.\n Solutions #  Min Heap #  很简单的想法，使用最小堆即可。\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeKLists(lists []*ListNode) *ListNode { \treturn mergeKListsSolution1(lists) }  // 使用最小堆，将所有的节点数据都插入到最小堆中，然后再把所有元素从最小堆中弹出 func mergeKListsSolution1(lists []*ListNode) *ListNode { \tvar minHeap MinHeapArr \theap.Init(\u0026amp;minHeap)  \tfor _, list := range lists { \tt := list \tfor t != nil { \theap.Push(\u0026amp;minHeap, t.Val) \tt = t.Next \t}  \t}  \tres := new(ListNode) \tnode := res \tfor len(minHeap) \u0026gt; 0 { \tval := heap.Pop(\u0026amp;minHeap).(int) \tt := new(ListNode) \tt.Val = val \tnode.Next = t \tnode = node.Next \t}  \treturn res.Next }   type MinHeapArr []int  func (h MinHeapArr) Len() int { \treturn len(h) }  func (h MinHeapArr) Less(i, j int) bool { \treturn h[i] \u0026lt; h[j] }  func (h MinHeapArr) Swap(i, j int) { \th[i], h[j] = h[j], h[i] }  func (h *MinHeapArr) Push(x interface{}) { \t*h = append(*h, x.(int)) }  func (h *MinHeapArr) Pop() interface{} { \tsize := len(*h) \tres := (*h)[size-1] \t*h = (*h)[:size-1] \treturn res }  func (h *MinHeapArr) Top() interface{} { \t// TODO \treturn nil } "},{"id":21,"href":"/docs/algs/leetcode/26_remove_duplicates_from_sorted_array/","title":"26. remove duplicated from sorted array","section":"Leetcode","content":"Description #   Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n Solution #  简单题。使用一个 pos 指针指向当前不重复元素应该存储的位置，然后遍历数组，对于重复元素则跳过，知道遇到不重复元素位置，将该元素放到 pos 处，然后让 pos 和 start 都自增，然后继续遍历\nfunc removeDuplicates(nums []int) int {  size := len(nums)  if size \u0026lt;= 1 {  return size  }   start, pos := 1, 1  for start \u0026lt; size {  for start \u0026lt; size \u0026amp;\u0026amp; nums[start] == nums[start-1] {  start++  }  if start \u0026lt; size {  nums[pos] = nums[start]  pos++  }   start++  }   return pos  } "},{"id":22,"href":"/docs/algs/leetcode/28_implement_strStr/","title":"28. Implement strStr","section":"Leetcode","content":"Description #   Implement strStr().\nGiven two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n Solutions #  太简单了在，直接看代码即可。\nfunc strStr(haystack string, needle string) int {  var pos int  size := len(haystack)  targetSize := len(needle)  if size == 0 || targetSize == 0 {  return pos  }   var start int   pos = -1  for start \u0026lt; size {  if haystack[start] != needle[0] {  start++  continue  }   if start + targetSize \u0026lt;= size \u0026amp;\u0026amp; haystack[start: start+targetSize] == needle {  pos = start  break  }  start++  }   return pos } "},{"id":23,"href":"/docs/algs/codingInterviews/28_%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"28. 对称的二叉树","section":"Coding Interviews","content":"Description #   给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）\n Solutions #  Recursive #  func isSymmetrical( pRoot *TreeNode ) bool {  // write code here  if pRoot == nil {  return true  }   return isSameTree(pRoot.Left, pRoot.Right) }  func isSameTree(root1, root2 *TreeNode) bool {  if root1 == nil \u0026amp;\u0026amp; root2 == nil {  return true  }   if root1 == nil || root2 == nil {  return false  }   if root1.Val != root2.Val {  return false  }   return isSameTree(root1.Left, root2.Right) \u0026amp;\u0026amp; isSameTree(root1.Right, root2.Left) } "},{"id":24,"href":"/docs/algs/leetcode/29_divide_two_integers/","title":"29. Divide Two Integers","section":"Leetcode","content":"Description #   Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\nThe integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\nReturn the quotient after dividing dividend by divisor.\nNote: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\n Solutions #  Subtraction #  俗话说得好，\u0026ldquo;计算中的除法都是通过减法来完成的\u0026rdquo;。 :)\n很不幸，下面这个解法超时了. :)\nfunc divide(dividend int, divisor int) int {  var quotient int  if dividend == 0 {  return quotient  }  negative := true  if dividend \u0026gt; 0 \u0026amp;\u0026amp; divisor \u0026gt; 0 || dividend \u0026lt; 0 \u0026amp;\u0026amp; divisor \u0026lt; 0 {  negative = false  }     dividend, divisor = abs(dividend), abs(divisor)  for dividend \u0026gt; 0 {  dividend -= divisor  if dividend \u0026gt;= 0 {  quotient++  }   if negative \u0026amp;\u0026amp; dividend \u0026gt; 0 \u0026amp;\u0026amp; quotient \u0026gt;= int(math.MaxInt32) + 1 {  return int(math.MinInt32)  }   if !negative \u0026amp;\u0026amp; dividend \u0026gt; 0 \u0026amp;\u0026amp; quotient \u0026gt;= int(math.MaxInt32) {  return int(math.MaxInt32)  }  }   if negative {  return -quotient  }   return quotient }  func abs(a int) int {  if a \u0026lt; 0 {  return -a  }   return a } "},{"id":25,"href":"/docs/algs/codingInterviews/29_%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/","title":"29. 顺时针打印矩阵","section":"Coding Interviews","content":"Description #   输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： [[1,2,3,4], [5,6,7,8], [9,10,11,12], [13,14,15,16]] 则依次打印出数字 [1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10]\n数据范围: $0 \\le matrix.length \\le 100$ $0 \\le matrix[i].length \\le 100$\n Solutions #  老面孔了，不多介绍。\nfunc printMatrix( matrix [][]int ) []int {  // write code here  var res []int  m, n := len(matrix), len(matrix[0])   top, down, left, right := 0, m-1, 0, n-1  for top \u0026lt;= down \u0026amp;\u0026amp; left \u0026lt;= right {\t// 注意这里是等号，从而让只有一行/列的时候也能进入循环  for i := left; i \u0026lt;= right; i++ {  res = append(res, matrix[top][i])  } \t// 避免上下重合  top++  if top \u0026gt; down {  break  }   for i := top; i \u0026lt;= down; i++ {  res = append(res, matrix[i][right])  } \t// 避免左右重合  right--  if right \u0026lt; left {  break  }   for i := right; i \u0026gt;= left; i-- {  res = append(res, matrix[down][i])  } \t// 避免上下重合  down--  if down \u0026lt; top {  break  }   for i := down; i \u0026gt;= top; i-- {  res = append(res, matrix[i][left])  }  \t// 避免左右重合  left++  if left \u0026gt; right {  break  }  }   return res } "},{"id":26,"href":"/docs/algs/codingInterviews/30_%E5%8C%85%E5%90%AB-min-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/","title":"30. 包含 min 函数的栈","section":"Coding Interviews","content":"Description #   定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数，输入操作时保证 pop、top 和 min 函数操作时，栈中一定有元素。\n此栈包含的方法有： push(value):将value压入栈中 pop():弹出栈顶元素 top():获取栈顶元素 min():获取栈中最小元素\n数据范围：操作数量满足 $0 \\le n \\le 300$ ，输入的元素满足 $|val| \\le 10000$ 进阶：栈的各个操作的时间复杂度是 $\\Omicron(1)$ ，空间复杂度是 $\\Omicron(n)$。\n Solutions #  Stack #  使用两个栈，一个栈stack1用于正常压入和弹出，另一个栈stack2用于实现单调栈。当压入一个元素时，如果当前元素比 stack2 的栈顶元素还要大，则将当前元素压入 stack1 的同时，还将当前元素压入 stack2，如果当前元素不比 stack2 的栈顶元素要大，则将 stack2 的栈顶元素重复入栈。当弹出元素时，将 stack1 和 stack2 的栈顶元素同步弹出。当获取最小值时，只需要取出 stack2 的栈顶元素即可。\n// 用于实现正常的 push 与 pop 操作 var stack1 []int // 用于存储最小值 var stack2 []int  func Push(node int) {  // write code here  stack1 = append(stack1, node)  size := len(stack2)  if size == 0 || stack2[size-1] \u0026gt; node {  stack2 = append(stack2, node)  } else {  stack2 = append(stack2, stack2[size-1])  }  } func Pop() {  // write code here  size := len(stack1)  stack1 = stack1[:size-1]  stack2 = stack2[:size-1] } func Top() int {  // write code here  size := len(stack1)  return stack1[size-1] } func Min() int {  // write code here  size := len(stack2)  return stack2[size-1] } "},{"id":27,"href":"/docs/algs/codingInterviews/31_%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/","title":"31. 栈的压入弹出序列","section":"Coding Interviews","content":"Description #   输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。\n Solutions #  栈模拟 #  新建一个栈来模拟出栈序列。使用一个指针 inPos 指向当前入栈序列的单签入栈元素，使用另一个指针 outPos 指向出栈序列当前应该出栈的元素，然后开始模拟出入栈。\n 首先，如果当前栈顶元素和出栈序列匹配，则出栈栈顶元素，并且将 outPos 右移，直到二者不匹配或者栈为空 将 inPos 指针指向的入栈序列的元素入栈，然后将 inPos 右移。 不断循环上述过程，直到入栈序列中的所有元素都入栈。 最后判断是否出栈序列中的所有元素都已经匹配完成即可。  func IsPopOrder( pushV []int , popV []int ) bool {  // write code here  size := len(pushV)  if size == 0 {  return true  }  var stack []int  stack = append(stack, pushV[0])  inPos, outPos := 1, 0 \t// 为什么这里的循环用的是 \u0026lt;= ，而不是 \u0026lt; ？ \t// 因为有可能我们一直从入栈序列中入栈的操作，直到所有元素都已经入栈。如果只使用 \u0026lt; 符号的话， \t// 我们就无法判断出栈序列是否和栈顶元素匹配（当然你也可以在 for 循环之后再加上这一步，只不过加 \t// 上这个=号之后可以少写一点代码）.  for inPos \u0026lt;= size {  // 如果栈顶元素和出栈序列当前元素匹配，则可以一直出栈  s := len(stack)  for s \u0026gt; 0 \u0026amp;\u0026amp; popV[outPos] == stack[s-1] {  stack = stack[:s-1]  s--  outPos++  }  \t// 为什么这里要有个 break ? \t// 很明显，当入栈序列已经全部入栈了时，我们需要跳出这个循环  if inPos == size {  break  }   // 当前栈中没有元素和出栈序列匹配，或者栈已经为空，则将入栈序列入栈  stack = append(stack, pushV[inPos])  inPos++  }   // 入栈序列遍历完之后，如果此时栈中的元素个数为0，则说明是有效序列；  // 否则如果栈中还有元素，则说明是无效序列。  return len(stack) == 0 \u0026amp;\u0026amp; outPos == size } "},{"id":28,"href":"/docs/algs/leetcode/33_search_in_rotated_array/","title":"33. Search in Rotated Sorted Array","section":"Leetcode","content":"Description #   There is an integer array nums sorted in ascending order (with distinct values).\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 \u0026lt;= k \u0026lt; nums.length) such that the resulting array is [nums[k], nums[k+1], \u0026hellip;, nums[n-1], nums[0], nums[1], \u0026hellip;, nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\nYou must write an algorithm with O(log n) runtime complexity.\n Solutions #  Binary Search #  引用别人的话：\n 将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。 此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环.\n 还是使用二分查找的方法来。首先，如果这个数组翻转了，那么至少有有一侧是占多数数字的，具体那哪一侧还要进一步判断。经过举例观察可以看到，如果中间数小于右边的数，那么右边一定是有序的；如果中间数大于右边的数，那么左半段是有序的。那么我们只需要在有序的区间内进行二分查找即可。详见代码。\nfunc search(nums []int, target int) int { \tsize := len(nums) \tleft, right := 0, size-1 \tfor left \u0026lt;= right { \tmid := left + (right-left)/2 \tif nums[mid] == target { \treturn mid \t} \t\tif nums[mid] \u0026lt; nums[right] { \t// 如果右半边有序，则对右半边进行二分 \tif nums[mid] \u0026lt; target \u0026amp;\u0026amp; nums[right] \u0026gt;= target { \tleft = mid + 1 \t} else { \tright = mid - 1 \t} \t} else { \t// 如果左半边有序，则对左半边进行二分 \tif nums[left] \u0026lt;= target \u0026amp;\u0026amp; nums[mid] \u0026gt; target { \tright = mid -1 \t} else { \tleft = mid + 1 \t} \t} \t}  \treturn -1 } "},{"id":29,"href":"/docs/algs/leetcode/34_find_first_and_last_position_of_element_in_sorted_array/","title":"34. Find First and Last Position of Element in Sorted Array","section":"Leetcode","content":"Description #   Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\nIf target is not found in the array, return [-1, -1].\nYou must write an algorithm with O(log n) runtime complexity.\n Solutions #  Binary Search #  二分查找再加上中间扩散，很容易想出来。\nfunc searchRange(nums []int, target int) []int {  res := []int{-1, -1}  size := len(nums)  if size == 0 {  return res  }   left, right := 0, size -1  for left \u0026lt;= right {  mid := (left+right)/2  if nums[mid] == target {  l,r := mid, mid  res[0] = l  res[1] = r  for l \u0026gt;= 0 \u0026amp;\u0026amp; nums[l] == target {  res[0] = l  l--  }   for r \u0026lt; size \u0026amp;\u0026amp; nums[r] == target {  res[1] = r  r++  }   break  } else if nums[mid] \u0026gt; target {  right = mid -1  } else if nums[mid] \u0026lt; target {  left = mid + 1  }  }   return res } "},{"id":30,"href":"/docs/algs/leetcode/36_valid_sudoku/","title":"36. Valid Sudoku","section":"Leetcode","content":"Description #   Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.   Solutions #  一个是要注意如何快速创建三维数组，另一个是要注意如何进行坐标转换。\nfunc isValidSudoku(board [][]byte) bool {  size := 9   // 一次性将所有行和列创建完毕  row, col := make([][]int, size), make([][]int, size)  for i := 0; i \u0026lt; size; i++ {  row[i], col[i] = make([]int, size), make([]int, size)  }   // 表示 9 个gird，么个 grid 有 9 个元素. 最后创建出来的是一个 grid[3][3][9] 的三维数组  grid := make([][][]int, 3)  for idx, _ := range grid {  grid[idx] = make([][]int, 3)  for i, _ := range grid[idx] {  grid[idx][i] = make([]int, size)  }  }  \t// 下面这种创建三维数组的方式太繁琐了  // for i := 0; i \u0026lt; 3; i++ {  // grid[i] = make([][]int, 3)  // }  // for i := 0; i \u0026lt; 3; i++ {  // for j := 0; j \u0026lt; 3; j++ {  // grid[i][j] = make([]int, size)  // }  // }   for i := 0; i \u0026lt; size; i++ {  for j := 0; j \u0026lt; size; j++ {  if board[i][j] == \u0026#39;.\u0026#39; {  continue  }   // 之所以要减去 1，是为了将值控制在 0-8 之内，避免数组访问越界  index := int(board[i][j] - \u0026#39;0\u0026#39; - 1)  row[i][index]++  col[j][index]++  grid[i/3][j/3][index]++  if row[i][index] \u0026gt; 1 || col[j][index] \u0026gt; 1 || grid[i/3][j/3][index] \u0026gt; 1 {  return false  }   }  }    return true } "},{"id":31,"href":"/docs/algs/codingInterviews/37_%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"37. 序列化二叉树","section":"Coding Interviews","content":"Description #   请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树。\n二叉树的序列化(Serialize)是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树等遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#）\n二叉树的反序列化(Deserialize)是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。\n Solutions #  PreOrder Traversal #  采用先序遍历的方式进行序列化，同样采用先序遍历的方式进行反序列化。\nvar emptyNode string = \u0026#34;#\u0026#34; var seperator string = \u0026#34; \u0026#34; func Serialize( root *TreeNode ) string {  // write code here  if root == nil {  return \u0026#34;\u0026#34;  }   var res []string  _serialize(root, \u0026amp;res)  return strings.Join(res, seperator) }  func _serialize(root *TreeNode, res *[]string) {  if root != nil {  v := strconv.Itoa(root.Val)  *res = append(*res, v)   _serialize(root.Left, res)  _serialize(root.Right, res)  } else { \t// 递归是收敛的  *res = append(*res, emptyNode)  } }  func Deserialize( s string ) *TreeNode {  // write code here  if len(s) == 0 {  return nil  }   values := strings.Split(s, seperator)  return _deserialize(\u0026amp;values) }  func _deserialize(values *[]string) *TreeNode { \t// 注意这里，为什么这里不会出现数组越界访问呢，也就是说，你是如何保证数组里一定会有元素的呢？ \t// 其实在序列化的时候，对于每一条路径，我们最后会走到的节点不是叶子节点，而是该叶子节点的两个空子节点。 \t// 那么也就是说，序列化后的字符的最后一个字符一定是 \u0026#34;#\u0026#34; 符号，代表走到空节点，那么一定也会在下面的第一个 if 后即递归终止，那么肯定就不会出现数组越界访问的情况。  s := (*values)[0]  *values = (*values)[1:]  \t// 递归是收敛的  if s == emptyNode {  return nil  }   v, _ := strconv.Atoi(s)  root := new(TreeNode)  root.Val = v  root.Left = _deserialize(values)  root.Right = _deserialize(values)  return root } Level Order Traversal #  基于层次遍历的思想，但是需要将序列化的顺序和反序列化的顺序一一对应起来。序列化时，如果该节点非空，则将节点值序列化，然后将其左右子节点入队，如果节点为空，则用特定的字符来代替。反序列化时，也是使用层次遍历的方式，先是使用一个节点作为根节点，然后将其入队，然后不断从队列中取出节点来更新其子节点。从字符串中取值的时候，如果当前取到的值代表是一个空节点，则可以直接跳过。\n注意领会，这里序列化和反序列的顺序其实是一一对应的。\nfunc Serialize( root *TreeNode ) string {  // write code here  if root == nil {  return \u0026#34;\u0026#34;  }   var res []string  emptyNode := \u0026#34;#\u0026#34;  seperator := \u0026#34; \u0026#34;    var queue []*TreeNode  queue = append(queue, root)  for len(queue) != 0 {  size := len(queue)  for i := 0; i \u0026lt; size; i++ {  node := queue[i]  if node != nil {  s := strconv.Itoa(node.Val)  res = append(res, s)  queue = append(queue, node.Left)  queue = append(queue, node.Right)  } else {  res = append(res, emptyNode)  }  }   queue = queue[size:]  }   return strings.Join(res, seperator) }  func Deserialize( s string ) *TreeNode {  // write code here  if len(s) == 0 {  return nil  }  seperator := \u0026#34; \u0026#34;  emptyNode := \u0026#34;#\u0026#34;  nodes := strings.Split(s, seperator)   root := new(TreeNode)  root.Val,_ = strconv.Atoi(nodes[0])  nodes = nodes[1:]   var queue []*TreeNode  queue = append(queue, root)  for len(queue) != 0 {  size := len(queue)  for i := 0; i \u0026lt; size; i++ {  node := queue[i]  val := nodes[0]  nodes = nodes[1:]  if val != emptyNode {  v,_ := strconv.Atoi(val)  tmp := new(TreeNode)  tmp.Val = v  node.Left = tmp  queue = append(queue, tmp)  }   val = nodes[0]  nodes = nodes[1:]  if val != emptyNode {  v,_ := strconv.Atoi(val)  tmp := new(TreeNode)  tmp.Val = v  node.Right = tmp  queue = append(queue, tmp)  }  }   queue = queue[size:]  }   return root } "},{"id":32,"href":"/docs/algs/leetcode/38_count_and_say/","title":"38. Count and Say","section":"Leetcode","content":"Descrition #   The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\ncountAndSay(1) = \u0026ldquo;1\u0026rdquo; countAndSay(n) is the way you would \u0026ldquo;say\u0026rdquo; the digit string from countAndSay(n-1), which is then converted into a different digit string. To determine how you \u0026ldquo;say\u0026rdquo; a digit string, split it into the minimal number of groups so that each group is a contiguous section all of the same character. Then for each group, say the number of characters, then say the character. To convert the saying into a digit string, replace the counts with a number and concatenate every saying.\n Solutions #  统计每个字符出现的次数即可。\nfunc countAndSay(n int) string {  if n == 0 {  return \u0026#34;0\u0026#34;  }   res := \u0026#34;1\u0026#34;  for n-1 \u0026gt; 0 {  cur := \u0026#34;\u0026#34;  \t// 统计 res 中每个字符出现的次数，然后将再将次数和该字符拼接到 cur 上，最后将 cur 赋值给 res  size := len(res)  for i := 0; i \u0026lt; size; i++ {  cnt := 1  for i + 1 \u0026lt; size \u0026amp;\u0026amp; res[i] == res[i+1] {  cnt++  i++  }   cur += strconv.Itoa(cnt) + string(res[i])  }   res = cur  n--  }   return res } "},{"id":33,"href":"/docs/algs/codingInterviews/38_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/","title":"38. 字符串的排列","section":"Coding Interviews","content":"Description #   输入一个长度为 n 字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组。\n例如输入字符串ABC,则输出由字符A,B,C所能排列出来的所有字符串ABC,ACB,BAC,BCA,CBA和CAB。\n Solutions #  使用全排列的思想来做。\nfunc Permutation( str string ) []string {  // write code here  var res []string  size := len(str)  if size == 0 {  return res  }   dict := make(map[string]bool)  permutate([]rune(str), 0, size, \u0026amp;dict)  for key, _ := range dict {  res = append(res, key)  }   return res }  func permutate(str []rune, start int, size int, dict *map[string]bool) {  if start == size {  s := string(str)  if _, ok := (*dict)[s]; !ok {  (*dict)[s] = true  }   return  }   for i := start; i \u0026lt; size; i++ {  str[start], str[i] = str[i], str[start] \t// 注意这里是 start + 1 而不是 i+1  permutate(str, start+1, size, dict) \t// 交换之后要还原  str[start], str[i] = str[i], str[start]  } } "},{"id":34,"href":"/docs/algs/codingInterviews/39_%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/","title":"39. 数组中出现次数超过一半的数字","section":"Coding Interviews","content":"Description #   给一个长度为 n 的数组，数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。\n数据范围：$n \\le 50000$，数组中元素的值 $0 \\le val \\le 10000$ 要求：空间复杂度：$\\Omicron(1)$，时间复杂度 $\\Omicron(n)$\n Solutions #  使用一个数字 cur 表示当前已经遍历到的元素，使用 cnt 表示当前 cur 出现次数。遍历一次数组，每当 cnt \u0026lt;= 0 时，则将 cur 更新为当前扫描到的元素，如果当前扫描的元素 num 不等于 cur， 那么 cnt \u0026ndash;，如果相等，则 cnt++，最后剩下的这个 cur 必然是多数元素。\n因为多数元素出现次数超过一半，所以扫描时，少数元素会把多数元素的出现次数给抵消掉，但是无论怎么抵消，多数元素的出现次数还是比所有少数元素的出现次数要少，所以最后剩下的元素一定是那个多数元素。\nfunc MoreThanHalfNum_Solution( numbers []int ) int {  // write code here  var cnt int  cur := -1   for _, num := range numbers {  if cnt \u0026lt;= 0 {  cur = num  cnt = 1  } else if num == cur {  cnt++  } else if num != cur {  cnt--  }  }   return cur } "},{"id":35,"href":"/docs/algs/codingInterviews/40_%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E4%B8%AA%E6%95%B0/","title":"40. 最小的 k 个数","section":"Coding Interviews","content":"Description #   给定一个长度为 n 的可能有重复值的数组，找出其中不去重的最小的 k 个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4(任意顺序皆可)。 数据范围：$0\\le k,n \\le 10000$ ，数组中每个数的大小 $0 \\le val \\le 1000$ 要求：空间复杂度 $\\Omicron(n)$ ，时间复杂度 $\\Omicron(n\\log n)$\n Solutions #  Min Heap #  使用最小堆的思想来做。把元素不断地压入堆中，然后再将前 k 个元素出堆即可。\nimport \u0026#34;container/heap\u0026#34; /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * @param input int整型一维数组 * @param k int整型 * @return int整型一维数组 */ func GetLeastNumbers_Solution( input []int , k int ) []int {  // write code here  var minHeap MinHeap  var res []int  heap.Init(\u0026amp;minHeap)  for _, value := range input {  heap.Push(\u0026amp;minHeap, value)  }   for i := 0; i \u0026lt; k; i++ {  x := heap.Pop(\u0026amp;minHeap)  res = append(res, x.(int))  }   return res }  //********** min heap ************** type MinHeap []int  func (m MinHeap) Less (i,j int) bool {  return m[i] \u0026lt; m[j] }  func (m MinHeap) Len() int {  return len(m) }  func (m MinHeap) Swap(i,j int) {  m[i], m[j] = m[j],m[i] }  func (m *MinHeap) Push(x interface{}) {  *m = append(*m, x.(int)) }  func (m *MinHeap) Pop() interface {} {  x := (*m)[m.Len()-1]  *m = (*m)[:m.Len()-1]  return x } Quick Sort #  因为快排每次都会选中一个元素作为 pivot，然后将比 pivot 小的元素放到左边，将比 pivot 大的元素放到右边，然后返回 pivot 这个元素最终所在的 index。也就是说，idnex 之前的元素都是比 pivot 要小的元素，那么只要这个 pivot 等于 k -1， 然后返回 nums[:k]即可。\n"},{"id":36,"href":"/docs/algs/codingInterviews/41_%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","title":"41. 数据流中的中位数","section":"Coding Interviews","content":"Description #   如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。\n数据范围：数据流中数个数满足 $1 \\le n \\le 1000$ ，大小满足 $1 \\le val \\le 1000$\n进阶： 空间复杂度 $\\Omicron(n)$ ， 时间复杂度 $\\Omicron(n\\log n)$\n Solutions #  Heap #  分别维持一个大根堆和小根堆，大根堆存储 median 左边的元素，小根堆存储 median 右边的元素，每当新来一个元素，优先放在右边小根堆，然后将小根堆堆顶元素放入大根堆。如果右边小根堆元素数量小于左边大根堆元素数量，那么将右边小根堆堆顶元素弹出并压入左边大根堆中，这样就能维持左边大根堆数量至多比右边小根堆数量多一个。\ntype MedianFinder struct { \tminHeap MinHeapArr \tmaxHeap MaxHeap }  func Constructor() MedianFinder { \tvar minHeap MinHeapArr \tvar maxHeap MaxHeap \theap.Init(\u0026amp;minHeap) \theap.Init(\u0026amp;maxHeap)  \treturn MedianFinder{ \tminHeap: minHeap, \tmaxHeap: maxHeap, \t} }  func (this *MedianFinder) AddNum(num int) { \t// 关键还是在这里的调整，这里的调整保证了左边大根堆的元素数量至多比右边小根堆的数量多一个：当元素总数为偶数时，二者相等；为奇数时，左边比右边大 1 \theap.Push(\u0026amp;(*this).minHeap, num) \theap.Push(\u0026amp;(*this).maxHeap, heap.Pop(\u0026amp;this.minHeap)) \tif (*this).minHeap.Len() \u0026lt; (*this).maxHeap.Len() { \theap.Push(\u0026amp;this.minHeap, heap.Pop(\u0026amp;this.maxHeap)) \t} }  func (this *MedianFinder) FindMedian() float64 { \tif this.minHeap.Len() \u0026gt; this.maxHeap.Len() { \tx := heap.Pop(\u0026amp;this.minHeap).(int) \theap.Push(\u0026amp;this.minHeap, x) \treturn float64(x) \t} else { \tx := heap.Pop(\u0026amp;this.minHeap).(int) \theap.Push(\u0026amp;this.minHeap, x)  \ty := heap.Pop(\u0026amp;this.maxHeap).(int) \theap.Push(\u0026amp;this.maxHeap, y)  \treturn float64(x+y) / 2 \t} }  //--------------- max heap ---------------------- type MaxHeap []int  func (h MaxHeap) Len() int { \treturn len(h) }  func (h MaxHeap) Swap(i, j int) { \th[i], h[j] = h[j], h[i] }  func (h MaxHeap) Less(i, j int) bool { \treturn h[i] \u0026gt; h[j] }  func (h *MaxHeap) Push(x interface{}) { \t*h = append(*h, x.(int)) }  func (h *MaxHeap) Pop() interface{} { \tsize := h.Len() \tif size == 0 { \treturn -1 \t}  \tx := (*h)[size-1] \t*h = (*h)[:size-1] \treturn x }  //************** min heap ************************** type MinHeapArr []int  func (h MinHeapArr) Len() int { \treturn len(h) }  func (h MinHeapArr) Less(i, j int) bool { \treturn h[i] \u0026lt; h[j] }  func (h MinHeapArr) Swap(i, j int) { \th[i], h[j] = h[j], h[i] }  func (h *MinHeapArr) Push(x interface{}) { \t*h = append(*h, x.(int)) }  func (h *MinHeapArr) Pop() interface{} { \tsize := len(*h) \tres := (*h)[size-1] \t*h = (*h)[:size-1] \treturn res } "},{"id":37,"href":"/docs/algs/leetcode/04_traping_rain_water/","title":"42. Traping Rain Water","section":"Leetcode","content":"Description #   Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\ndetail see: https://leetcode.com/problems/trapping-rain-water/\n Solutions #  Array #  使用两个数组扫描两趟，第一个数组 fromLeft 从左到右扫描，记录到目前为止遇到的最大值，第二个数组fromRight 从右向左扫描，记录当前为止遇到的最大值。最后扫描一下这两个数组，对于每个位置 i，取 fromLeft 和 fromRight 二者中的较小者与当前 height[i] 的差值作为当前格子所能盛水量。\nfunc trap(nums []int) int {  var res int  size := len(nums)  if size \u0026lt;= 1 {  return res  }   curMax := nums[0]  fromLeft := make([]int, size)  for idx, num := range nums {  curMax = max(num, curMax)  fromLeft[idx] = curMax  }   curMax = nums[size-1]  fromRight := make([]int, size)  for i := size-1; i \u0026gt;= 0; i-- {  curMax = max(nums[i], curMax)  fromRight[i] = curMax  }   for i := 0; i \u0026lt; size; i++ {  res += min(fromLeft[i], fromRight[i]) - nums[i]  }   return res }  func min(a,b int) int {  if a \u0026lt; b {  return a  }   return b }  func max(a,b int) int {  if a \u0026lt; b {  return b  }   return a } 还有一种解法，就是先找出整个数组的最大值，这个最大值将整个数组切分为两部分，然后分别处理左半边和右半边。处理单边的时候，记录自己当前遇到的历史最大值，如果当前值比历史最大值要大，则更新历史最大值为当前值；否则的话说明历史最大值比当前值要大，那么当前值是可以盛水的，则更新结果盛水量。为什么只需要记录当前历史最大值就可以了呢，毕竟能不能盛水其实要靠两边而不是一边啊？答案是我我们已经找出了整个数组的最大值，那么当前的历史最大值只会比整个数组的最大值要小，能盛多少水完全取决于较短的一方（参考短板理论），所以只需要维持一个最大值即可。\n// 先找到数组中的最大值，这个最大值将数组分为左右两部分，然后分别计算左边的所能盛的水和右边所能盛的水 func trap(nums []int) int {  var res int  size := len(nums)  if size \u0026lt;= 1 {  return res  }   // 找到当前最大高度，这个高度将数组一分为二  var maxHeight int  for idx, value := range nums {  if nums[maxHeight] \u0026lt; value {  maxHeight = idx  }  }   // 处理左半边  peakL := nums[0] // 存储当前扫描到的历史  left := 0  for left \u0026lt; maxHeight {  // 当前元素更大，则更新历史最大值  if nums[left] \u0026gt; peakL {  peakL = nums[left]  } else {  // 历史最大值还是大于当前元素，则可以盛水  res += peakL - nums[left]  }   left++  }   // 处理右半边  peakR := nums[size-1]  right := size-1  for right \u0026gt; maxHeight {  if nums[right] \u0026gt; peakR {  peakR = nums[right]  } else {  res += peakR - nums[right]  }   right--  }    return res } "},{"id":38,"href":"/docs/algs/codingInterviews/42_%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/","title":"42. 连续子数组的最大和","section":"Coding Interviews","content":"Description #   输入一个长度为n的整型数组array，数组中的一个或连续多个整数组成一个子数组，子数组最小长度为1。求所有子数组的和的最大值。\n Solutions #  Kadane 方法 #  参见这个 链接， 已经有现成的 $\\Omicron(n)$ 方法。\npackage main  import \u0026#34;math\u0026#34; /** * * @param array int整型一维数组 * @return int整型 */ func FindGreatestSumOfSubArray( array []int ) int {  // write code here  size := len(array)  if size == 0 {  return 0  }   sum := int(math.MinInt32)  res := sum  for i := 0; i \u0026lt; size; i++ {  sum = max(array[i], sum+array[i])  res = max(res, sum)  }   return res }  func max(a,b int) int {  if a \u0026lt; b {  return b  }   return a } 动态规划 #  定义 dp[i] 表示以 i 为结尾的连续子数组的最大和，则很明显，dp[i] 的值受到 dp[i-1] 和 array[i] 的影响，稍微一想即可得到转态转移方程：$dp[i] = \\max (dp[i-1] + array[i], array[i])$\nfunc FindGreatestSumOfSubArray( array []int ) int {  // write code here  size := len(array)  if size == 0 {  return 0  }   res := array[0]  dp := make([]int, size)  dp[0] = array[0]  for i := 1; i \u0026lt; size; i++ {  dp[i] = max(dp[i-1]+array[i], array[i])  res = max(res, dp[i])  }   return res }  func max(a,b int) int {  if a \u0026lt; b {  return b  }   return a } "},{"id":39,"href":"/docs/algs/codingInterviews/43_%E6%95%B4%E6%95%B0%E4%B8%AD-1-%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/","title":"43. 整数中 1 出现的次数","section":"Coding Interviews","content":"Description #   输入一个整数 n ，求 1～n 这 n 个整数的十进制表示中 1 出现的次数 例如， 1~13 中包含 1 的数字有 1 、 10 、 11 、 12 、 13 因此共出现 6 次\n注意：11 这种情况算两次\n数据范围： $1 \\le n \\le 30000$ 进阶：空间复杂度 $\\Omicron(1)$ ，时间复杂度 $\\Omicron(n\\log n)$\n Solutions #  TODO\n"},{"id":40,"href":"/docs/algs/leetcode/44_wildcard_matching/","title":"44. Wildcard Matching","section":"Leetcode","content":"Description #   Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for \u0026lsquo;?\u0026rsquo; and \u0026lsquo;*\u0026rsquo; where:\n\u0026lsquo;?\u0026rsquo; Matches any single character. \u0026lsquo;*\u0026rsquo; Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial).\n Solutions #  TODO\n"},{"id":41,"href":"/docs/algs/codingInterviews/45_%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/","title":"45. 把数组排成最小的数","section":"Coding Interviews","content":"Description #   输入一个非负整数数组numbers，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 例如输入数组[3，32，321]，则打印出这三个数字能排成的最小数字为321323。 1.输出结果可能非常大，所以你需要返回一个字符串而不是整数 2.拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0\n数据范围: $0\u0026lt;=len(numbers)\u0026lt;=100$\n Solutions #  这里的解法比较巧妙，如果没有做过这个题目的话，第一次碰到应该很难做出来。在 golang 中，我们对数组排序的时候可以指定一个 less 函数，来表明我们希望的排序策略，比如说 4 \u0026lt; 5， 那么 4 应该排在 5 前面。而这里涉及到的是字符串拼接，对于 \u0026ldquo;bc\u0026rdquo; 和 \u0026ldquo;bca\u0026rdquo; 这两个字符串，一般的排序方法会把 bc 排到 bca 前面，这样就会出现 \u0026ldquo;bcbca\u0026rdquo; 这个字符，很明显这不是最小的。这里单独排序一个字符显然是不行的，我们的解决办法是对两个字符的不同拼接进行比较，这样就可以确定什么样的拼接能够放在前面，这样的拼接导致的整体字符串的字典序更小一些。\nfunc PrintMinNumber( numbers []int ) string {  // write code here  var res string \tsize := len(numbers) \tif size == 0 { \treturn res \t}  \tvar strs []string \tfor _, value := range numbers { \ts := strconv.Itoa(value) \tstrs = append(strs, s) \t}  \tsort.Slice(strs, func(i, j int) bool { \treturn strs[i] + strs[j] \u0026lt; strs[j] + strs[i] \t})  \tres = strings.Join(strs, \u0026#34;\u0026#34;) \treturn res } "},{"id":42,"href":"/docs/algs/leetcode/46_permutations/","title":"46. Permutations","section":"Leetcode","content":"Description #   Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\n Solutions #  Array(swap) #  基于交换进行 permutate 即可。\nfunc permute(nums []int) [][]int { \tvar res [][]int \tsize := len(nums) \thelper(0, size, nums, \u0026amp;res) \treturn res }  func helper(start,size int, nums []int, res *[][]int) {  if start \u0026gt;= size {  tmp := make([]int, size)  copy(tmp, nums)  *res = append(*res, tmp)  return  }    for i := start; i \u0026lt; size; i++ {  nums[i], nums[start] = nums[start], nums[i]  // 注意这里是 start + 1， 而不是 i  helper(start+1, size, nums, res)  nums[i], nums[start] = nums[start], nums[i]  } } "},{"id":43,"href":"/docs/algs/codingInterviews/46_%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"46. 把数字翻译成字符串","section":"Coding Interviews","content":"Description #   有一种将字母编码成数字的方式：\u0026lsquo;a\u0026rsquo;-\u0026gt;1, \u0026lsquo;b-\u0026gt;2\u0026rsquo;, \u0026hellip; , \u0026lsquo;z-\u0026gt;26\u0026rsquo;。 我们把一个字符串编码成一串数字，再考虑逆向编译成字符串。 由于没有分隔符，数字编码成字母可能有多种编译结果，例如 11 既可以看做是两个 \u0026lsquo;a\u0026rsquo; 也可以看做是一个 \u0026lsquo;k\u0026rsquo; 。但 10 只可能是 \u0026lsquo;j\u0026rsquo; ，因为 0 不能编译成任何结果。 现在给一串数字，返回有多少种可能的译码结果\n Solutions #  Recursive #  func solve( nums string ) int {  // write code here  var res int  size := len(nums)  if size == 0 {  return 0  }   helper(nums, \u0026amp;res)  return res }   func helper(nums string, res *int) {  size := len(nums)  if size == 0 {  *res += 1  return  }  \t// 如果开头字符是 0， 那么说明只是一次不合法的拆分在，直接返回即可  if nums[0] == \u0026#39;0\u0026#39; {  return  }   // 如果可能将连个字符放在一起，则将两个字符放在一起  if size \u0026gt;= 2 \u0026amp;\u0026amp; nums[:2] \u0026gt;= \u0026#34;10\u0026#34; \u0026amp;\u0026amp; nums[:2] \u0026lt;= \u0026#34;26\u0026#34; {  helper(nums[2:], res)  }  \t// 永远可以拆分为单个字符  helper(nums[1:], res) } Dynamic Programming #  定义 dp(i) 表示以第 i 位结尾的前缀串翻译的方案数，初始化 dp[0] = dp[1] = 1, 可以得出递推方程： $$ dp[i]=\\begin{cases} dp[i-2] + dp[i-1], \u0026amp; 10 \\le nums[i-2: i] \\le 25 \\ dp[i-1], \u0026amp; else \\end{cases} $$\n"},{"id":44,"href":"/docs/algs/codingInterviews/47_%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/","title":"47. 礼物的最大价值","section":"Coding Interviews","content":"Description #   在一个m\\times nm×n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？ 如输入这样的一个二维数组， [ [1,3,1], [1,5,1], [4,2,1] ] 那么路径 1→3→5→2→1 可以拿到最多价值的礼物，价值为12\n Solutions #  Dynamic Programming #  定义 dp[i][j] 表示在 grid[i][j] 所能得到的最大礼物值，则很明显，dp[i][j]的值要么是从左边转移得到的，要么是从上侧转移得到的，则可以得到递推方程 dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1])。base case 的话，很明显，第一行的数据只能从左边得到，第一列数据只能从上侧得到。我们可以直接复用原数组，这样还能节省一下空间开销。\nfunc maxValue( grid [][]int ) int {  // write code here  m,n := len(grid), len(grid[0]) \t// 如果我们开辟一个 (m+1) * (n+1) 的数组，那么下面这两个 for 语句就不需要了，代码可以更加简洁。  // 第一列只能来自上方  for i := 1; i \u0026lt; m; i++ {  grid[i][0] += grid[i-1][0]  }  // 第一行只能来自左边  for i := 1; i \u0026lt; n; i++ {  grid[0][i] += grid[0][i-1]  }   for i := 1; i \u0026lt; m; i++ {  for j := 1; j \u0026lt; n; j++ {  grid[i][j] = grid[i][j] + max(grid[i-1][j], grid[i][j-1])  }  }   return grid[m-1][n-1] } "},{"id":45,"href":"/docs/algs/leetcode/48_rotate_image/","title":"48. Rotate Image","section":"Leetcode","content":"Description #   You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n  You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n Solutions #  补充几个矩阵变换公式： - 主对角线对折： arr[i][j] = arr[j][i] - 副对角线对折： arr[i][j] = arr[n-j-1][n-i-1] go for i := 0; i \u0026lt; n; i++ { for j := 0; j \u0026lt; n-i; j++ { matrix[i][j], matrix[n-j-1][n-i-1] = matrix[n-j-1][n-i-1], matrix[i][j] } }  - 横向对折： arr[i][j] = arr[n-i-1][j] - 纵向对折： arr[i][j] = arr[i][n-j-1]\n// 先左右对折，再根据副对角线对折 func rotate(matrix [][]int) {  m := len(matrix)   // 左右对折  for i := 0; i \u0026lt; m; i++ {  left, right := 0, m-1  for left \u0026lt; right {  matrix[i][left], matrix[i][right] = matrix[i][right], matrix[i][left]  left++  right--  }  }   // 副对角线对折  for i := 0; i \u0026lt; m ;i++ {  for j := 0; j \u0026lt; m-i ;j++ {  matrix[i][j], matrix[m-j-1][m-i-1] = matrix[m-j-1][m-i-1], matrix[i][j]  }  }  } "},{"id":46,"href":"/docs/algs/leetcode/49_group_anagrams/","title":"49. Group Anagrams","section":"Leetcode","content":"Description #   Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n Solutions #  简单的方法就是，对具有相同字母以及字母出现次数也相同的字符串进行排序时，其排序结果都是一样的。所以可以创建一个 map，其中 key 为字符串的排序，value 为具有这样一个排序结果的字符串数组。\nfunc groupAnagrams(strs []string) [][]string { \tvar res [][]string \tm := make(map[string][]string) \tfor _, str := range strs { \tstr_splited := strings.Split(str, \u0026#34;\u0026#34;) \tsort.Strings(str_splited) \ts := strings.Join(str_splited, \u0026#34;\u0026#34;) \tm[s] = append(m[s], str) \t}  \tfor _, strs := range m { \tres = append(res, strs) \t}  \treturn res } "},{"id":47,"href":"/docs/algs/leetcode/50_powxn/","title":"50. Pow(x, n)","section":"Leetcode","content":"Description #   Implement pow(x, n), which calculates x raised to the power n (i.e., xn).\n Solutions #  Map #  可以使用快速幂以及记忆化数组，单独使用快速幂会导致超时，所以需要配合记忆化数组使用。\nfunc myPow(x float64, n int) float64 {  if x == 0 {  return 0  }  if n == 0 {  return 1  }   var negative bool  if n \u0026lt; 0 {  negative = true  n = -n  }    dict := make(map[int]float64)  dict[0], dict[1] = 1, x  res := helper(x, n, \u0026amp;dict)  if negative {  return 1 / res  }   return res }  func helper(x float64, n int, dict *map[int]float64) float64 {  if value, ok := (*dict)[n]; ok {  return value  }   res := helper(x, n/2, dict) * helper(x, n/2, dict) * helper(x, n%2, dict)  (*dict)[n] = res  return res } "},{"id":48,"href":"/docs/algs/leetcode/53_maximum_subarray/","title":"53. Maximum Subarray","section":"Leetcode","content":"Description #   Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\nA subarray is a contiguous part of an array.\n Solutions #  Kadane #  Kadane 算法，最优子结构性质，当前位置的和取决于前一个位置的子数组和以及当前元素。\n def max_subarray(arr): \tmax_sum_so_far, sum_ending_here = arr[0], arr[0] \tfor e in range(arr[1:]): \tsum_ending_here = max(e, sum_ending_here + e) \tmax_sum_so_far = max(max_sum_so_far, sum_ending_here)  \treturn max_sum_so_far 如果数组中有负数，并且允许返回长度为 0 的子数列，则该问题可以改为：\ndef max_subarray(arr): \tmax_sum_so_far, sum_ending_here = 0, 0 \tfor e in range(arr): \tsum_ending_here = max(sum_ending_here + e, e) \tmax_sum_so_far = max(max_sum_so_far, sum_ending_here) return max_sum_so_far 完整代码是：\nfunc maxSubArray(nums []int) int {  size := len(nums) \tif size == 0 { \treturn 0 \t}  \tres, curSum := nums[0], nums[0] \tfor i := 1; i \u0026lt; size; i++ { \tcurSum = max(curSum+nums[i], nums[i]) \tres = max(res, curSum) \t}  \treturn res }  func max(a,b int) int {  if a \u0026gt; b {  return a  }   return b } DP #  定义 dp[i] 表示以 i 为结尾的连续子数组的最大和，则很明显，dp[i] 的值受到 dp[i-1] 和 array[i] 的影响，稍微一想即可得到转态转移方程：$dp[i] = \\max (dp[i-1] + array[i], array[i])$\nfunc maxSubArray(nums []int) int {  // write code here  size := len(nums)  if size == 0 {  return 0  }   res := nums[0]  dp := make([]int, size)  dp[0] = array[0]  for i := 1; i \u0026lt; size; i++ {  dp[i] = max(dp[i-1]+nums[i], nums[i])  res = max(res, dp[i])  }   return res }  func max(a,b int) int {  if a \u0026lt; b {  return b  }   return a } "},{"id":49,"href":"/docs/algs/codingInterviews/53_%E6%95%B0%E5%AD%97%E5%9C%A8%E5%8D%87%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/","title":"53. 数字在升序数组中出现的次数","section":"Coding Interviews","content":"Description #   给定一个长度为 n 的非降序数组和一个非负数整数 k ，要求统计 k 在数组中出现的次数\n数据范围：$0 \\le n \\le 1000 $, $0 \\le k \\le 100$ ，数组中每个元素的值满足 $0 \\le val \\le 100$. 要求：空间复杂度 $\\Omicron(1)$，时间复杂度 $\\Omicron(\\log n)$\n Solutions #  Binary Search #  func GetNumberOfK( data []int , k int ) int {  // write code here  var res int  size := len(data)  if size \u0026lt; 1 {  return res  }   left, right := 0, size - 1  for left \u0026lt;= right {  mid := (left +right)/2  if data[mid] \u0026gt; k {  right = mid - 1  } else if data[mid] \u0026lt; k {  left = mid + 1  } else if data[mid] == k {  l,r := mid, mid  for l \u0026gt;= 0 \u0026amp;\u0026amp; data[l] == k {  l--  }   for r \u0026lt; size \u0026amp;\u0026amp; data[r] == k {  r++  }   res = r - l - 1  break  }  }   return res } "},{"id":50,"href":"/docs/algs/leetcode/54_spiral_matrix/","title":"54. Spiral Matrix","section":"Leetcode","content":"Description #   Given an m x n matrix, return all elements of the matrix in spiral order.\n Solutions #  其实就是顺时针旋转打印数组。\nfunc spiralOrder(matrix [][]int) []int {  var res []int  m, n := len(matrix), len(matrix[0])   up, bottom, left, right := 0, m-1, 0, n - 1  for up \u0026lt;= bottom \u0026amp;\u0026amp; left \u0026lt;= right {  for i := left; i \u0026lt;= right; i++ {  res = append(res, matrix[up][i])  }  up++  if up \u0026gt; bottom {  break  }   for i := up; i \u0026lt;= bottom; i++ {  res = append(res, matrix[i][right])  }   right--  if right \u0026lt; left {  break  }   for i := right; i \u0026gt;= left; i-- {  res = append(res, matrix[bottom][i])  }  bottom--  if bottom \u0026lt; up {  break  }   for i := bottom; i \u0026gt;= up;i-- {  res = append(res, matrix[i][left])  }  left++  if left \u0026gt; right {  break  }  }   return res } "},{"id":51,"href":"/docs/algs/leetcode/55_jump_game/","title":"55. Jump Game","section":"Leetcode","content":"Description #   You are given an integer array nums. You are initially positioned at the array\u0026rsquo;s first index, and each element in the array represents your maximum jump length at that position.\nReturn true if you can reach the last index, or false otherwise.\n Solutions #  Recursive #  很容易想到递归的办法，但是也很容易就超时了 :)\nfunc canJump(nums []int) bool { \tsize := len(nums)  if helper(0, size, nums) {  return true  }   return false  }  func helper(start int, size int, nums []int) bool {  if start \u0026gt;= size -1 {  return true  }   for i := 1; i \u0026lt;= nums[start]; i++ {  if helper(start+i, size, nums) {  return true  }  }   return false } Greedy #  使用一个变量 remianed 表示当前剩余的跳力（指从当前节点最多还可以跳几步），然后使用一个值 maxDst 表示当前能够跳到的最远距离。每遍历到一个节点，判断是否能跳到当前节点，也就是 i 是否大于 Dst，如果大于，则说明跳不到当前节点，则可以直接返回 false； 否则说明能跳到当前节点，然后根据当前节点的跳力更新当前节点的最大跳力以及能跳到的最远距离。\nfunc canJump(nums []int) bool {  size := len(nums)  var remained, maxDst int  for i := 0; i \u0026lt; size; i++ { \t// 跳不到当前节点  if i \u0026gt; maxDst {  return false  }  \t// 剩余的最大跳力  remained = max(nums[i], remained) \t// 从当前节点跳是否能跳更远的距离  maxDst = max(maxDst, i + remained)  remained--  }    return true }   func max(a, b int) int {  if a \u0026lt; b {  return b  }   return a } DP #  维护一个dp数组，其中dp[i]表示到达i位置所剩余的跳力，若到达某个位置时跳力为负，则说明无法到达该位置。\n当前位置的跳力跟上一个位置的跳力以及上一个位置剩余的跳力有关，所以当前位置的剩余跳力和当前位置新的跳力中较大的那个数决定了当前能达到的最远距离，而下一个位置的剩余跳力等于当前位置的跳力减去1，所以 dp[i] = max(dp[i-1], nums[i-1]) - 1。如果当前dp为负，则说明无法抵达当前位置，返回false。\nfunc canJump(nums []int) bool { \tsize := len(nums) \tdp := make([]int, size) \tfor i := 1; i \u0026lt; size; i++ { \tdp[i] = max(dp[i-1], nums[i-1]) - 1 \tif dp[i] \u0026lt; 0 { \treturn false \t} \t}  \treturn true }  func max(a, b int) int {  if a \u0026lt; b {  return b  }   return a } "},{"id":52,"href":"/docs/algs/leetcode/56_merge_intervals/","title":"56. Merge Intervals","section":"Leetcode","content":"Description #   Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n Solutions #  典型的区间合并问题。\n首先先对区间按照开始时间从小到大进行排序，然后使用一个指针 cur 指向当前 intervals 数组遍历到的位置，使用一个指针 tail 指向 res 数组最后一个元素。然后开始对 intervals 数组进行遍历，如果当前遍历到的区间跟 res 数组的最后一个区间没有重叠，则直接将这个区间插入 res 数组，然后 tail 自增；否则的话就合并区间，更新 res[tail] 的结束时间；每次遍历结束，cur 自增。\nfunc merge(intervals [][]int) [][]int {  var res [][]int \tsize := len(intervals)  if size \u0026lt;= 1 {  return intervals  }  sort.Slice(intervals, func(i,j int)bool {  return intervals[i][0] \u0026lt; intervals[j][0]  })   res = append(res, intervals[0])  var tail int  cur := 1  for cur \u0026lt; size {  // 如果开始时间相等，或者 cur 的开始时间小于 tail 的结束时间，则说明有重叠，则需要合并  if intervals[cur][0] \u0026lt;= res[tail][1] || intervals[cur][0] == res[tail][0]{  res[tail][1] = max(res[tail][1], intervals[cur][1])  } else {  // 如果没有重叠，则直接插入  res = append(res, intervals[cur])  tail++  }    cur++  }    return res } //*************** util **************** func min(a,b int) int {  if a \u0026lt; b {  return a  }    return b }   func max(a,b int) int {  if a \u0026lt; b {  return b  }   return a } "},{"id":53,"href":"/docs/algs/codingInterviews/56_%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/","title":"56. 数组中只出现一次的两个数字","section":"Coding Interviews","content":"Description #   一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。\n数据范围：数组长度 $2\\le n \\le 1000$，数组中每个数的大小 $0 \u0026lt; val \\le 1000000$ 要求：空间复杂度 $\\Omicron(1)$，时间复杂度 $\\Omicron(n)$\n提示：输出时按非降序排列。\n Solutions #  Hash Table #  建立一个哈希表，对每个出现的数字计数，最后将只出现一次的数字返回即可。\n// 使用哈希表 func FindNumsAppearOnce( array []int ) []int {  dict := make(map[int]int)  for _, value := range nums {  dict[value]++  }   var res []int  for value, count := range dict {  if count == 1 {  res = append(res, value)  }  }   if len(res) == 2 \u0026amp;\u0026amp; res[1] \u0026lt; res[0] {  res[0], res[1] = res[1], res[0]  }   return res } 位运算 #  如果只要一个数字是不同的，那么很容易计算，只需要直接对整个数组计算异或值即可，这个异或值即为我们所求。但是这里有两个不同值，那么怎么办呢？方法就是对他们进行分组（这里不需要两个组的元素数量相同），将两个不同的值分到不同的组里面，而且还要把相同的值分到同一个组里面，这样分别对两个不同的组进行异或计算，得到的两个值就是我们所求的两个数。\n那么怎么分组呢？关键是要找出两个数字之间的差异，这里可以使用异或来进行操作。两个不同的数字进行异或，他们对应的某一位如果不同，那么对应的异或结果的那一位就是 1，我们可以使用这个特性来对整个数组进行分组：首先算出整个数组的异或值，然后找出这个异或值的第一个二进制值为 1 的位，然后使用这个位代表的值来对整个数组进行分组，并对每个分组分别计算异或值，这样就可以得到我们所求的两个值。\nfunc FindNumsAppearOnce( array []int ) []int {  // write code here  var xor int  // 找到最终的异或值  for _, value := range array {  xor ^= value  }   // 找到异或结果中二进制为 1 的那一位  t := 1  for t \u0026amp; xor == 0 {  t \u0026lt;\u0026lt;= 1  }   // 这里赋值为 0 并不会影响异或结果  var a,b int  // 根据 t 将数组分为两个分组  for _, value := range array {  if value \u0026amp; t == 0 {  a ^= value  } else {  b ^= value  }  }   if a \u0026lt; b {  return []int{a, b}  } else {  return []int{b, a}  }  } "},{"id":54,"href":"/docs/algs/codingInterviews/57_%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/","title":"57. 和为 S 的两个数字","section":"Coding Interviews","content":"Description #   输入一个升序数组 array 和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，返回任意一组即可，如果无法找出这样的数字，返回一个空数组即可。\n数据范围: $0 \\le len(array) \\le 10^5$ ,$1 \\le array[i] \\le 10^6$\n Solutions #  func FindNumbersWithSum( array []int , sum int ) []int {  // write code here  size := len(array)  if size \u0026lt;= 1 {  return nil  }   left, right := 0, size -1  for left \u0026lt; right {  if array[left] + array[right] == sum {  return []int{array[left], array[right]}  } else if array[left] + array[right] \u0026lt; sum {  left++  } else if array[left] + array[right] \u0026gt; sum {  right--  }  }   return nil } "},{"id":55,"href":"/docs/algs/codingInterviews/58_%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"58. 左旋转字符串","section":"Coding Interviews","content":"Description #   汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列 S ，请你把其循环左移 K 位后的序列输出。例如，字符序列 S = ”abcXYZdef” , 要求输出循环左移 3 位后的结果，即 “XYZdefabc”\n数据范围：输入的字符串长度满足 $0 \\le len \\le 100$， $0 \\le n \\le 100$ 进阶：空间复杂度 $\\Omicron(n)$ ，时间复杂度 $\\Omicron(n)$\n Solutions #  字符串拼接 #  func LeftRotateString( str string , n int ) string {  // write code here  size := len(str)  if size == 0 || n%size == 0 {  return str  }  n %= size // n 可能会大于 size，所以需要取余   left, right := str[:n], str[n:]  return right+left } 字符串翻转 #  先将整个字符串翻转一次，然后再将从左边开始数的 size - n 个字符翻转一次，最后再将右边剩余的 n 个字符翻转一次。\nfunc LeftRotateString( str string , n int ) string {  // write code here  size := len(str)  if size == 0 || n%size == 0 {  return str  }  n %= size // n 可能会大于 size，所以需要取余   rs := []rune(str)  for i,j := 0, size-1; i \u0026lt; j; i,j = i+1, j-1 {  rs[i],rs[j] = rs[j], rs[i]  }   for i,j := 0, size-n-1; i \u0026lt; j; i,j = i+1, j-1 {  rs[i],rs[j] = rs[j], rs[i]  }   for i, j := size-n, size-1; i \u0026lt; j; i,j = i+1, j-1 {  rs[i], rs[j] = rs[j], rs[i]  }  return string(rs) } "},{"id":56,"href":"/docs/algs/codingInterviews/59_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/","title":"59. 滑动窗口的最大值","section":"Coding Interviews","content":"Description #   给定一个长度为 n 的数组 nums 和滑动窗口的大小 size ，找出所有滑动窗口里数值的最大值。\n例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。\n Solutions #  Dequeue #  使用一个单调递减的单调队列来做。维持一个最大长度为 size 的单调队列，每当遍历到当前元素 i，如果当前元素 nums[i] 比队列尾部元素要大，则不断将队列尾部元素出队，直到队列为空或者当前元素 nums[i] 比队尾元素要小，然后将当前元素入队。这样的话，队列中要么维持着一个最大值，要么顶多维持着 size 个相对递减的连续值。然后检查队首元素是否过期，如果过期，则将队首元素出队，因为我们每次顶多入队一个，所以每次遍历也顶多只会有一个元素过期。最后检查当前窗口长度是否达到 size，如果达到了，则将队列首部元素入队即可。\n// 可以使用单调递减的单调队列来实现 func maxInWindows( num []int , size int ) []int {  // write code here  var res []int  n := len(num)  if size \u0026lt; 1 || n \u0026lt; 1 {  return res  }   var queue []int  for i := 0; i \u0026lt; n; i++ {  // 如果当前遍历到的元素比队尾元素要大，则不断将队尾元素出队  curLen := len(queue)  for curLen \u0026gt; 0 \u0026amp;\u0026amp; num[i] \u0026gt; num[queue[curLen-1]] {  curLen--  queue = queue[:curLen]  }   queue = append(queue, i) \t// 如果当前队首元素滑出左边界，则将其删除  if queue[0] + size \u0026lt;= i {  queue = queue[1:]  }  \t// 如果当前已经构成了一个有效的滑动窗口，则将当前最大值存入结果  if size \u0026lt;= i+1 {  res = append(res, num[queue[0]])  }  }   return res } "},{"id":57,"href":"/docs/algs/codingInterviews/61_%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/","title":"61. 扑克牌顺子","section":"Coding Interviews","content":"Description #   现在有2副扑克牌，从扑克牌中随机五张扑克牌，我们需要来判断一下是不是顺子。 有如下规则：\n A为1，J为11，Q为12，K为13，A不能视为14 大、小王为 0，0可以看作任意牌 如果给出的五张牌能组成顺子（即这五张牌是连续的）就输出true，否则就输出false。 4.数据保证每组5个数字，每组最多含有4个零，数组的数取值为 [0, 13]  要求：空间复杂度 $\\Omicron(1)$，时间复杂度 $\\Omicron(n \\log n)$，本题也有时间复杂度 $\\Omicron(n)$ 的解法\n Solutions #  建立一个大小为14 的数组，记录每只牌出现的次数。然后从 1 开始遍历这个数组直到第一只计数值为 1 的牌，如果任意一只牌的计数值大于 1，则返回 false；然后从这只牌开始模拟，如果以这只牌开始的五只牌都能构成顺子，则返回 true；否则\nfunc IsContinuous( numbers []int ) bool {  // write code here \t// 记录每只牌出现的次数  emu := make([]int, 14)  for _, value := range numbers {  emu[value]++  }   for i := 1; i \u0026lt; 14; i++ { \t// 任意一只牌的出现次数大于 1，则无法构成顺子  if emu[i] \u0026gt; 1 {  return false  }  \t// 如果这只牌只出现了一次，那么检查能不能构成顺子  if emu[i] == 1 { \t// 顶多检查五只牌  for j := i; i+5 \u0026lt; 14 \u0026amp;\u0026amp; j \u0026lt; i+5; j++ { \t// 任何一只牌出现次数大于 1，则返回 false  if emu[j] \u0026gt; 1 {  return false  }  \t// 如果当前牌只出现了一次，则继续遍历  if emu[j] == 1 {  continue  } \t// 如果当前牌没有出现，则看 0 是否还有剩余，如果有，则继续遍历；如果没有，则返回 false  if emu[j] == 0 {  if emu[0] \u0026gt; 0 {  emu[0]--  continue  } else {  return false  }  }  }  \t// 以 i 开头的牌组可以成为顺子，返回 true  return true  }  }  \t// 没有找到任何一个顺子，返回 false  return false } "},{"id":58,"href":"/docs/algs/leetcode/62_unique_paths/","title":"62. Unique Paths","section":"Leetcode","content":"Description #   There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\nGiven the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\nThe test cases are generated so that the answer will be less than or equal to 2 * 109.\n Solutions #  DP #  假设 dp[i][j] 表示到达[i,j] 这个位置的路径数，则很明显，dp[i][j] 的值只会受到 dp[i-1][j] 和 dp[i][j-1] 影响，进而可以进一步得到递推公式 dp[i][j] = dp[i-1][j] + dp[i][j-1]。 base case 的话，第一行第一列的路径应该为 1， 即 dp[i][0] = dp[0][j] = 1。最后 dp[m-1][n-1]即为所求。\nfunc uniquePaths(m int, n int) int { \t// corner case  if m == 1 || n == 1 {  return 1  }   dp := make([][]int, m)  for idx, _ :=range dp {  dp[idx] = make([]int, n)  }   //corner case  for i := 0; i \u0026lt; m; i++ {  dp[i][0] = 1  }   for i := 0; i \u0026lt; n; i++ {  dp[0][i] = 1  }   for i := 1; i \u0026lt; m ; i++ {  for j := 1; j \u0026lt; n; j++ {  dp[i][j] = dp[i-1][j] + dp[i][j-1]  }  }   return dp[m-1][n-1] } Math #  这里也可使用排列组合的方法来做。对于一个 m 行 n 类的矩阵，要想从左上角到达右下角，那么必须需要向下走 m-1 步，向右走 n-1 步， 那么也就是说，我们需要从 m-1+n-2 的步数里面，跳出 m -1 个向下的步数和 n-1 个向右的步数。既然想到这里，那么这个问题就很好解决了，直接使用排列组合公式即可。\nfunc uniquePaths(m int, n int) int { \t// corner case  if m == 1 || n == 1 {  return 1  }   // 确保 n 是较小的那一个，不然下面的算法会导致溢出，进而导致错误的结算结果  if n \u0026gt; m {  n,m = m, n  }   // 计算排列组合 C_n_(m-1+n-1)  res := 1  for i := 0; i \u0026lt; n-1; i++ {  res *= (n-1+m-1-i)  res /= (i+1)  }   return res } "},{"id":59,"href":"/docs/algs/codingInterviews/62_%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0/","title":"62. 圆圈中最后剩下的数","section":"Coding Interviews","content":"Description #   每年六一儿童节，牛客都会准备一些小礼物和小游戏去看望孤儿院的孩子们。其中，有个游戏是这样的：首先，让 n 个小朋友们围成一个大圈，小朋友们的编号是0~n-1。然后，随机指定一个数 m ，让编号为0的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始，继续0\u0026hellip; m-1报数\u0026hellip;.这样下去\u0026hellip;.直到剩下最后一个小朋友，可以不用表演，并且拿到牛客礼品，请你试着想下，哪个小朋友会得到这份礼品呢？\n Solutions #  循环链表模拟 #  可以将元素串成一个循环链表，然后进行遍历即可。\n使用数组模拟 #  用数组求解的基本思想就是用一个一维数组去标识这 n 个人的状态，默认全为 1 ，也就是都在圈子内，当数到 m 的人出圈之后，标识置为 0（就是出圈了），同时报数器清 0，下一个人要从 1 开始。在每次报数之前要判断他是否在圈子内（也就是他的标识是否为 1 ），如果在圈子里面才会继续报数。定义一个变量记录出圈的人数， 出圈的人数等于 n-1 时，则游戏结束。\n"},{"id":60,"href":"/docs/algs/codingInterviews/63_%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A5%BD%E6%97%B6%E6%9C%BA/","title":"63. 买卖股票的最好时机","section":"Coding Interviews","content":"Description #   假设你有一个数组prices，长度为n，其中prices[i]是股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益 1.你可以买入一次股票和卖出一次股票，并非每天都可以买入或卖出一次，总共只能买入和卖出一次，且买入必须在卖出的前面的某一天 2.如果不能获取到任何利润，请返回0 3.假设买入卖出均无手续费\n Solutions #  一次扫描，扫描过程中维护当前扫描到的数字的最小值，然后不断的用当前扫描到的数字减去这个最小得到一个差，取这个差的最大值即可。\nfunc maxProfit( prices []int ) int {  // write code here  var res int  size := len(prices)  if size == 0 {  return res  }   curMin := prices[0]  for _, price := range prices {  if price \u0026lt; curMin {  curMin = price  }   res = max(res, price-curMin)  }   return res } "},{"id":61,"href":"/docs/algs/codingInterviews/65_%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/","title":"65. 不用加减乘除做加法","section":"Coding Interviews","content":"Description #   写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。\n数据范围：两个数都满足 $-10 \\le n \\le 1000$ 进阶：空间复杂度 $\\Omicron(1)$，时间复杂度 $\\Omicron(1)$\n Solutions #  Bit Manipulation #  使用位与操作表示两数相加的进位（需要左移一位）， 使用异或操作表示两数相加的和，这样就可以递归计算，递归终止条件是进位为 0.\nfunc Add( num1 int , num2 int ) int {  // write code here  if num1 == 0 {  return num2  }   carry := (num1 \u0026amp; num2) \u0026lt;\u0026lt; 1  sum := num1 ^ num2  return Add(carry, sum) } "},{"id":62,"href":"/docs/algs/leetcode/66_plus_one/","title":"66. Plus One","section":"Leetcode","content":"Description #   You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0\u0026rsquo;s.\nIncrement the large integer by one and return the resulting array of digits.\n Solutions #  简单题，直接计算即可。\nfunc plusOne(digits []int) []int {  size := len(digits)  if size == 0 {  return digits  }    carry := 1  for i := size-1; i \u0026gt;= 0; i-- {  sum := digits[i] + carry  carry = sum / 10  digits[i] = sum % 10  }   if carry \u0026gt; 0 {  digits = append([]int{carry}, digits...)  }   return digits } "},{"id":63,"href":"/docs/algs/codingInterviews/67_%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%88%90%E6%95%B4%E6%95%B0atoi/","title":"67. 把字符串转成整数(atoi)","section":"Coding Interviews","content":"Description #   写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。传入的字符串可能有以下部分组成: 1.若干空格 2.（可选）一个符号字符（\u0026rsquo;+\u0026rsquo; 或 \u0026lsquo;-\u0026rsquo;） 3. 数字，字母，符号，空格组成的字符串表达式 4. 若干空格\n转换算法如下: 1.去掉无用的前导空格 2.第一个非空字符为+或者-号时，作为该整数的正负号，如果没有符号，默认为正数 3.判断整数的有效部分： 3.1 确定符号位之后，与之后面尽可能多的连续数字组合起来成为有效整数数字，如果没有有效的整数部分，那么直接返回0 3.2 将字符串前面的整数部分取出，后面可能会存在存在多余的字符(字母，符号，空格等)，这些字符可以被忽略，它们对于函数不应该造成影响 3.3 整数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231的整数应该被调整为 −231 ，大于 231 − 1 的整数应该被调整为 231 − 1 4.去掉无用的后导空格\n Solutions #  "},{"id":64,"href":"/docs/algs/codingInterviews/66_%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/","title":"67. 构建乘积数组","section":"Coding Interviews","content":"Description #   给定一个数组 A[0,1,\u0026hellip;,n-1] ,请构建一个数组 B[0,1,\u0026hellip;,n-1] ,其中 B 的元素 B[i]=A[0]A[1]\u0026hellip;*A[i-1]A[i+1]\u0026hellip;*A[n-1]（除 A[i] 以外的全部元素的的乘积）。程序中不能使用除法。（注意：规定 B[0] = A[1] * A[2] * \u0026hellip; * A[n-1]，B[n-1] = A[0] * A[1] * \u0026hellip; * A[n-2]） 对于 A 长度为 1 的情况，B 无意义，故而无法构建，用例中不包括这种情况。\n数据范围：$1 \\le n \\le 10$ ，数组中元素满足 $|val| \\le 10$\n Solutions #  Array #  使用两个数组，一个数组left从左到右扫描，left[i] 表示从 A 数组开始位置到 i 位置之前的元素的累乘；一个数组 right 从右向左扫描， right[i] 表示从数组最后一个位置到 i 位置的累乘。最后复用 left ，left[i] *= right[i]， left 即为所求。\nfunc multiply( A []int ) []int {  // write code here  size := len(A)  if size \u0026lt;= 1 {  return nil  }   left, right := make([]int, size), make([]int, size)  left[0], right[size-1] = 1, 1  for i := 1; i \u0026lt; size; i++ {  left[i] = A[i-1] * left[i-1]  }   for i := size-2; i \u0026gt;= 0; i-- {  right[i] = A[i+1] * right[i+1]  }   for i := 0; i \u0026lt; size; i++ {  left[i] *= right[i]  }   return left } "},{"id":65,"href":"/docs/algs/codingInterviews/68_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","title":"68. 二叉搜索树的最近公共祖先","section":"Coding Interviews","content":"Description #   给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n Solutions #  Recursive #  如果当前节点的值比要查找的值的最小值还要小，说明应该往当前节点的右节点进行查找；如果当前节点的值比要查找的值的最大值还要大，说明应该往当前节点的左子树进行查找。否则说明当前节点处于要查找的值之间，那么当前节点就是我们要查找的最近公共祖先。\nfunc lowestCommonAncestor( root *TreeNode , p int , q int ) int {  // write code here  if root == nil {  return -1  }   // 保持 p 比 q 要小  if p \u0026gt; q {  p,q = q, p  }   res := lcaHelper(root, p, q)  return res.Val }  func lcaHelper(root *TreeNode, mn,mx int) *TreeNode {  if root.Val \u0026gt; mx {  return lcaHelper(root.Left, mn, mx)  } else if root.Val \u0026lt; mn {  return lcaHelper(root.Right, mn, mx)  } else {  return root  } } "},{"id":66,"href":"/docs/algs/leetcode/69_sqrtx/","title":"69. Sqrt(x)","section":"Leetcode","content":"Description #   Given a non-negative integer x, compute and return the square root of x.\nSince the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.\nNote: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.\n Solutions #  使用二分法快速进行快速查找：\nfunc mySqrt(x int) int {  if x \u0026lt;= 1 {  return x  }   low, high := 0, x  for low \u0026lt; high {  mid := (low+high)/2  if mid * mid == x {  return mid  } else if mid * mid \u0026gt; x {  high = mid  } else {  low = mid + 1  }  }    return high - 1 } "},{"id":67,"href":"/docs/algs/leetcode/70_climing_stairs/","title":"70. Climbing Stairs","section":"Leetcode","content":"Descriptioin #   You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n Solutions #  斐波那契数列问题，不多说。\nfunc climbStairs(n int) int {  if n \u0026lt;= 2 {  return n  }  FMinusOne, FMinusTwo := 2, 1  for i := 3; i \u0026lt;= n; i++ {  fn := FMinusOne + FMinusTwo  FMinusTwo = FMinusOne  FMinusOne = fn   }   return FMinusOne } "},{"id":68,"href":"/docs/algs/codingInterviews/70_%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/","title":"70. 矩形覆盖","section":"Coding Interviews","content":"Description #   我们可以用 21 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 21 的小矩形无重叠地覆盖一个 2*n 的大矩形，从同一个方向看总共有多少种不同的方法？\n数据范围：$0 \\le n \\le 38$ 进阶：空间复杂度 $\\Omicron(1)$ ，时间复杂度 $\\Omicron(n)$\n注意：约定 n == 0 时，输出 0\n Solutions #  举例可以发现这其实也是个斐波那契数列问题。\nfunc rectCover( number int ) int {  // write code here  if number \u0026lt;= 3 {  return number  }   NMinusTwo, NMinusOne := 2, 3  for i := 4; i \u0026lt;= number; i++ {  N := NMinusOne + NMinusTwo  NMinusTwo = NMinusOne  NMinusOne = N  }   return NMinusOne } "},{"id":69,"href":"/docs/algs/codingInterviews/69_%E8%B7%B3%E5%8F%B0%E9%98%B6/","title":"70. 跳台阶","section":"Coding Interviews","content":"Description #   一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。\n数据范围：$1 \\leq n \\leq 40$ 要求：时间复杂度：$\\Omicron(n)$ ，空间复杂度： $\\Omicron(1)$\n Solutions #  动态规划 #  func jumpFloor( number int ) int {  // write code here  if number \u0026lt;= 1 {  return number  }   NMinusTwo, NMinusOne := 0, 1  for i := 1; i \u0026lt;= number; i++ {  n := NMinusOne + NMinusTwo  NMinusTwo = NMinusOne  NMinusOne = n  }   return NMinusOne } "},{"id":70,"href":"/docs/algs/codingInterviews/71_%E8%B7%B3%E5%8F%B0%E9%98%B6%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98/","title":"71. 跳台阶扩展问题","section":"Coding Interviews","content":"Description #   一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶(n为正整数)总共有多少种跳法。\n Solutions #  Math #  其实可以通过举例来发现规律: $f(n) = 2 * f(n-1) (n \u0026gt; 2)$，如果 $0 \\le n \\le 2$，则直接返回 n 即可。\nfunc jumpFloorII( number int ) int {  // write code here  if number \u0026lt;= 2 {  return number  }   return int(math.Pow(2, float64(number-1))) } "},{"id":71,"href":"/docs/algs/leetcode/73_set_matrix_zeroes/","title":"73. Set Matrix Zeroes","section":"Leetcode","content":"Descriptioin #   Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0\u0026rsquo;s.\nYou must do it in place.\n Solutions #  这里需要注意的是，因为要求不使用额外的内存空间，所以我们就要有这种充分利用原有空间的觉悟。这里的思想是，先检查第一行第一列是否有 0，如果有，则将相应的标志设置为 true，然后使用第一行和第一列来做标记。从第二行第二列开始遍历数组，当 matrix[i][j] = 0 时，则将该行对应的第一个数设置为 0，将该列对应的第一个数设置为 0。遍历结束之后再遍历一次数组，也是从第一行和第一列开始，如果改行或者该列的第一个元素为 0， 则将相应的相应的格子设置为 0.遍历结束后，再根据刚开始设置的行 flag 和列 flag 判断是否应该将第一行和第一列设置为 0.\nfunc setZeroes(matrix [][]int) {  m, n := len(matrix), len(matrix[0])  var rowZero, colZero bool   // 检查第一列是否包含 0  for i := 0; i \u0026lt; m ;i++ {  if matrix[i][0] == 0 {  colZero = true  break  }  }   // 检查第一行是否包含 0  for i := 0; i \u0026lt; n; i++ {  if matrix[0][i] == 0 {  rowZero = true  break  }  }    // 检查剩余行和列是否包含 0，如果包含，则将相应的第一行位置设为 0，第一列位置设为 0  for i := 1; i \u0026lt; m ;i++ {  for j := 1; j \u0026lt; n; j++ {  if matrix[i][j] == 0 {  matrix[i][0] = 0  matrix[0][j] = 0  }  }  }   // 根据第一行第一列的检测结果，将相应的行和列设置为 0  for i := 1; i \u0026lt; m; i++ {  for j := 1; j \u0026lt; n; j++ {  if matrix[i][0] == 0 || matrix[0][j] == 0 {  matrix[i][j] = 0  }  }  }   // 如果第一行有 0， 则将第一行设置为 0  if rowZero {  for i := 0; i \u0026lt; n; i++ {  matrix[0][i] = 0  }  }   // 如果第一列有 0， 则将第一列设置为 0  if colZero {  for i := 0; i \u0026lt; m ;i++ {  matrix[i][0] = 0  }  } } "},{"id":72,"href":"/docs/algs/codingInterviews/73_%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97/","title":"73. 翻转单词序列","section":"Coding Interviews","content":"Description #   牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“nowcoder. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a nowcoder.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？\n Solutions #  先翻转整个句子，然后再针对每个空格分割的单词单独翻转。\nfunc ReverseSentence( str string ) string {  // write code here  size := len(str)  if size \u0026lt;= 1 {  return str  }   runes := []rune(str)  size = len(runes)  // 先翻转整个字符串  for left,right := 0, size-1; left \u0026lt; right; left,right = left+1, right-1 {  runes[left],runes[right] = runes[right], runes[left]  }   // 再翻转这个字符串里的每个单词  var left, right int  for right \u0026lt;= size {  for right \u0026lt; size \u0026amp;\u0026amp; runes[right] != \u0026#39; \u0026#39; {  right++  }    for i,j := left, right-1; i \u0026lt; j \u0026amp;\u0026amp; right \u0026lt;= size; i,j = i+1, j-1 {  runes[i], runes[j] = runes[j], runes[i]  }   left,right = right+1, right+1  }   return string(runes) } "},{"id":73,"href":"/docs/algs/codingInterviews/74_%E5%92%8C%E4%B8%BA-S-%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/","title":"74. 和为 S 的连续正数序列","section":"Coding Interviews","content":"Description #   小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列?\n数据范围：$0 \u0026lt; n \\le 100$ 进阶：时间复杂度 $\\Omicron(n)$\n Solutions #  Sliding Window #  从某一个数字开始的连续序列和等于目标数如果有，只能有一个，于是我们可以用这个性质来使区间滑动。\n使用滑动窗口，left 指向窗口左边，right 指向窗口右边，初始时 left 和 right 分别等于 1 和 2.然后计算 [left, right] 这个区间的数字的和，如果和刚好等于 sum，则将这些数字存入 res；如果和大于 sum，说明窗口中元素太多了，需要收缩左窗口；如果和小于 sum，说明窗口中元素太少了，需要收缩右窗口。\nfunc FindContinuousSequence( sum int ) [][]int {  // write code here  var res [][]int  left, right := 1, 2  for left \u0026lt; right {  s := (left+right) * (right - left+1)/2  if s == sum {  var tmp []int  for i := left; i \u0026lt;= right; i++ {  tmp = append(tmp, i)  }   res = append(res, tmp)  left++  } else if s \u0026gt; sum {  left++  } else if s \u0026lt; sum {  right++  }  }   return res } "},{"id":74,"href":"/docs/algs/leetcode/75_sort_colors/","title":"75. Sort Colors","section":"Leetcode","content":"Description #   Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library\u0026rsquo;s sort function.\n Solutions #  其实这里应该用任意的一个排序算法都可以。\n冒泡排序的思路 #  参考冒泡排序算法。\n// 方法 1， 冒泡排序的思路 func sortColors(nums []int) {  size := len(nums)  for i := size -1; i \u0026gt; 0; i-- {  for j := 0; j \u0026lt; i; j++ {  if nums[j] \u0026gt; nums[j+1] {  nums[j], nums[j+1] = nums[j+1], nums[j]  }  }  } } 计数排序的思路 #  func sortColors(nums []int) {  colors := make([]int, 3)  for _, color := range nums {  colors[color]++  }   var cur int  for i := 0; i \u0026lt; 3; i++ {  for j := 0; j \u0026lt; colors[i]; j++ {  nums[cur] = i  cur++  }  } } "},{"id":75,"href":"/docs/algs/codingInterviews/75_%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/","title":"75. 字符流中第一个不重复出现的字符","section":"Coding Interviews","content":"Description #   请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 \u0026ldquo;go\u0026rdquo; 时，第一个只出现一次的字符是 \u0026ldquo;g\u0026rdquo; 。当从该字符流中读出前六个字符 “google\u0026quot; 时，第一个只出现一次的字符是\u0026quot;l\u0026quot;。\n数据范围：字符串长度满足 $1 \\le n \\le 1000$ ，字符串中出现的字符一定在 ASCII 码内。 进阶：空间复杂度 $\\Omicron(n)$ ，时间复杂度 $\\Omicron(n)$\n Solutions #  var dict = make(map[byte]int) var bs []byte func Insert(ch byte) { \tbs = append(bs, ch)  dict[ch]++ }  func FirstAppearingOnce() byte {  for _, ch := range bs {  if cnt, _ := dict[ch]; cnt == 1 {  return ch  }  }   return byte(\u0026#39;#\u0026#39;) } "},{"id":76,"href":"/docs/algs/leetcode/76_minimum_window_substring/","title":"76. Minimum Window Substring","section":"Leetcode","content":"Description #   Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \u0026ldquo;\u0026rdquo;.\nThe testcases will be generated such that the answer is unique.\nA substring is a contiguous sequence of characters within the string.\n Solutions #  Sliding Window #  这里应该很容易可以看出需要使用滑动窗口来做，但是与一般的滑动窗口不同的是，这里的滑动窗口中可以包含一些不在字符串 t 中的字符。另外还需要注意的是，窗口中字符的出现顺序不需要和 t 一致，但是出现次数需要一致。\n首先应该很容易能够想到的是，需要一个 map 来扫一遍 t，记录 t 中出现的字符的个数。而问题的难点在于如何维持窗口，并保证t 中的字符都出现在窗口内。 其实在维护这个滑动窗口的过程中，我们可以完全无视那些没有出现在 t 中的字符，这些字符在窗口右边界扩张的时候可以跳过，在左边界收缩的时候也可以跳过。 那么我们先扫描一遍 t，统计每个字符出现的个数，将其存到字典 dict 中。然后初始化一个 left = 0，表示滑动窗口左边界；我们还需要一个 minLen，初始化为最大值，表示包含 t 中所有字符的滑动窗口的最小长度；我们还需要一个变量 cnt， 表示当前滑动窗口中已经匹配到的 t 中字符个数。 接着开始遍历 s 中的每个字符，这相当于扩展滑动窗口右边界。对于每个遍历到的字符，在 dict 中减去该字符的出现次数，减去之后如果该字符的出现次数仍然大于等于 0，则说明这个出现在滑动窗口中的字符 c 是出现在 t 中的，则 cnt 加 1。 这里忽略了那些出现在滑动窗口中但是没有出现在 t 中的字符，对于这些字符，减去 1 之后，dict 对该字符的计数小于 0，并不会对 cnt 产生影响。\n一旦 cnt 等于 t 长度，说明此时 t 中的所有字符都已经出现在了滑动窗口中，那么接下来就应该收缩窗口，找到能包含 t 中所有字符的最小窗口。需要收缩右边界吗？答案是不需要，因为我们在 cnt 等于 t 长度的时候才停下来，这个时候滑动窗口刚刚才匹配了 t 中最后一个字符，所以右边是没有冗余字符的，不需要收缩右边界。 但是对于左边界，是有可能会出现冗余的，于是我们就需要收缩左边界。那么怎么收缩呢？首先需要明确的是，我们收缩的目的是为了祛除左边界中的冗余字符，那么就是说，在收缩左边界的过程中，滑动窗口中已经匹配的字符数 cnt 应该不受影响，其值应该正好等于 t 的长度。\n收缩左边界的过程中，如果发现 minLen 比 i - left + 1还要长了，那么说明我们抛弃了更多的冗余字符，找到了可以包含 t 中全部字符的更小的滑动窗口，那么更新结果 res 。在收缩的过程中，因为左边界移动了，所以要把 dict 中字符补充回来，所以需要对字符的出现次数加 1；如果加 1 之后，该字符的出现次数大于等于 1 了，那么说明这个字符是出现在 t 中的字符，这次收缩影响到了滑动窗口中对 t 所有字符的计数值 cnt，则 cnt 需要减去 1. 最后返回\nfunc minWindow(s string, t string) string {  m,n := len(s), len(t)  var res string  minLen, left, cnt := math.MaxInt, 0, 0   // 统计 t 中每个字符出现次数  dict := make(map[byte]int)  for idx, _ := range t {  dict[t[idx]]++  }   // 右边界不断扩张  for i := 0; i \u0026lt; m; i++ {  // 如果该字符是出现在了 t 中的字符，则 cnt 自增  dict[s[i]]--  if dict[s[i]] \u0026gt;= 0 {  cnt++  }   // 如果当前窗口中包含了 t 中所有字符  for cnt == n {  // 如果当前窗口更小，那么更新结果值和最小窗口  if minLen \u0026gt; i - left + 1 {  minLen = i - left + 1  res = s[left: i+1]  }   // 缩小左边界，缩小时候需要还原字符计数  dict[s[left]]++  if dict[s[left]] \u0026gt; 0 {  cnt--  }   left++  }  }   return res } "},{"id":77,"href":"/docs/algs/leetcode/78_subsets/","title":"78. Subsets","section":"Leetcode","content":"Descrition #   Given an integer array nums of unique elements, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.\n Solutions #  观察一下可以发现，其实子集合就是一个追加操作。你只需要把新元素不断的追加到就有的集合上构成一个新的集合，然后再将这个新集合添加到结果数组中即可。重复上述操作，直到你把原数组中的所有元素都遍历完一次即可。\nfunc subsets(nums []int) [][]int {  res := [][]int{{}}  size := len(nums)   for i := 0; i \u0026lt; size; i++ {  n := len(res)  for j := 0; j \u0026lt; n; j++ {  t := make([]int, len(res[j]))  copy(t, res[j])  t = append(t, nums[i])  res = append(res, t)   // 注意不能用下面这样的方式。  // 因为 golang 中切片其实底层是一个指向实际数组的指针，所以下面的添加可能会旧元素上进行添加，而不是在新元素上进行添加。  // t := res[j]  // t = append(t, nums[i])  // res = append(res, t)  }  }   return res } "},{"id":78,"href":"/docs/algs/codingInterviews/78_%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/","title":"78. 把二叉树打印成多行","section":"Coding Interviews","content":"Description #   给定一个节点数为 n 二叉树，要求从上到下按层打印二叉树的 val 值，同一层结点从左至右输出，每一层输出一行，将输出的结果存放到一个二维数组中返回。\n Solutions #  Level Order Traversal #  简单题，只需要进行一次层次遍历即可。\nfunc Print( pRoot *TreeNode ) [][]int {  // write code here  var res [][]int  if pRoot == nil {  return res  }   var queue []*TreeNode  queue = append(queue, pRoot)   for len(queue) != 0 {  size := len(queue)  var level []int  for i := 0; i \u0026lt; size; i++ {  node := queue[i]  level = append(level, node.Val)  if node.Left != nil {  queue = append(queue, node.Left)  }  if node.Right != nil {  queue = append(queue, node.Right)  }  }   res = append(res, level)  queue = queue[size:]  }   return res } "},{"id":79,"href":"/docs/algs/leetcode/79_word_search/","title":"79. Word Search","section":"Leetcode","content":"Description #   Given an m x n grid of characters board and a string word, return true if word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n Solutions #  递归回溯即可。\nfunc exist(board [][]byte, word string) bool { \tm, n := len(board), len(board[0]) \tfor i := 0; i \u0026lt; m; i++ { \tfor j := 0; j \u0026lt; n; j++ { \tif board[i][j] == word[0] { \tvisited := make([][]bool, m) \tfor i, _ := range visited { \tvisited[i] = make([]bool, n) \t} \tif existBacktrace(board, word, i, j, m, n, \u0026amp;visited) { \treturn true \t} \t} \t} \t} \treturn false }  func existBacktrace(board [][]byte, word string, si, sj, m, n int, visited *[][]bool) bool { \tif len(word) == 0 { \treturn true \t} \tif si \u0026lt; 0 || sj \u0026lt; 0 || si \u0026gt;= m || sj \u0026gt;= n || (*visited)[si][sj] || board[si][sj] != word[0] { \treturn false \t} \tif board[si][sj] == word[0] { \t// 不用重新建立一个 visited 数组,因为下面的语句会把 visited 数组还原 \t(*visited)[si][sj] = true \tif existBacktrace(board, word[1:], si+1, sj, m, n, visited) || \texistBacktrace(board, word[1:], si-1, sj, m, n, visited) || \texistBacktrace(board, word[1:], si, sj+1, m, n, visited) || \texistBacktrace(board, word[1:], si, sj-1, m, n, visited) { \treturn true \t} \t(*visited)[si][sj] = false \t}  \treturn false } "},{"id":80,"href":"/docs/algs/codingInterviews/81_%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2II/","title":"81. 调整数组顺序使奇数位于偶数前面 II","section":"Coding Interviews","content":"Description #   输入一个长度为 n 整数数组，数组里面可能含有相同的元素，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前面部分，所有的偶数位于数组的后面部分，对奇数和奇数，偶数和偶数之间的相对位置不做要求，但是时间复杂度和空间复杂度必须如下要求。\n数据范围：$0 \\le n \\le 50000$，数组中每个数的值 $0 \\le val \\le 10000$ 要求：时间复杂度 $\\Omicron(n)$，空间复杂度 $\\Omicron(1)$\n Solutions #  参考快速排序将小于 pivot 的元素放在左侧，将大于 pivot 的元素放在右侧的做法。这里使用两个指针left和 right，分别指向数组开头和末尾，然后 left 不断向右遍历，直到查找到偶数元素停止，然后 right 不断向左遍历，直到查找到奇数元素停止，然后交换 left 和 right 指向的元素，这样就把奇数放在了左侧，偶数放在了右侧，然后继续遍历，直到 left 和 right 重叠为止。\nfunc reOrderArrayTwo( array []int ) []int {  // write code here  size := len(array)  if size \u0026lt;= 1 {  return array  }   left, right := 0, size -1  for left \u0026lt; right {  for left \u0026lt; right \u0026amp;\u0026amp; array[left] % 2 == 1 {  left++  }   for left \u0026lt; right \u0026amp;\u0026amp; array[right] % 2 == 0 {  right--  }   array[left], array[right] = array[right], array[left]  left++  right--  }   return array } "},{"id":81,"href":"/docs/algs/leetcode/84_largest_rectangle_in_histogram/","title":"84. Largest Rectangle in Histogram","section":"Leetcode","content":"Description #   Given an array of integers heights representing the histogram\u0026rsquo;s bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\n Solutions #  寻找每一个局部峰值 i (heights[i] \u0026gt; heights[i+1])，然后从这个局部峰值 i 开始向前遍历所有的值，算出共同的矩形面积，每次对比保留最大值。 很不幸，超时了 :)\nfunc largestRectangleArea(heights []int) int {  var res int  size := len(heights)  if size == 0 {  return res  }   for i := 0; i \u0026lt; size; i++ {  if i+1 \u0026lt; size \u0026amp;\u0026amp; heights[i] \u0026lt;= heights[i+1] {  continue  }   curMin := heights[i]  for j := i; j \u0026gt;= 0; j-- {  if heights[j] \u0026lt; curMin {  curMin = heights[j]  }  res = max(res, curMin * (i-j+1))  }  }   return res }   func max(a,b int) int {  if a \u0026lt; b {  return b  }   return a } "},{"id":82,"href":"/docs/algs/codingInterviews/84_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84III/","title":"84. 二叉树中和为某一值的路径 III","section":"Coding Interviews","content":"Description #   给定一个二叉树root和一个整数值 sum ，求该树有多少路径的的节点值之和等于 sum 。 1.该题路径定义不需要从根节点开始，也不需要在叶子节点结束，但是一定是从父亲节点往下到孩子节点 2.总节点数目为n 3.保证最后返回的路径个数在整形范围内(即路径个数小于$2^{31}$-1)\n Solutions #  注意，这里的路径不一定需要从根节点开始，也不一定需要在叶节点结束。\nRecursice #  核心思想就是，每个节点都可能是一条路径的起始节点，所以每个节点都需要作为根节点来遍历一次。\nvar res int func FindPath( root *TreeNode , sum int ) int {  // write code here  if root == nil {  return res  }   findPathHelper(root, sum)  \t// 每个节点都需要作为根节点来进行一次查找  FindPath(root.Left, sum)  FindPath(root.Right, sum)  return res }  func findPathHelper(root *TreeNode, sum int) {  if root == nil {  return  }  // 注意这里的小技巧  if sum == root.Val {  res++  }   findPathHelper(root.Left, sum - root.Val)  findPathHelper(root.Right, sum - root.Val) } "},{"id":83,"href":"/docs/algs/codingInterviews/85_%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C-II/","title":"85. 连续子数组的最大和 II","section":"Coding Interviews","content":"Description #   输入一个长度为n的整型数组array，数组中的一个或连续多个整数组成一个子数组，找到一个具有最大和的连续子数组。 1.子数组是连续的，比如[1,3,5,7,9]的子数组有[1,3]，[3,5,7]等等，但是[1,3,7]不是子数组 2.如果存在多个最大和的连续子数组，那么返回其中长度最长的，该题数据保证这个最长的只存在一个 3.该题定义的子数组的最小长度为1，不存在为空的子数组，即不存在[]是某个数组的子数组 4.返回的数组不计入空间复杂度计算\n Solutions #  Kadane 方法 #  详情参见 42 题的 「连续子数组的最大和」，这个方法跟那个方法是同一个思路。\nfunc FindGreatestSumOfSubArray( array []int ) []int {  // write code here  size := len(array)  if size == 0 {  return nil  }  var start, end int  res, sum := array[0],array[0]   for i := 1; i \u0026lt; size; i++ { \t// 这里的 start 可能会在不断的向右扩张，而 end 只有在 sum 比 res 大的时候才会扩展，所以可能会出现 start 比 end 大的情况。  if array[i] \u0026gt; sum + array[i] {  start = i  }  sum = max(array[i], sum+array[i])  if sum \u0026gt;= res {  res = sum  end = i  }  }  \t// 当 start 不断向前推进时，可能会出现 start 大于 end 的情况，这个时候需要重置 start 的值  if start \u0026gt; end {  start = end  }  return array[start: end+1] }  func max(a,b int) int {  if a \u0026lt; b {  return b  }   return a } 上面的这个解法的优化, 这个方法其实也可以改成动态规划的方法，只需要将 sum 替换成 dp[i] 即可。\nfunc FindGreatestSumOfSubArray( array []int ) []int {  // write code here  size := len(array)  if size == 0 {  return nil  }   // start 和 end 是不断扩展的指针  var start, end int  // resl 和 resr 指向最大连续和子数组的起始和结束区间  var resl, resr int  res, sum := array[0],array[0]   for i := 1; i \u0026lt; size; i++ {  end++   // 重置 start 指针  if array[i] \u0026gt; sum + array[i] {  start = i  }  sum = max(array[i], sum+array[i])   // 有可能出现连续子数组的最大和虽然不再增长，但是子数组的长度在增长的情况  if sum \u0026gt; res || sum == res \u0026amp;\u0026amp; (end - start + 1) \u0026gt; (resr - resl + 1) {  res = sum  resl = start  resr = end  }  }   return array[resl: resr+1] }  func max(a,b int) int {  if a \u0026lt; b {  return b  }   return a } "},{"id":84,"href":"/docs/algs/codingInterviews/86_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","title":"86. 二叉树中两个节点的最近公共祖先","section":"Coding Interviews","content":"Description #   给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。\n数据范围：树上节点数满足$1 \\le n \\le 10^5$, 节点值val满足区间 [0,n) 要求：时间复杂度 $\\Omicron(n)$\n Solutions #  Recursive #  具体解释看注释即可。\nfunc lowestCommonAncestor( root *TreeNode , o1 int , o2 int ) int {  // write code here  if root == nil {  return -1  }   res := lcaHelper(root, o1, o2)  return res.Val }  func lcaHelper(root *TreeNode, o1, o2 int) *TreeNode {  // 如果已经遍历到空节点或者已经找到其中一个节点，则返回该节点  if root == nil || root.Val == o1 || root.Val == o2 {  return root  }   // 分别查找左子树和右子树  left := lcaHelper(root.Left, o1, o2)  right := lcaHelper(root.Right, o1, o2)   // 如果left 为空，说明这两个节点在 root 的右子树上，则返回右子树查找结果  if left == nil {  return right  }  // 如果 right 为空，说明这两个节点在 root 的左子树上，则返回左子树查找结果  if right == nil {  return left  }   // 如果 left 和 right 都不为空，则说明这两个节点一个在 root 的左子树上，一个在 root 的右子树上，则返回 root 即可  return root } "},{"id":85,"href":"/docs/algs/leetcode/88_merge_sorted_array/","title":"88. Merge Sorted Array","section":"Leetcode","content":"Description #   You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\n Solutions #  题目意思是 nums1 的总长是 n+m， 但是只有前 m 个元素才是合法的，后 n 个元素相当于是空位置。现在需要你合并一下 nums1 和 nums2. Follow up 那里是问你是否能够就地合并。\n归并排序 #  很明显应该可以想到归并排序的思路，但是问题是，归并排序需要使用额外的空间。那么如何能够不使用额外的空间也可以合并这两个数组呢（这也是 Follow up 的要求）？其实这里要学会充分利用已有的数组空间，在 LeetCode 的众多题目中，利用已有空间的题并不少。这里我们可以先把 nums1 的 m 个元素右移，然后前面就可以空出来 n 个元素，这就相当于 n 个空位，那么我们就可以借助这 n 个空位完成归并排序。\nfunc merge(nums1 []int, m int, nums2 []int, n int) {  // corner case  if m == 0 \u0026amp;\u0026amp; n == 0 || n == 0 {  return  }   // 将前 m 个元素每个往后移动 n 位  size := len(nums1)  for i := m-1; i \u0026gt;= 0; i-- {  nums1[i+n] = nums1[i]  }   // 归并排序  // 注意 pos1 的起始坐标  pos1, pos2, cur := size-m, 0, 0  for pos1 \u0026lt; size \u0026amp;\u0026amp; pos2 \u0026lt; n {  if nums1[pos1] \u0026lt; nums2[pos2] {  nums1[cur] = nums1[pos1]  pos1++  } else {  nums1[cur] = nums2[pos2]  pos2++  }   cur++  }   for pos1 \u0026lt; size {  nums1[cur] = nums1[pos1]  pos1++  cur++  }   for pos2 \u0026lt; n {  nums1[cur] = nums2[pos2]  pos2++  cur++  } } 插入排序 #  首先，nums1 的前 m 个元素已经排好序了，那么我们只需要将 nums2 的 n 个元素插入到 nums1 中，然后从插入的位置开始进行插入排序即可。\nfunc merge(nums1 []int, m int, nums2 []int, n int) {  if m == 0 \u0026amp;\u0026amp; n == 0 || n == 0 {  return  }    size := len(nums1)  for i,j := m, 0; i \u0026lt; size; i,j = i+1, j+1 {  nums1[i] = nums2[j]  }   for i := m; i \u0026lt; size; i++ {  tmp := nums1[i]  j := i  for j \u0026gt; 0 \u0026amp;\u0026amp; nums1[j-1] \u0026gt; tmp {  nums1[j] = nums1[j-1]  j--  }  nums1[j] = tmp  } } "},{"id":86,"href":"/docs/algs/others/1.-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","title":"合并两个有序数组","section":"Others","content":"字节真题\n描述 #  给出两个递增数组 A=[3,4,5,0,0]、 B=[7,8] 和两个数 m、n 分别表示两个数组中有效元素的个数。其中 A 中的 0 表示该位置为空位，没有元素。要求合并这两个数组，不使用额外空间。\n解法 #  插入排序 #  思路很简单，将 B 数组的元素都放到 A 数组无效位置去，然后从放进去的那个位置开始进行插入排序。\n归并排序 #  很明显能够看出来这个可以用归并排序的思想来做，但是问题在于不能开辟额外的地址空间，那怎么办呢？其实可以发现 A 数组中是有足够的额外空间的，我们只需要把 A 数组的元素都往后移，那么额外空间就到了 A 数组的前方，那么此时我们就可以进行归并排序了。\n"},{"id":87,"href":"/docs/algs/others/2.-%E7%AD%89%E6%A6%82%E7%8E%87%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E4%B8%AD-k-%E4%B8%AA%E5%85%83%E7%B4%A0/","title":"等概率返回数组中 k 个元素","section":"Others","content":"题目描述 #   给你一个输入数据流，数据内容为一系列的信号。 设计一个方法，能在流的终止信号到达时，返回数据流内的随机k个信号结果。 要求：数据流内每个信号被选中的概率均等。数据流内信号个数不足k个时，全部返回。\n Solutions #  这个题之前在考研的时候见过，核心思想是：维持一个大小为 k 的数组，然后将输入的前 k 个元素存入到数组中的，对于后面的每个元素，使用随机数产生一个[0,k-1]之内的数，然后使用这个数作为下标，替换掉数组中对应位置的数。最后返回数组中的这 k 个数为止。\n"},{"id":88,"href":"/docs/algs/codingInterviews/48_%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"48. 最长不含重复字符的子字符串","section":"Coding Interviews","content":"Description #   请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。 数据范围: $\\text{s.length}\\le 40000$\n Solutions #  滑动窗口 #   func lengthOfLongestSubstring( s string ) int {  // write code here  size := len(s)  if size \u0026lt;= 1 {  return size  }   res, start := 1, -1  dict := make(map[byte]int) \t// 这里用等号主要是因为当最后几个字符串都不重复时，如果不在这里加上一个等号，则可能会缺少一次计算，从而导致结果不准确。 \t// 下面的第一个 if 也是为了跟这种情况搭配才加上的。  for i := 0; i \u0026lt;= size; i++ {  if i == size {  res = max(res, i - start - 1)  break  }  if index, ok := dict[s[i]]; ok \u0026amp;\u0026amp; index \u0026gt; start {  res = max(res, i - start - 1)  start = index  }   dict[s[i]] = i  }    return res }  func max(a,b int) int {  if a \u0026lt; b {  return b  }   return a } 下面是上面这种解法的更简介写法：\nfunc lengthOfLongestSubstring( s string ) int {  // write code here  size := len(s)  if size \u0026lt;= 1 {  return size  }  \t// 处理 corner case， 最少会有一个不重复子串 \t// 注意 start 初始赋值为-1而不是 0，因为窗口的左边界是从 0 开始计算的  res, start := 1, -1  dict := make(map[byte]int)  for i := 0; i \u0026lt; size; i++ { \t// 当出现重复字符时，就更新滑动窗口左边界 \t// 注意这里为什么要加上一个 index \u0026gt; start 的判断条件：因为这是一个 map，有的字符可能之前已经出现过了， \t// 但是这个字符可能并没有出现在我们正在维持的滑动窗口中，所以要把这种情况给排除  if index, ok := dict[s[i]]; ok \u0026amp;\u0026amp; index \u0026gt; start {  start = index  }  \t// 不断扩展窗口右边界  dict[s[i]] = i \t// 持续扩大滑动窗口最大值  res = max(res, i - start)  }   return res }  func max(a,b int) int {  if a \u0026lt; b {  return b  }   return a } "},{"id":89,"href":"/docs/algs/codingInterviews/49_%E4%B8%91%E6%95%B0/","title":"49. 丑数","section":"Coding Interviews","content":"Description #   把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第 n个丑数。\n数据范围：$0 \\le n \\le 2000$ 要求：空间复杂度 $\\Omicron(n)$ ， 时间复杂度 $\\Omicron(n)$\n Solutions #  很明显丑数只会是可以用 $2^x3^y5^z$ 表示的一个数字。分别表示从 1 开始乘 2、3、5 的三条丑数队列，每次从这三个丑数队列中取出最小的数字来作为我们当前得到的最小丑数，然后更新那个贡献了这个数字的丑数队列的下一个值。更精简的做法是，我们可以直接维护三个指针 i2、i3、 i5, 来表示这个三个队列。\nfunc GetUglyNumber_Solution( index int ) int {  // write code here  if index == 0 {  return 0  }  var i2, i3, i5 int  res := make([]int, index)  res[0] = 1  for i := 1; i \u0026lt; index; i++ { \t// 取出当前队列的最小值  res[i] = min(res[i2]*2, min(res[i3]*3, res[i5]*5)) \t// 如果是这个队列贡献了这个值，那么更新队列元素  if res[i] == res[i2]*2 {  i2++  }  if res[i] == res[i3] * 3 {  i3++  }  if res[i] == res[i5] * 5 {  i5++  }  }   return res[index-1] }  func min(a,b int) int {  if a \u0026lt; b {  return a  }   return b } "},{"id":90,"href":"/docs/algs/codingInterviews/50_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/","title":"50. 第一个只出现一次的字符","section":"Coding Interviews","content":"Description #   在一个长为 字符串中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）\n数据范围：$0 \\le n \\le 10000$，且字符串只有字母组成。 要求：空间复杂度 $\\Omicron(n)$，时间复杂度 $\\Omicron(n)$\n Solutions #  Hash Table #  使用一个 hash table 记录每个字符出现的次数，然后再从头扫描一次 str，遇到第一个出现次数为 1 的字符则返回其下标；否则返回-1.\nfunc FirstNotRepeatingChar( str string ) int {  // write code here  size := len(str)  if size == 0 {  return -1  }   dict := make(map[byte]int)  for idx, _ := range str {  dict[str[idx]]++  }   for idx, _ := range str {  if cnt, _ := dict[str[idx]]; cnt == 1 {  return idx  }  }   return -1 } "},{"id":91,"href":"/docs/algs/codingInterviews/51_%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/","title":"51. 数组中的逆序对","section":"Coding Interviews","content":"Description #   在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P mod 1000000007\n数据范围： 对于 $50%$ 的数据, $size \\leq 10^4$\n对于 $100%$ 的数据, $size\\leq 10^5$\n数组中所有数字的值满足 $0 \\le val \\le 1000000$\n要求：空间复杂度 $\\Omicron(n)$，时间复杂度 $\\Omicron(n \\log n)$\n Solutions #  如果两个区间为[4, 3] 和[1, 2], 那么逆序数为(4,1),(4,2),(3,1),(3,2)，同样的如果区间变为有序，比如[3,4] 和 [1,2], 那么逆序数也是一样的，也就是说区间有序和无序结果是一样的。但是区间有序带来的好处是，比如[3,4] 和 [1,2]，如果3 \u0026gt; 1, 显然3后面的所有数都大于1，那么逆序对计算就会方便很多。\nMerge Sort #  const MOD int = 1000000007 func InversePairs( data []int ) int {  // write code here  var res int  size := len(data)  if size \u0026lt;= 1 {  return res  }   tmp := make([]int, size)  mergeSort(data, tmp, 0, size-1, \u0026amp;res)  return res }  func mergeSort(nums,tmp []int, start, end int, res *int) {  if start \u0026gt;= end {  return  }  mid := (start + end)/2  mergeSort(nums, tmp, start, mid, res)  mergeSort(nums, tmp, mid+1, end, res)  merge(nums, tmp, start, mid, end, res) }  func merge(nums,tmp []int, start, mid, end int, res *int) {  left, right := start, mid+1  var idx int  for left \u0026lt;= mid \u0026amp;\u0026amp; right \u0026lt;= end {  if nums[left] \u0026gt; nums[right] {  tmp[idx] = nums[right]  right++  *res += mid - left + 1  *res %= MOD  } else {  tmp[idx] = nums[left]  left++  }   idx++  }    for left \u0026lt;= mid {  tmp[idx] = nums[left]  idx++  left++  }   for right \u0026lt;= end {  tmp[idx] = nums[right]  idx++  right++  }   for i,k := start, 0; i \u0026lt;= end; i,k = i+1, k+1 {  nums[i] = tmp[k]  } } "}]