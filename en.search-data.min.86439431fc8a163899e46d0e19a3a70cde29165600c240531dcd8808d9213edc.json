[{"id":0,"href":"/docs/algs/","title":"Algorithms","section":"Docs","content":"This is where I document some problems that I solved.\n"},{"id":1,"href":"/docs/algs/codingInterviews/","title":"Coding Interviews","section":"Algorithms","content":"这里是一些《剑指 Offer》的刷题题解。\n链表 #   反转链表\nTODO recheck 注意这里递归方法的反转思路。\n  两个链表的第一个公共节点\n  TODO recheck\n注意条件  链表中环的入口节点  TODO recheck\n首先需要注意如何进行环检测，如何判断环终止。其次需要注意的是，如何找到环中的入口节点。\n 复杂链表的复制\n链表的复制和图的复制都可以考虑 map。\n  删除链表中的重复节点\n这里一个非常需要注意的点就是，如果头结点也要被删除的话怎么办？如果头结点的也要被删除的话，那么判断条件就会变得比较复杂，这里的一个解决办法就是，增加一个虚拟的头结点，然后让这个虚拟的头结点指向真正的头结点，遍历的时候就从这个虚拟的头结点开始遍历，这样就能够应付真实头结点也要被删除的情况。 TODO rechck 增加虚拟头结点的技巧\n  从尾到头打印链表 简单题\n  合并两个排序的链表 简单题\n  链表中倒数最后 k 个节点 简单题\n  删除链表汇中重复的节点 TODO recheck\n  删除链表的节点 简单，注意虚拟头结点的使用\n  树 #   二叉树的深度 简单题\n  按之字形顺序打印二叉树 简单题\n  二叉搜索树的第 k 个节点 简单题\n  重建二叉树 TODO recheck\n  树的子结构 简单题\n  二叉树的镜像 简单题\n  从上往下打印二叉树 简单题\n  二叉搜索树的后序遍历序列 注意 corner case\n  二叉树和为某一值的路径 TODO 注意叶子节点的判断方式\n  二叉树中和为某一值的路径 II TODO 注意叶子节点的判断方式\n  二叉搜索树与双向链表 TODO recheck 这个题需要注意，尤其是怎么确定 head 节点，以及 pre 节点的选择，还有就是怎么将 pre 节点和当前节点做连接。题目本身其实并不算难，就是中序遍历，但是问题就是一些边界条件的考量，在这里尤其需要注意。\n  判断是不是平衡二叉树 TODO recheck 这里虽然是个简单题，但是还是要注意一些，要快速做出来。\n  二叉树的下一个节点 TODO recheck 这里需要好好注意一下问题是怎么分析的。\n  对称的二叉树 简单题\n  把二叉树打印成多行 简单题，其实就是一个二叉树的层次遍历。\n  "},{"id":2,"href":"/docs/algs/leetcode/","title":"Leetcode","section":"Algorithms","content":"这里是一些 LeetCode 的刷题题解。\n"},{"id":3,"href":"/docs/algs/codingInterviews/28_%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"28. 对称的二叉树","section":"Coding Interviews","content":"Description #   给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）\n Solutions #  Recursive #  func isSymmetrical( pRoot *TreeNode ) bool {  // write code here  if pRoot == nil {  return true  }   return isSameTree(pRoot.Left, pRoot.Right) }  func isSameTree(root1, root2 *TreeNode) bool {  if root1 == nil \u0026amp;\u0026amp; root2 == nil {  return true  }   if root1 == nil || root2 == nil {  return false  }   if root1.Val != root2.Val {  return false  }   return isSameTree(root1.Left, root2.Right) \u0026amp;\u0026amp; isSameTree(root1.Right, root2.Left) } "},{"id":4,"href":"/docs/algs/codingInterviews/78_%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/","title":"78. 把二叉树打印成多行","section":"Coding Interviews","content":"Description #   给定一个节点数为 n 二叉树，要求从上到下按层打印二叉树的 val 值，同一层结点从左至右输出，每一层输出一行，将输出的结果存放到一个二维数组中返回。\n Solutions #  Level Order Traversal #  简单题，只需要进行一次层次遍历即可。\nfunc Print( pRoot *TreeNode ) [][]int {  // write code here  var res [][]int  if pRoot == nil {  return res  }   var queue []*TreeNode  queue = append(queue, pRoot)   for len(queue) != 0 {  size := len(queue)  var level []int  for i := 0; i \u0026lt; size; i++ {  node := queue[i]  level = append(level, node.Val)  if node.Left != nil {  queue = append(queue, node.Left)  }  if node.Right != nil {  queue = append(queue, node.Right)  }  }   res = append(res, level)  queue = queue[size:]  }   return res } "},{"id":5,"href":"/docs/algs/codingInterviews/37_%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"37 序列化二叉树","section":"Coding Interviews","content":"Description #   请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树。\n二叉树的序列化(Serialize)是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树等遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#）\n二叉树的反序列化(Deserialize)是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。\n Solutions #  Level Order Traversal #  func Serialize( root *TreeNode ) string {  // write code here  if root == nil {  return \u0026#34;\u0026#34;  }   var res []string  emptyNode := \u0026#34;#\u0026#34;  seperator := \u0026#34; \u0026#34;    var queue []*TreeNode  queue = append(queue, root)  for len(queue) != 0 {  size := len(queue)  for i := 0; i \u0026lt; size; i++ {  node := queue[i]  if node != nil {  s := strconv.Itoa(node.Val)  res = append(res, s)  queue = append(queue, node.Left)  queue = append(queue, node.Right)  } else {  res = append(res, emptyNode)  }  }   queue = queue[size:]  }   return strings.Join(res, seperator) }  func Deserialize( s string ) *TreeNode {  // write code here  if len(s) == 0 {  return nil  }  seperator := \u0026#34; \u0026#34;  emptyNode := \u0026#34;#\u0026#34;  nodes := strings.Split(s, seperator)   root := new(TreeNode)  root.Val,_ = strconv.Atoi(nodes[0])  nodes = nodes[1:]   var queue []*TreeNode  queue = append(queue, root)  for len(queue) != 0 {  size := len(queue)  for i := 0; i \u0026lt; size; i++ {  node := queue[i]  val := nodes[0]  nodes = nodes[1:]  if val != emptyNode {  v,_ := strconv.Atoi(val)  tmp := new(TreeNode)  tmp.Val = v  node.Left = tmp  queue = append(queue, tmp)  }   val = nodes[0]  nodes = nodes[1:]  if val != emptyNode {  v,_ := strconv.Atoi(val)  tmp := new(TreeNode)  tmp.Val = v  node.Right = tmp  queue = append(queue, tmp)  }  }   queue = queue[size:]  }   return root } "}]