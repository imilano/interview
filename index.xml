<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Interview</title><link>https://example.com/</link><description>Recent content in Introduction on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/index.xml" rel="self" type="application/rss+xml"/><item><title>0001. Two Sum</title><link>https://example.com/docs/algs/leetcode/01_two_sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/01_two_sum/</guid><description>Description # Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.
Solutions # Hash Table # 这里因为答案唯一，那么也就意味着数组里的元素是唯一的，所以可以使用 map 来做，只需要一次遍历即可，具体看下面代码就好。
func twoSum(nums []int, target int) []int { dict := make(map[int]int) for idx, num := range nums{ t := target - num if exist(dict, t) { return []int{idx, dict[t]} } dict[num] = idx } return nil } func exist(dict map[int]int, target int) bool { if _, ok := dict[target]; ok { return true } return false } Sort &amp;amp;&amp;amp; Two Pointer # 这里也可以使用排序来做，根据值进行排序，但是需要保存该值对应的下标。排好序之后可以使用双指针，一个 left 指向开头，一个 right 指向结尾，计算二者和，如果小于 target，则 left++，否则 right++，直到二者之和等于 target 即可。思路大概就这样，代码就不写了。</description></item><item><title>0003. Longest Substring Without Repeating Characters</title><link>https://example.com/docs/algs/leetcode/03_longest_substring_without_repeatng_characters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/03_longest_substring_without_repeatng_characters/</guid><description>Description # Given a string s, find the length of the longest substring without repeating characters.
Solutions # Hash Table # 中间扩散法，时间复杂度会比较高，因为会有很多的重复扫描。核心思想是，遍历一次字符串，然后对于每个遍历到的位置，从中心向两侧进行扫描，扫描时使用一个 map 来记录那些已经出现过的字符；在一侧扫描过程中，如果发现该字符已经出现过，则停止扫描该侧。最后 map 的长度即为以该字符为中心的不重复字符的长度。
// 对于每个位置的字符，从中间向两侧扫描；使用一个 map 记录已经出现过的字符。在一侧扫描过程中，如果该字符已经出现过，则停止扫描该侧。 // 最后 map 的长度即为以该字符为中心的不重复字符的长度 func lengthOfLongestSubstringSolution1(s string) int { // handle empty string var res int if len(s) &amp;lt;= 1 { return len(s) } for i := 0; i &amp;lt; len(s); i++ { res = max(res, helper(s, i)) } return res } func helper(s string, mid int) int { left, right := mid-1, mid+1 dict := make(map[byte]bool) dict[s[mid]] = true for left &amp;gt; 0 { _, ok := dict[s[left]] if ok { break } dict[s[left]] = true left-- } for right &amp;lt; len(s) { _, ok := dict[s[right]] if ok { break } dict[s[right]] = true right++ } return len(dict) } Sliding Window &amp;amp; Hash Table # 很明显也可以使用滑动窗口配合 Hash Table 的方式来解题。首先固定滑动窗口的左边界，然后将滑动窗口的右边界向右滑动，每滑动一个位置，就检查该位置的字符是否有在当前滑动窗口中出现过(也就是说，既要检查该字符是否在 Hash Table 中出现过，还要检查最近一次出现的下标是否位于滑动窗口之内)，如果出现过，则更新滑动串口左边界。另外，每次遍历都需要更新当前滑动窗口的最大长度。</description></item><item><title>0005. Longest Palindrome Substring</title><link>https://example.com/docs/algs/leetcode/05_longest_palindrome_substring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/05_longest_palindrome_substring/</guid><description>Description # Given a string s, return the longest palindromic substring in s.
Solutions # 中心扩散 # 题主首先想到的是中心扩散方法。核心思想就是遍历以此字符串，然后对于遍历到的每个位置，找出以这个位置为中心能找到的最长回文串。需要注意的是，一个回文串可能是偶数长度，也可能是奇数长度。如果是奇数长度，那么就需要以 i 为中心来对左右进行扩散；而如果是偶数长度，那么就需要以 i 和 i-1 为中心来进行扩散。
func longestPalindrome(s string) string { size := len(s) if size &amp;lt;= 1 { return s } var res string for i := 0; i &amp;lt; size; i++ { // 最长回文串可能会出现在以 i 为中心对称的子串上，也可能出现在以 i 和 i - 1 为中心的子串上 r1 := longestPalindromeHelper(s, i, i, size) r2 := longestPalindromeHelper(s, i-1, i, size) res = getMaxString(r1, r2, res) } return res } func longestPalindromeHelper(s string, left, right, size int) string { var res string for left &amp;gt;= 0 &amp;amp;&amp;amp; right &amp;lt; size { if s[left] == s[right] { // res 放在这里更新，这样的话，就不用写判断 left 和 right 是否有效的逻辑了 res = s[left : right+1] left-- right++ } else { break } } return res } func getMaxString(a, b, s string) string { if len(a) &amp;lt; len(b) { if len(b) &amp;lt; len(s) { return s } else { return b } } else { if len(a) &amp;lt; len(s) { return s } else { return a } } } Longest Common Stirng # 将输入字符串逆转之后，原问题就可以转换为求最长公共子串(leetcode 第 718 题)的问题。</description></item><item><title>0020. Valid Parentheses</title><link>https://example.com/docs/algs/leetcode/20_valid_parentheses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/20_valid_parentheses/</guid><description> Description # Given a string s containing just the characters &amp;lsquo;(&amp;rsquo;, &amp;lsquo;)&amp;rsquo;, &amp;lsquo;{&amp;rsquo;, &amp;lsquo;}&amp;rsquo;, &amp;lsquo;[&amp;rsquo; and &amp;lsquo;]&amp;rsquo;, determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Solutions # 简单题，直接使用栈即可。
func isValid(s string) bool { var stack []byte size := len(s) for i := 0; i &amp;lt; size; i++ { if s[i] == &amp;#39;(&amp;#39; || s[i] == &amp;#39;[&amp;#39; || s[i] == &amp;#39;{&amp;#39; { stack = append(stack, s[i]) } else { cap := len(stack) if cap == 0 { return false } tail := stack[cap-1] if s[i] == &amp;#39;)&amp;#39; &amp;amp;&amp;amp; tail == &amp;#39;(&amp;#39; || s[i] ==&amp;#39;]&amp;#39; &amp;amp;&amp;amp; tail == &amp;#39;[&amp;#39; || s[i] == &amp;#39;}&amp;#39; &amp;amp;&amp;amp; tail == &amp;#39;{&amp;#39; { stack = stack[:cap-1] } else { return false } } } return len(stack) == 0 }</description></item><item><title>0021. Merge Two Sorted List</title><link>https://example.com/docs/algs/leetcode/21_merge_two_sorted_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/21_merge_two_sorted_list/</guid><description>Description # You are given the heads of two sorted linked lists list1 and list2.
Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.
Return the head of the merged linked list.
Solutions # 简单题，不多说了，参考归并排序思想。
Merge Sort # func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode { res := new(ListNode) node := res dummyHead1, dummyHead2 := list1, list2 for dummyHead1 !</description></item><item><title>0022. Generate Parentheses</title><link>https://example.com/docs/algs/leetcode/22_generate_parentheses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/22_generate_parentheses/</guid><description> Description # Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
Solutions # Recursive # 参见： https://leetcode-cn.com/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/
使用两个变量 left 和 right 来表示「左括号使用了集合」和「右括号使用了几个」，通过分析可以得到以下结论： - 只有当left 和 right 都比 n 小的时候，才产生分支。 - 产生左分支的时候，只看当前还有左括号可用 - 产生右分支的时候，还受到左括号数量的限制，left 要大于 right 的时候，才可以产生分支。否则就是无效分支，可以直接返回。 - 在左边和右边的括号数都等于 n 的时候结算。
func generateParenthesis(n int) []string { var res []string if n == 0 { return res } generateParenthesisHelper(n, 0,0,&amp;#34;&amp;#34;, &amp;amp;res) return res } func generateParenthesisHelper(n, left, right int, cur string, res *[]string) { if left == n &amp;amp;&amp;amp; right == n { *res = append(*res, cur) return } // 剪枝 if left &amp;lt; right { return } if left &amp;lt; n { generateParenthesisHelper(n, left+1, right, cur + &amp;#34;(&amp;#34;, res) } if right &amp;lt; n { generateParenthesisHelper(n, left, right+1, cur + &amp;#34;)&amp;#34;, res) } }</description></item><item><title>0023. Merge K Sorted List</title><link>https://example.com/docs/algs/leetcode/23_merge_k_sorted_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/23_merge_k_sorted_list/</guid><description>Description # You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.
Merge all the linked-lists into one sorted linked-list and return it.
Solutions # Min Heap # 很简单的想法，使用最小堆即可。
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeKLists(lists []*ListNode) *ListNode { return mergeKListsSolution1(lists) } // 使用最小堆，将所有的节点数据都插入到最小堆中，然后再把所有元素从最小堆中弹出 func mergeKListsSolution1(lists []*ListNode) *ListNode { var minHeap MinHeapArr heap.</description></item><item><title>0026. remove duplicated from sorted array</title><link>https://example.com/docs/algs/leetcode/26_remove_duplicates_from_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/26_remove_duplicates_from_sorted_array/</guid><description>Description # Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.
Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result.</description></item><item><title>0027. Remove Element</title><link>https://example.com/docs/algs/leetcode/27_remove_element/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/27_remove_element/</guid><description>Description # Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.
Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result.</description></item><item><title>0028. Implement strStr</title><link>https://example.com/docs/algs/leetcode/28_implement_strStr/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/28_implement_strStr/</guid><description>Description # Implement strStr().
Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Solutions # 太简单了在，直接看代码即可。
func strStr(haystack string, needle string) int { var pos int size := len(haystack) targetSize := len(needle) if size == 0 || targetSize == 0 { return pos } var start int pos = -1 for start &amp;lt; size { if haystack[start] !</description></item><item><title>0029. Divide Two Integers</title><link>https://example.com/docs/algs/leetcode/29_divide_two_integers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/29_divide_two_integers/</guid><description>Description # Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.
The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.
Return the quotient after dividing dividend by divisor.
Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1].</description></item><item><title>0033. Search in Rotated Sorted Array</title><link>https://example.com/docs/algs/leetcode/33_search_in_rotated_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/33_search_in_rotated_array/</guid><description>Description # There is an integer array nums sorted in ascending order (with distinct values).
Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], &amp;hellip;, nums[n-1], nums[0], nums[1], &amp;hellip;, nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].
Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.</description></item><item><title>0034. Find First and Last Position of Element in Sorted Array</title><link>https://example.com/docs/algs/leetcode/34_find_first_and_last_position_of_element_in_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/34_find_first_and_last_position_of_element_in_sorted_array/</guid><description>Description # Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.
If target is not found in the array, return [-1, -1].
You must write an algorithm with O(log n) runtime complexity.
Solutions # Binary Search # 二分查找再加上中间扩散，很容易想出来。
func searchRange(nums []int, target int) []int { res := []int{-1, -1} size := len(nums) if size == 0 { return res } left, right := 0, size -1 for left &amp;lt;= right { mid := (left+right)/2 if nums[mid] == target { l,r := mid, mid res[0] = l res[1] = r for l &amp;gt;= 0 &amp;amp;&amp;amp; nums[l] == target { res[0] = l l-- } for r &amp;lt; size &amp;amp;&amp;amp; nums[r] == target { res[1] = r r++ } break } else if nums[mid] &amp;gt; target { right = mid -1 } else if nums[mid] &amp;lt; target { left = mid + 1 } } return res } 在最坏情况下，比如数组中所有数字均相同，则时间复杂度会退化为 \( \Omircon(n) \) 。下面是优化之后的解法。</description></item><item><title>0036. Valid Sudoku</title><link>https://example.com/docs/algs/leetcode/36_valid_sudoku/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/36_valid_sudoku/</guid><description>Description # Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Solutions # 一个是要注意如何快速创建三维数组，另一个是要注意如何进行坐标转换。
func isValidSudoku(board [][]byte) bool { size := 9 // 一次性将所有行和列创建完毕 row, col := make([][]int, size), make([][]int, size) for i := 0; i &amp;lt; size; i++ { row[i], col[i] = make([]int, size), make([]int, size) } // 表示 9 个gird，么个 grid 有 9 个元素.</description></item><item><title>0038. Count and Say</title><link>https://example.com/docs/algs/leetcode/38_count_and_say/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/38_count_and_say/</guid><description>Descrition # The count-and-say sequence is a sequence of digit strings defined by the recursive formula:
countAndSay(1) = &amp;ldquo;1&amp;rdquo; countAndSay(n) is the way you would &amp;ldquo;say&amp;rdquo; the digit string from countAndSay(n-1), which is then converted into a different digit string. To determine how you &amp;ldquo;say&amp;rdquo; a digit string, split it into the minimal number of groups so that each group is a contiguous section all of the same character. Then for each group, say the number of characters, then say the character.</description></item><item><title>0041. First Missing Positive</title><link>https://example.com/docs/algs/leetcode/41_first_msssing_positive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/41_first_msssing_positive/</guid><description>Description # Given an unsorted integer array nums, return the smallest missing positive integer.
You must implement an algorithm that runs in O(n) time and uses constant extra space.
Solutions # Hash Table # 可以使用一个 hash table 记录所以出现的值，然后找出当前值中的最大值。然后从 1 到最大值开始遍历，如果出现一个不在 hash table 中的数，则将该数返回即可。如果所有数都出现在了 hash table 中，那么返回最大值加 1 即可。但是最后这里需要注意的是，有可能整个数组都是负数，这样的话会导致前面的判断失效，所以返回值应该最小要返回 1.
func firstMissingPositive(nums []int) int { dict := make(map[int]bool) curMax := nums[0] for _, num := range nums { dict[num] = true if num &amp;gt; curMax { curMax = num } } for i := 1; i &amp;lt;= curMax; i++ { if _, ok := dict[i]; !</description></item><item><title>0042. Traping Rain Water</title><link>https://example.com/docs/algs/leetcode/42_traping_rain_water/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/42_traping_rain_water/</guid><description>Description # Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.
detail see: https://leetcode.com/problems/trapping-rain-water/
Solutions # Array # 使用两个数组扫描两趟，第一个数组 fromLeft 从左到右扫描，记录到目前为止遇到的最大值，第二个数组fromRight 从右向左扫描，记录当前为止遇到的最大值。最后扫描一下这两个数组，对于每个位置 i，取 fromLeft 和 fromRight 二者中的较小者与当前 height[i] 的差值作为当前格子所能盛水量。
func trap(nums []int) int { var res int size := len(nums) if size &amp;lt;= 1 { return res } curMax := nums[0] fromLeft := make([]int, size) for idx, num := range nums { curMax = max(num, curMax) fromLeft[idx] = curMax } curMax = nums[size-1] fromRight := make([]int, size) for i := size-1; i &amp;gt;= 0; i-- { curMax = max(nums[i], curMax) fromRight[i] = curMax } for i := 0; i &amp;lt; size; i++ { res += min(fromLeft[i], fromRight[i]) - nums[i] } return res } func min(a,b int) int { if a &amp;lt; b { return a } return b } func max(a,b int) int { if a &amp;lt; b { return b } return a } 还有一种解法，就是先找出整个数组的最大值，这个最大值将整个数组切分为两部分，然后分别处理左半边和右半边。处理单边的时候，记录自己当前遇到的历史最大值，如果当前值比历史最大值要大，则更新历史最大值为当前值；否则的话说明历史最大值比当前值要大，那么当前值是可以盛水的，则更新结果盛水量。为什么只需要记录当前历史最大值就可以了呢，毕竟能不能盛水其实要靠两边而不是一边啊？答案是我我们已经找出了整个数组的最大值，那么当前的历史最大值只会比整个数组的最大值要小，能盛多少水完全取决于较短的一方（参考短板理论），所以只需要维持一个最大值即可。</description></item><item><title>0044. Wildcard Matching</title><link>https://example.com/docs/algs/leetcode/44_wildcard_matching/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/44_wildcard_matching/</guid><description>Description # Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for &amp;lsquo;?&amp;rsquo; and &amp;lsquo;*&amp;rsquo; where:
&amp;lsquo;?&amp;rsquo; Matches any single character. &amp;lsquo;*&amp;rsquo; Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial).
Solutions # TODO</description></item><item><title>0046. Permutations</title><link>https://example.com/docs/algs/leetcode/46_permutations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/46_permutations/</guid><description> Description # Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.
Solutions # Array(swap) # 基于交换进行 permutate 即可。
func permute(nums []int) [][]int { var res [][]int size := len(nums) helper(0, size, nums, &amp;amp;res) return res } func helper(start,size int, nums []int, res *[][]int) { if start &amp;gt;= size { tmp := make([]int, size) copy(tmp, nums) *res = append(*res, tmp) return } for i := start; i &amp;lt; size; i++ { nums[i], nums[start] = nums[start], nums[i] // 注意这里是 start + 1， 而不是 i helper(start+1, size, nums, res) nums[i], nums[start] = nums[start], nums[i] } }</description></item><item><title>0048. Rotate Image</title><link>https://example.com/docs/algs/leetcode/48_rotate_image/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/48_rotate_image/</guid><description>Description # You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.
Solutions # 补充几个矩阵变换公式： - 主对角线对折： arr[i][j] = arr[j][i] - 副对角线对折： arr[i][j] = arr[n-j-1][n-i-1] go for i := 0; i &amp;lt; n; i++ { for j := 0; j &amp;lt; n-i; j++ { matrix[i][j], matrix[n-j-1][n-i-1] = matrix[n-j-1][n-i-1], matrix[i][j] } } - 横向对折： arr[i][j] = arr[n-i-1][j] - 纵向对折： arr[i][j] = arr[i][n-j-1]</description></item><item><title>0049. Group Anagrams</title><link>https://example.com/docs/algs/leetcode/49_group_anagrams/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/49_group_anagrams/</guid><description>Description # Given an array of strings strs, group the anagrams together. You can return the answer in any order.
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
Solutions # 简单的方法就是，对具有相同字母以及字母出现次数也相同的字符串进行排序时，其排序结果都是一样的。所以可以创建一个 map，其中 key 为字符串的排序，value 为具有这样一个排序结果的字符串数组。
func groupAnagrams(strs []string) [][]string { var res [][]string m := make(map[string][]string) for _, str := range strs { str_splited := strings.</description></item><item><title>0050. Pow(x, n)</title><link>https://example.com/docs/algs/leetcode/50_powxn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/50_powxn/</guid><description> Description # Implement pow(x, n), which calculates x raised to the power n (i.e., xn).
Solutions # Map # 可以使用快速幂以及记忆化数组，单独使用快速幂会导致超时，所以需要配合记忆化数组使用。
func myPow(x float64, n int) float64 { if x == 0 { return 0 } if n == 0 { return 1 } var negative bool if n &amp;lt; 0 { negative = true n = -n } dict := make(map[int]float64) dict[0], dict[1] = 1, x res := helper(x, n, &amp;amp;dict) if negative { return 1 / res } return res } func helper(x float64, n int, dict *map[int]float64) float64 { if value, ok := (*dict)[n]; ok { return value } res := helper(x, n/2, dict) * helper(x, n/2, dict) * helper(x, n%2, dict) (*dict)[n] = res return res }</description></item><item><title>0051. N Queens</title><link>https://example.com/docs/algs/leetcode/51_n_queens/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/51_n_queens/</guid><description>Description # The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.
Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.
Each solution contains a distinct board configuration of the n-queens&amp;rsquo; placement, where &amp;lsquo;Q&amp;rsquo; and &amp;lsquo;.&amp;rsquo; both indicate a queen and an empty space, respectively.</description></item><item><title>0052. N Queens II</title><link>https://example.com/docs/algs/leetcode/52_n_queens_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/52_n_queens_ii/</guid><description>Description # The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.
Given an integer n, return the number of distinct solutions to the n-queens puzzle.
Solutions # 这题跟 51 题的解法其实是一致的，区别只是这里求的是一个计数值。
func totalNQueens(n int) int { // 将棋盘全部初始化为点 var res int board := make([][]string, n) for idx, _ := range board { board[idx] = make([]string, n) } for i := 0; i &amp;lt; n ;i++ { for j := 0; j &amp;lt; n; j++ { board[i][j] = &amp;#34;.</description></item><item><title>0053. Maximum Subarray</title><link>https://example.com/docs/algs/leetcode/53_maximum_subarray/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/53_maximum_subarray/</guid><description>Description # Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.
A subarray is a contiguous part of an array.
Solutions # Kadane # Kadane 算法，最优子结构性质，当前位置的和取决于前一个位置的子数组和以及当前元素。
def max_subarray(arr): max_sum_so_far, sum_ending_here = arr[0], arr[0] for e in range(arr[1:]): sum_ending_here = max(e, sum_ending_here + e) max_sum_so_far = max(max_sum_so_far, sum_ending_here) return max_sum_so_far 如果数组中有负数，并且允许返回长度为 0 的子数列，则该问题可以改为：
def max_subarray(arr): max_sum_so_far, sum_ending_here = 0, 0 for e in range(arr): sum_ending_here = max(sum_ending_here + e, e) max_sum_so_far = max(max_sum_so_far, sum_ending_here) return max_sum_so_far 完整代码是：</description></item><item><title>0054. Spiral Matrix</title><link>https://example.com/docs/algs/leetcode/54_spiral_matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/54_spiral_matrix/</guid><description> Description # Given an m x n matrix, return all elements of the matrix in spiral order.
Solutions # 其实就是顺时针旋转打印数组。
func spiralOrder(matrix [][]int) []int { var res []int m, n := len(matrix), len(matrix[0]) up, bottom, left, right := 0, m-1, 0, n - 1 for up &amp;lt;= bottom &amp;amp;&amp;amp; left &amp;lt;= right { for i := left; i &amp;lt;= right; i++ { res = append(res, matrix[up][i]) } up++ if up &amp;gt; bottom { break } for i := up; i &amp;lt;= bottom; i++ { res = append(res, matrix[i][right]) } right-- if right &amp;lt; left { break } for i := right; i &amp;gt;= left; i-- { res = append(res, matrix[bottom][i]) } bottom-- if bottom &amp;lt; up { break } for i := bottom; i &amp;gt;= up;i-- { res = append(res, matrix[i][left]) } left++ if left &amp;gt; right { break } } return res }</description></item><item><title>0055. Jump Game</title><link>https://example.com/docs/algs/leetcode/55_jump_game/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/55_jump_game/</guid><description>Description # You are given an integer array nums. You are initially positioned at the array&amp;rsquo;s first index, and each element in the array represents your maximum jump length at that position.
Return true if you can reach the last index, or false otherwise.
Solutions # Recursive # 很容易想到递归的办法，但是也很容易就超时了 :)
func canJump(nums []int) bool { size := len(nums) if helper(0, size, nums) { return true } return false } func helper(start int, size int, nums []int) bool { if start &amp;gt;= size -1 { return true } for i := 1; i &amp;lt;= nums[start]; i++ { if helper(start+i, size, nums) { return true } } return false } Greedy # 使用一个变量 remianed 表示当前剩余的跳力（指从当前节点最多还可以跳几步），然后使用一个值 maxDst 表示当前能够跳到的最远距离。每遍历到一个节点，判断是否能跳到当前节点，也就是 i 是否大于 Dst，如果大于，则说明跳不到当前节点，则可以直接返回 false； 否则说明能跳到当前节点，然后根据当前节点的跳力更新当前节点的最大跳力以及能跳到的最远距离。</description></item><item><title>0056. Merge Intervals</title><link>https://example.com/docs/algs/leetcode/56_merge_intervals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/56_merge_intervals/</guid><description>Description # Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.
Solutions # 典型的区间合并问题。
首先先对区间按照开始时间从小到大进行排序，然后使用一个指针 cur 指向当前 intervals 数组遍历到的位置，使用一个指针 tail 指向 res 数组最后一个元素。然后开始对 intervals 数组进行遍历，如果当前遍历到的区间跟 res 数组的最后一个区间没有重叠，则直接将这个区间插入 res 数组，然后 tail 自增；否则的话就合并区间，更新 res[tail] 的结束时间；每次遍历结束，cur 自增。
func merge(intervals [][]int) [][]int { var res [][]int size := len(intervals) if size &amp;lt;= 1 { return intervals } sort.</description></item><item><title>0062. Unique Paths</title><link>https://example.com/docs/algs/leetcode/62_unique_paths/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/62_unique_paths/</guid><description>Description # There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.
Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.</description></item><item><title>0064. Minimum Path Sum</title><link>https://example.com/docs/algs/leetcode/64_minimum_path_sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/64_minimum_path_sum/</guid><description>Description # Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.
Note: You can only move either down or right at any point in time.
Solutions # DP # 这题跟第 120. Triangle 解法几乎一样。相比之下，这题要简单一些。这里很明显需要使用 DP，并且状态转移方程也是很明确的 dp[i][j] += min(dp[i-1][j], dp[i][j-1])，也就是说，当前位置的值只能从左边移动过来或者上边移动过来。特例情况就是第一行跟第一列，这个地方只有一种移动方向，所以需要特别处理一下。
func minPathSum(grid [][]int) int { m, n := len(grid), len(grid[0]) // corner case for i := 1; i &amp;lt; m ;i++ { grid[i][0] += grid[i-1][0] } for i := 1; i &amp;lt; n; i++ { grid[0][i] += grid[0][i-1] } for i := 1; i &amp;lt; m; i++ { for j := 1; j &amp;lt; n; j++ { grid[i][j] += min(grid[i-1][j], grid[i][j-1]) } } return grid[m-1][n-1] } func min(a,b int) int { if a &amp;lt; b { return a } return b } 当然，如果你不想污染原数组，那么也可以创建一个新的二维数组来做 DP 数组。</description></item><item><title>0066. Plus One</title><link>https://example.com/docs/algs/leetcode/66_plus_one/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/66_plus_one/</guid><description>Description # You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0&amp;rsquo;s.
Increment the large integer by one and return the resulting array of digits.
Solutions # 简单题，直接计算即可。
func plusOne(digits []int) []int { size := len(digits) if size == 0 { return digits } carry := 1 for i := size-1; i &amp;gt;= 0; i-- { sum := digits[i] + carry carry = sum / 10 digits[i] = sum % 10 } if carry &amp;gt; 0 { digits = append([]int{carry}, digits.</description></item><item><title>0069. Sqrt(x)</title><link>https://example.com/docs/algs/leetcode/69_sqrtx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/69_sqrtx/</guid><description> Description # Given a non-negative integer x, compute and return the square root of x.
Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.
Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.
Solutions # Binary Search # 使用二分法进行快速查找。开头就去除掉一些 corner case 的话，后面整体逻辑写起来就会更加的清晰。
func mySqrt(x int) int { if x &amp;lt;= 1 { return x } low, high := 0, x for low &amp;lt; high { mid := (low+high)/2 if mid * mid == x { return mid } else if mid * mid &amp;gt; x { high = mid } else { low = mid + 1 } } // 注意这里为什么返回的是 high - 1 return high - 1 }</description></item><item><title>0070. Climbing Stairs</title><link>https://example.com/docs/algs/leetcode/70_climing_stairs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/70_climing_stairs/</guid><description> Descriptioin # You are climbing a staircase. It takes n steps to reach the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
Solutions # 斐波那契数列问题，不多说。
func climbStairs(n int) int { if n &amp;lt;= 2 { return n } FMinusOne, FMinusTwo := 2, 1 for i := 3; i &amp;lt;= n; i++ { fn := FMinusOne + FMinusTwo FMinusTwo = FMinusOne FMinusOne = fn } return FMinusOne }</description></item><item><title>0073. Set Matrix Zeroes</title><link>https://example.com/docs/algs/leetcode/73_set_matrix_zeroes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/73_set_matrix_zeroes/</guid><description> Descriptioin # Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0&amp;rsquo;s.
You must do it in place.
Solutions # 这里需要注意的是，因为要求不使用额外的内存空间，所以我们就要有这种充分利用原有空间的觉悟。这里的思想是，先检查第一行第一列是否有 0，如果有，则将相应的标志设置为 true，然后使用第一行和第一列来做标记。从第二行第二列开始遍历数组，当 matrix[i][j] = 0 时，则将该行对应的第一个数设置为 0，将该列对应的第一个数设置为 0。遍历结束之后再遍历一次数组，也是从第一行和第一列开始，如果改行或者该列的第一个元素为 0， 则将相应的相应的格子设置为 0.遍历结束后，再根据刚开始设置的行 flag 和列 flag 判断是否应该将第一行和第一列设置为 0.
func setZeroes(matrix [][]int) { m, n := len(matrix), len(matrix[0]) var rowZero, colZero bool // 检查第一列是否包含 0 for i := 0; i &amp;lt; m ;i++ { if matrix[i][0] == 0 { colZero = true break } } // 检查第一行是否包含 0 for i := 0; i &amp;lt; n; i++ { if matrix[0][i] == 0 { rowZero = true break } } // 检查剩余行和列是否包含 0，如果包含，则将相应的第一行位置设为 0，第一列位置设为 0 for i := 1; i &amp;lt; m ;i++ { for j := 1; j &amp;lt; n; j++ { if matrix[i][j] == 0 { matrix[i][0] = 0 matrix[0][j] = 0 } } } // 根据第一行第一列的检测结果，将相应的行和列设置为 0 for i := 1; i &amp;lt; m; i++ { for j := 1; j &amp;lt; n; j++ { if matrix[i][0] == 0 || matrix[0][j] == 0 { matrix[i][j] = 0 } } } // 如果第一行有 0， 则将第一行设置为 0 if rowZero { for i := 0; i &amp;lt; n; i++ { matrix[0][i] = 0 } } // 如果第一列有 0， 则将第一列设置为 0 if colZero { for i := 0; i &amp;lt; m ;i++ { matrix[i][0] = 0 } } }</description></item><item><title>0074. Search a 2D Matrix</title><link>https://example.com/docs/algs/leetcode/74_search_a_2d_matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/74_search_a_2d_matrix/</guid><description> Description # Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:
Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.
Solutions # Binary Search # 这题的二分解法真的比较巧妙。这里首先具备了两个特征：每一行从左向右递增，每一列从上到下递增。那么我们可以从第一列最后一个元素开始进行搜索，如果target 比当前元素要小，那么如果target 要存在，就只能在当前行上边，于是row-1；如果target比当前元素要大，那么如果该元素存在的话，智能在当前列右侧，于是col+1。按照以上规则进行遍历即可。
func searchMatrix(matrix [][]int, target int) bool { m, n := len(matrix), len(matrix[0]) row, col := m-1, 0 for row &amp;gt;= 0 &amp;amp;&amp;amp; col &amp;lt; n { if matrix[row][col] == target { return true } if matrix[row][col] &amp;lt; target { col++ } // 上面的 if 语句可能会导致这里出现越界访问，所以要加上 col &amp;lt; n if col &amp;lt; n &amp;amp;&amp;amp; matrix[row][col] &amp;gt; target { row-- } } return false }</description></item><item><title>0075. Sort Colors</title><link>https://example.com/docs/algs/leetcode/75_sort_colors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/75_sort_colors/</guid><description>Description # Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.
We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.
You must solve this problem without using the library&amp;rsquo;s sort function.
Solutions # 其实这里应该用任意的一个排序算法都可以。
冒泡排序的思路 # 参考冒泡排序算法。</description></item><item><title>0076. Minimum Window Substring</title><link>https://example.com/docs/algs/leetcode/76_minimum_window_substring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/76_minimum_window_substring/</guid><description>Description # Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string &amp;ldquo;&amp;rdquo;.
The testcases will be generated such that the answer is unique.
A substring is a contiguous sequence of characters within the string.
Solutions # Sliding Window # 这里应该很容易可以看出需要使用滑动窗口来做，但是与一般的滑动窗口不同的是，这里的滑动窗口中可以包含一些不在字符串 t 中的字符。另外还需要注意的是，窗口中字符的出现顺序不需要和 t 一致，但是出现次数需要一致。</description></item><item><title>0078. Subsets</title><link>https://example.com/docs/algs/leetcode/78_subsets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/78_subsets/</guid><description> Descrition # Given an integer array nums of unique elements, return all possible subsets (the power set).
The solution set must not contain duplicate subsets. Return the solution in any order.
Solutions # 观察一下可以发现，其实子集合就是一个追加操作。你只需要把新元素不断的追加到就有的集合上构成一个新的集合，然后再将这个新集合添加到结果数组中即可。重复上述操作，直到你把原数组中的所有元素都遍历完一次即可。
func subsets(nums []int) [][]int { res := [][]int{{}} size := len(nums) for i := 0; i &amp;lt; size; i++ { n := len(res) for j := 0; j &amp;lt; n; j++ { t := make([]int, len(res[j])) copy(t, res[j]) t = append(t, nums[i]) res = append(res, t) // 注意不能用下面这样的方式。 // 因为 golang 中切片其实底层是一个指向实际数组的指针，所以下面的添加可能会旧元素上进行添加，而不是在新元素上进行添加。 // t := res[j] // t = append(t, nums[i]) // res = append(res, t) } } return res }</description></item><item><title>0079. Word Search</title><link>https://example.com/docs/algs/leetcode/79_word_search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/79_word_search/</guid><description>Description # Given an m x n grid of characters board and a string word, return true if word exists in the grid.
The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.
Solutions # 递归回溯即可。
func exist(board [][]byte, word string) bool { m, n := len(board), len(board[0]) for i := 0; i &amp;lt; m; i++ { for j := 0; j &amp;lt; n; j++ { if board[i][j] == word[0] { visited := make([][]bool, m) for i, _ := range visited { visited[i] = make([]bool, n) } if existBacktrace(board, word, i, j, m, n, &amp;amp;visited) { return true } } } } return false } func existBacktrace(board [][]byte, word string, si, sj, m, n int, visited *[][]bool) bool { if len(word) == 0 { return true } if si &amp;lt; 0 || sj &amp;lt; 0 || si &amp;gt;= m || sj &amp;gt;= n || (*visited)[si][sj] || board[si][sj] !</description></item><item><title>0084. Largest Rectangle in Histogram</title><link>https://example.com/docs/algs/leetcode/84_largest_rectangle_in_histogram/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/84_largest_rectangle_in_histogram/</guid><description> Description # Given an array of integers heights representing the histogram&amp;rsquo;s bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.
Solutions # 寻找每一个局部峰值 i (heights[i] &amp;gt; heights[i+1])，然后从这个局部峰值 i 开始向前遍历所有的值，算出共同的矩形面积，每次对比保留最大值。 很不幸，超时了 :)
func largestRectangleArea(heights []int) int { var res int size := len(heights) if size == 0 { return res } for i := 0; i &amp;lt; size; i++ { if i+1 &amp;lt; size &amp;amp;&amp;amp; heights[i] &amp;lt;= heights[i+1] { continue } curMin := heights[i] for j := i; j &amp;gt;= 0; j-- { if heights[j] &amp;lt; curMin { curMin = heights[j] } res = max(res, curMin * (i-j+1)) } } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a }</description></item><item><title>0088. Merge Sorted Array</title><link>https://example.com/docs/algs/leetcode/88_merge_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/88_merge_sorted_array/</guid><description>Description # You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.
Merge nums1 and nums2 into a single array sorted in non-decreasing order.
The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored.</description></item><item><title>0091. Decode Ways</title><link>https://example.com/docs/algs/leetcode/91_decode_ways/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/91_decode_ways/</guid><description>Description # A message containing letters from A-Z can be encoded into numbers using the following mapping:
&amp;lsquo;A&amp;rsquo; -&amp;gt; &amp;ldquo;1&amp;rdquo; &amp;lsquo;B&amp;rsquo; -&amp;gt; &amp;ldquo;2&amp;rdquo; &amp;hellip; &amp;lsquo;Z&amp;rsquo; -&amp;gt; &amp;ldquo;26&amp;rdquo; To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, &amp;ldquo;11106&amp;rdquo; can be mapped into:
&amp;ldquo;AAJF&amp;rdquo; with the grouping (1 1 10 6) &amp;ldquo;KJF&amp;rdquo; with the grouping (11 10 6) Note that the grouping (1 11 06) is invalid because &amp;ldquo;06&amp;rdquo; cannot be mapped into &amp;lsquo;F&amp;rsquo; since &amp;ldquo;6&amp;rdquo; is different from &amp;ldquo;06&amp;rdquo;.</description></item><item><title>0092. Reverse Linked List II</title><link>https://example.com/docs/algs/leetcode/92_reverse_linked_list_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/92_reverse_linked_list_ii/</guid><description>Description # Given the head of a singly linked list and two integers left and right where left &amp;lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list.
Solutions # 使用头插法来翻转节点：先找到待翻转节点的前一个节点pre，pre 的下一个几点就是要翻转的第一个节点 cur，使用一个节点 t 表示 cur 的下一个节点，防止断链。然后将 cur 连接到 t 的下一个节点上，然后将 t 的下一个节点设置为 cur，然后再将 pre 指向 t，这样就完成了一个节点的翻转，然后继续翻转下面的节点即可。
func reverseBetween(head *ListNode, left int, right int) *ListNode { if head == nil || right &amp;lt; left { return nil } // 试用 dummy 防止出现需要翻转第一个节点的情况 dummy := new(ListNode) dummy.</description></item><item><title>0094. Bianry Tree Inorder Traversal</title><link>https://example.com/docs/algs/leetcode/94_binary_tree_inorder_traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/94_binary_tree_inorder_traversal/</guid><description>Description # Given the root of a binary tree, return the inorder traversal of its nodes&amp;rsquo; values.
Solutions # 二叉树中序遍历，又分为迭代和递归两种方式。
Recursive # func inorderTraversal(root *TreeNode) []int { var res []int if root == nil { return res } helper(root, &amp;amp;res) return res } func helper(root *TreeNode, res *[]int) { if root == nil { return } helper(root.Left, res) *res = append(*res, root.Val) helper(root.Right, res) } Iterative # 中序遍历需要借助栈来实现。
func inorderTraversal(root *TreeNode) []int { var res []int if root == nil { return res } var stack []*TreeNode cur := root for cur !</description></item><item><title>0098. Validate Bianry Search Tree</title><link>https://example.com/docs/algs/leetcode/98_validate_binary_search_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/98_validate_binary_search_tree/</guid><description>Description # Given the root of a binary tree, determine if it is a valid binary search tree (BST).
A valid BST is defined as follows:
The left subtree of a node contains only nodes with keys less than the node&amp;rsquo;s key. The right subtree of a node contains only nodes with keys greater than the node&amp;rsquo;s key. Both the left and right subtrees must also be binary search trees.</description></item><item><title>0101. Symmetric Tree</title><link>https://example.com/docs/algs/leetcode/101_symmetric_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/101_symmetric_tree/</guid><description>Description # Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).
Solutions # 简单题，左子树的左节点的值要等于右子树的右子树的右节点的值，左子树的右节点的值要等于右子树的左节点的值。
func isSymmetric(root *TreeNode) bool { return helper(root, root) } func helper(root1, root2 *TreeNode) bool { if root1 == nil &amp;amp;&amp;amp; root2 == nil { return true } if root1 == nil || root2 == nil { return false } if root1.Val != root2.Val { return false } return helper(root1.</description></item><item><title>0102. Binary Tree Level Order Traversal</title><link>https://example.com/docs/algs/leetcode/102_binary_tree_level_order_traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/102_binary_tree_level_order_traversal/</guid><description>Description # Given the root of a binary tree, return the level order traversal of its nodes&amp;rsquo; values. (i.e., from left to right, level by level).
Solutions # 层次遍历，使用队列来做即可。
func levelOrder(root *TreeNode) [][]int { var res [][]int if root == nil { return res } queue := new(Queue) queue.Push(root) for queue.Len() != 0 { size := queue.Len() var arr []int for size != 0 { ele := queue.Pop().(*TreeNode) size -= 1 if ele == nil { continue } arr = append(arr, ele.</description></item><item><title>0103. Binary Tree ZigZag Level Order Traversal</title><link>https://example.com/docs/algs/leetcode/103_binary_tree_zigzag_level_order_traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/103_binary_tree_zigzag_level_order_traversal/</guid><description>Description # Given the root of a binary tree, return the zigzag level order traversal of its nodes&amp;rsquo; values. (i.e., from left to right, then right to left for the next level and alternate between).
Solutions # 简单题，使用队列进行层次遍历即可。
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func zigzagLevelOrder(root *TreeNode) [][]int { var res [][]int if root == nil { return res } var queue []*TreeNode queue = append(queue, root) var flag bool for len(queue) !</description></item><item><title>0104. Maximum Depth of Binary Tree</title><link>https://example.com/docs/algs/leetcode/104_maximum_depth_of_binary_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/104_maximum_depth_of_binary_tree/</guid><description> Description # Given the root of a binary tree, return its maximum depth.
A binary tree&amp;rsquo;s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
Solutions # 简单题，无需多说。
func maxDepth(root *TreeNode) int { if root == nil { return 0 } return max(maxDepth(root.Left), maxDepth(root.Right)) + 1 } func max(a,b int) int { if a &amp;lt; b { return b } return a }</description></item><item><title>0105. Construct Bianry Tree From Preorder and Inorder Traversal</title><link>https://example.com/docs/algs/leetcode/105_construct_binary_tree_from_preorder_and_inorder_traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/105_construct_binary_tree_from_preorder_and_inorder_traversal/</guid><description>Description # Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.
Solutions # func buildTree(preorder []int, inorder []int) *TreeNode { pre_size, in_size := len(preorder), len(inorder) return buildTreeSolution(preorder, 0, pre_size-1, inorder, 0, in_size -1) } func buildTreeSolution(preorder []int, pleft, pright int, inorder []int, ileft, iright int) *TreeNode { if pleft &amp;gt; pright || ileft &amp;gt; iright { return nil } var rootIndex int for i := ileft; i &amp;lt;= iright; i++ { if inorder[i] == preorder[pleft] { rootIndex = i break } } root := new(TreeNode) root.</description></item><item><title>0108. Convert Sorted Array to Binary Search Tree</title><link>https://example.com/docs/algs/leetcode/108_convert_sorted_array_to_binary_search_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/108_convert_sorted_array_to_binary_search_tree/</guid><description>Description # Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.
A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.
Solutions # 简单题，直接递归构建即可。
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func sortedArrayToBST(nums []int) *TreeNode { size := len(nums) if size == 0 { return nil } return helper(nums, 0, size-1) } func helper(nums []int, start, end int) *TreeNode { if start &amp;gt; end { return nil } mid := (start+end)/2 node := new(TreeNode) node.</description></item><item><title>0116. Populating Next Right Pointers in Eech Node</title><link>https://example.com/docs/algs/leetcode/116_populating_next_right_pointers_in_each_node/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/116_populating_next_right_pointers_in_each_node/</guid><description>Description # You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:
struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.
Initially, all next pointers are set to NULL.</description></item><item><title>0118. Pascal's Triangle</title><link>https://example.com/docs/algs/leetcode/118_pascals_triangle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/118_pascals_triangle/</guid><description> Description # Given an integer numRows, return the first numRows of Pascal&amp;rsquo;s triangle.
In Pascal&amp;rsquo;s triangle, each number is the sum of the two numbers directly above it
Solutions # 这里有很多 trick，还是需要注意一下。
func generate(numRows int) [][]int { var res [][]int for i := 0; i &amp;lt; numRows; i++ { var cur []int for j := 0; j &amp;lt; i+1; j++ { cur = append(cur, 1) } res = append(res, cur) for j := 1; j &amp;lt; i; j++ { res[i][j] = res[i-1][j-1] + res[i-1][j] } } return res }</description></item><item><title>0120. Triangle</title><link>https://example.com/docs/algs/leetcode/120_triangle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/120_triangle/</guid><description>Description # Given a triangle array, return the minimum path sum from top to bottom.
For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.
Solutions # Brute Force # 题主首先想出了贪心的解法，但是因为”局部最优并不代表全局最优“，所以没能通过，不过还是贴一下代码：
func minimumTotal(triangle [][]int) int { size := len(triangle) arr := make([]int, size+1) var start int for i := 1; i &amp;lt;= size; i++ { if start + 1 &amp;lt; len(triangle[i-1]) &amp;amp;&amp;amp; triangle[i-1][start+1] &amp;lt; triangle[i-1][start] { start = start + 1 } arr[i] = dp[i-1] + triangle[i-1][start] } return arr[size] } 既然上面的贪心不行，那么使用递归来试试呢？于是楼主又写出了下面的解法：</description></item><item><title>0121. Best Time to But And Sell Stock</title><link>https://example.com/docs/algs/leetcode/121_best_time_to_buy_and_sell_stock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/121_best_time_to_buy_and_sell_stock/</guid><description>Description # You are given an array prices where prices[i] is the price of a given stock on the ith day.
You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.
Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.
Solutions # 首先可以直接暴力求解，但是会超时。</description></item><item><title>0122. Best Time to But And Sell Stock II</title><link>https://example.com/docs/algs/leetcode/122_best_time_to_buy_and_sell_stock_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/122_best_time_to_buy_and_sell_stock_ii/</guid><description>Description # You are given an integer array prices where prices[i] is the price of a given stock on the ith day.
On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.
Find and return the maximum profit you can achieve.</description></item><item><title>0124. Binary Tree Maximum Path Sum</title><link>https://example.com/docs/algs/leetcode/124_binary_tree_maximum_path_sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/124_binary_tree_maximum_path_sum/</guid><description>Description # A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.
The path sum of a path is the sum of the node&amp;rsquo;s values in the path.
Given the root of a binary tree, return the maximum path sum of any non-empty path.</description></item><item><title>0125. Valid Palindrome</title><link>https://example.com/docs/algs/leetcode/125_valid_palindrome/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/125_valid_palindrome/</guid><description>Description # A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.
Given a string s, return true if it is a palindrome, or false otherwise.
Solutions # 简单题，去除字符之后直接判断即可。
func isPalindrome(s string) bool { if len(s) &amp;lt;= 1 { return true } s = strings.ToLower(s) var str []rune for _, r := range s { if r &amp;gt;= rune(&amp;#39;a&amp;#39;) &amp;amp;&amp;amp; r &amp;lt;= rune(&amp;#39;z&amp;#39;) || r &amp;gt;= rune(&amp;#39;0&amp;#39;) &amp;amp;&amp;amp; r &amp;lt;= rune(&amp;#39;9&amp;#39;){ str = append(str, r) } } size := len(str) if size &amp;lt;= 1{ return true } left, right := 0, size -1 for left &amp;lt; right { if str[left] !</description></item><item><title>0127. Word Ladder</title><link>https://example.com/docs/algs/leetcode/127_word_ladder/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/127_word_ladder/</guid><description>Description # A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -&amp;gt; s1 -&amp;gt; s2 -&amp;gt; &amp;hellip; -&amp;gt; sk such that:
Every adjacent pair of words differs by a single letter. Every si for 1 &amp;lt;= i &amp;lt;= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.</description></item><item><title>0128. Longest Consecurive Sequence</title><link>https://example.com/docs/algs/leetcode/128_longest_consecutive_sequence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/128_longest_consecutive_sequence/</guid><description> Description # Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.
You must write an algorithm that runs in O(n) time.
Solutions # 使用一个集合存入所有的数字，然后遍历数组中的每个数字，如果其在集合中存在，那么将其移除，然后 pre 再自减 1，直至pre 不在集合之中，对 next 采用同样的方法，那么 next - pre -1 就是当前数字的最长连续序列。之所以要移除数字，是为了避免重复计算。比如说对于 4、3、2，如果计算 4 的时候不把 3 和 2 移除掉，那么计算 3 和 2 的时候就会出现重复计算的情况。
func longestConsecutive(nums []int) int { var res int dict := make(map[int]bool) for _, num := range nums { dict[num] = true } for _, num := range nums { left, right := num -1, num + 1 for dict[left] == true { delete(dict, left) left-- } for dict[right] == true { delete(dict, right) right++ } res = max(res, right-left-1) } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a }</description></item><item><title>0130. Surrounded Regions</title><link>https://example.com/docs/algs/leetcode/130_surrounded_regions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/130_surrounded_regions/</guid><description>Description # Given an m x n matrix board containing &amp;lsquo;X&amp;rsquo; and &amp;lsquo;O&amp;rsquo;, capture all regions that are 4-directionally surrounded by &amp;lsquo;X&amp;rsquo;.
A region is captured by flipping all &amp;lsquo;O&amp;rsquo;s into &amp;lsquo;X&amp;rsquo;s in that surrounded region.</description></item><item><title>0131. Palindrome Partitioning</title><link>https://example.com/docs/algs/leetcode/131_palindrome_partitioning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/131_palindrome_partitioning/</guid><description>Description # Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.
A palindrome string is a string that reads the same backward as forward.
Solutions # 简单递归回溯即可。
func partition(s string) [][]string { var res [][]string size := len(s) if size == 0 { return res } var cur []string helper(s,0,size, cur, &amp;amp;res) return res } func helper(s string, start, size int, cur []string, res *[][]string) { if start &amp;gt;= size { tmp := make([]string, len(cur)) copy(tmp, cur) *res = append(*res, tmp) return } for i := start; i &amp;lt; size; i++ { if isPalindrome(s[start: i+1]) { cur = append(cur, s[start:i+1]) helper(s, i+1, size, cur, res) cur = cur[:len(cur)-1] } } } func isPalindrome(s string) bool { size := len(s) left, right := 0, size -1 for left &amp;lt; right { if s[left] !</description></item><item><title>0134. Gas Station</title><link>https://example.com/docs/algs/leetcode/134_gas_station/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/134_gas_station/</guid><description>Description # There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].
You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.
Given two integer arrays gas and cost, return the starting gas station&amp;rsquo;s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</description></item><item><title>0136. Single Number</title><link>https://example.com/docs/algs/leetcode/136_single_number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/136_single_number/</guid><description> Description # Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.
You must implement a solution with a linear runtime complexity and use only constant extra space.
Solutions # 简单题，直接使用异或运算符即可。注意 res 初始化应该为 0.
func singleNumber(nums []int) int { var res int for _, num := range nums { res ^= num } return res }</description></item><item><title>0141. Linked List Cycle</title><link>https://example.com/docs/algs/leetcode/141_Linked-List-Cycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/141_Linked-List-Cycle/</guid><description>Description # Given head, the head of a linked list, determine if the linked list has a cycle in it.
There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail&amp;rsquo;s next pointer is connected to. Note that pos is not passed as a parameter.</description></item><item><title>0142. Linked List Cycle II</title><link>https://example.com/docs/algs/leetcode/142_linked_list_cycle_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/142_linked_list_cycle_ii/</guid><description>Description # Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.
There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail&amp;rsquo;s next pointer is connected to (0-indexed). It is -1 if there is no cycle.</description></item><item><title>0146. LRU Cache</title><link>https://example.com/docs/algs/leetcode/146_lru_cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/146_lru_cache/</guid><description>Description # Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.
Implement the LRUCache class:
LRUCache(int capacity) Initialize the LRU cache with positive size capacity. int get(int key) Return the value of the key if the key exists, otherwise return -1. void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache.</description></item><item><title>0148. Sort List</title><link>https://example.com/docs/algs/leetcode/148_sort_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/148_sort_list/</guid><description>Description # Given the head of a linked list, return the list after sorting it in ascending order.
Solutions # 第一个想法很简单，先扫描一遍链表，把扫描到的值记录到数组，然后对数组进行排序，最后再把排序结果赋值给原链表即可。时间复杂度 \(\Omicron(n\log n)\) , 空间复杂度 \($\Omicron(n)$\) 。
方法二，可以用插入排序的思想。维持一个排好序的链表，从头结点开始扫描，每扫描到一个节点，就将其插入到这个有序链表中去。这样空间复杂度就是 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n^2)$\) 。
follow up 但是这里要求的是时间复杂度 \($\Omicron(n\log n)$\) ，空间复杂度 \($\Omicron(1)$\) ，那很明显上述解法都不满足。这里竟然可以用归并排序，归并排序的时间复杂度是 \($\Omicron(n\logn)$\) ，归并排序又分为自顶向下和自底向上两种，前者空间复杂度是 \($\Omicron(\log n)$\) （因为栈深度），后者可以达到 \($\Omicron(1)$\) 。
这里是自顶向下的解法，需要注意的是，在 getMiddle 函数中将 middle 节点和前一个节点断开是一个非常重要的操作。
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func sortList(head *ListNode) *ListNode { return mergeSortUpDown(head) } func mergeSortUpDown(head *ListNode) *ListNode { if head == nil || head.</description></item><item><title>0150. Evaluate Reverse Polish Notation</title><link>https://example.com/docs/algs/leetcode/150_evaluate_reverse_polish_notation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/150_evaluate_reverse_polish_notation/</guid><description>Description # Evaluate the value of an arithmetic expression in Reverse Polish Notation.
Valid operators are +, -, *, and /. Each operand may be an integer or another expression.
Note that division between two integers should truncate toward zero.
It is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.</description></item><item><title>0155. Min Stack</title><link>https://example.com/docs/algs/leetcode/155_min_stack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/155_min_stack/</guid><description>Desctiption # Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
Implement the MinStack class:
MinStack() initializes the stack object. void push(int val) pushes the element val onto the stack. void pop() removes the element on the top of the stack. int top() gets the top element of the stack. int getMin() retrieves the minimum element in the stack. Solutions # 除了维持一个正常的栈来维持压入的元素之外，还需要维持一个单调递减栈当前的最小数。具体做法是，当压入一个元素的时候，如果单调栈中元素为空，则直接压入元素到单调栈中；如果单调中元素不为空，那么又分为单调栈顶元素比当前压入元素大还是小两种情况，如果栈顶元素比当前压入元素大，那么将当前压入元素压入单调栈；如果栈顶元素比当前压入元素小，那么再次压入栈顶元素。弹出时，除了对正常栈进行弹出之外，还需要对单调栈进行弹出操作。getMin 函数直接返回单调栈顶元素即可。</description></item><item><title>0160. Intersection of Two Linked Lists</title><link>https://example.com/docs/algs/leetcode/160_intersection_of_two_linked_lists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/160_intersection_of_two_linked_lists/</guid><description>Description # Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.
Solutions # Hash Table # 首先很容易想到哈希表的解法。
func getIntersectionNode(headA, headB *ListNode) *ListNode { if headA == nil || headB == nil { return nil } dict := make(map[*ListNode]bool) dummyA , dummyB := headA, headB for dummyA != nil { dict[dummyA] = true dummyA = dummyA.</description></item><item><title>0162. Find Peak Element</title><link>https://example.com/docs/algs/leetcode/162_find_peak_element/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/162_find_peak_element/</guid><description>Description # A peak element is an element that is strictly greater than its neighbors.
Given an integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.
You may imagine that nums[-1] = nums[n] = -∞.
You must write an algorithm that runs in \( Omicron(\log n) \) time.
Solutions # One Pass Iteration # 这里可以通过一次数组的一次遍历来完成。为了方便，我们可以在头部和尾部分别添加上一个最小值，这样能够减少一些边界值判断。当然，这种方法并不符合题目要求的 \( \Omicron(n\log n) \) 的要求。</description></item><item><title>0167. Two Sum II - Input Array Is Sorted</title><link>https://example.com/docs/algs/leetcode/167_two_sum_ii_input_array_is_sorted/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/167_two_sum_ii_input_array_is_sorted/</guid><description>Description # Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &amp;lt;= index1 &amp;lt; index2 &amp;lt;= numbers.length.
Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.
The tests are generated such that there is exactly one solution.</description></item><item><title>0179. Largest Number</title><link>https://example.com/docs/algs/leetcode/179_largest_numbe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/179_largest_numbe/</guid><description>Description # Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.
Since the result may be very large, so you need to return a string instead of an integer.
Solutions # 这里的解法需要十分注意，跟一般的排序是有区别的。
import ( &amp;#34;strconv&amp;#34; &amp;#34;sort&amp;#34; &amp;#34;strings&amp;#34; ) func largestNumber(nums []int) string { var rs []string for _, num := range nums { rs = append(rs, strconv.Itoa(num)) } // 这里应该进行连接排序 sort.</description></item><item><title>0191. Number of 1 Bits</title><link>https://example.com/docs/algs/leetcode/191_number_of_1_bits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/191_number_of_1_bits/</guid><description> Description # Write a function that takes an unsigned integer and returns the number of &amp;lsquo;1&amp;rsquo; bits it has (also known as the Hamming weight).
Solutions # 太简单了，并且输入还是无符号数，没啥好说的，直接看代码。
func hammingWeight(num uint32) int { var res int for num != 0 { res += int(num&amp;amp;1) num &amp;gt;&amp;gt;= 1 } return res }</description></item><item><title>0206. Reverse Linked List</title><link>https://example.com/docs/algs/leetcode/206_reverse_linked_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/206_reverse_linked_list/</guid><description>Description # Given the head of a singly linked list, reverse the list, and return the reversed list.
Solutions # Iterative # 迭代法，但是要注意虚拟头节点的使用。
func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } dummy := new(ListNode) cur := head for cur != nil { tail := dummy.Next next := cur.Next dummy.Next = cur cur.Next = tail cur = next } return dummy.Next } Recursive # 这里递归法如何反转节点也是需要十分注意的。</description></item><item><title>0215. Kth Largest Element in an Array</title><link>https://example.com/docs/algs/leetcode/215_kth_largest_element_in_an_arrary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/215_kth_largest_element_in_an_arrary/</guid><description>Description # Given an integer array nums and an integer k, return the kth largest element in the array.
Note that it is the kth largest element in the sorted order, not the kth distinct element.
Solutions # Heap # 创建一个 k 个大小的最小堆，首先先将前 k 个元素压入堆中，而后面的元素只有当其比堆顶元素要大的时候才可以入堆。最后堆顶元素即为所求。
import ( &amp;#34;container/heap&amp;#34; ) func findKthLargest(nums []int, k int) int { return findKthLargestUsingSort(nums, 0, len(nums)-1, k) } // 解法1， 使用最大堆来解 func findKthLargestUsingHeap(nums []int, k int) int { var maxHeap MaxHeap heap.</description></item><item><title>0224. Basic Calculator</title><link>https://example.com/docs/algs/leetcode/224_basic_calculator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/224_basic_calculator/</guid><description>Description # Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.
Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().
Solutions # 第一个想法就是，可以先把中缀表达式转换为后缀表达式，然后再对后缀表达式进行计算，这样就会简单很多。那么问题是，如果将一个带有括号的中缀表达式转换为后缀表达式呢？这里的精简版算法如下：
声明 Q：输出队列 声明 S：操作符栈 遍历中缀表达式中的每一个 token x： - 如果 x 是一个操作数，则直接将 x 追加到输出队列 Q 末尾，否则往下检查； - 如果 x 是一个左括号&amp;#34;(&amp;#34;，则将 x 压入操作符栈，否则往下检查； - 如果 x 是一个操作符： - 如果操作符栈 S 栈顶为一个优先级大于等于 x 的操作符，则将 S 栈顶的操作符弹出并且追加到输出队列 Q 末尾，最后将 x 压入栈顶； - 如果操作符栈 S 栈顶为一个优先级小于等于 x 的操作符，或者不为操作符（这里只可能是左括号&amp;#34;（&amp;#34;）,则直接将 x 压入栈顶即可。 - 如果 x 是一个右括号，则将操作符栈 S 栈顶往下到第一个左括号之间的元素以此弹出炳且追加到输出队列末尾，然后将左括号丢弃，右括号也不用入栈。注意，如果栈到底后仍然没有找到左括号，则说明表达式不合法，左右括号不匹配。 最后将栈 S 中得到的元素全部依次弹出并且入队 Q 即可。 TODO</description></item><item><title>0225. Implement Stack using Queues</title><link>https://example.com/docs/algs/leetcode/225_implement_stack_using_queues/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/225_implement_stack_using_queues/</guid><description>Description # Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).
Implement the MyStack class:
void push(int x) Pushes element x to the top of the stack. int pop() Removes the element on the top of the stack and returns it. int top() Returns the element on the top of the stack. boolean empty() Returns true if the stack is empty, false otherwise.</description></item><item><title>0227. Basic Calculator II</title><link>https://example.com/docs/algs/leetcode/227_basic_calculator_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/227_basic_calculator_ii/</guid><description>Description # Given a string s which represents an expression, evaluate this expression and return its value.
The integer division should truncate toward zero.
You may assume that the given expression is always valid. All intermediate results will be in the range of \([-2^31, 2^31 - 1]\) .
Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().
Solutions # 这个题目因为不涉及乘除法，相比第 224 题就简单很多了，老老实实使用栈来求值就好了。这里也可以先将中缀表达式转换为后缀表达式，然后再对后缀表达式进行求值。</description></item><item><title>0232. Implement Queue using Stacks</title><link>https://example.com/docs/algs/leetcode/232_implement_queue_using_stacks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/232_implement_queue_using_stacks/</guid><description>Description # Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).
Implement the MyQueue class:
void push(int x) Pushes element x to the back of the queue. int pop() Removes the element from the front of the queue and returns it. int peek() Returns the element at the front of the queue.</description></item><item><title>0240. Search a 2D Matrix II</title><link>https://example.com/docs/algs/leetcode/240_search_a_2d_matrix_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/240_search_a_2d_matrix_ii/</guid><description> Description # Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:
Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom.
Solutions # Binary Search # 这个题使用跟 74 题一样的解法完全可以解决。
这题的二分解法真的比较巧妙。这里首先具备了两个特征：每一行从左向右递增，每一列从上到下递增。那么我们可以从第一列最后一个元素开始进行搜索，如果target 比当前元素要小，那么如果target 要存在，就只能在当前行上边，于是row-1；如果target比当前元素要大，那么如果该元素存在的话，智能在当前列右侧，于是col+1。按照以上规则进行遍历即可。
func searchMatrix(matrix [][]int, target int) bool { m,n := len(matrix), len(matrix[0]) row, col := m - 1, 0 for row &amp;gt;= 0 &amp;amp;&amp;amp; col &amp;lt; n { if matrix[row][col] == target { return true } if matrix[row][col] &amp;lt; target { col++ } if col &amp;lt; n &amp;amp;&amp;amp; matrix[row][col] &amp;gt; target { row-- } } return false }</description></item><item><title>0263. Ugly Number</title><link>https://example.com/docs/algs/leetcode/263_ugly_number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/263_ugly_number/</guid><description> Description # An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.
Given an integer n, return true if n is an ugly number.
Solutions # 如果一个数是丑数，那么它的因子必然只有 2、3、5 这三个，那么如果 n 能够被它的这些因子整除，那就不断的缩小 n，最后检查 n 不断被整除后的 n 其是否等于 1 即可。
func isUgly(n int) bool { if n &amp;lt;= 0 { return false } if n &amp;lt;= 6 { return true } for n % 2 == 0 { n /= 2 } for n %3 == 0 { n /= 3 } for n % 5 == 0 { n /= 5 } return n == 1 }</description></item><item><title>0264. Ugly Number II</title><link>https://example.com/docs/algs/leetcode/264_ugly_number_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/264_ugly_number_ii/</guid><description>Description # An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.
Given an integer n, return the nth ugly number.
Solutions # 下面这种是错误的解法，下面的逻辑意味着丑数只能从 2 的幂、3 的幂以及 5 的幂中出现，但是 6 并不属于上述任何一种，但是 6 也是幂。
func nthUglyNumber(n int) int { if n &amp;lt;= 6 { return n } res := 1 i2,i3,i5 := 1,1,1 for i := 2; i &amp;lt; n; i++ { res = min(i2*2, min(i3*3, i5*5)) // 错误做法。按照下面的逻辑，丑数只能从 2 的幂，3 的幂以及 5 的幂中出现，这个逻辑是不对的。 if res /2 == i2 { i2 *= 2 } if res / 3 == i3 { i3 *= 3 } if res / 5 == i5 { i5 *= 5 } } return res } func min(a,b int) int { if a &amp;lt; b { return a } return b } 下面这个才是正确的解法，这个解法是从已有丑数中找出下一个最小的丑数。</description></item><item><title>0268. Missing Number</title><link>https://example.com/docs/algs/leetcode/268_missing_number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/268_missing_number/</guid><description> Description # Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.
Solutions # 这题很简单，只需要使用求和公式来进行计算就可以了。直接给出代码。
func missingNumber(nums []int) int { n := len(nums) sum := (0+n) * (n+1)/2 for _, num := range nums { sum -= num } return sum }</description></item><item><title>0278. First Bad Version</title><link>https://example.com/docs/algs/leetcode/278_first_bad_version/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/278_first_bad_version/</guid><description>Description # You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.
Suppose you have n versions [1, 2, &amp;hellip;, n] and you want to find out the first bad one, which causes all the following ones to be bad.</description></item><item><title>0281. Zigzag Iterator</title><link>https://example.com/docs/algs/leetcode/281_zigzag_iterator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/281_zigzag_iterator/</guid><description>Description # Given two 1d vectors, implement an iterator to return their elements alternately.
For example, given two 1d vectors:
v1 = [1, 2] v2 = [3, 4, 5, 6] By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1, 3, 2, 4, 5, 6].
Follow up: What if you are given k 1d vectors? How well can your code be extended to such cases?</description></item><item><title>03. 数组中重复的数字</title><link>https://example.com/docs/algs/codingInterviews/03_%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E7%BB%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/03_%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E7%BB%84/</guid><description> Description # 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组[2,3,1,0,2,5,3]，那么对应的输出是2或者3。存在不合法的输入的话输出-1
数据范围： \($0\le n \le 10000$\) 进阶：时间复杂度 \($\Omicron(n)$\) ，空间复杂度 \($\Omicron(n)$\) Solutions # Hash table # 简单题，要么使用哈希表，要么就排一下序。
func duplicate( numbers []int ) int { // write code here // size := len(numbers) dict := make(map[int]bool) for _, value := range numbers { if _, ok := dict[value]; ok { return value } dict[value] = true } return -1 }</description></item><item><title>0303. Range Sum Query - Immutable</title><link>https://example.com/docs/algs/leetcode/303_range_sum_query_immutable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/303_range_sum_query_immutable/</guid><description>Solutions # Brute Force &amp;amp; Memorial # 本来题主以为这里考的是使用记忆化数组来避免重复计算，结果一提交结果，发现自己还是太天真了&amp;hellip;
type NumArray struct { nums []int dict map[string]int } func Constructor(nums []int) NumArray { return NumArray{nums, make(map[string]int)} } func (this *NumArray) SumRange(left int, right int) int { if left == right { return (*this).nums[left] } if left &amp;gt; right { return 0 } target := string(left) + string(right) if _, ok := (*this).dict[target]; ok { return (*this).dict[target] } res := this.nums[left] + this.</description></item><item><title>0304. Range Sum Query - Mutable</title><link>https://example.com/docs/algs/leetcode/307_range_sum_query_mutable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/307_range_sum_query_mutable/</guid><description>Description # Given an integer array nums, handle multiple queries of the following types:
Update the value of an element in nums.
Calculate the sum of the elements of nums between indices left and right inclusive where left &amp;lt;= right. Implement the NumArray class:
NumArray(int[] nums) Initializes the object with the integer array nums.
void update(int index, int val) Updates the value of nums[index] to be val.
int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.</description></item><item><title>0304. Range Sum Query 2D - Immutable</title><link>https://example.com/docs/algs/leetcode/304_range_sum_query_2d_immutable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/304_range_sum_query_2d_immutable/</guid><description>Description # Given a 2D matrix matrix, handle multiple queries of the following type:
Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2). Implement the NumMatrix class:
NumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix. int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).</description></item><item><title>0313. Super Ugly Number</title><link>https://example.com/docs/algs/leetcode/313_super_ugly_number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/313_super_ugly_number/</guid><description>Description # A super ugly number is a positive integer whose prime factors are in the array primes.
Given an integer n and an array of integers primes, return the nth super ugly number.
The nth super ugly number is guaranteed to fit in a 32-bit signed integer.
Solutions # K Pointer # 这个题可以用第 264 题的解法来解。区别是，第 264 题中我们只有三个因子，但是这里的因子是不固定的，那么我们只需要使用一个 map 来充当 264 题中的多指针即可。
关于为什么使用多指针就可以，这里参见一个 LeetCode 上的 回答:
这道题一开始死活不明白三指针到底是怎么用的。后来突然就想明白了：
例如 n = 10， primes = [2, 3, 5]。 打印出丑数列表：1, 2, 3, 4, 5, 6, 8, 9, 10, 12 首先一定要知道，后面的丑数一定由前面的丑数乘以2，或者乘以3，或者乘以5得来。例如，8,9,10,12一定是1, 2, 3, 4, 5, 6乘以2,3,5三个质数中的某一个得到。</description></item><item><title>0318. Maximum Product of Word Lengths</title><link>https://example.com/docs/algs/leetcode/318_maximum_product_of_word_lengths/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/318_maximum_product_of_word_lengths/</guid><description> Description # Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0.
Solutions # \( \Omicron (n^2) \) 的解法，相当于暴力求解了，因为限定了字符串中只会出现小写字符，而小写字符只有 26 个，那么就可以一个 32 位的 int 值 mask 来记录每个字符是否出现过，然后不同字符的 mask 之间进行相与，如果与的结果为 0，说明这两个字符没有重叠字符，那么就更新结果。
func maxProduct(words []string) int { var res int size := len(words) dict := make(map[int]int, size) for i := 0; i &amp;lt; size; i++ { for _, r := range words[i] { dict[i] |= 1 &amp;lt;&amp;lt; (int(r) - int(&amp;#39;a&amp;#39;)) } for j := 0; j &amp;lt; i; j++ { if (dict[i] &amp;amp; dict[j]) == 0 { res = max(res, len(words[i]) * len(words[j])) } } } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a }</description></item><item><title>0328. Odd Even Linked List</title><link>https://example.com/docs/algs/leetcode/328_odd_even_linked_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/328_odd_even_linked_list/</guid><description>Description # Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.
The first node is considered odd, and the second node is even, and so on.
Note that the relative order inside both the even and odd groups should remain as it was in the input.
You must solve the problem in O(1) extra space complexity and O(n) time complexity.</description></item><item><title>0346. Moving Average from Data Stream</title><link>https://example.com/docs/algs/leetcode/346_moving_average_from_data_stream/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/346_moving_average_from_data_stream/</guid><description>Description # Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.
Example: &amp;rsquo;&amp;rsquo;&amp;rsquo; MovingAverage m = new MovingAverage(3); m.next(1) = 1 m.next(10) = (1 + 10) / 2 m.next(3) = (1 + 10 + 3) / 3 m.next(5) = (10 + 3 + 5) / 3 &amp;rsquo;''
Solutions # 很明显是使用队列啦。
type MovingAverage struct { nums []int size int sum int } /** Initialize your data structure here.</description></item><item><title>0347. Top K Frequent Elements</title><link>https://example.com/docs/algs/leetcode/347_top_k_frequent_elements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/347_top_k_frequent_elements/</guid><description>Description # Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.
Solutions # Hash Table &amp;amp; Sort # 这里首先使用 map 来统计每个元素出现的次数，然后将元素和其出现的次数组成一个 pair 对，根据每个 pair 对的元素出现次数对 pair 对进行排序，最后取前 k 个即可。
func topKFrequent(nums []int, k int) []int { dict := make(map[int]int) for _, num := range nums { dict[num]++ } type Pair struct { num int cnt int } var pairs []Pair for key, cnt := range dict { pairs = append(pairs, Pair{key, cnt}) } sort.</description></item><item><title>0349. Intersection of Two Arrays</title><link>https://example.com/docs/algs/leetcode/349_intersection_of_two_arrays/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/349_intersection_of_two_arrays/</guid><description> Description # Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.
Solutoins # 简单题，只需要使用 map 即可。
func intersection(nums1 []int, nums2 []int) []int { d1,d2 := make(map[int]int), make(map[int]int) for _, num := range nums1 { d1[num]++ } for _, num := range nums2 { d2[num]++ } var res []int for key, _ := range d1 { if _, ok := d2[key]; ok { res = append(res, key) } } return res }</description></item><item><title>0350. Intersection of Two Arrays II</title><link>https://example.com/docs/algs/leetcode/350_intersection_of_two_arrays_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/350_intersection_of_two_arrays_ii/</guid><description> Description # Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.
Solutions # 这里跟 349 题的区别是，一个元素可能会出现多次，所以我们在统计完两个书中的元素的出现次数之后，需要确定把该元素放几次到结果数组中，那么需要放几次呢？这个次数应该跟该元素在两个数组中出现的最小次数相等。
func intersect(nums1 []int, nums2 []int) []int { d1,d2 := make(map[int]int), make(map[int]int) for _, num := range nums1 { d1[num]++ } for _, num := range nums2 { d2[num]++ } var res []int for key, value := range d1 { if cnt, ok := d2[key]; ok { m := min(cnt, value) for i := 0; i &amp;lt; m; i++ { res = append(res, key) } } } return res } func min(a,b int) int { if a &amp;lt; b { return a } return b }</description></item><item><title>0354. Russian Doll Envelopes</title><link>https://example.com/docs/algs/leetcode/354_russian_doll_envelopes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/354_russian_doll_envelopes/</guid><description>Description # You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.
One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope&amp;rsquo;s width and height.
Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).
Note: You cannot rotate an envelope.</description></item><item><title>0362. Design Hit Counter</title><link>https://example.com/docs/algs/leetcode/362_design_hit_counter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/362_design_hit_counter/</guid><description>Description # Design a hit counter which counts the number of hits received in the past 5 minutes.
Each function accepts a timestamp parameter (in seconds granularity) and you may assume that calls are being made to the system in chronological order (ie, the timestamp is monotonically increasing). You may assume that the earliest timestamp starts at 1.
It is possible that several hits arrive roughly at the same time.</description></item><item><title>0362. Design Hit Counter</title><link>https://example.com/docs/algs/leetcode/367_valid_perfect_square/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/367_valid_perfect_square/</guid><description> Description # Given a positive integer num, write a function which returns True if num is a perfect square else False.
Follow up: Do not use any built-in library function such as sqrt.
Solutions # Binary Search # 这里跟 69 题其实是完全一样的解法，需要注意的是，在开始的时候去除掉一些 corner case 能够让后面的整体逻辑更清晰一些。
func isPerfectSquare(num int) bool { if num &amp;lt;= 1 { return true } left, right := 0, num for left &amp;lt; right { mid := left + (right - left)/2 res := mid * mid if res == num { return true } if res &amp;gt; num { right = mid } else { left = mid + 1 } } return false }</description></item><item><title>0378. Kth Smallest Element in a Sorted Matrix</title><link>https://example.com/docs/algs/leetcode/378_kth_smallest_element_in_a_sorted_matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/378_kth_smallest_element_in_a_sorted_matrix/</guid><description>Description # Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix.
Note that it is the kth smallest element in the sorted order, not the kth distinct element.
You must find a solution with a memory complexity better than \( \Omicron(n^2) \) Solutions # 这里可以使用最小堆，遍历矩阵，不断往堆中加入元素，遍历完之后，取堆中第 k 个元素就可。或者使用一个大小为 k 的最大堆，当堆中元素数量不足 k 时，将元素入堆，当堆中元素比 k 大时，将堆顶元素出堆即可。</description></item><item><title>0380. Insert Delete GetRandom O(1)</title><link>https://example.com/docs/algs/leetcode/380_insert_delete_getrandom_O1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/380_insert_delete_getrandom_O1/</guid><description>Solutions # Hash Table &amp;amp; Array # 这里使用一个 Hash Table 和一个数组，Hash Table 存储的是值和该值在数组中的下标。这里稍微有点 tricky 的是，删除的时候，不是直接在 Hash Table 中删除该元素，而是在数组中将该元素和尾元素调换位置，然后删除尾元素。 这样所有操作都能达到 \( \Omicron(1) \) 的时间复杂度。
import &amp;#34;math/rand&amp;#34; type RandomizedSet struct { dict map[int]int nums []int } func Constructor() RandomizedSet { return RandomizedSet{dict: make(map[int]int), nums: []int{}} } func (this *RandomizedSet) Insert(val int) bool { var present bool if _, ok := (*this).dict[val]; !ok { present = true size := len((*this).nums) (*this).nums = append((*this).</description></item><item><title>04. 二维数组中的查找</title><link>https://example.com/docs/algs/codingInterviews/04_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/04_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</guid><description> Description # 在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
数据范围：矩阵的长宽满足 \($0 \le n$\) , \($m \le 500$\) ， 矩阵中的值满足 \($0 \le val \le 10^9$\) 。
进阶：空间复杂度 O(1)O(1) ，时间复杂度 O(n+m)O(n+m)
Solutions # 从左下角开始进行遍历，因为数组维持了从左到右递增，从上到下递增的性质，那么如果当前元素比 target 要大， target 一定位于当前元素的右边；如果当前元素比 target 要小，那么 target 一定位于当前元素的上侧。
func Find( target int , array [][]int ) bool { // write code here var res bool m, n := len(array), len(array[0]) x, y := m-1, 0 for { if x &amp;lt; 0 || y &amp;gt;= n { break } if array[x][y] == target { res = true break } if target &amp;gt; array[x][y] { y++ } // 这里要加上一个 y &amp;lt; n, 因为上一个 if 对 y 进行了自增，导致这里的 y 不一定合法 if y &amp;lt; n &amp;amp;&amp;amp; target &amp;lt; array[x][y] { x-- } } return res }</description></item><item><title>0474. Ones and Zeroes</title><link>https://example.com/docs/algs/leetcode/474_ones_and_zeroes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/474_ones_and_zeroes/</guid><description>Description # You are given an array of binary strings strs and two integers m and n.
Return the size of the largest subset of strs such that there are at most m 0&amp;rsquo;s and n 1&amp;rsquo;s in the subset.
A set x is a subset of a set y if all elements of x are also elements of y.
Solutions # 这里很难想到要用动态规划吧。假设 dp[i][j] 表示一个能包含 i 个 0 和 j 个 1 的子集中的字符串个数。则当扫描到字符串str[i]时，统计其中出现0 位 zeros，1 为 ones。则 \(dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones]&amp;#43;1)\) 。</description></item><item><title>05. 替换空格</title><link>https://example.com/docs/algs/codingInterviews/05_%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/05_%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</guid><description> Description # 请实现一个函数，将一个字符串s中的每个空格替换成“%20”。 例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
数据范围: \($0 \le len(s) \le 1000$\) 。保证字符串中的字符为大写英文字母、小写英文字母和空格中的一种。
Solutions # func replaceSpace( s string ) string { // write code here var res string size := len(s) if size == 0 { return res } for _, r := range s { if r != &amp;#39; &amp;#39; { res += string(r) } else { res += &amp;#34;%20&amp;#34; } } return res }</description></item><item><title>0528. Random Pick with Weight</title><link>https://example.com/docs/algs/leetcode/528_random_pick_with_weight/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/528_random_pick_with_weight/</guid><description>Description # You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith index.
You need to implement the function pickIndex(), which randomly picks an index in the range [0, w.length - 1] (inclusive) and returns it. The probability of picking an index i is w[i] / sum(w).
For example, if w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.</description></item><item><title>0540. Single Element in a Sorted Array</title><link>https://example.com/docs/algs/leetcode/540_single_element_in_a_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/540_single_element_in_a_sorted_array/</guid><description>Description # You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.
Return the single element that appears only once.
Your solution must run in \(\Omicron(\log n) {{ &amp;lt; /katex &amp;gt;}} time and {{ &amp;lt; katex &amp;gt; \Omicron(1) {{ &amp;lt; /katex &amp;gt; }}} space. ### Bit Manipulation 这个题一眼看到，首先想到的就是使用异或操作，因为异或会导致相同的元素相互抵消为零，所以最后只会剩下哪个只出现一次的元素。 ```go func singleNonDuplicate(nums []int) int { var res int for _, num := range nums { res ^= num } return res } ``` ### Binary Search 这里因为数组有序，并且题目也要求 &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;/katex/katex.</description></item><item><title>0560. Subarray Sum Equals K</title><link>https://example.com/docs/algs/leetcode/560_subarray_sum_equals_k/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/560_subarray_sum_equals_k/</guid><description> Description # Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.
A subarray is a contiguous non-empty sequence of elements within an array.
Solutions # Prefix Sum # 这个题可以使用前缀和的技巧来解决。前缀和相关的介绍可以看 这里。
func subarraySum(nums []int, k int) int { var res int size := len(nums) prefix := make([]int, size+1) // 计算前缀和 idx := 1 for _, num := range nums { prefix[idx] = prefix[idx-1] + num idx++ } // 计算子数组 for i := 1; i &amp;lt;= size; i++ { for j := 0; j &amp;lt; i; j++ { if prefix[i] - prefix[j] == k { res++ } } } return res }</description></item><item><title>0583. Delete Operations for Two Strings</title><link>https://example.com/docs/algs/leetcode/583_delete_operation_for_two_strings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/583_delete_operation_for_two_strings/</guid><description>Description # Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same.
In one step, you can delete exactly one character in either string.
Solutions # DP # 求最少的删除步数来使两个字符串一致，其实就是求两个字符串的最长公共子序列（注意，子序列意味着可以不连续），最少的步数就是二者的长度之和减去最长公共子序列的两倍。所以问题就是如何求两个字符串的最长公共子序列。定义 dp[i][j] 表示 str1（假设长度为m）的前i个字符和str2（假设长度为n）的前j个字符的最长公共子序列的长度，根据这个定义，我们最求所求的值就是dp[m][n]，那么我们应该申请的数组就是 (m+1) * (n+1)的二维数组。
当 str1[i] 和 str2[j] 相等时，dp[i][j] 的值取决于str1的前i-1个i个字符和str2的前j个字符的最长公共子序列，也就是说， dp[i][j] = dp[i-1][j-1] + 1; 当 str1[i] 和 str2[j] 不相等时， 由于所求的时最大长度，dp[i][j] 的值就继承于 dp[i-1][j] 和 dp[i][j-1]中的较大者。 而对于初始条件，可以轻松得到， dp[0][j] = dp[i][0] = 0。</description></item><item><title>06. 从尾到头打印链表</title><link>https://example.com/docs/algs/codingInterviews/06_%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/06_%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</guid><description>Description # 输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。
Solutions # Recursive # 递归解法，太简单直接看代码就可以。
func printListFromTailToHead( head *ListNode) []int { // write code here var res []int printListFromTailToHeadHelper(head, &amp;amp;res) return res } func printListFromTailToHeadHelper(head *ListNode, res *[]int) { if head == nil { return } printListFromTailToHeadHelper(head.Next, res) *res = append(*res, head.Val) } Stack # 当然了，不用递归也可以用栈，直接看代码：
func printListFromTailToHead( head *ListNode) []int { // write code here var res []int if head == nil { return res } var stack []*ListNode cur := head for cur !</description></item><item><title>0643. Maximum Average Subarray I</title><link>https://example.com/docs/algs/leetcode/643_maximum_average_subarray_i_/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/643_maximum_average_subarray_i_/</guid><description>Description # You are given an integer array nums consisting of n elements, and an integer k.
Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted.
Solutions # Sliding Window # 这题没什么难度，可以用一个固定长度的队列来模拟滑动窗口即可。
func findMaxAverage(nums []int, k int) float64 { var queue []int res, size, sum := math.</description></item><item><title>07. 重建二叉树</title><link>https://example.com/docs/algs/codingInterviews/07_%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/07_%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>Description # 给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。
Solutions # TODO
func reConstructBinaryTree( pre []int , vin []int ) *TreeNode { // write code here pre_size, in_size := len(pre), len(vin) return buildTreeSolution(pre, 0, pre_size-1, vin, 0, in_size-1) } func buildTreeSolution(preorder []int, pleft, pright int, inorder []int, ileft, iright int) *TreeNode { if pleft &amp;gt; pright || ileft &amp;gt; iright { return nil } var rootIndex int for i := ileft; i &amp;lt;= iright; i++ { if inorder[i] == preorder[pleft] { rootIndex = i break } } root := new(TreeNode) root.</description></item><item><title>0718. Maximum Length of Repeated Subarray</title><link>https://example.com/docs/algs/leetcode/718_maximum_length_of_repeated_subarray/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/718_maximum_length_of_repeated_subarray/</guid><description> Description # Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays.
Solutions # Dynamic Programming # 定义 dp[i][j]表示 nums1 中以 i 为结尾的子数组和 nums2 中以 j 为结尾的子数组当前的匹配的最长公共子数组的长度。如果 nums1[i] == num2[j]，说明当前两个数字相同，那么当前最长公共子数组的长度就是 nums1 以 i-1 为结尾的子数组和 nums2 以 j-1 为结尾的子数组的最长公共子数组的长度加 1，即 dp[i][j] = dp[i-1][j-1] + 1；否则说明二者当前无公共子子数组或者公共子数组在当前位置不连续，则dp[i][j] = 0。
func findLength(nums1 []int, nums2 []int) int { m,n := len(nums1), len(nums2) dp := make([][]int, m+1) for idx, _ := range dp { dp[idx] = make([]int, n + 1) } var res int for i := 1; i &amp;lt;= m;i++ { for j := 1; j &amp;lt;= n; j++ { if nums1[i-1] == nums2[j-1] { dp[i][j] = dp[i-1][j-1] + 1 res = max(res, dp[i][j]) } else { dp[i][j] = 0 } } } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a }</description></item><item><title>0735. Asteroid Collisiion</title><link>https://example.com/docs/algs/leetcode/735_asteroid_collision/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/735_asteroid_collision/</guid><description>Description # We are given an array asteroids of integers representing asteroids in a row.
For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.
Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode.</description></item><item><title>0745. Prefix and Suffix Search</title><link>https://example.com/docs/algs/leetcode/745_prefix_and_suffix_search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/745_prefix_and_suffix_search/</guid><description>Description # Design a special dictionary with some words that searchs the words in it by a prefix and a suffix.
Implement the WordFilter class:
WordFilter(string[] words) Initializes the object with the words in the dictionary. f(string prefix, string suffix) Returns the index of the word in the dictionary, which has the prefix prefix and the suffix suffix. If there is more than one valid index, return the largest of them.</description></item><item><title>0767. Reorganize String</title><link>https://example.com/docs/algs/leetcode/767_reorganizing_string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/767_reorganizing_string/</guid><description>Description # Given a string s, rearrange the characters of s so that any two adjacent characters are not the same.
Return any possible rearrangement of s or return &amp;quot;&amp;quot; if not possible.
Solutions # 这里的解法还是很巧妙的，需要注意一下。
type Pair struct { char byte cnt int } func reorganizeString(s string) string { dict := make(map[byte]int) for idx, _ := range s { dict[s[idx]]++ } var maxHeap MaxHeap heap.Init(&amp;amp;maxHeap) for char, cnt := range dict { if cnt &amp;gt; (len(s)+1)/2 { return &amp;#34;&amp;#34; } heap.</description></item><item><title>08. 二叉树的下一个节点</title><link>https://example.com/docs/algs/codingInterviews/08_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/08_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/</guid><description>Description # 给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的next指针。下图为一棵有9个节点的二叉树。树中从父节点指向子节点的指针用实线表示，从子节点指向父节点的用虚线表示
Solutions # 一般我们中序遍历都是从根节点开始的，但是这里并没有给出根节点，而是给出了一个要查找的节点。那首先我们可以通过不断的往上走，直到找到根节点，然后进行中序遍历，这样就可以找到我们需要的节点的下一个节点。这里的写法很简单，我们就不上代码了。
那如果我们不找根节点，直接从当前节点开始遍历呢？这里情形就稍微有点复杂了，需要分情况讨论: - 如果当前节点有右节点，则右节点的最左节点就是我们所找的节点 - 如果当前节点没有右节点，且当前节点没有父节点，则返回 nil - 如果当前节点没有右节点，当前节点有父节点，且当前节点是父节点的左子节点，则返回当前节点的父节点 - 如果当前节点没有右节点，当前节点有父节点，且当前节点是父节点的右子节点，则一路向上查找，直到找到一个节点，这个节点是其父节点的左子节点，返回父节点；如果没有这样的父节点，返回 nil。
下面给出上面第二种方法的代码。
func GetNext(pNode *TreeLinkNode) *TreeLinkNode { if pNode == nil { return nil } // 情况一，当前节点的右子树非空，则直接找出当前节点的右子树的最左节点即可 if pNode.Right != nil { pNode = pNode.Right for pNode.Left != nil { pNode = pNode.Left } return pNode } // 情况二，当前节点的右子树为空，且父节点也为空，说明当前节点就是根节点，没有下一个节点，返回 nil 即可。 if pNode.Next == nil { return nil } // 情况三， 当前节点右子树为空，父节点非空，并且当前节点是其父节点的左节点，那么直接返回其父节点 if pNode == pNode.</description></item><item><title>0867. Transpose Matrix</title><link>https://example.com/docs/algs/leetcode/867_transpose_matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/867_transpose_matrix/</guid><description> Description # Given a 2D integer array matrix, return the transpose of matrix.
The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix&amp;rsquo;s row and column indices.
Solutions # 简言之就是需要行列倒置。
func transpose(matrix [][]int) [][]int { m,n := len(matrix),len(matrix[0]) res := make([][]int, n) for idx, _ := range res { res[idx] = make([]int, m) } for i := 0; i &amp;lt; m; i++ { for j := 0; j &amp;lt; n; j++ { res[j][i] = matrix[i][j] } } return res }</description></item><item><title>0876. Median of the Linked List</title><link>https://example.com/docs/algs/leetcode/876_median_of_the_linked_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/876_median_of_the_linked_list/</guid><description>Description # Given the head of a singly linked list, return the middle node of the linked list.
If there are two middle nodes, return the second middle node.
Solutions # 使用快慢指针法，最后返回慢指针指向的节点即可。
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func middleNode(head *ListNode) *ListNode { slow, fast := head, head // 注意这里的判断条件 for fast != nil &amp;amp;&amp;amp; fast.</description></item><item><title>0895. Max Frequency Stack</title><link>https://example.com/docs/algs/leetcode/895_max_frequency_stack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/895_max_frequency_stack/</guid><description>Description # Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.
Implement the FreqStack class:
FreqStack() constructs an empty frequency stack. void push(int val) pushes an integer val onto the top of the stack. int pop() removes and returns the most frequent element in the stack. If there is a tie for the most frequent element, the element closest to the stack&amp;rsquo;s top is removed and returned.</description></item><item><title>09. 双栈实现队列</title><link>https://example.com/docs/algs/codingInterviews/09_%E5%8F%8C%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/09_%E5%8F%8C%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</guid><description>Description # 用两个栈来实现一个队列，使用n个元素来完成 n 次在队列尾部插入整数(push)和n次在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。
数据范围： \($n \le 1000$\) 要求：存储n个元素的空间复杂度为 \($\Omicron(n)$\) ，插入与删除的时间复杂度都是 \($\Omicron(1)$\) Solutions # 使用两个队列，队列1专用于push，队列用专用于pop 和 peek。push 时，入队 stack1； pop 时，如果 stack2 不为空，则弹出 stack2 栈顶即可，若 stack2 为空，则将 stack1 的所有元素压入 stack2， 然后将 stack2 的栈顶元素弹出。
type MyQueue struct { stack1 []int stack2 []int } func Constructor() MyQueue { return MyQueue{ stack1: make([]int, 0), stack2: make([]int, 0), } } func (this *MyQueue) Push(x int) { this.stack1 = append(this.stack1, x) } func (this *MyQueue) Pop() int { var res int len1, len2 := len(this.</description></item><item><title>0968. Binary Tree Cameras</title><link>https://example.com/docs/algs/leetcode/968_binary_tree_cameras/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/968_binary_tree_cameras/</guid><description>Description # You are given the root of a binary tree. We install cameras on the tree nodes where each camera at a node can monitor its parent, itself, and its immediate children.
Return the minimum number of cameras needed to monitor all nodes of the tree.
Solutions # Greedy Algorithms # 这种 hard 题，题主肯定是不会做的啦（囧�� ），所以只好求助于网上大神了：
这里先考虑把相机放在什么位置上能看到的节点最多（这样的话相机数量就会最少）？能放在叶节点吗？显然不能，叶节点最多只能看到两个节点；能放到根节点吗？根节点最多也只能看到 3 个。最优解是放在叶节点的父节点上，这样最多就可以看到四个节点。所以策略是先找到叶节点，然后在其父节点上放相机，同时标记父节点的父节点为被拍到了的状态。这样就有三种不同的状态，用 0 表示当前节点是叶节点，用 1 表示当前节点是叶节点的父节点并且放置了相机，用 2 表示当前节点是叶节点的爷爷节点，并且被相机拍到了。这里使用一个全局变量 res 记录相机个数。在递归过程中，若当前节点不存在，则返回 2，空节点也可以看做被相机拍到了。否则对相机左右节点递归调用，若二者中有一个返回 0，则当前节点至少有一个节点是叶节点，需要在当前位置放置一个相机，res 自增 1，并返回 1；如果左右节点的返回值中有一个为 1，说明左右节点中至少有一个已经放上了相机，当前节点已经被拍到了，返回 2。若都不是，则说明当前节点是叶节点，返回 0。在主函数中，若对根节点调用递归的返回值是 0，说明这个树只有一个节点或者根节点的左右节点没有子节点或者根节点就是叶节点，此时没有办法，只能在根节点上也放一个相机，否则不用加。</description></item><item><title>0973. K Closest Points to Origin</title><link>https://example.com/docs/algs/leetcode/973_k_closest_points_to_origin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/973_k_closest_points_to_origin/</guid><description>Description # Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).
The distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x1 - x2)2 + (y1 - y2)2).
You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).</description></item><item><title>10. 斐波那契数列</title><link>https://example.com/docs/algs/codingInterviews/10_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/10_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</guid><description> Description # 输入一个正整数 n ，请你输出斐波那契数列的第 n 项
Solutions # 简单题，简单的动态规划。
func Fibonacci( n int ) int { // write code here if n &amp;lt;= 2 { return 1 } NMinusOne, NMinusTwo := 1, 1 for i := 3; i &amp;lt;= n; i++ { N := NMinusOne + NMinusTwo NMinusTwo = NMinusOne NMinusOne = N } return NMinusOne }</description></item><item><title>1047. Remove All Adjacent Duplicates in String</title><link>https://example.com/docs/algs/leetcode/1047_remove_all_duplicated_in_string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1047_remove_all_duplicated_in_string/</guid><description>Description # You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.
We repeatedly make duplicate removals on s until we no longer can.
Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique.
Solutions # 很容易想到用栈。这里需要注意的是，对于&amp;quot;abbaca&amp;quot;这样的字符，移除之后的结果是 “ca”，而不是“abaca”喔，这里的删除是指一旦连续两个字符相同，那么把这两个字符都删去，而不是只保留一个。
func removeDuplicates(s string) string { size := len(s) if size &amp;lt;= 1 { return s } var stack []rune for _, r := range s { size = len(stack) if size == 0 || stack[size-1] !</description></item><item><title>1048. Longest String Chain</title><link>https://example.com/docs/algs/leetcode/1048_longest_string_chain/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1048_longest_string_chain/</guid><description>Description # You are given an array of words where each word consists of lowercase English letters.
wordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB.
For example, &amp;quot;abc&amp;quot; is a predecessor of &amp;quot;abac&amp;quot;, while &amp;quot;cba&amp;quot; is not a predecessor of &amp;quot;bcad&amp;quot;. A word chain is a sequence of words [word1, word2, .</description></item><item><title>1060. Missing Element in Sorted Array</title><link>https://example.com/docs/algs/leetcode/1060_missing_element_in_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1060_missing_element_in_sorted_array/</guid><description>Description # Given an array containing n distinct numbers taken from 0, 1, 2, &amp;hellip;, n, find the one that is missing from the array.
For example, Given nums = [0, 1, 3] return 2.
Note: Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?
Solutions # Math # 这个题还是很简单的，首先需要求出求出 [0,n] 的累和，然后用这个累和减去数组中出现的每个数，最后剩下的数就是结果。
func missingNumber(nums []int) int { size := len(nums) res := (1 + n)*n/2 for _, num := range nums { res -= num } return num } Bit Manipulation # 这个题也可以使用异或来做。既然从 0 到 n 中缺了一个，那么我们就可以使用从 0 到 n 的每个数字来跟数组中的数字进行异或操作，最后的那个数字肯定就是缺的那个数字啦。</description></item><item><title>1062. Longest Repeating Substring</title><link>https://example.com/docs/algs/leetcode/1062_longest_repeating_substring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1062_longest_repeating_substring/</guid><description> Description # Given a string S, find out the length of the longest repeating substring(s). Return 0 if no repeating substring exists.
Solutions # Dynamic Programming # 这种什么最长、最大的题目，当然是使用 DP 来解啦，不过题主想了好一会也没想到该怎么定义状态方程，只好上网去看各路大神怎么搞的：这里定了 dp[i][j] 表示 s 中以第 i 个字符为结尾的子串为和以第 j 个字符为结尾的子串的最大公共后缀的长度。当s[i] == s[j] 时，dp[i][j] = dp[i-1][j-1] + 1；否则，dp[i][j] = 0。在 dp 更新的过程中，不断保存最大值即可。
这里 DP 的递推式跟「718. Maximum Length of Repeated Subarray」是一致的。
func longestRepeatingSubstring(s string) int { res,size := math.MinInt, len(s) dp := make([]int, size + 1) for idx, _ := range dp { dp[idx] = make([]int, size + 1) } for i := 1; i &amp;lt;= size; i++ { for j := 1; j &amp;lt;i;j++ { if s[i-1] == s[j-1] { dp[i][j] = dp[i-1][j-1] + 1 } res = max(res, dp[i][j]) } } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a }</description></item><item><title>1086. High Five</title><link>https://example.com/docs/algs/leetcode/1086_high_five/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1086_high_five/</guid><description>Description # Given a list of the scores of different students, items, where items[i] = [IDi, scorei] represents one score from a student with IDi, calculate each student&amp;rsquo;s top five average.
Return the answer as an array of pairs result, where result[j] = [IDj, topFiveAveragej] represents the student with IDj and their top five average. Sort result by IDj in increasing order.
A student&amp;rsquo;s top five average is calculated by taking the sum of their top five scores and dividing it by 5 using integer division.</description></item><item><title>1095. Find in Mountain Array</title><link>https://example.com/docs/algs/leetcode/1095_find_in_mountain_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1095_find_in_mountain_array/</guid><description>Description # (This problem is an interactive problem.)
You may recall that an array arr is a mountain array if and only if:
arr.length &amp;gt;= 3 There exists some i with 0 &amp;lt; i &amp;lt; arr.length - 1 such that: arr[0] &amp;lt; arr[1] &amp;lt; &amp;hellip; &amp;lt; arr[i - 1] &amp;lt; arr[i] arr[i] &amp;gt; arr[i + 1] &amp;gt; &amp;hellip; &amp;gt; arr[arr.length - 1] Given a mountain array mountainArr, return the minimum index such that mountainArr.</description></item><item><title>11. 旋转数组的最小数字</title><link>https://example.com/docs/algs/codingInterviews/11_%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/11_%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</guid><description> Descriptioin # 有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。
数据范围： \($1 \le n \le 10000$\) ，数组中任意元素的值: \($0 \le val \le 10000$\) 。 要求：空间复杂度： \($\Omicron(1)$\) ，时间复杂度： \($\Omicron(\log n)$\) Solutions # Binary Search # 二分查找，使用两个指针 left 和 right 分别指向数组的待查找序列的左侧和右侧，则：
如果中间元素比右侧元素小，那么向左查找，即 right = mid 如果中间元素比右侧元素大，那么向右查找， 即 left = mid + 1 如果中间元素等于右侧元素，那么最小元素即可能在左边，也可能在右边，则可以收缩右边界 最后返回 left 指向的元素即可。 func minNumberInRotateArray( nums []int ) int { // write code here var res int size := len(nums) if size == 0 { return res } left, right := 0, size -1 for left &amp;lt; right { mid := (left+right)/2 if nums[mid] &amp;gt; nums[right] { left = mid + 1 } else if nums[mid] &amp;lt; nums[right] { right = mid } else if nums[mid] == nums[right] { right = right -1 } } return nums[left] }</description></item><item><title>12. 矩阵中的路径</title><link>https://example.com/docs/algs/codingInterviews/12_%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/12_%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</guid><description>Description # 请设计一个函数，用来判断在一个n乘m的矩阵中是否存在一条包含某长度为len的字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如: \($\begin{bmatrix} a &amp;amp; b &amp;amp; c &amp;amp;e \\ s &amp;amp; f &amp;amp; c &amp;amp; s \\ a &amp;amp; d &amp;amp; e&amp;amp; e\\ \end{bmatrix}\quad$\) 矩阵中包含一条字符串&amp;quot;bcced&amp;quot;的路径，但是矩阵中不包含&amp;quot;abcb&amp;quot;路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 数据范围： \($0 \le n,m \le 20$\) , \($1\le len \le 25$\) Solutions # Backtracing # func hasPath( matrix [][]byte , word string ) bool { // write code here n,m := len(matrix), len(matrix[0]) for i := 0; i &amp;lt; n; i++ { for j := 0; j &amp;lt; m; j++ { // 剪枝 if word[0] == matrix[i][j] &amp;amp;&amp;amp; helper(matrix, word, i, j, n, m) { return true } } } return false } func helper(matrix [][]byte, word string, x,y,n,m int) bool { size := len(word) // 这里之所以可以直接取 word[0] 而不用判断数组越界，主要是因为下面第二个 if 语句会保证进入递归的 word 一定不是空串 if x &amp;lt; 0 || x &amp;gt;= n || y &amp;lt; 0 || y &amp;gt;= m || matrix[x][y] == &amp;#39;.</description></item><item><title>1209. Remove All Adjacent Duplicates in String</title><link>https://example.com/docs/algs/leetcode/1209_remove_all_adjacent_duplicates_in_string_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1209_remove_all_adjacent_duplicates_in_string_ii/</guid><description>Description # You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, causing the left and the right side of the deleted substring to concatenate together.
We repeatedly make k duplicate removals on s until we no longer can.
Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.</description></item><item><title>1249. Minimum Remove to Make Valid Parentheses</title><link>https://example.com/docs/algs/leetcode/1249_minimum_remove_to_make_valid_parentheses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1249_minimum_remove_to_make_valid_parentheses/</guid><description>Description # Given a string s of &amp;lsquo;(&amp;rsquo; , &amp;lsquo;)&amp;rsquo; and lowercase English characters.
Your task is to remove the minimum number of parentheses ( &amp;lsquo;(&amp;rsquo; or &amp;lsquo;)&amp;rsquo;, in any positions ) so that the resulting parentheses string is valid and return any valid string.
Formally, a parentheses string is valid if and only if:
It is the empty string, contains only lowercase characters, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string.</description></item><item><title>1268. Search Suggestions System</title><link>https://example.com/docs/algs/leetcode/1268_search_suggestions_system/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1268_search_suggestions_system/</guid><description>Description # You are given an array of strings products and a string searchWord.
Design a system that suggests at most three product names from products after each character of searchWord is typed. Suggested products should have common prefix with searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products.
Return a list of lists of the suggested products after each character of searchWord is typed.</description></item><item><title>13. 机器人的运动范围</title><link>https://example.com/docs/algs/codingInterviews/13_%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/13_%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</guid><description>Description # 地上有一个 rows 行和 cols 列的方格。坐标从 [0,0] 到 [rows-1,cols-1] 。一个机器人从坐标 [0,0] 的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 threshold 的格子。 例如，当 threshold 为 18 时，机器人能够进入方格 [35,37] ，因为 3+5+3+7 = 18。但是，它不能进入方格 [35,38] ，因为 3+5+3+8 = 19 。请问该机器人能够达到多少个格子？
数据范围： \($0 \le threshold \le 15$\) ， \($1 \le rows,cols \le 100$\) Solutions # func movingCount( threshold int , rows int , cols int ) int { // write code here if rows &amp;lt;= 0 || cols &amp;lt;= 0 || threshold &amp;lt; 0 { return 0 } visited := make([][]bool, rows) for idx, _ := range visited { visited[idx] = make([]bool, cols) } return helper(threshold, rows, cols, 0, 0, &amp;amp;visited) } func helper(threshold int, rows int,cols int, row int, col int, visited *[][]bool) int { t := pathSum(row) + pathSum(col) if row &amp;lt; 0 || row &amp;gt;= rows || col &amp;lt; 0 || col &amp;gt;= cols || (*visited)[row][col] || t &amp;gt; threshold { return 0 } (*visited)[row][col] = true return 1 + helper(threshold, rows, cols, row+1, col, visited) + helper(threshold, rows, cols, row-1, col, visited) + helper(threshold, rows, cols, row, col+1, visited) + helper(threshold, rows, cols, row, col-1, visited) } func pathSum(num int) int { var sum int for num !</description></item><item><title>1300. Sum of Mutated Array Closest to Target</title><link>https://example.com/docs/algs/leetcode/1300_sum_of_mutated_array_closest_to_target/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1300_sum_of_mutated_array_closest_to_target/</guid><description>Description # Given an integer array arr and a target value target, return the integer value such that when we change all the integers larger than value in the given array to be equal to value, the sum of the array gets as close as possible (in absolute difference) to target.
In case of a tie, return the minimum such integer.
Notice that the answer is not neccesarilly a number from arr.</description></item><item><title>1332. Remove Palindromic Subsequences</title><link>https://example.com/docs/algs/leetcode/1332_remove_palindromic_subsequence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1332_remove_palindromic_subsequence/</guid><description>Description # You are given a string s consisting only of letters &amp;lsquo;a&amp;rsquo; and &amp;lsquo;b&amp;rsquo;. In a single step you can remove one palindromic subsequence from s.
Return the minimum number of steps to make the given string empty.
A string is a subsequence of a given string if it is generated by deleting some characters of a given string without changing its order. Note that a subsequence does not necessarily need to be contiguous.</description></item><item><title>1342. Number of Steps to Reduce a Number to Zero</title><link>https://example.com/docs/algs/leetcode/1342_number_of_steps_to_reduce_a_number_to_zero/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1342_number_of_steps_to_reduce_a_number_to_zero/</guid><description> Description # Given an integer num, return the number of steps to reduce it to zero.
In one step, if the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.
Solutions # 这题太简单了，没什么好说的，直接上代码。
func numberOfSteps(num int) int { var res int for num != 0 { if num%2 == 0 { num /= 2 } else { num -= 1 } res++ } return res }</description></item><item><title>14. 剪绳子</title><link>https://example.com/docs/algs/codingInterviews/14_%E5%89%AA%E7%BB%B3%E5%AD%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/14_%E5%89%AA%E7%BB%B3%E5%AD%90/</guid><description>Description # 给你一根长度为 n 的绳子，请把绳子剪成整数长的 m 段（ m 、 n 都是整数， n &amp;gt; 1 并且 m &amp;gt; 1 ， m &amp;lt;= n ），每段绳子的长度记为 k[1],&amp;hellip;,k[m] 。请问 k[1]k[2]&amp;hellip;*k[m] 可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18 。
数据范围： \($2 \le n \le 60$\) 进阶：空间复杂度 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n)$\) Solutions # Recursive # 我们可以发现，当我们求某一个数字的时候，我们只需要将这个数字分解出1,2,3。对于3以上的数字，其实也可以分解成这三个数字，比如4=2x2,5=2x3。对于分解出1的情况，我们发现这个是对答案没有贡献的。所以直接忽略。我们只需要讨论2和3的情况。所以，我们只需要将数字分为2和3组成的就行了。
func cutRope( n int ) int { // write code here if n &amp;lt;= 3 { return n } return max(2*cutRope(n-2), 3*cutRope(n-3)) } func max(a,b int) int { if a &amp;lt; b { return b } return a } Dynamic Programming # 对于一个长度为 n 的绳子，如何确定其分出的最大乘积呢？我们可以尝试其中一段不可分的为 j，那么如果另一段 n-j 最大乘积已知，那么我们就可以遍历所有 j 找到这个最大乘积。因此用 dp[i] 表示长度为 i 的绳子可以被剪出来的最大乘积，那么后续遍历每个 j 的时候，我们取最大 dp[i] = max(dp[i], j *dp[i-j])即可。也就是:</description></item><item><title>1429. First Unique Number</title><link>https://example.com/docs/algs/leetcode/1429_first_unique_number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1429_first_unique_number/</guid><description>Description # You have a queue of integers, you need to retrieve the first unique integer in the queue.
Implement the FirstUnique class:
FirstUnique(int[] nums) Initializes the object with the numbers in the queue. int showFirstUnique() returns the value of the first unique integer of the queue, and returns -1 if there is no such integer. void add(int value) insert value to the queue. Solutions # 可以这么做： 维护一个哈希表，哈希表的 key 为数字，value 为一个Pair， Pair 中存储 key 在数组中的下标以及该数字的出现次数。然后再创建一个 queue， 将所有出现次数为 1 的数字按照在队列中的出现顺序入队。 调用 showFirstUnique 的时候， 从队列中取出元素，检查在哈希表中该元素的出现次数是否为 1，如果不是，则持续出对队，直到找到第一个出现次数为 1 的元素，然后将该元素输出。add 的时候，将该元素在哈希表中的对应次数加 1，并检查队头元素是否为该元素，如果是， 则将该元素出队即可。</description></item><item><title>1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit</title><link>https://example.com/docs/algs/leetcode/1438_longest_continuous_subarray_with_absolute_diff_less_than_or_equal_to_limit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1438_longest_continuous_subarray_with_absolute_diff_less_than_or_equal_to_limit/</guid><description>Description # Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit.
Solutions # TODO</description></item><item><title>1461. Check If a String Contains All Binary Codes of Size K</title><link>https://example.com/docs/algs/leetcode/1461_check_if_a_string_contains_all_binary_codes_of_size_k/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1461_check_if_a_string_contains_all_binary_codes_of_size_k/</guid><description>Description # Given a binary string s and an integer k, return true if every binary code of length k is a substring of s. Otherwise, return false.
Solutions # Brute Force # 下面是题主一开始想出来的方法，可惜最后几个用例过于变态，所以超时了。
func hasAllCodes(s string, k int) bool { size := len(s) if size &amp;lt; k { return false } // golang 格式化打印字符串，%04b 这个格式化字符串能够将数字转换为二进制表示，并且当表示字符串长度小于 4 时，能够自动在前面增加 0 作为 padding。 fmtStr := &amp;#34;%0&amp;#34; + strconv.Itoa(k) + &amp;#34;b&amp;#34; maxEle := int(math.</description></item><item><title>1472. Design Browser History</title><link>https://example.com/docs/algs/leetcode/1472_design_browser_history/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1472_design_browser_history/</guid><description>Description # You have a browser of one tab where you start on the homepage and you can visit another url, get back in the history number of steps or move forward in the history number of steps.
Implement the BrowserHistory class:
BrowserHistory(string homepage) Initializes the object with the homepage of the browser. void visit(string url) Visits url from the current page. It clears up all the forward history. string back(int steps) Move steps back in history.</description></item><item><title>1480. Running Sum of 1d Array</title><link>https://example.com/docs/algs/leetcode/1480_running_sum_of_1d_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1480_running_sum_of_1d_array/</guid><description> Description # Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]).
Return the running sum of nums.
Solutions # 简单题，直接看代码就好了。
func runningSum(nums []int) []int { var res []int var pre int for _, num := range nums { pre += num res = append(res, pre) } return res }</description></item><item><title>15. 二进制中 1 的个数</title><link>https://example.com/docs/algs/codingInterviews/15_%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD-1-%E7%9A%84%E4%B8%AA%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/15_%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD-1-%E7%9A%84%E4%B8%AA%E6%95%B0/</guid><description> Description # 输入一个整数 n ，输出该数32位二进制表示中1的个数。其中负数用补码表示。
Solutions # Bit Manipulation # 这里需要注意的是，因为负数用补码表示，而负数补码右移会导致高位补 1，所以对负数不能直接进行右移。
func NumberOf1( n int ) int { // write code here var count int t := 0x80000000 for n != 0 { count += (n &amp;amp; t) &amp;gt;&amp;gt; 31 n &amp;lt;&amp;lt;= 1 } return count }</description></item><item><title>16. 数值的整数次方</title><link>https://example.com/docs/algs/codingInterviews/16_%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/16_%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</guid><description> Description # 实现函数 double Power(double base, int exponent)，求base的exponent次方。
注意： 1.保证base和exponent不同时为0。 2.不得使用库函数，同时不需要考虑大数问题 3.有特殊判题，不用考虑小数点后面0的位数。
数据范围： \($|base| \le 100$\) ， \($|exponent| \le 100$\) ,保证最终结果一定满足 \($|val| \le 10^4$\) 进阶：空间复杂度 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n)$\) 快速幂 # func Power( base float64 , exponent int ) float64 { // write code here if base == 0 { return 0 } var negative bool if exponent &amp;lt; 0 { negative = true exponent = -exponent } res := helper(base, exponent) if negative { res = 1 / res } return res } func helper(base float64, exponent int) float64 { if base == 0 { return 0 } if exponent == 0 { return 1 } if exponent == 1 { return base } return helper(base, exponent/2) * helper(base, exponent/2) * helper(base, exponent%2) }</description></item><item><title>1658. Minimum Operations to Reduce X to Zero</title><link>https://example.com/docs/algs/leetcode/1658_minimum_operations_to_reduce_x_to_zero/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1658_minimum_operations_to_reduce_x_to_zero/</guid><description>Description # You are given an integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x. Note that this modifies the array for future operations.
Return the minimum number of operations to reduce x to exactly 0 if it is possible, otherwise, return -1.
Solutions # Backtrace # 这是题主一开始想出来的解法，直接暴力回溯，但是超时了。仔细分析一下，发现时间复杂度确很高得离谱&amp;hellip;</description></item><item><title>1695. Maximum Erasure Value</title><link>https://example.com/docs/algs/leetcode/1695_maximum_erasure_value/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1695_maximum_erasure_value/</guid><description>Description # You are given an array of positive integers nums and want to erase a subarray containing unique elements. The score you get by erasing the subarray is equal to the sum of its elements.
Return the maximum score you can get by erasing exactly one subarray.
An array b is called to be a subarray of a if it forms a contiguous subsequence of a, that is, if it is equal to a[l],a[l+1],&amp;hellip;,a[r] for some (l,r).</description></item><item><title>17. 打印从 1 到最大的 n 位数</title><link>https://example.com/docs/algs/codingInterviews/17_%E6%89%93%E5%8D%B0%E4%BB%8E-1-%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84-n-%E4%BD%8D%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/17_%E6%89%93%E5%8D%B0%E4%BB%8E-1-%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84-n-%E4%BD%8D%E6%95%B0/</guid><description> Description # 输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。
用返回一个整数列表来代替打印 n 为正整数，0 &amp;lt; n &amp;lt;= 5 Solutions # func printNumbers( n int ) []int { // write code here var res []int if n == 0 { return res } curMax := 0 for n &amp;gt; 0 { curMax *= 10 curMax += 9 n-- } for i := 1; i &amp;lt;= curMax; i++ { res = append(res, i) } return res }</description></item><item><title>18. 删除链表的节点</title><link>https://example.com/docs/algs/codingInterviews/18_%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/18_%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</guid><description> Description # 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。
1.此题对比原题有改动 2.题目保证链表中节点的值互不相同 3.该题只会输出返回的链表和结果做对比，所以若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点
Solutions # 这里一个非常需要注意的点就是，如果头结点也要被删除的话怎么办？如果头结点的也要被删除的话，那么判断条件就会变得比较复杂，这里的一个解决办法就是，增加一个虚拟的头结点，然后让这个虚拟的头结点指向真正的头结点，遍历的时候就从这个虚拟的头结点开始遍历，这样就能够应付真实头结点也要被删除的情况。
不多说，直接上代码。
func deleteNode( head *ListNode , val int ) *ListNode { // write code here dummpy := new(ListNode) dummpy.Next = head pre, cur := dummpy, head for cur != nil { if cur.Val == val { pre.Next = cur.Next break } pre = cur cur = cur.Next } return dummpy.Next }</description></item><item><title>21. 调整数组顺序使奇数位于偶数前面</title><link>https://example.com/docs/algs/codingInterviews/21_%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/21_%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</guid><description>Description # 输入一个长度为 n 整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前面部分，所有的偶数位于数组的后面部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。
数据范围： \($0 \le n \le 5000$\) ，数组中每个数的值 \($0 \le val \le 10000$\) 要求：时间复杂度 \($\Omicron(n)$\) ，空间复杂度 \($\Omicron(n)$\) 进阶：时间复杂度 \($\Omicron(n^2)$\) ，空间复杂度 \($\Omicron(1)$\) Solutions # Array # 分别创建两个数组，一个用于存储奇数，一个用于存储偶数，然后扫描一次原数组，将奇数放入奇数数组，将偶数放入偶数数组，最后再将这两个数组拼接在一起即可。
func reOrderArray( array []int ) []int { // write code here size := len(array) if size == 0 { return nil } var odd, even []int for _, num := range array { if num %2 == 0 { even = append(even, num) } else { odd = append(odd, num) } } return append(odd, even.</description></item><item><title>22. 链表中倒数最后 k 个节点</title><link>https://example.com/docs/algs/codingInterviews/22_%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E6%9C%80%E5%90%8E-k-%E4%B8%AA%E8%8A%82%E7%82%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/22_%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E6%9C%80%E5%90%8E-k-%E4%B8%AA%E8%8A%82%E7%82%B9/</guid><description>Description # 输入一个长度为 n 的链表，设链表中的元素的值为 ai ，返回该链表中倒数第k个节点。 如果该链表长度小于k，请返回一个长度为 0 的链表。
数据范围： \($0 \leq n \leq 10^5$\) , \($0 \leq a_i \leq 10^9$\) ， \($0 \leq k \leq 10^9$\) 要求：空间复杂度 \($\Omicron(n)$\) ，时间复杂度 \($\Omicron(n)$\) 进阶：空间复杂度 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n)$\) Solutions # 快慢指针 # 简答题目，不多说，直接上代码。
func FindKthToTail( pHead *ListNode , k int ) *ListNode { // write code here fast, slow := pHead, pHead for k != 0 { if fast == nil { return nil } fast = fast.</description></item><item><title>23. 链表中环的入口节点</title><link>https://example.com/docs/algs/codingInterviews/23_%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/23_%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9/</guid><description>Description # 给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。
数据范围： \($n\le10000$\) ， \($1&amp;lt;=结点值&amp;lt;=10000$\) 要求：空间复杂度 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n)$\) Solutions # 哈希表 # 最简单的做法是， 从头到尾遍历链表，然后一个哈希表来记录已经遍历过的节点。第一个被重复遍历的节点就是我们所求的结果（前提是链表中存在环）。
func EntryNodeOfLoop(pHead *ListNode) *ListNode { if pHead == nil { return nil } cur := pHead dict := make(map[*ListNode]bool) for cur != nil { if _, ok := dict[cur]; ok { return cur } dict[cur] = true cur = cur.Next } return nil } 双指针 # 通过快慢指针来解。 func EntryNodeOfLoop(pHead *ListNode) *ListNode { if pHead == nil { return nil } // 找到相遇节点 slow, fast := pHead, pHead for fast !</description></item><item><title>24. 反转链表</title><link>https://example.com/docs/algs/codingInterviews/24_%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/24_%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid><description> Description # 给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。
数据范围： \($0\leq n\leq1000$\) 要求：空间复杂度 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n)$\) 。
Solutions # 参考链表插入中的头插法。下面的递归反转解法中连接各个节点的方式需要注意一下：
func ReverseList( pHead *ListNode ) *ListNode { // write code here return reverseListSolution3(pHead) } func reverseListSolution3(pHead *ListNode) *ListNode { // 到最后一个节点则返回 if pHead == nil || pHead.Next == nil { return pHead } // 继续反转下一个节点 newHead := reverseListSolution3(pHead.Next) // 逆转当前节点的（注意画图理解） pHead.Next.Next = pHead // 断开当前节点与下一个节点的关系 pHead.Next = nil // 返回最后一个节点作为头结点 return newHead }</description></item><item><title>25. 合并两个排序的链表</title><link>https://example.com/docs/algs/codingInterviews/25_%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/25_%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</guid><description>Description # 输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。 数据范围： \($0 \le n \le 1000$\) ， \($-1000 \le 节点值 \le 1000$\) 要求：空间复杂度 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n)$\) Solutions # 参考归并排序，很简单。
func Merge( pHead1 *ListNode , pHead2 *ListNode ) *ListNode { // write code here if pHead1 == nil { return pHead2 } if pHead2 == nil { return pHead1 } head := new(ListNode) cur := head h1, h2 := pHead1, pHead2 for h1 != nil &amp;amp;&amp;amp; h2 !</description></item><item><title>26. 树的子结构</title><link>https://example.com/docs/algs/codingInterviews/26_%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/26_%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</guid><description>Description # 输入两棵二叉树A，B，判断B是不是A的子结构。（我们约定空树不是任意一个树的子结构）
Solutions # 这里需要注意如何将左右节点又作为一个子问题来求解的方法。
func HasSubtree( pRoot1 *TreeNode , pRoot2 *TreeNode ) bool { // write code here // 空树不是任意一个树的子结构 if pRoot2 == nil { return false } if pRoot1 == nil &amp;amp;&amp;amp; pRoot2 != nil { return false } // 判断是否是子结构 if sameTree(pRoot1, pRoot2) { return true } // 将左右节点又分别作为一个子问题 return HasSubtree(pRoot1.Left, pRoot2) || HasSubtree(pRoot1.Right, pRoot2) } func sameTree(p, q *TreeNode) bool { if p == nil &amp;amp;&amp;amp; q == nil { return true } if p !</description></item><item><title>27. 二叉树的镜像</title><link>https://example.com/docs/algs/codingInterviews/27_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/27_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</guid><description> Description # 操作给定的二叉树，将其变换为源二叉树的镜像。 数据范围：二叉树的节点数 \($0 \le n \le 1000$\) ， 二叉树每个节点的值 \($0\le val \le 1000$\) 。 要求： 空间复杂度 \($\Omicron(n)$\) 。本题也有原地操作，即空间复杂度 \($\Omicron(1)$\) 的解法，时间复杂度 \($\Omicron(n)$\) Solutions # 简单题，左右节点交换即可，直接上代码。
func Mirror( pRoot *TreeNode ) *TreeNode { // write code here if pRoot == nil { return nil } pRoot.Right, pRoot.Left = Mirror(pRoot.Left), Mirror(pRoot.Right) return pRoot }</description></item><item><title>28. 对称的二叉树</title><link>https://example.com/docs/algs/codingInterviews/28_%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/28_%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>Description # 给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）
Solutions # Recursive # func isSymmetrical( pRoot *TreeNode ) bool { // write code here if pRoot == nil { return true } return isSameTree(pRoot.Left, pRoot.Right) } func isSameTree(root1, root2 *TreeNode) bool { if root1 == nil &amp;amp;&amp;amp; root2 == nil { return true } if root1 == nil || root2 == nil { return false } if root1.Val != root2.Val { return false } return isSameTree(root1.</description></item><item><title>29. 顺时针打印矩阵</title><link>https://example.com/docs/algs/codingInterviews/29_%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/29_%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</guid><description> Description # 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： [[1,2,3,4], [5,6,7,8], [9,10,11,12], [13,14,15,16]] 则依次打印出数字 [1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10]
数据范围: \($0 \le matrix.length \le 100$\) \($0 \le matrix[i].length \le 100$\) Solutions # 老面孔了，不多介绍。
func printMatrix( matrix [][]int ) []int { // write code here var res []int m, n := len(matrix), len(matrix[0]) top, down, left, right := 0, m-1, 0, n-1 for top &amp;lt;= down &amp;amp;&amp;amp; left &amp;lt;= right { // 注意这里是等号，从而让只有一行/列的时候也能进入循环 for i := left; i &amp;lt;= right; i++ { res = append(res, matrix[top][i]) } // 避免上下重合 top++ if top &amp;gt; down { break } for i := top; i &amp;lt;= down; i++ { res = append(res, matrix[i][right]) } // 避免左右重合 right-- if right &amp;lt; left { break } for i := right; i &amp;gt;= left; i-- { res = append(res, matrix[down][i]) } // 避免上下重合 down-- if down &amp;lt; top { break } for i := down; i &amp;gt;= top; i-- { res = append(res, matrix[i][left]) } // 避免左右重合 left++ if left &amp;gt; right { break } } return res }</description></item><item><title>30. 包含 min 函数的栈</title><link>https://example.com/docs/algs/codingInterviews/30_%E5%8C%85%E5%90%AB-min-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/30_%E5%8C%85%E5%90%AB-min-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</guid><description> Description # 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数，输入操作时保证 pop、top 和 min 函数操作时，栈中一定有元素。
此栈包含的方法有： push(value):将value压入栈中 pop():弹出栈顶元素 top():获取栈顶元素 min():获取栈中最小元素
数据范围：操作数量满足 \($0 \le n \le 300$\) ，输入的元素满足 \($|val| \le 10000$\) 进阶：栈的各个操作的时间复杂度是 \($\Omicron(1)$\) ，空间复杂度是 \($\Omicron(n)$\) 。
Solutions # Stack # 使用两个栈，一个栈stack1用于正常压入和弹出，另一个栈stack2用于实现单调栈。当压入一个元素时，如果当前元素比 stack2 的栈顶元素还要大，则将当前元素压入 stack1 的同时，还将当前元素压入 stack2，如果当前元素不比 stack2 的栈顶元素要大，则将 stack2 的栈顶元素重复入栈。当弹出元素时，将 stack1 和 stack2 的栈顶元素同步弹出。当获取最小值时，只需要取出 stack2 的栈顶元素即可。
// 用于实现正常的 push 与 pop 操作 var stack1 []int // 用于存储最小值 var stack2 []int func Push(node int) { // write code here stack1 = append(stack1, node) size := len(stack2) if size == 0 || stack2[size-1] &amp;gt; node { stack2 = append(stack2, node) } else { stack2 = append(stack2, stack2[size-1]) } } func Pop() { // write code here size := len(stack1) stack1 = stack1[:size-1] stack2 = stack2[:size-1] } func Top() int { // write code here size := len(stack1) return stack1[size-1] } func Min() int { // write code here size := len(stack2) return stack2[size-1] }</description></item><item><title>31. 栈的压入弹出序列</title><link>https://example.com/docs/algs/codingInterviews/31_%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/31_%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</guid><description>Description # 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。
Solutions # 栈模拟 # 新建一个栈来模拟出栈序列。使用一个指针 inPos 指向当前入栈序列的单签入栈元素，使用另一个指针 outPos 指向出栈序列当前应该出栈的元素，然后开始模拟出入栈。
首先，如果当前栈顶元素和出栈序列匹配，则出栈栈顶元素，并且将 outPos 右移，直到二者不匹配或者栈为空 将 inPos 指针指向的入栈序列的元素入栈，然后将 inPos 右移。 不断循环上述过程，直到入栈序列中的所有元素都入栈。 最后判断是否出栈序列中的所有元素都已经匹配完成即可。 func IsPopOrder( pushV []int , popV []int ) bool { // write code here size := len(pushV) if size == 0 { return true } var stack []int stack = append(stack, pushV[0]) inPos, outPos := 1, 0 // 为什么这里的循环用的是 &amp;lt;= ，而不是 &amp;lt; ？ // 因为有可能我们一直从入栈序列中入栈的操作，直到所有元素都已经入栈。如果只使用 &amp;lt; 符号的话， // 我们就无法判断出栈序列是否和栈顶元素匹配（当然你也可以在 for 循环之后再加上这一步，只不过加 // 上这个=号之后可以少写一点代码）.</description></item><item><title>32. 从上往下打印二叉树</title><link>https://example.com/docs/algs/codingInterviews/32_%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/32_%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>Description # 不分行从上往下打印出二叉树的每个节点，同层节点从左至右打印
Solutions # 层次遍历即可，直接上代码。
func PrintFromTopToBottom( root *TreeNode ) []int { // write code here var res []int if root == nil { return res } var queue []*TreeNode queue = append(queue, root) for len(queue) != 0 { size := len(queue) for i := 0; i &amp;lt; size; i++ { node := queue[i] if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.</description></item><item><title>33. 二叉搜索树的后序遍历序列</title><link>https://example.com/docs/algs/codingInterviews/33_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/33_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</guid><description> Description # 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回 true ,否则返回 false。假设输入的数组的任意两个数字都互不相同。
数据范围： 节点数量 \($0 \le n \le 1000$\) ，节点上的值满足 \($1 \le val \le 10^{5}$\) ，保证节点上的值各不相同 要求：空间复杂度 O(n)O(n) ，时间时间复杂度 \($\Omicron(n^2)$\) Solutions # 后序遍历具有“左右根”的结构，而因为这里是二叉搜索树，那么必然有左子树所有元素比根小，右子树所有元素比根大，那么我们只需要确定根所在的位置，然后从该位置向左查找，直到第一个比根小的元素，然后从该元素往左都是左子树，从该元素下一个位置到根元素的前一个位置都是右子树的元素，然后只需要检查左子树是否比根元素小，右子树是否比根元素大，然后递归检查左子树和有右子树即可。
func VerifySquenceOfBST(sequence []int ) bool { // write code here size := len(sequence) if size == 0 { return false } return helper(sequence, 0, size-1) } func helper(sequence []int, left, right int) bool { if left &amp;gt;= right { return true } root := sequence[right] sep := right-1 for sep &amp;gt;= 0 &amp;amp;&amp;amp; sequence[sep] &amp;gt; root { sep-- } for i := 0; i &amp;lt;= sep; i++ { if sequence[i] &amp;gt; root { return false } } return helper(sequence, left, sep) &amp;amp;&amp;amp; helper(sequence, sep+1, right-1) }</description></item><item><title>34. 二叉树中和为某一值的路径（二）</title><link>https://example.com/docs/algs/codingInterviews/34_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E4%BA%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/34_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E4%BA%8C/</guid><description>Description # 输入一颗二叉树的根节点root和一个整数expectNumber，找出二叉树中结点值的和为expectNumber的所有路径。 1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点 2.叶子节点是指没有子节点的节点 3.路径只能从父节点到子节点，不能从子节点到父节点 4.总节点数目为n
Solutions # 因为这里的路径要求是从根节点到叶子节点的，所以也很简单，直接回溯即可。但是需要注意的是，下面这种通过 expectedNum - root.Val 的方式能够减少额外维护一个当前路径上的元素组成的数组的开销，很值得推荐。
func FindPath( root *TreeNode , expectNumber int ) [][]int { // write code here var res [][]int if root == nil { return res } var nums []int findPathHelper(root, expectNumber, nums, &amp;amp;res) return res } func findPathHelper(root *TreeNode, expecteNumber int, nums []int, res *[][]int) { if root == nil { return } // 这里能够减少单独再维护一个数组的开销，很值得推荐 nums = append(nums, root.</description></item><item><title>35. 复杂链表的复制</title><link>https://example.com/docs/algs/codingInterviews/35_%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/35_%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</guid><description> Description # 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）。 下图是一个含有5个结点的复杂链表。图中实线箭头表示next指针，虚线箭头表示random指针。为简单起见，指向null的指针没有画出。
Solutions # 链表或者图的复制非常适合用哈希表来做。
func Clone( head *RandomListNode ) *RandomListNode { //write your code here if head == nil { return nil } dict := make(map[*RandomListNode]*RandomListNode) p := head for p != nil { node := new(RandomListNode) node.Label = p.Label dict[p] = node p = p.Next } p = head for p != nil { dict[p].Next = dict[p.Next] dict[p].Random = dict[p.Random] p = p.Next } return dict[head] }</description></item><item><title>36. 二叉搜索树与双向链表</title><link>https://example.com/docs/algs/codingInterviews/36_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/36_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid><description>Description # 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。 注意: 1.要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继 2.返回链表中的第一个节点的指针 3.函数返回的TreeNode，有左右指针，其实可以看成一个双向链表的数据结构 4.你不用输出双向链表，程序会根据你的返回值自动打印输出
Solutions # 这里的解法还是很巧妙的，需要多多注意。
var head, pre *TreeNode func Convert( pRootOfTree *TreeNode ) *TreeNode { // write code here if pRootOfTree == nil { return pRootOfTree } convertHelper(pRootOfTree) return head } // 这里就是一个中序遍历 func convertHelper(cur *TreeNode) { if cur == nil { return } convertHelper(cur.Left) // 如果 pre 为空，说明已经遍历到了最左节点，那么这个节点很明显就是头结点。 // 如果 pre 不为空，说明此时遍历到的不是最左节点，而是其他的一般节点，那么此时就需要做一个连接 if pre == nil { head = cur } else { pre.</description></item><item><title>37. 序列化二叉树</title><link>https://example.com/docs/algs/codingInterviews/37_%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/37_%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>Description # 请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树。
二叉树的序列化(Serialize)是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树等遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#）
二叉树的反序列化(Deserialize)是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。
Solutions # PreOrder Traversal # 采用先序遍历的方式进行序列化，同样采用先序遍历的方式进行反序列化。
var emptyNode string = &amp;#34;#&amp;#34; var seperator string = &amp;#34; &amp;#34; func Serialize( root *TreeNode ) string { // write code here if root == nil { return &amp;#34;&amp;#34; } var res []string _serialize(root, &amp;amp;res) return strings.Join(res, seperator) } func _serialize(root *TreeNode, res *[]string) { if root != nil { v := strconv.Itoa(root.Val) *res = append(*res, v) _serialize(root.</description></item><item><title>38. 字符串的排列</title><link>https://example.com/docs/algs/codingInterviews/38_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/38_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</guid><description>Description # 输入一个长度为 n 字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组。
例如输入字符串ABC,则输出由字符A,B,C所能排列出来的所有字符串ABC,ACB,BAC,BCA,CBA和CAB。
Solutions # 使用全排列的思想来做。
func Permutation( str string ) []string { // write code here var res []string size := len(str) if size == 0 { return res } dict := make(map[string]bool) permutate([]rune(str), 0, size, &amp;amp;dict) for key, _ := range dict { res = append(res, key) } return res } func permutate(str []rune, start int, size int, dict *map[string]bool) { if start == size { s := string(str) if _, ok := (*dict)[s]; !</description></item><item><title>39. 数组中出现次数超过一半的数字</title><link>https://example.com/docs/algs/codingInterviews/39_%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/39_%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</guid><description>Description # 给一个长度为 n 的数组，数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。
数据范围： \($n \le 50000$\) ，数组中元素的值 \($0 \le val \le 10000$\) 要求：空间复杂度： \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n)$\) Solutions # 使用一个数字 cur 表示当前已经遍历到的元素，使用 cnt 表示当前 cur 出现次数。遍历一次数组，每当 cnt &amp;lt;= 0 时，则将 cur 更新为当前扫描到的元素，如果当前扫描的元素 num 不等于 cur， 那么 cnt &amp;ndash;，如果相等，则 cnt++，最后剩下的这个 cur 必然是多数元素。
因为多数元素出现次数超过一半，所以扫描时，少数元素会把多数元素的出现次数给抵消掉，但是无论怎么抵消，多数元素的出现次数还是比所有少数元素的出现次数要少，所以最后剩下的元素一定是那个多数元素。
func MoreThanHalfNum_Solution( numbers []int ) int { // write code here var cnt int cur := -1 for _, num := range numbers { if cnt &amp;lt;= 0 { cur = num cnt = 1 } else if num == cur { cnt++ } else if num !</description></item><item><title>40. 最小的 k 个数</title><link>https://example.com/docs/algs/codingInterviews/40_%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E4%B8%AA%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/40_%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E4%B8%AA%E6%95%B0/</guid><description>Description # 给定一个长度为 n 的可能有重复值的数组，找出其中不去重的最小的 k 个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4(任意顺序皆可)。 数据范围： \($0\le k,n \le 10000$\) ，数组中每个数的大小 \($0 \le val \le 1000$\) 要求：空间复杂度 \($\Omicron(n)$\) ，时间复杂度 \($\Omicron(n\log n)$\) Solutions # Min Heap # 使用最小堆的思想来做。把元素不断地压入堆中，然后再将前 k 个元素出堆即可。
import &amp;#34;container/heap&amp;#34; /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * @param input int整型一维数组 * @param k int整型 * @return int整型一维数组 */ func GetLeastNumbers_Solution( input []int , k int ) []int { // write code here var minHeap MinHeap var res []int heap.</description></item><item><title>41. 数据流中的中位数</title><link>https://example.com/docs/algs/codingInterviews/41_%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/41_%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</guid><description>Description # 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。
数据范围：数据流中数个数满足 \($1 \le n \le 1000$\) ，大小满足 \($1 \le val \le 1000$\) 进阶： 空间复杂度 \($\Omicron(n)$\) ， 时间复杂度 \($\Omicron(n\log n)$\) Solutions # Heap # 分别维持一个大根堆和小根堆，大根堆存储 median 左边的元素，小根堆存储 median 右边的元素，每当新来一个元素，优先放在右边小根堆，然后将小根堆堆顶元素放入大根堆。如果右边小根堆元素数量小于左边大根堆元素数量，那么将右边小根堆堆顶元素弹出并压入左边大根堆中，这样就能维持左边大根堆数量至多比右边小根堆数量多一个。
type MedianFinder struct { minHeap MinHeapArr maxHeap MaxHeap } func Constructor() MedianFinder { var minHeap MinHeapArr var maxHeap MaxHeap heap.Init(&amp;amp;minHeap) heap.Init(&amp;amp;maxHeap) return MedianFinder{ minHeap: minHeap, maxHeap: maxHeap, } } func (this *MedianFinder) AddNum(num int) { // 关键还是在这里的调整，这里的调整保证了左边大根堆的元素数量至多比右边小根堆的数量多一个：当元素总数为偶数时，二者相等；为奇数时，左边比右边大 1 heap.</description></item><item><title>42. 连续子数组的最大和</title><link>https://example.com/docs/algs/codingInterviews/42_%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/42_%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</guid><description> Description # 输入一个长度为n的整型数组array，数组中的一个或连续多个整数组成一个子数组，子数组最小长度为1。求所有子数组的和的最大值。
Solutions # Kadane 方法 # 参见这个 链接， 已经有现成的 \($\Omicron(n)$\) 方法。
package main import &amp;#34;math&amp;#34; /** * * @param array int整型一维数组 * @return int整型 */ func FindGreatestSumOfSubArray( array []int ) int { // write code here size := len(array) if size == 0 { return 0 } sum := int(math.MinInt32) res := sum for i := 0; i &amp;lt; size; i++ { sum = max(array[i], sum+array[i]) res = max(res, sum) } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a } 动态规划 # 定义 dp[i] 表示以 i 为结尾的连续子数组的最大和，则很明显，dp[i] 的值受到 dp[i-1] 和 array[i] 的影响，稍微一想即可得到转态转移方程： \($dp[i] = \max (dp[i-1] &amp;#43; array[i], array[i])$\) func FindGreatestSumOfSubArray( array []int ) int { // write code here size := len(array) if size == 0 { return 0 } res := array[0] dp := make([]int, size) dp[0] = array[0] for i := 1; i &amp;lt; size; i++ { dp[i] = max(dp[i-1]+array[i], array[i]) res = max(res, dp[i]) } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a }</description></item><item><title>43. 整数中 1 出现的次数</title><link>https://example.com/docs/algs/codingInterviews/43_%E6%95%B4%E6%95%B0%E4%B8%AD-1-%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/43_%E6%95%B4%E6%95%B0%E4%B8%AD-1-%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</guid><description>Description # 输入一个整数 n ，求 1～n 这 n 个整数的十进制表示中 1 出现的次数 例如， 1~13 中包含 1 的数字有 1 、 10 、 11 、 12 、 13 因此共出现 6 次
注意：11 这种情况算两次
数据范围： \($1 \le n \le 30000$\) 进阶：空间复杂度 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n\log n)$\) Solutions # TODO</description></item><item><title>45. 把数组排成最小的数</title><link>https://example.com/docs/algs/codingInterviews/45_%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/45_%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</guid><description>Description # 输入一个非负整数数组numbers，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 例如输入数组[3，32，321]，则打印出这三个数字能排成的最小数字为321323。 1.输出结果可能非常大，所以你需要返回一个字符串而不是整数 2.拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0
数据范围: \($0&amp;lt;=len(numbers)&amp;lt;=100$\) Solutions # 这里的解法比较巧妙，如果没有做过这个题目的话，第一次碰到应该很难做出来。在 golang 中，我们对数组排序的时候可以指定一个 less 函数，来表明我们希望的排序策略，比如说 4 &amp;lt; 5， 那么 4 应该排在 5 前面。而这里涉及到的是字符串拼接，对于 &amp;ldquo;bc&amp;rdquo; 和 &amp;ldquo;bca&amp;rdquo; 这两个字符串，一般的排序方法会把 bc 排到 bca 前面，这样就会出现 &amp;ldquo;bcbca&amp;rdquo; 这个字符，很明显这不是最小的。这里单独排序一个字符显然是不行的，我们的解决办法是对两个字符的不同拼接进行比较，这样就可以确定什么样的拼接能够放在前面，这样的拼接导致的整体字符串的字典序更小一些。
func PrintMinNumber( numbers []int ) string { // write code here var res string size := len(numbers) if size == 0 { return res } var strs []string for _, value := range numbers { s := strconv.</description></item><item><title>46. 把数字翻译成字符串</title><link>https://example.com/docs/algs/codingInterviews/46_%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/46_%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description> Description # 有一种将字母编码成数字的方式：&amp;lsquo;a&amp;rsquo;-&amp;gt;1, &amp;lsquo;b-&amp;gt;2&amp;rsquo;, &amp;hellip; , &amp;lsquo;z-&amp;gt;26&amp;rsquo;。 我们把一个字符串编码成一串数字，再考虑逆向编译成字符串。 由于没有分隔符，数字编码成字母可能有多种编译结果，例如 11 既可以看做是两个 &amp;lsquo;a&amp;rsquo; 也可以看做是一个 &amp;lsquo;k&amp;rsquo; 。但 10 只可能是 &amp;lsquo;j&amp;rsquo; ，因为 0 不能编译成任何结果。 现在给一串数字，返回有多少种可能的译码结果
Solutions # Recursive # func solve( nums string ) int { // write code here var res int size := len(nums) if size == 0 { return 0 } helper(nums, &amp;amp;res) return res } func helper(nums string, res *int) { size := len(nums) if size == 0 { *res += 1 return } // 如果开头字符是 0， 那么说明只是一次不合法的拆分在，直接返回即可 if nums[0] == &amp;#39;0&amp;#39; { return } // 如果可能将连个字符放在一起，则将两个字符放在一起 if size &amp;gt;= 2 &amp;amp;&amp;amp; nums[:2] &amp;gt;= &amp;#34;10&amp;#34; &amp;amp;&amp;amp; nums[:2] &amp;lt;= &amp;#34;26&amp;#34; { helper(nums[2:], res) } // 永远可以拆分为单个字符 helper(nums[1:], res) } Dynamic Programming # 定义 dp(i) 表示以第 i 位结尾的前缀串翻译的方案数，初始化 dp[0] = dp[1] = 1, 可以得出递推方程： \(dp[i]=\begin{cases} dp[i-2] &amp;#43; dp[i-1], &amp;amp; 10 \le nums[i-2: i] \le 25 \\ dp[i-1], &amp;amp; else \end{cases}\)</description></item><item><title>47. 礼物的最大价值</title><link>https://example.com/docs/algs/codingInterviews/47_%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/47_%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</guid><description> Description # 在一个m\times nm×n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？ 如输入这样的一个二维数组， [ [1,3,1], [1,5,1], [4,2,1] ] 那么路径 1→3→5→2→1 可以拿到最多价值的礼物，价值为12
Solutions # Dynamic Programming # 定义 dp[i][j] 表示在 grid[i][j] 所能得到的最大礼物值，则很明显，dp[i][j]的值要么是从左边转移得到的，要么是从上侧转移得到的，则可以得到递推方程 dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1])。base case 的话，很明显，第一行的数据只能从左边得到，第一列数据只能从上侧得到。我们可以直接复用原数组，这样还能节省一下空间开销。
func maxValue( grid [][]int ) int { // write code here m,n := len(grid), len(grid[0]) // 如果我们开辟一个 (m+1) * (n+1) 的数组，那么下面这两个 for 语句就不需要了，代码可以更加简洁。 // 第一列只能来自上方 for i := 1; i &amp;lt; m; i++ { grid[i][0] += grid[i-1][0] } // 第一行只能来自左边 for i := 1; i &amp;lt; n; i++ { grid[0][i] += grid[0][i-1] } for i := 1; i &amp;lt; m; i++ { for j := 1; j &amp;lt; n; j++ { grid[i][j] = grid[i][j] + max(grid[i-1][j], grid[i][j-1]) } } return grid[m-1][n-1] }</description></item><item><title>48. 最长不含重复字符的子字符串</title><link>https://example.com/docs/algs/codingInterviews/48_%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/48_%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description>Description # 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。 数据范围: \($\text{s.length}\le 40000$\) Solutions # 滑动窗口 # func lengthOfLongestSubstring( s string ) int { // write code here size := len(s) if size &amp;lt;= 1 { return size } res, start := 1, -1 dict := make(map[byte]int) // 这里用等号主要是因为当最后几个字符串都不重复时，如果不在这里加上一个等号，则可能会缺少一次计算，从而导致结果不准确。 // 下面的第一个 if 也是为了跟这种情况搭配才加上的。 for i := 0; i &amp;lt;= size; i++ { if i == size { res = max(res, i - start - 1) break } if index, ok := dict[s[i]]; ok &amp;amp;&amp;amp; index &amp;gt; start { res = max(res, i - start - 1) start = index } dict[s[i]] = i } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a } 下面是上面这种解法的更简介写法：</description></item><item><title>49. 丑数</title><link>https://example.com/docs/algs/codingInterviews/49_%E4%B8%91%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/49_%E4%B8%91%E6%95%B0/</guid><description> Description # 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第 n个丑数。
数据范围： \($0 \le n \le 2000$\) 要求：空间复杂度 \($\Omicron(n)$\) ， 时间复杂度 \($\Omicron(n)$\) Solutions # 很明显丑数只会是可以用 \($2^x*3^y*5^z$\) 表示的一个数字。分别表示从 1 开始乘 2、3、5 的三条丑数队列，每次从这三个丑数队列中取出最小的数字来作为我们当前得到的最小丑数，然后更新那个贡献了这个数字的丑数队列的下一个值。更精简的做法是，我们可以直接维护三个指针 i2、i3、 i5, 来表示这个三个队列。
func GetUglyNumber_Solution( index int ) int { // write code here if index == 0 { return 0 } var i2, i3, i5 int res := make([]int, index) res[0] = 1 for i := 1; i &amp;lt; index; i++ { // 取出当前队列的最小值 res[i] = min(res[i2]*2, min(res[i3]*3, res[i5]*5)) // 如果是这个队列贡献了这个值，那么更新队列元素 if res[i] == res[i2]*2 { i2++ } if res[i] == res[i3] * 3 { i3++ } if res[i] == res[i5] * 5 { i5++ } } return res[index-1] } func min(a,b int) int { if a &amp;lt; b { return a } return b }</description></item><item><title>50. 第一个只出现一次的字符</title><link>https://example.com/docs/algs/codingInterviews/50_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/50_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</guid><description> Description # 在一个长为 字符串中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）
数据范围： \($0 \le n \le 10000$\) ，且字符串只有字母组成。 要求：空间复杂度 \($\Omicron(n)$\) ，时间复杂度 \($\Omicron(n)$\) Solutions # Hash Table # 使用一个 hash table 记录每个字符出现的次数，然后再从头扫描一次 str，遇到第一个出现次数为 1 的字符则返回其下标；否则返回-1.
func FirstNotRepeatingChar( str string ) int { // write code here size := len(str) if size == 0 { return -1 } dict := make(map[byte]int) for idx, _ := range str { dict[str[idx]]++ } for idx, _ := range str { if cnt, _ := dict[str[idx]]; cnt == 1 { return idx } } return -1 }</description></item><item><title>51. 数组中的逆序对</title><link>https://example.com/docs/algs/codingInterviews/51_%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/51_%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</guid><description> Description # 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P mod 1000000007
数据范围： 对于 \($50\%$\) 的数据, \($size \leq 10^4$\) 对于 \($100\%$\) 的数据, \($size\leq 10^5$\) 数组中所有数字的值满足 \($0 \le val \le 1000000$\) 要求：空间复杂度 \($\Omicron(n)$\) ，时间复杂度 \($\Omicron(n \log n)$\) Solutions # 如果两个区间为[4, 3] 和[1, 2], 那么逆序数为(4,1),(4,2),(3,1),(3,2)，同样的如果区间变为有序，比如[3,4] 和 [1,2], 那么逆序数也是一样的，也就是说区间有序和无序结果是一样的。但是区间有序带来的好处是，比如[3,4] 和 [1,2]，如果3 &amp;gt; 1, 显然3后面的所有数都大于1，那么逆序对计算就会方便很多。
Merge Sort # const MOD int = 1000000007 func InversePairs( data []int ) int { // write code here var res int size := len(data) if size &amp;lt;= 1 { return res } tmp := make([]int, size) mergeSort(data, tmp, 0, size-1, &amp;amp;res) return res } func mergeSort(nums,tmp []int, start, end int, res *int) { if start &amp;gt;= end { return } mid := (start + end)/2 mergeSort(nums, tmp, start, mid, res) mergeSort(nums, tmp, mid+1, end, res) merge(nums, tmp, start, mid, end, res) } func merge(nums,tmp []int, start, mid, end int, res *int) { left, right := start, mid+1 var idx int for left &amp;lt;= mid &amp;amp;&amp;amp; right &amp;lt;= end { if nums[left] &amp;gt; nums[right] { tmp[idx] = nums[right] right++ *res += mid - left + 1 *res %= MOD } else { tmp[idx] = nums[left] left++ } idx++ } for left &amp;lt;= mid { tmp[idx] = nums[left] idx++ left++ } for right &amp;lt;= end { tmp[idx] = nums[right] idx++ right++ } for i,k := start, 0; i &amp;lt;= end; i,k = i+1, k+1 { nums[i] = tmp[k] } }</description></item><item><title>52. 两个链表的第一个公共节点</title><link>https://example.com/docs/algs/codingInterviews/52_%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/52_%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</guid><description>Description # 输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）
数据范围： \($n \le 1000$\) 要求：空间复杂度 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n)$\) Solutions # 从两个链表的头节点 pHead1 和 pHead2 开始不断向后遍历，如果 pHead1 遍历到末尾，则从 pHead2 开始继续进行遍历，如果 pHead2 遍历到末尾，则从 pHead1 开始继续进行遍历。这样的话，如果存在公共节点，那么它们就会在第一个公共节点处相遇，此时他们都走过了相同的路程，返回这个节点即可。
func FindFirstCommonNode( pHead1 *ListNode , pHead2 *ListNode ) *ListNode { // write code here p1, p2 := pHead1, pHead2 for p1 != p2 { if p1 == nil { p1 = pHead2 }else { p1 = p1.Next } if p2 == nil { p2 = pHead1 } else { p2 = p2.</description></item><item><title>53. 数字在升序数组中出现的次数</title><link>https://example.com/docs/algs/codingInterviews/53_%E6%95%B0%E5%AD%97%E5%9C%A8%E5%8D%87%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/53_%E6%95%B0%E5%AD%97%E5%9C%A8%E5%8D%87%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</guid><description> Description # 给定一个长度为 n 的非降序数组和一个非负数整数 k ，要求统计 k 在数组中出现的次数
数据范围： \($0 \le n \le 1000 $\) , \($0 \le k \le 100$\) ，数组中每个元素的值满足 \($0 \le val \le 100$\) . 要求：空间复杂度 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(\log n)$\) Solutions # Binary Search # func GetNumberOfK( data []int , k int ) int { // write code here var res int size := len(data) if size &amp;lt; 1 { return res } left, right := 0, size - 1 for left &amp;lt;= right { mid := (left +right)/2 if data[mid] &amp;gt; k { right = mid - 1 } else if data[mid] &amp;lt; k { left = mid + 1 } else if data[mid] == k { l,r := mid, mid for l &amp;gt;= 0 &amp;amp;&amp;amp; data[l] == k { l-- } for r &amp;lt; size &amp;amp;&amp;amp; data[r] == k { r++ } res = r - l - 1 break } } return res }</description></item><item><title>54. 二叉搜索树的第 k 个节点</title><link>https://example.com/docs/algs/codingInterviews/54_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/54_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9/</guid><description>Description # 给定一棵结点数为n 二叉搜索树，请找出其中的第 k 小的TreeNode结点值。 1.返回第k小的节点值即可 2.不能查找的情况，如二叉树为空，则返回-1，或者k大于n等等，也返回-1 3.保证n个节点的值不一样
数据范围： \($0 \le n \le1000$\) ， \($0 \le k \le1000$\) ，树上每个结点的值满足 \($0 \le val \le 1000$\) 进阶：空间复杂度 \($\Omicron(n)$\) ，时间复杂度 \($\Omicron(n)$\) Solutions # 很简单，中序遍历求第 k 个节点即可。
func KthNode( proot *TreeNode , k int ) int { // write code here if proot == nil { return -1 } var stack []*TreeNode cur := proot for cur != nil || len(stack) != 0 { for cur !</description></item><item><title>55. 二叉树的深度</title><link>https://example.com/docs/algs/codingInterviews/55_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/55_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</guid><description> Description # 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度，根节点的深度视为 1 。
数据范围：节点的数量满足 \($0 \le n \le 100$\) ，节点上的值满足 \($0 \le val \le 100$\) 进阶：空间复杂度 \($\Omciron(1)$\) ，时间复杂度 \($\Omicron(n)$\) Solutions # 简单题，不多说直接上代码。
func TreeDepth( pRoot *TreeNode ) int { // write code here if pRoot == nil { return 0 } return max(TreeDepth(pRoot.Left), TreeDepth(pRoot.Right)) + 1 } func max(a, b int) int { if a &amp;lt; b { return b } return a }</description></item><item><title>56. 数组中只出现一次的两个数字</title><link>https://example.com/docs/algs/codingInterviews/56_%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/56_%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</guid><description>Description # 一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
数据范围：数组长度 \($2\le n \le 1000$\) ，数组中每个数的大小 \($0 &amp;lt; val \le 1000000$\) 要求：空间复杂度 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n)$\) 提示：输出时按非降序排列。
Solutions # Hash Table # 建立一个哈希表，对每个出现的数字计数，最后将只出现一次的数字返回即可。
// 使用哈希表 func FindNumsAppearOnce( array []int ) []int { dict := make(map[int]int) for _, value := range nums { dict[value]++ } var res []int for value, count := range dict { if count == 1 { res = append(res, value) } } if len(res) == 2 &amp;amp;&amp;amp; res[1] &amp;lt; res[0] { res[0], res[1] = res[1], res[0] } return res } 位运算 # 如果只要一个数字是不同的，那么很容易计算，只需要直接对整个数组计算异或值即可，这个异或值即为我们所求。但是这里有两个不同值，那么怎么办呢？方法就是对他们进行分组（这里不需要两个组的元素数量相同），将两个不同的值分到不同的组里面，而且还要把相同的值分到同一个组里面，这样分别对两个不同的组进行异或计算，得到的两个值就是我们所求的两个数。</description></item><item><title>57. 和为 S 的两个数字</title><link>https://example.com/docs/algs/codingInterviews/57_%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/57_%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</guid><description> Description # 输入一个升序数组 array 和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，返回任意一组即可，如果无法找出这样的数字，返回一个空数组即可。
数据范围: \($0 \le len(array) \le 10^5$\) , \($1 \le array[i] \le 10^6$\) Solutions # func FindNumbersWithSum( array []int , sum int ) []int { // write code here size := len(array) if size &amp;lt;= 1 { return nil } left, right := 0, size -1 for left &amp;lt; right { if array[left] + array[right] == sum { return []int{array[left], array[right]} } else if array[left] + array[right] &amp;lt; sum { left++ } else if array[left] + array[right] &amp;gt; sum { right-- } } return nil }</description></item><item><title>58. 左旋转字符串</title><link>https://example.com/docs/algs/codingInterviews/58_%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/58_%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description>Description # 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列 S ，请你把其循环左移 K 位后的序列输出。例如，字符序列 S = ”abcXYZdef” , 要求输出循环左移 3 位后的结果，即 “XYZdefabc”
数据范围：输入的字符串长度满足 \($0 \le len \le 100$\) ， \($0 \le n \le 100$\) 进阶：空间复杂度 \($\Omicron(n)$\) ，时间复杂度 \($\Omicron(n)$\) Solutions # 字符串拼接 # func LeftRotateString( str string , n int ) string { // write code here size := len(str) if size == 0 || n%size == 0 { return str } n %= size // n 可能会大于 size，所以需要取余 left, right := str[:n], str[n:] return right+left } 字符串翻转 # 先将整个字符串翻转一次，然后再将从左边开始数的 size - n 个字符翻转一次，最后再将右边剩余的 n 个字符翻转一次。</description></item><item><title>59. 滑动窗口的最大值</title><link>https://example.com/docs/algs/codingInterviews/59_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/59_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</guid><description> Description # 给定一个长度为 n 的数组 nums 和滑动窗口的大小 size ，找出所有滑动窗口里数值的最大值。
例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。
Solutions # Dequeue # 使用一个单调递减的单调队列来做。维持一个最大长度为 size 的单调队列，每当遍历到当前元素 i，如果当前元素 nums[i] 比队列尾部元素要大，则不断将队列尾部元素出队，直到队列为空或者当前元素 nums[i] 比队尾元素要小，然后将当前元素入队。这样的话，队列中要么维持着一个最大值，要么顶多维持着 size 个相对递减的连续值。然后检查队首元素是否过期，如果过期，则将队首元素出队，因为我们每次顶多入队一个，所以每次遍历也顶多只会有一个元素过期。最后检查当前窗口长度是否达到 size，如果达到了，则将队列首部元素入队即可。
// 可以使用单调递减的单调队列来实现 func maxInWindows( num []int , size int ) []int { // write code here var res []int n := len(num) if size &amp;lt; 1 || n &amp;lt; 1 { return res } var queue []int for i := 0; i &amp;lt; n; i++ { // 如果当前遍历到的元素比队尾元素要大，则不断将队尾元素出队 curLen := len(queue) for curLen &amp;gt; 0 &amp;amp;&amp;amp; num[i] &amp;gt; num[queue[curLen-1]] { curLen-- queue = queue[:curLen] } queue = append(queue, i) // 如果当前队首元素滑出左边界，则将其删除 if queue[0] + size &amp;lt;= i { queue = queue[1:] } // 如果当前已经构成了一个有效的滑动窗口，则将当前最大值存入结果 if size &amp;lt;= i+1 { res = append(res, num[queue[0]]) } } return res }</description></item><item><title>61. 扑克牌顺子</title><link>https://example.com/docs/algs/codingInterviews/61_%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/61_%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/</guid><description> Description # 现在有2副扑克牌，从扑克牌中随机五张扑克牌，我们需要来判断一下是不是顺子。 有如下规则：
A为1，J为11，Q为12，K为13，A不能视为14 大、小王为 0，0可以看作任意牌 如果给出的五张牌能组成顺子（即这五张牌是连续的）就输出true，否则就输出false。 4.数据保证每组5个数字，每组最多含有4个零，数组的数取值为 [0, 13] 要求：空间复杂度 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n \log n)$\) ，本题也有时间复杂度 \($\Omicron(n)$\) 的解法
Solutions # 建立一个大小为14 的数组，记录每只牌出现的次数。然后从 1 开始遍历这个数组直到第一只计数值为 1 的牌，如果任意一只牌的计数值大于 1，则返回 false；然后从这只牌开始模拟，如果以这只牌开始的五只牌都能构成顺子，则返回 true；否则
func IsContinuous( numbers []int ) bool { // write code here // 记录每只牌出现的次数 emu := make([]int, 14) for _, value := range numbers { emu[value]++ } for i := 1; i &amp;lt; 14; i++ { // 任意一只牌的出现次数大于 1，则无法构成顺子 if emu[i] &amp;gt; 1 { return false } // 如果这只牌只出现了一次，那么检查能不能构成顺子 if emu[i] == 1 { // 顶多检查五只牌 for j := i; i+5 &amp;lt; 14 &amp;amp;&amp;amp; j &amp;lt; i+5; j++ { // 任何一只牌出现次数大于 1，则返回 false if emu[j] &amp;gt; 1 { return false } // 如果当前牌只出现了一次，则继续遍历 if emu[j] == 1 { continue } // 如果当前牌没有出现，则看 0 是否还有剩余，如果有，则继续遍历；如果没有，则返回 false if emu[j] == 0 { if emu[0] &amp;gt; 0 { emu[0]-- continue } else { return false } } } // 以 i 开头的牌组可以成为顺子，返回 true return true } } // 没有找到任何一个顺子，返回 false return false }</description></item><item><title>62. 圆圈中最后剩下的数</title><link>https://example.com/docs/algs/codingInterviews/62_%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/62_%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0/</guid><description>Description # 每年六一儿童节，牛客都会准备一些小礼物和小游戏去看望孤儿院的孩子们。其中，有个游戏是这样的：首先，让 n 个小朋友们围成一个大圈，小朋友们的编号是0~n-1。然后，随机指定一个数 m ，让编号为0的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始，继续0&amp;hellip; m-1报数&amp;hellip;.这样下去&amp;hellip;.直到剩下最后一个小朋友，可以不用表演，并且拿到牛客礼品，请你试着想下，哪个小朋友会得到这份礼品呢？
Solutions # 循环链表模拟 # 可以将元素串成一个循环链表，然后进行遍历即可。
使用数组模拟 # 用数组求解的基本思想就是用一个一维数组去标识这 n 个人的状态，默认全为 1 ，也就是都在圈子内，当数到 m 的人出圈之后，标识置为 0（就是出圈了），同时报数器清 0，下一个人要从 1 开始。在每次报数之前要判断他是否在圈子内（也就是他的标识是否为 1 ），如果在圈子里面才会继续报数。定义一个变量记录出圈的人数， 出圈的人数等于 n-1 时，则游戏结束。</description></item><item><title>63. 买卖股票的最好时机</title><link>https://example.com/docs/algs/codingInterviews/63_%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A5%BD%E6%97%B6%E6%9C%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/63_%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A5%BD%E6%97%B6%E6%9C%BA/</guid><description> Description # 假设你有一个数组prices，长度为n，其中prices[i]是股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益 1.你可以买入一次股票和卖出一次股票，并非每天都可以买入或卖出一次，总共只能买入和卖出一次，且买入必须在卖出的前面的某一天 2.如果不能获取到任何利润，请返回0 3.假设买入卖出均无手续费
Solutions # 一次扫描，扫描过程中维护当前扫描到的数字的最小值，然后不断的用当前扫描到的数字减去这个最小得到一个差，取这个差的最大值即可。
func maxProfit( prices []int ) int { // write code here var res int size := len(prices) if size == 0 { return res } curMin := prices[0] for _, price := range prices { if price &amp;lt; curMin { curMin = price } res = max(res, price-curMin) } return res }</description></item><item><title>65. 不用加减乘除做加法</title><link>https://example.com/docs/algs/codingInterviews/65_%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/65_%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</guid><description> Description # 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。
数据范围：两个数都满足 \($-10 \le n \le 1000$\) 进阶：空间复杂度 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(1)$\) Solutions # Bit Manipulation # 使用位与操作表示两数相加的进位（需要左移一位）， 使用异或操作表示两数相加的和，这样就可以递归计算，递归终止条件是进位为 0.
func Add( num1 int , num2 int ) int { // write code here if num1 == 0 { return num2 } carry := (num1 &amp;amp; num2) &amp;lt;&amp;lt; 1 sum := num1 ^ num2 return Add(carry, sum) }</description></item><item><title>67. 把字符串转成整数(atoi)</title><link>https://example.com/docs/algs/codingInterviews/67_%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%88%90%E6%95%B4%E6%95%B0atoi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/67_%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%88%90%E6%95%B4%E6%95%B0atoi/</guid><description> Description # 写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。传入的字符串可能有以下部分组成: 1.若干空格 2.（可选）一个符号字符（&amp;rsquo;+&amp;rsquo; 或 &amp;lsquo;-&amp;rsquo;） 3. 数字，字母，符号，空格组成的字符串表达式 4. 若干空格
转换算法如下: 1.去掉无用的前导空格 2.第一个非空字符为+或者-号时，作为该整数的正负号，如果没有符号，默认为正数 3.判断整数的有效部分： 3.1 确定符号位之后，与之后面尽可能多的连续数字组合起来成为有效整数数字，如果没有有效的整数部分，那么直接返回0 3.2 将字符串前面的整数部分取出，后面可能会存在存在多余的字符(字母，符号，空格等)，这些字符可以被忽略，它们对于函数不应该造成影响 3.3 整数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231的整数应该被调整为 −231 ，大于 231 − 1 的整数应该被调整为 231 − 1 4.去掉无用的后导空格
Solutions #</description></item><item><title>67. 构建乘积数组</title><link>https://example.com/docs/algs/codingInterviews/66_%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/66_%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</guid><description> Description # 给定一个数组 A[0,1,&amp;hellip;,n-1] ,请构建一个数组 B[0,1,&amp;hellip;,n-1] ,其中 B 的元素 B[i]=A[0]A[1]&amp;hellip;*A[i-1]A[i+1]&amp;hellip;*A[n-1]（除 A[i] 以外的全部元素的的乘积）。程序中不能使用除法。（注意：规定 B[0] = A[1] * A[2] * &amp;hellip; * A[n-1]，B[n-1] = A[0] * A[1] * &amp;hellip; * A[n-2]） 对于 A 长度为 1 的情况，B 无意义，故而无法构建，用例中不包括这种情况。
数据范围： \($1 \le n \le 10$\) ，数组中元素满足 \($|val| \le 10$\) Solutions # Array # 使用两个数组，一个数组left从左到右扫描，left[i] 表示从 A 数组开始位置到 i 位置之前的元素的累乘；一个数组 right 从右向左扫描， right[i] 表示从数组最后一个位置到 i 位置的累乘。最后复用 left ，left[i] *= right[i]， left 即为所求。
func multiply( A []int ) []int { // write code here size := len(A) if size &amp;lt;= 1 { return nil } left, right := make([]int, size), make([]int, size) left[0], right[size-1] = 1, 1 for i := 1; i &amp;lt; size; i++ { left[i] = A[i-1] * left[i-1] } for i := size-2; i &amp;gt;= 0; i-- { right[i] = A[i+1] * right[i+1] } for i := 0; i &amp;lt; size; i++ { left[i] *= right[i] } return left }</description></item><item><title>68. 二叉搜索树的最近公共祖先</title><link>https://example.com/docs/algs/codingInterviews/68_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/68_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid><description>Description # 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
Solutions # Recursive # 如果当前节点的值比要查找的值的最小值还要小，说明应该往当前节点的右节点进行查找；如果当前节点的值比要查找的值的最大值还要大，说明应该往当前节点的左子树进行查找。否则说明当前节点处于要查找的值之间，那么当前节点就是我们要查找的最近公共祖先。
func lowestCommonAncestor( root *TreeNode , p int , q int ) int { // write code here if root == nil { return -1 } // 保持 p 比 q 要小 if p &amp;gt; q { p,q = q, p } res := lcaHelper(root, p, q) return res.Val } func lcaHelper(root *TreeNode, mn,mx int) *TreeNode { if root.Val &amp;gt; mx { return lcaHelper(root.</description></item><item><title>70. 矩形覆盖</title><link>https://example.com/docs/algs/codingInterviews/70_%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/70_%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/</guid><description> Description # 我们可以用 21 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 21 的小矩形无重叠地覆盖一个 2*n 的大矩形，从同一个方向看总共有多少种不同的方法？
数据范围： \($0 \le n \le 38$\) 进阶：空间复杂度 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n)$\) 注意：约定 n == 0 时，输出 0
Solutions # 举例可以发现这其实也是个斐波那契数列问题。
func rectCover( number int ) int { // write code here if number &amp;lt;= 3 { return number } NMinusTwo, NMinusOne := 2, 3 for i := 4; i &amp;lt;= number; i++ { N := NMinusOne + NMinusTwo NMinusTwo = NMinusOne NMinusOne = N } return NMinusOne }</description></item><item><title>70. 跳台阶</title><link>https://example.com/docs/algs/codingInterviews/69_%E8%B7%B3%E5%8F%B0%E9%98%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/69_%E8%B7%B3%E5%8F%B0%E9%98%B6/</guid><description> Description # 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
数据范围： \($1 \leq n \leq 40$\) 要求：时间复杂度： \($\Omicron(n)$\) ，空间复杂度： \($\Omicron(1)$\) Solutions # 动态规划 # func jumpFloor( number int ) int { // write code here if number &amp;lt;= 1 { return number } NMinusTwo, NMinusOne := 0, 1 for i := 1; i &amp;lt;= number; i++ { n := NMinusOne + NMinusTwo NMinusTwo = NMinusOne NMinusOne = n } return NMinusOne }</description></item><item><title>71. 跳台阶扩展问题</title><link>https://example.com/docs/algs/codingInterviews/71_%E8%B7%B3%E5%8F%B0%E9%98%B6%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/71_%E8%B7%B3%E5%8F%B0%E9%98%B6%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98/</guid><description> Description # 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶(n为正整数)总共有多少种跳法。
Solutions # Math # 其实可以通过举例来发现规律: \($f(n) = 2 * f(n-1) (n &amp;gt; 2)$\) ，如果 \($0 \le n \le 2$\) ，则直接返回 n 即可。
func jumpFloorII( number int ) int { // write code here if number &amp;lt;= 2 { return number } return int(math.Pow(2, float64(number-1))) }</description></item><item><title>73. 翻转单词序列</title><link>https://example.com/docs/algs/codingInterviews/73_%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/73_%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97/</guid><description>Description # 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“nowcoder. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a nowcoder.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？
Solutions # 先翻转整个句子，然后再针对每个空格分割的单词单独翻转。
func ReverseSentence( str string ) string { // write code here size := len(str) if size &amp;lt;= 1 { return str } runes := []rune(str) size = len(runes) // 先翻转整个字符串 for left,right := 0, size-1; left &amp;lt; right; left,right = left+1, right-1 { runes[left],runes[right] = runes[right], runes[left] } // 再翻转这个字符串里的每个单词 var left, right int for right &amp;lt;= size { for right &amp;lt; size &amp;amp;&amp;amp; runes[right] !</description></item><item><title>74. 和为 S 的连续正数序列</title><link>https://example.com/docs/algs/codingInterviews/74_%E5%92%8C%E4%B8%BA-S-%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/74_%E5%92%8C%E4%B8%BA-S-%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</guid><description> Description # 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列?
数据范围： \($0 &amp;lt; n \le 100$\) 进阶：时间复杂度 \($\Omicron(n)$\) Solutions # Sliding Window # 从某一个数字开始的连续序列和等于目标数如果有，只能有一个，于是我们可以用这个性质来使区间滑动。
使用滑动窗口，left 指向窗口左边，right 指向窗口右边，初始时 left 和 right 分别等于 1 和 2.然后计算 [left, right] 这个区间的数字的和，如果和刚好等于 sum，则将这些数字存入 res；如果和大于 sum，说明窗口中元素太多了，需要收缩左窗口；如果和小于 sum，说明窗口中元素太少了，需要收缩右窗口。
func FindContinuousSequence( sum int ) [][]int { // write code here var res [][]int left, right := 1, 2 for left &amp;lt; right { s := (left+right) * (right - left+1)/2 if s == sum { var tmp []int for i := left; i &amp;lt;= right; i++ { tmp = append(tmp, i) } res = append(res, tmp) left++ } else if s &amp;gt; sum { left++ } else if s &amp;lt; sum { right++ } } return res }</description></item><item><title>75. 字符流中第一个不重复出现的字符</title><link>https://example.com/docs/algs/codingInterviews/75_%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/75_%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/</guid><description> Description # 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 &amp;ldquo;go&amp;rdquo; 时，第一个只出现一次的字符是 &amp;ldquo;g&amp;rdquo; 。当从该字符流中读出前六个字符 “google&amp;quot; 时，第一个只出现一次的字符是&amp;quot;l&amp;quot;。
数据范围：字符串长度满足 \($1 \le n \le 1000$\) ，字符串中出现的字符一定在 ASCII 码内。 进阶：空间复杂度 \($\Omicron(n)$\) ，时间复杂度 \($\Omicron(n)$\) Solutions # var dict = make(map[byte]int) var bs []byte func Insert(ch byte) { bs = append(bs, ch) dict[ch]++ } func FirstAppearingOnce() byte { for _, ch := range bs { if cnt, _ := dict[ch]; cnt == 1 { return ch } } return byte(&amp;#39;#&amp;#39;) }</description></item><item><title>76. 删除链表中重复的节点</title><link>https://example.com/docs/algs/codingInterviews/76_%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/76_%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9/</guid><description>Description # 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表 1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5 处理后为 1-&amp;gt;2-&amp;gt;5
数据范围：链表长度满足 \($0 \le n \le 1000$\) ，链表中的值满足 \($1 \le val \le 1000$\) 进阶：空间复杂度 \($\Omicron(n)$\) ，时间复杂度 \($\Omicron(n)$\) Solutions # 并不难，但是要注意虚拟头结点的使用。
func deleteDuplication( pHead *ListNode ) *ListNode { // write code here if pHead == nil { return nil } // 增加一个虚拟头结点，方便头结点的删除 dummyHead := new(ListNode) dummyHead.Next = pHead pre , cur := dummyHead, pHead for cur != nil { if cur.Next != nil &amp;amp;&amp;amp; cur.</description></item><item><title>77. 按之字形顺序打印二叉树</title><link>https://example.com/docs/algs/codingInterviews/77_%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/77_%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>Description # 给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）
数据范围： \($0 \le n \le 1500$\) ,树上每个节点的val满足 \($|val| \le 1500$\) 要求：空间复杂度： \($\Omicron(n)$\) ，时间复杂度： \($\Omicron(n)$\) Solutions # 就是一个树的层次遍历，不多说。
func Print( pRoot *TreeNode ) [][]int { // write code here var res [][]int if pRoot == nil { return res } var queue []*TreeNode queue = append(queue, pRoot) var reverse bool for len(queue) != 0 { size := len(queue) var arr []int for i := 0; i &amp;lt; size; i++ { top := queue[i] arr = append(arr, top.</description></item><item><title>78. 把二叉树打印成多行</title><link>https://example.com/docs/algs/codingInterviews/78_%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/78_%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/</guid><description>Description # 给定一个节点数为 n 二叉树，要求从上到下按层打印二叉树的 val 值，同一层结点从左至右输出，每一层输出一行，将输出的结果存放到一个二维数组中返回。
Solutions # Level Order Traversal # 简单题，只需要进行一次层次遍历即可。
func Print( pRoot *TreeNode ) [][]int { // write code here var res [][]int if pRoot == nil { return res } var queue []*TreeNode queue = append(queue, pRoot) for len(queue) != 0 { size := len(queue) var level []int for i := 0; i &amp;lt; size; i++ { node := queue[i] level = append(level, node.</description></item><item><title>79. 判断是不是平衡二叉树</title><link>https://example.com/docs/algs/codingInterviews/79_%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/79_%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>Description # 输入一棵节点数为 n 二叉树，判断该二叉树是否是平衡二叉树。 在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树 平衡二叉树（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
Solutions # 这里需要注意，光判断根节点是否是平衡二叉树是不够的，还需要对每个子树都做相应的判断。注意这里的解法跟 26 题的相似性。
func IsBalanced_Solution( pRoot *TreeNode ) bool { // write code here if pRoot == nil { return true } if !isBalanced(getTreeHeight(pRoot.Left), getTreeHeight(pRoot.Right)) { return false } return IsBalanced_Solution(pRoot.Left) &amp;amp;&amp;amp; IsBalanced_Solution(pRoot.Right) } func isBalanced(a, b int) bool { if a &amp;gt;b { a, b = b, a } return b - a &amp;lt;= 1 } func getTreeHeight(root *TreeNode) int { if root == nil { return 0 } return max(getTreeHeight(root.</description></item><item><title>81. 调整数组顺序使奇数位于偶数前面 II</title><link>https://example.com/docs/algs/codingInterviews/81_%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/81_%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2II/</guid><description> Description # 输入一个长度为 n 整数数组，数组里面可能含有相同的元素，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前面部分，所有的偶数位于数组的后面部分，对奇数和奇数，偶数和偶数之间的相对位置不做要求，但是时间复杂度和空间复杂度必须如下要求。
数据范围： \($0 \le n \le 50000$\) ，数组中每个数的值 \($0 \le val \le 10000$\) 要求：时间复杂度 \($\Omicron(n)$\) ，空间复杂度 \($\Omicron(1)$\) Solutions # 参考快速排序将小于 pivot 的元素放在左侧，将大于 pivot 的元素放在右侧的做法。这里使用两个指针left和 right，分别指向数组开头和末尾，然后 left 不断向右遍历，直到查找到偶数元素停止，然后 right 不断向左遍历，直到查找到奇数元素停止，然后交换 left 和 right 指向的元素，这样就把奇数放在了左侧，偶数放在了右侧，然后继续遍历，直到 left 和 right 重叠为止。
func reOrderArrayTwo( array []int ) []int { // write code here size := len(array) if size &amp;lt;= 1 { return array } left, right := 0, size -1 for left &amp;lt; right { for left &amp;lt; right &amp;amp;&amp;amp; array[left] % 2 == 1 { left++ } for left &amp;lt; right &amp;amp;&amp;amp; array[right] % 2 == 0 { right-- } array[left], array[right] = array[right], array[left] left++ right-- } return array }</description></item><item><title>82. 二叉树中和为某一值的路径（一）</title><link>https://example.com/docs/algs/codingInterviews/82_%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E4%B8%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/82_%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E4%B8%80/</guid><description>Description # 给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。 1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点 2.叶子节点是指没有子节点的节点 3.路径只能从父节点到子节点，不能从子节点到父节点 4.总节点数目为n
Solutions # 因为这里的路径是从根节点开始的，所以也很简单，直接递归回溯即可。
func hasPathSum( root *TreeNode , sum int ) bool { // write code here if root == nil { return false } var stack []*TreeNode var num int cur := root for cur != nil || len(stack) != 0 { for cur != nil { num += cur.Val stack = append(stack, cur) cur = cur.Left } if num == sum &amp;amp;&amp;amp; cur == nil { return true } size := len(stack) cur = stack[size-1] stack = stack[:size-1] if cur.</description></item><item><title>84. 二叉树中和为某一值的路径 III</title><link>https://example.com/docs/algs/codingInterviews/84_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84III/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/84_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84III/</guid><description>Description # 给定一个二叉树root和一个整数值 sum ，求该树有多少路径的的节点值之和等于 sum 。 1.该题路径定义不需要从根节点开始，也不需要在叶子节点结束，但是一定是从父亲节点往下到孩子节点 2.总节点数目为n 3.保证最后返回的路径个数在整形范围内(即路径个数小于 \($2^{31}$\) -1)
Solutions # 注意，这里的路径不一定需要从根节点开始，也不一定需要在叶节点结束。
Recursice # 核心思想就是，每个节点都可能是一条路径的起始节点，所以每个节点都需要作为根节点来遍历一次。
var res int func FindPath( root *TreeNode , sum int ) int { // write code here if root == nil { return res } findPathHelper(root, sum) // 每个节点都需要作为根节点来进行一次查找 FindPath(root.Left, sum) FindPath(root.Right, sum) return res } func findPathHelper(root *TreeNode, sum int) { if root == nil { return } // 注意这里的小技巧 if sum == root.</description></item><item><title>85. 连续子数组的最大和 II</title><link>https://example.com/docs/algs/codingInterviews/85_%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/85_%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C-II/</guid><description>Description # 输入一个长度为n的整型数组array，数组中的一个或连续多个整数组成一个子数组，找到一个具有最大和的连续子数组。 1.子数组是连续的，比如[1,3,5,7,9]的子数组有[1,3]，[3,5,7]等等，但是[1,3,7]不是子数组 2.如果存在多个最大和的连续子数组，那么返回其中长度最长的，该题数据保证这个最长的只存在一个 3.该题定义的子数组的最小长度为1，不存在为空的子数组，即不存在[]是某个数组的子数组 4.返回的数组不计入空间复杂度计算
Solutions # Kadane 方法 # 详情参见 42 题的 「连续子数组的最大和」，这个方法跟那个方法是同一个思路。
func FindGreatestSumOfSubArray( array []int ) []int { // write code here size := len(array) if size == 0 { return nil } var start, end int res, sum := array[0],array[0] for i := 1; i &amp;lt; size; i++ { // 这里的 start 可能会在不断的向右扩张，而 end 只有在 sum 比 res 大的时候才会扩展，所以可能会出现 start 比 end 大的情况。 if array[i] &amp;gt; sum + array[i] { start = i } sum = max(array[i], sum+array[i]) if sum &amp;gt;= res { res = sum end = i } } // 当 start 不断向前推进时，可能会出现 start 大于 end 的情况，这个时候需要重置 start 的值 if start &amp;gt; end { start = end } return array[start: end+1] } func max(a,b int) int { if a &amp;lt; b { return b } return a } 上面的这个解法的优化, 这个方法其实也可以改成动态规划的方法，只需要将 sum 替换成 dp[i] 即可。</description></item><item><title>86. 二叉树中两个节点的最近公共祖先</title><link>https://example.com/docs/algs/codingInterviews/86_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/86_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid><description>Description # 给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。
数据范围：树上节点数满足 \($1 \le n \le 10^5$\) , 节点值val满足区间 [0,n) 要求：时间复杂度 \($\Omicron(n)$\) Solutions # Recursive # 具体解释看注释即可。
func lowestCommonAncestor( root *TreeNode , o1 int , o2 int ) int { // write code here if root == nil { return -1 } res := lcaHelper(root, o1, o2) return res.Val } func lcaHelper(root *TreeNode, o1, o2 int) *TreeNode { // 如果已经遍历到空节点或者已经找到其中一个节点，则返回该节点 if root == nil || root.</description></item><item><title>Blind 75 List</title><link>https://example.com/docs/algs/leetcode/Blind-75-list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/Blind-75-list/</guid><description>Blind 75 # Sequence # Two Sum
使用一个 map 记录元素值与元素下标的映射，只需要一次扫描数组，检查 target - value 是否在 map 中，同时将 value 和其下标放到 map 中 。
Best Time to Buy and Sell Stock
使用一个值记录当前扫描到的最小值，然后扫描一次数组，每扫描到一个值，用当前值减去当前得到的最小值，然后得到结果，取结果的最大值。如果当前值小于最小值，则更新最小值为当前值。只需要一次扫描。
Contains Duplicate
简单题，只需要一个 map 就可以了，扫描一次即可。
Product of Array Except Self 创建两个数组left 和 right，数组 left[i] 表示 i 位置前的元素的累积，数组 right[i]表示 i 位置后的元素的累积。然后创建一个数组 res， res[i] = left[i] * right[i]。
Maximum Subarray
Kadane 算法，最优子结构性质，当前位置的和取决于前一个位置的子数组和以及当前元素。
def max_subarray(arr): max_sum_so_far, sum_ending_here = arr[0], arr[0] for e in range(arr[1:]): sum_ending_here = max(e, sum_ending_here + e) max_sum_so_far = max(max_sum_so_far, sum_ending_here) return max_sum_so_far 如果数组中有负数，并且允许返回长度为 0 的子数列，则该问题可以改为：</description></item><item><title>Top Interview Questions</title><link>https://example.com/docs/algs/leetcode/Top-Leetcode-Interview-Questions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/Top-Leetcode-Interview-Questions/</guid><description>Two Sum 简单题，可跳过。
Add Two Numbers 不难，注意 dummyHead 的使用
Longest Substring Without Repeating Character 滑动窗口，不难。
Median of Two Sorted Arrays TODO 难题， 暂时跳过
Longest Palindromic Substring 不难
Reverse Integer NOTE 注意这里对溢出的处理技巧，以及对负数的处理
String to Integer(atoi) 不难，只是繁琐
Regular Expression Matching TODO 暂时跳过
Container With Most Water 不难，但是要注意一题多解
Roman to Integer 不难
Longest Common Prefix 不难
3Sum TODO 注意如何做优化，这里的优化技巧很值得学习学习
Letter Combinations of a Phone Number 简单题，不难
Remove Nth Node From End of List 不难</description></item><item><title>排序算法笔记</title><link>https://example.com/docs/algs/basic/msort/notes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/basic/msort/notes/</guid><description>归并排序 # 归并排序才用了分治法。 从下图可以看到这棵树很像一颗完全二叉树，它的树高为 \($\log_2^n$\) ,每次合并操作的平均复杂度是 \($\Omega(n)$\) ， 所以总的时间复杂度是 \($n\log_2^n$\) 。最好、最坏和平均复杂度均一致。 动图演示如下： 归并排序分为自顶向下的排序和自底向上的排序。自顶向下的排序先把元素不断的二分，直到子数组的元素个数为一个，然后再将两个有序的序列合并成一个新的有序序列，两个新的有序序列又可以合并成另一个新的有序序列，以此类推，直到合并成一个有序的数组。一般自顶向下方法可以通过递归来做。自底向上的想是先把数组中一个一个归并成两两有序的序列，两两有序的序列再归并成四有序序列，两个四有序序列再归并成八有序序列，直到归并的长度大于整个数组的长度。需要注意的是，数组按照归并长度划分，最后一个子数组可能不满足长度要求，这个情况需要特殊处理。一般自底向上归并可以用循环来实现。
希尔排序 # 希尔排序也叫缩小增量排序， 是简单插入排序的改进版。希尔排序是基于插入排序的以下两点性质做出改进的：
插入排序在对几乎已经排好序的数据进行操作时，效率很高，可以打到线性排序的效率。 插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。 希尔排序的基本思想是：把整个待排序序列分成若干个子序列分别进行插入排序，等数组基本有序之后，再对全体数据进行直接插入排序。
需要注意的是，希尔排序要的不是让子数组完全有序，而是只需要部分有序即可。
快速排序 # 快排采用分治法，基本思想是： 通过一趟排序将要排序的序列分成两部分，其中一部分的所有数据都比另一部分要小，然后再通过此方法对数据的左右俩部分分别进行快速排序。
快排的性能对数据的有序性很敏感，数据越有序，快排的性能越差。对于一个顺序数组进行快排，性能会达到 \($\Omicron(n)^2$\) ，所以尽量在进行快排之前将数组打乱。
快排的平均期望时间是 \($\Omicron(n\log n)$\) ， 且 \($\Omicron(n\log n)$\) 中隐含的常数因子很小，比复杂度稳定于 \($\Omicron(n\log n)$\) 的归并排序要小很多。所以，对大多数顺序性较弱的随机数组而言，快排总是优于归并排序。
堆排序 # 堆是具有如下性质的一棵完全二叉树：每个节点的值都大于等于其左右子节点的值，称为大顶堆；每个节点的值都小于等于其左右子节点的值，称为小顶堆。因为堆是一棵完全二叉树，所以也可以用数组来存储。假设小标从 0 开始，则其左子节点位置为 2i+1, 右子节点为 2i + 2, 父节点为 （i-1)/2。</description></item><item><title>等概率返回数组中 k 个元素</title><link>https://example.com/docs/algs/others/2.-%E7%AD%89%E6%A6%82%E7%8E%87%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E4%B8%AD-k-%E4%B8%AA%E5%85%83%E7%B4%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/others/2.-%E7%AD%89%E6%A6%82%E7%8E%87%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E4%B8%AD-k-%E4%B8%AA%E5%85%83%E7%B4%A0/</guid><description>题目描述 # 给你一个输入数据流，数据内容为一系列的信号。 设计一个方法，能在流的终止信号到达时，返回数据流内的随机k个信号结果。 要求：数据流内每个信号被选中的概率均等。数据流内信号个数不足k个时，全部返回。
Solutions # 这个题之前在考研的时候见过，核心思想是：维持一个大小为 k 的数组，然后将输入的前 k 个元素存入到数组中的，对于后面的每个元素，使用随机数产生一个[0,k-1]之内的数，然后使用这个数作为下标，替换掉数组中对应位置的数。最后返回数组中的这 k 个数为止。</description></item><item><title/><link>https://example.com/docs/algs/leetcode/14-patterns-to-ace-any-coding-interview-questions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/14-patterns-to-ace-any-coding-interview-questions/</guid><description>关于算法笔试的常见的十四中模式。
1. 滑动窗口 # 特征 # 问题输入是线性的数据结构 目的是找出最长/短子字符串、子数组或者指定期望值 2. 双指针 # 特征 # 对有序序列或者链表进行操作，目的是找到满足特定条件的一串元素 目标是一对元素或者三个元素，甚至是一个子数组 3. 快慢指针 # 特征 # 问题是处理链表或者数组中的循环 当你需要知道某个元素在整个链表中的位置 4. 区间合并 # 区间合并的几种情况： 。
特征 # 对互斥区间生成一个链表 出现关键词“overlaping intervals” 5. 循环排序(cyclic sort) # 6. 链表就地翻转 # 7. 树的深度优先遍历 # 8. 树的广度优先遍历 # 9. 双堆 # 10. 子集 # 11. 改动的二分搜索 # 12. Top K 个元素 # 一般可以用最大/小堆来解决
13. K 路合并 # 可以使用最大/小堆来实现
14. 拓扑排序 # Refs # 14 Patterns to Ace Any Coding Interview Questions Blind 75 # Sequence # Two Sum</description></item><item><title/><link>https://example.com/docs/algs/leetcode/692_top_k_frequent_words/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/692_top_k_frequent_words/</guid><description>Description # Given an array of strings words and an integer k, return the k most frequent strings.
Return the answer sorted by the frequency from highest to lowest. Sort the words with the same frequency by their lexicographical order.
Solutions # Hash Table &amp;amp; Sort # 首先还是创建一个 dict 统计一下各个单词出现的次数， 然后用单词以及该单词出现的次数组成 pair 对，把这些 pair 对组成数组中，然后根据每个单词的出现频率对这个数组进行排序，如果单词频率相同，则根据单词的字母顺序进行排序。最后放回前 k 个即可。
func topKFrequent(words []string, k int) []string { dict := make(map[string]int) for _, word := range words { dict[word]++ } type Pair struct { str string cnt int } var pairs []Pair for word, cnt := range dict { pairs = append(pairs, Pair{word, cnt}) } sort.</description></item></channel></rss>