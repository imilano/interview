<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Interview</title><link>https://example.com/</link><description>Recent content in Introduction on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/index.xml" rel="self" type="application/rss+xml"/><item><title>11. 旋转数组的最小数字</title><link>https://example.com/docs/algs/codingInterviews/11_%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/11_%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</guid><description>Descriptioin # 有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。
数据范围：$1 \le n \le 10000$，数组中任意元素的值: $0 \le val \le 10000$。 要求：空间复杂度：$\Omicron(1)$ ，时间复杂度：$\Omicron(\log n)$
Solutions # Binary Search # 二分查找，使用两个指针 left 和 right 分别指向数组的待查找序列的左侧和右侧，则：
如果中间元素比右侧元素小，那么向左查找，即 right = mid 如果中间元素比右侧元素大，那么向右查找， 即 left = mid + 1 如果中间元素等于右侧元素，那么最小元素即可能在左边，也可能在右边，则可以搜索右边界 最后返回 left 指向的元素即可。 func minNumberInRotateArray( nums []int ) int { // write code here var res int size := len(nums) if size == 0 { return res } left, right := 0, size -1 for left &amp;lt; right { mid := (left+right)/2 if nums[mid] &amp;gt; nums[right] { left = mid + 1 } else if nums[mid] &amp;lt; nums[right] { right = mid } else if nums[mid] == nums[right] { right = right -1 } } return nums[left] }</description></item><item><title>21. Merge Two Sorted List</title><link>https://example.com/docs/algs/leetcode/21_merge_two_sorted_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/21_merge_two_sorted_list/</guid><description>Description # You are given the heads of two sorted linked lists list1 and list2.
Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.
Return the head of the merged linked list.
Solutions # Merge Sort # func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode { res := new(ListNode) node := res dummyHead1, dummyHead2 := list1, list2 for dummyHead1 !</description></item><item><title>22. Generate Parentheses</title><link>https://example.com/docs/algs/leetcode/22_generate_parentheses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/22_generate_parentheses/</guid><description>Description # Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
Solutions # Recursive # 参见： https://leetcode-cn.com/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/
使用两个变量 left 和 right 来表示「左括号使用了集合」和「右括号使用了几个」，通过分析可以得到以下结论： - 只有当left 和 right 都比 n 小的时候，才产生分支。 - 产生左分支的时候，只看当前还有左括号可用 - 产生右分支的时候，还受到左括号数量的限制，left 要大于 right 的时候，才可以产生分支。否则就是无效分支，可以直接返回。 - 在左边和右边的括号数都等于 n 的时候结算。
func generateParenthesis(n int) []string { var res []string if n == 0 { return res } generateParenthesisHelper(n, 0,0,&amp;#34;&amp;#34;, &amp;amp;res) return res } func generateParenthesisHelper(n, left, right int, cur string, res *[]string) { if left == n &amp;amp;&amp;amp; right == n { *res = append(*res, cur) return } // 剪枝 if left &amp;lt; right { return } if left &amp;lt; n { generateParenthesisHelper(n, left+1, right, cur + &amp;#34;(&amp;#34;, res) } if right &amp;lt; n { generateParenthesisHelper(n, left, right+1, cur + &amp;#34;)&amp;#34;, res) } }</description></item><item><title>23. Merge K Sorted List</title><link>https://example.com/docs/algs/leetcode/23_merge_k_sorted_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/23_merge_k_sorted_list/</guid><description>Description # You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.
Merge all the linked-lists into one sorted linked-list and return it.
Solutions # Min Heap # 很简单的想法，使用最小堆即可。
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeKLists(lists []*ListNode) *ListNode { return mergeKListsSolution1(lists) } // 使用最小堆，将所有的节点数据都插入到最小堆中，然后再把所有元素从最小堆中弹出 func mergeKListsSolution1(lists []*ListNode) *ListNode { var minHeap MinHeapArr heap.</description></item><item><title>26. remove duplicated from sorted array</title><link>https://example.com/docs/algs/leetcode/26_remove_duplicates_from_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/26_remove_duplicates_from_sorted_array/</guid><description>Description # Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.
Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result.</description></item><item><title>28. Implement strStr</title><link>https://example.com/docs/algs/leetcode/28_implement_strStr/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/28_implement_strStr/</guid><description>Description # Implement strStr().
Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Solutions # 太简单了在，直接看代码即可。
func strStr(haystack string, needle string) int { var pos int size := len(haystack) targetSize := len(needle) if size == 0 || targetSize == 0 { return pos } var start int pos = -1 for start &amp;lt; size { if haystack[start] !</description></item><item><title>28. 对称的二叉树</title><link>https://example.com/docs/algs/codingInterviews/28_%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/28_%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>Description # 给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）
Solutions # Recursive # func isSymmetrical( pRoot *TreeNode ) bool { // write code here if pRoot == nil { return true } return isSameTree(pRoot.Left, pRoot.Right) } func isSameTree(root1, root2 *TreeNode) bool { if root1 == nil &amp;amp;&amp;amp; root2 == nil { return true } if root1 == nil || root2 == nil { return false } if root1.</description></item><item><title>29. Divide Two Integers</title><link>https://example.com/docs/algs/leetcode/29_divide_two_integers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/29_divide_two_integers/</guid><description>Description # Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.
The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.
Return the quotient after dividing dividend by divisor.
Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1].</description></item><item><title>30. 包含 min 函数的栈</title><link>https://example.com/docs/algs/codingInterviews/30_%E5%8C%85%E5%90%AB-min-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/30_%E5%8C%85%E5%90%AB-min-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</guid><description>Description # 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数，输入操作时保证 pop、top 和 min 函数操作时，栈中一定有元素。
此栈包含的方法有： push(value):将value压入栈中 pop():弹出栈顶元素 top():获取栈顶元素 min():获取栈中最小元素
数据范围：操作数量满足 $0 \le n \le 300$ ，输入的元素满足 $|val| \le 10000$ 进阶：栈的各个操作的时间复杂度是 $\Omicron(1)$ ，空间复杂度是 $\Omicron(n)$。
Solutions # Stack # 使用两个栈，一个栈stack1用于正常压入和弹出，另一个栈stack2用于实现单调栈。当压入一个元素时，如果当前元素比 stack2 的栈顶元素还要大，则将当前元素压入 stack1 的同时，还将当前元素压入 stack2，如果当前元素不比 stack2 的栈顶元素要大，则将 stack2 的栈顶元素重复入栈。当弹出元素时，将 stack1 和 stack2 的栈顶元素同步弹出。当获取最小值时，只需要取出 stack2 的栈顶元素即可。
// 用于实现正常的 push 与 pop 操作 var stack1 []int // 用于存储最小值 var stack2 []int func Push(node int) { // write code here stack1 = append(stack1, node) size := len(stack2) if size == 0 || stack2[size-1] &amp;gt; node { stack2 = append(stack2, node) } else { stack2 = append(stack2, stack2[size-1]) } } func Pop() { // write code here size := len(stack1) stack1 = stack1[:size-1] stack2 = stack2[:size-1] } func Top() int { // write code here size := len(stack1) return stack1[size-1] } func Min() int { // write code here size := len(stack2) return stack2[size-1] }</description></item><item><title>31. 栈的压入弹出序列</title><link>https://example.com/docs/algs/codingInterviews/31_%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/31_%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</guid><description>Description # 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。
Solutions # 栈模拟 # 新建一个栈来模拟出栈序列。使用一个指针 inPos 指向当前入栈序列的单签入栈元素，使用另一个指针 outPos 指向出栈序列当前应该出栈的元素，然后开始模拟出入栈。
首先，如果当前栈顶元素和出栈序列匹配，则出栈栈顶元素，并且将 outPos 右移，直到二者不匹配或者栈为空 将 inPos 指针指向的入栈序列的元素入栈，然后将 inPos 右移。 不断循环上述过程，直到入栈序列中的所有元素都入栈。 最后判断是否出栈序列中的所有元素都已经匹配完成即可。 func IsPopOrder( pushV []int , popV []int ) bool { // write code here size := len(pushV) if size == 0 { return true } var stack []int stack = append(stack, pushV[0]) inPos, outPos := 1, 0 // 为什么这里的循环用的是 &amp;lt;= ，而不是 &amp;lt; ？ // 因为有可能我们一直从入栈序列中入栈的操作，直到所有元素都已经入栈。如果只使用 &amp;lt; 符号的话， // 我们就无法判断出栈序列是否和栈顶元素匹配（当然你也可以在 for 循环之后再加上这一步，只不过加 // 上这个=号之后可以少写一点代码）.</description></item><item><title>33. Search in Rotated Sorted Array</title><link>https://example.com/docs/algs/leetcode/33_search_in_rotated_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/33_search_in_rotated_array/</guid><description>Description # There is an integer array nums sorted in ascending order (with distinct values).
Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], &amp;hellip;, nums[n-1], nums[0], nums[1], &amp;hellip;, nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].
Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.</description></item><item><title>34. Find First and Last Position of Element in Sorted Array</title><link>https://example.com/docs/algs/leetcode/34_find_first_and_last_position_of_element_in_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/34_find_first_and_last_position_of_element_in_sorted_array/</guid><description>Description # Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.
If target is not found in the array, return [-1, -1].
You must write an algorithm with O(log n) runtime complexity.
Solutions # Binary Search # 二分查找再加上中间扩散，很容易想出来。
func searchRange(nums []int, target int) []int { res := []int{-1, -1} size := len(nums) if size == 0 { return res } left, right := 0, size -1 for left &amp;lt;= right { mid := (left+right)/2 if nums[mid] == target { l,r := mid, mid res[0] = l res[1] = r for l &amp;gt;= 0 &amp;amp;&amp;amp; nums[l] == target { res[0] = l l-- } for r &amp;lt; size &amp;amp;&amp;amp; nums[r] == target { res[1] = r r++ } break } else if nums[mid] &amp;gt; target { right = mid -1 } else if nums[mid] &amp;lt; target { left = mid + 1 } } return res }</description></item><item><title>37. 序列化二叉树</title><link>https://example.com/docs/algs/codingInterviews/37_%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/37_%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>Description # 请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树。
二叉树的序列化(Serialize)是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树等遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#）
二叉树的反序列化(Deserialize)是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。
Solutions # PreOrder Traversal # 采用先序遍历的方式进行序列化，同样采用先序遍历的方式进行反序列化。
var emptyNode string = &amp;#34;#&amp;#34; var seperator string = &amp;#34; &amp;#34; func Serialize( root *TreeNode ) string { // write code here if root == nil { return &amp;#34;&amp;#34; } var res []string _serialize(root, &amp;amp;res) return strings.Join(res, seperator) } func _serialize(root *TreeNode, res *[]string) { if root !</description></item><item><title>38. 字符串的排列</title><link>https://example.com/docs/algs/codingInterviews/38_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/38_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</guid><description>Description # 输入一个长度为 n 字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组。
例如输入字符串ABC,则输出由字符A,B,C所能排列出来的所有字符串ABC,ACB,BAC,BCA,CBA和CAB。
Solutions # 使用全排列的思想来做。
func Permutation( str string ) []string { // write code here var res []string size := len(str) if size == 0 { return res } dict := make(map[string]bool) permutate([]rune(str), 0, size, &amp;amp;dict) for key, _ := range dict { res = append(res, key) } return res } func permutate(str []rune, start int, size int, dict *map[string]bool) { if start == size { s := string(str) if _, ok := (*dict)[s]; !</description></item><item><title>4. 二维数组中的查找</title><link>https://example.com/docs/algs/codingInterviews/4_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/4_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</guid><description>Description # 在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
数据范围：矩阵的长宽满足 $0 \le n$,$m \le 500$ ， 矩阵中的值满足 $0 \le val \le 10^9$。
进阶：空间复杂度 O(1)O(1) ，时间复杂度 O(n+m)O(n+m)
Solutions # 从左下角开始进行遍历，因为数组维持了从左到右递增，从上到下递增的性质，那么如果当前元素比 target 要大， target 一定位于当前元素的右边；如果当前元素比 target 要小，那么 target 一定位于当前元素的上侧。
func Find( target int , array [][]int ) bool { // write code here var res bool m, n := len(array), len(array[0]) x, y := m-1, 0 for { if x &amp;lt; 0 || y &amp;gt;= n { break } if array[x][y] == target { res = true break } if target &amp;gt; array[x][y] { y++ } // 这里要加上一个 y &amp;lt; n, 因为上一个 if 对 y 进行了自增，导致这里的 y 不一定合法 if y &amp;lt; n &amp;amp;&amp;amp; target &amp;lt; array[x][y] { x-- } } return res }</description></item><item><title>53. 数字在升序数组中出现的次数</title><link>https://example.com/docs/algs/codingInterviews/53_%E6%95%B0%E5%AD%97%E5%9C%A8%E5%8D%87%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/53_%E6%95%B0%E5%AD%97%E5%9C%A8%E5%8D%87%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</guid><description>Description # 给定一个长度为 n 的非降序数组和一个非负数整数 k ，要求统计 k 在数组中出现的次数
数据范围：$0 \le n \le 1000 $, $0 \le k \le 100$ ，数组中每个元素的值满足 $0 \le val \le 100$. 要求：空间复杂度 $\Omicron(1)$，时间复杂度 $\Omicron(\log n)$
Solutions # Binary Search # func GetNumberOfK( data []int , k int ) int { // write code here var res int size := len(data) if size &amp;lt; 1 { return res } left, right := 0, size - 1 for left &amp;lt;= right { mid := (left +right)/2 if data[mid] &amp;gt; k { right = mid - 1 } else if data[mid] &amp;lt; k { left = mid + 1 } else if data[mid] == k { l,r := mid, mid for l &amp;gt;= 0 &amp;amp;&amp;amp; data[l] == k { l-- } for r &amp;lt; size &amp;amp;&amp;amp; data[r] == k { r++ } res = r - l - 1 break } } return res }</description></item><item><title>59. 滑动窗口的最大值</title><link>https://example.com/docs/algs/codingInterviews/59_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/59_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</guid><description>Description # 给定一个长度为 n 的数组 nums 和滑动窗口的大小 size ，找出所有滑动窗口里数值的最大值。
例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。
Solutions # Dequeue # 使用一个单调递减的单调队列来做。维持一个最大长度为 size 的单调队列，每当遍历到当前元素 i，如果当前元素 nums[i] 比队列尾部元素要大，则不断将队列尾部元素出队，直到队列为空或者当前元素 nums[i] 比队尾元素要小，然后将当前元素入队。这样的话，队列中要么维持着一个最大值，要么顶多维持着 size 个相对递减的连续值。然后检查队首元素是否过期，如果过期，则将队首元素出队，因为我们每次顶多入队一个，所以每次遍历也顶多只会有一个元素过期。最后检查当前窗口长度是否达到 size，如果达到了，则将队列首部元素入队即可。
// 可以使用单调递减的单调队列来实现 func maxInWindows( num []int , size int ) []int { // write code here var res []int n := len(num) if size &amp;lt; 1 || n &amp;lt; 1 { return res } var queue []int for i := 0; i &amp;lt; n; i++ { // 如果当前遍历到的元素比队尾元素要大，则不断将队尾元素出队 curLen := len(queue) for curLen &amp;gt; 0 &amp;amp;&amp;amp; num[i] &amp;gt; num[queue[curLen-1]] { curLen-- queue = queue[:curLen] } queue = append(queue, i) // 如果当前队首元素滑出左边界，则将其删除 if queue[0] + size &amp;lt;= i { queue = queue[1:] } // 如果当前已经构成了一个有效的滑动窗口，则将当前最大值存入结果 if size &amp;lt;= i+1 { res = append(res, num[queue[0]]) } } return res }</description></item><item><title>68. 二叉搜索树的最近公共祖先</title><link>https://example.com/docs/algs/codingInterviews/68_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/68_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid><description>Description # 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
Solutions # Recursive # 如果当前节点的值比要查找的值的最小值还要小，说明应该往当前节点的右节点进行查找；如果当前节点的值比要查找的值的最大值还要大，说明应该往当前节点的左子树进行查找。否则说明当前节点处于要查找的值之间，那么当前节点就是我们要查找的最近公共祖先。
func lowestCommonAncestor( root *TreeNode , p int , q int ) int { // write code here if root == nil { return -1 } // 保持 p 比 q 要小 if p &amp;gt; q { p,q = q, p } res := lcaHelper(root, p, q) return res.</description></item><item><title>73. 翻转单词序列</title><link>https://example.com/docs/algs/codingInterviews/73_%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/73_%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97/</guid><description>Description # 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“nowcoder. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a nowcoder.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？
Solutions # 先翻转整个句子，然后再针对每个空格分割的单词单独翻转。
func ReverseSentence( str string ) string { // write code here size := len(str) if size &amp;lt;= 1 { return str } runes := []rune(str) size = len(runes) // 先翻转整个字符串 for left,right := 0, size-1; left &amp;lt; right; left,right = left+1, right-1 { runes[left],runes[right] = runes[right], runes[left] } // 再翻转这个字符串里的每个单词 var left, right int for right &amp;lt;= size { for right &amp;lt; size &amp;amp;&amp;amp; runes[right] !</description></item><item><title>78. 把二叉树打印成多行</title><link>https://example.com/docs/algs/codingInterviews/78_%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/78_%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/</guid><description>Description # 给定一个节点数为 n 二叉树，要求从上到下按层打印二叉树的 val 值，同一层结点从左至右输出，每一层输出一行，将输出的结果存放到一个二维数组中返回。
Solutions # Level Order Traversal # 简单题，只需要进行一次层次遍历即可。
func Print( pRoot *TreeNode ) [][]int { // write code here var res [][]int if pRoot == nil { return res } var queue []*TreeNode queue = append(queue, pRoot) for len(queue) != 0 { size := len(queue) var level []int for i := 0; i &amp;lt; size; i++ { node := queue[i] level = append(level, node.</description></item><item><title>84. 二叉树中和为某一值的路径 III</title><link>https://example.com/docs/algs/codingInterviews/84_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84III/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/84_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84III/</guid><description>Description # 给定一个二叉树root和一个整数值 sum ，求该树有多少路径的的节点值之和等于 sum 。 1.该题路径定义不需要从根节点开始，也不需要在叶子节点结束，但是一定是从父亲节点往下到孩子节点 2.总节点数目为n 3.保证最后返回的路径个数在整形范围内(即路径个数小于$2^{31}$-1)
Solutions # 注意，这里的路径不一定需要从根节点开始，也不一定需要在叶节点结束。
Recursice # 核心思想就是，每个节点都可能是一条路径的起始节点，所以每个节点都需要作为根节点来遍历一次。
var res int func FindPath( root *TreeNode , sum int ) int { // write code here if root == nil { return res } findPathHelper(root, sum) // 每个节点都需要作为根节点来进行一次查找 FindPath(root.Left, sum) FindPath(root.Right, sum) return res } func findPathHelper(root *TreeNode, sum int) { if root == nil { return } // 注意这里的小技巧 if sum == root.</description></item><item><title>86. 二叉树中两个节点的最近公共祖先</title><link>https://example.com/docs/algs/codingInterviews/86_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/86_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid><description>Description # 给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。
数据范围：树上节点数满足$1 \le n \le 10^5$, 节点值val满足区间 [0,n) 要求：时间复杂度 $\Omicron(n)$
Solutions # Recursive # 具体解释看注释即可。
func lowestCommonAncestor( root *TreeNode , o1 int , o2 int ) int { // write code here if root == nil { return -1 } res := lcaHelper(root, o1, o2) return res.Val } func lcaHelper(root *TreeNode, o1, o2 int) *TreeNode { // 如果已经遍历到空节点或者已经找到其中一个节点，则返回该节点 if root == nil || root.</description></item><item><title>9. 双栈实现队列</title><link>https://example.com/docs/algs/codingInterviews/9_%E5%8F%8C%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/codingInterviews/9_%E5%8F%8C%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</guid><description>Description # 用两个栈来实现一个队列，使用n个元素来完成 n 次在队列尾部插入整数(push)和n次在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。
数据范围： $n \le 1000$ 要求：存储n个元素的空间复杂度为 $\Omicron(n)$ ，插入与删除的时间复杂度都是 $\Omicron(1)$
Solutions # 使用两个队列，队列1专用于push，队列用专用于pop 和 peek。push 时，入队 stack1； pop 时，如果 stack2 不为空，则弹出 stack2 栈顶即可，若 stack2 为空，则将 stack1 的所有元素压入 stack2， 然后将 stack2 的栈顶元素弹出。
type MyQueue struct { stack1 []int stack2 []int } func Constructor() MyQueue { return MyQueue{ stack1: make([]int, 0), stack2: make([]int, 0), } } func (this *MyQueue) Push(x int) { this.</description></item></channel></rss>