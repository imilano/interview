<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Binary Search Tree on Interview</title><link>https://example.com/tags/Binary-Search-Tree/</link><description>Recent content in Binary Search Tree on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/Binary-Search-Tree/index.xml" rel="self" type="application/rss+xml"/><item><title>0098. Validate Bianry Search Tree</title><link>https://example.com/docs/algs/leetcode/98_validate_binary_search_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/98_validate_binary_search_tree/</guid><description>Description # Given the root of a binary tree, determine if it is a valid binary search tree (BST).
A valid BST is defined as follows:
The left subtree of a node contains only nodes with keys less than the node&amp;rsquo;s key. The right subtree of a node contains only nodes with keys greater than the node&amp;rsquo;s key. Both the left and right subtrees must also be binary search trees.</description></item><item><title>0230. Kth Smallest Element in a BST</title><link>https://example.com/docs/algs/leetcode/230_kth_smallest_element_in_a_bst/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/230_kth_smallest_element_in_a_bst/</guid><description>Description # Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.
Solutions # 这个题很简单，只需要使用中序遍历即可。一下分别给出递归和迭代的解法。
Recursive # type TreeNode struct { Val int Left *TreeNode Right *TreeNode } func kthSmallest(root *TreeNode, k int) int { if root == nil { return math.MinInt } return helper(root, &amp;amp;k) } func helper(root *TreeNode, cur *int) int { if root == nil { return math.</description></item><item><title>0235. Lowest Common Ancestor of Binary Search Tree</title><link>https://example.com/docs/algs/leetcode/235_lowest_common_ancestor_of_a_binary_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/235_lowest_common_ancestor_of_a_binary_tree/</guid><description>Description # Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”
Solutions # Recursive # 这题很简单，因为 BST 本身就具备有序的性质，所以我们只需要抓住这个性质来进行遍历即可。首先我们假设 p 比 q 要小，那么对于递归遍历到的每个节点 root， 如果 root 的值大于最大 q 的值，那么说明最小公共节点一并比 root 要小，我们需要往root 的左子树进行查找；如果 root 的值小于最小值 p 的值，那么说明最小公共祖先一定比 p 要大，那么我们需要往 p 的右节点进行查找；否则，说明 root 的值刚好结余 p 和 q 之间，此时 root 就是我们所查找的最小公共组节点，返回 root 即可。</description></item></channel></rss>