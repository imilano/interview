<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Two Pointer on Interview</title><link>https://example.com/tags/Two-Pointer/</link><description>Recent content in Two Pointer on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/Two-Pointer/index.xml" rel="self" type="application/rss+xml"/><item><title>0001. Two Sum</title><link>https://example.com/docs/algs/leetcode/01_two_sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/01_two_sum/</guid><description>Description # Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.
Solutions # Hash Table # 这里因为答案唯一，那么也就意味着数组里的元素是唯一的，所以可以使用 map 来做，只需要一次遍历即可，具体看下面代码就好。
func twoSum(nums []int, target int) []int { dict := make(map[int]int) for idx, num := range nums{ t := target - num if exist(dict, t) { return []int{idx, dict[t]} } dict[num] = idx } return nil } func exist(dict map[int]int, target int) bool { if _, ok := dict[target]; ok { return true } return false } Sort &amp;amp;&amp;amp; Two Pointer # 这里也可以使用排序来做，根据值进行排序，但是需要保存该值对应的下标。排好序之后可以使用双指针，一个 left 指向开头，一个 right 指向结尾，计算二者和，如果小于 target，则 left++，否则 right++，直到二者之和等于 target 即可。思路大概就这样，代码就不写了。</description></item><item><title>0005. Longest Palindrome Substring</title><link>https://example.com/docs/algs/leetcode/05_longest_palindrome_substring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/05_longest_palindrome_substring/</guid><description>Description # Given a string s, return the longest palindromic substring in s.
Solutions # 中心扩散 # 题主首先想到的是中心扩散方法。核心思想就是遍历以此字符串，然后对于遍历到的每个位置，找出以这个位置为中心能找到的最长回文串。需要注意的是，一个回文串可能是偶数长度，也可能是奇数长度。如果是奇数长度，那么就需要以 i 为中心来对左右进行扩散；而如果是偶数长度，那么就需要以 i 和 i-1 为中心来进行扩散。
func longestPalindrome(s string) string { size := len(s) if size &amp;lt;= 1 { return s } var res string for i := 0; i &amp;lt; size; i++ { // 最长回文串可能会出现在以 i 为中心对称的子串上，也可能出现在以 i 和 i - 1 为中心的子串上 r1 := longestPalindromeHelper(s, i, i, size) r2 := longestPalindromeHelper(s, i-1, i, size) res = getMaxString(r1, r2, res) } return res } func longestPalindromeHelper(s string, left, right, size int) string { var res string for left &amp;gt;= 0 &amp;amp;&amp;amp; right &amp;lt; size { if s[left] == s[right] { // res 放在这里更新，这样的话，就不用写判断 left 和 right 是否有效的逻辑了 res = s[left : right+1] left-- right++ } else { break } } return res } func getMaxString(a, b, s string) string { if len(a) &amp;lt; len(b) { if len(b) &amp;lt; len(s) { return s } else { return b } } else { if len(a) &amp;lt; len(s) { return s } else { return a } } } Longest Common Stirng # 将输入字符串逆转之后，原问题就可以转换为求最长公共子串(leetcode 第 718 题)的问题。</description></item><item><title>0011. Container with Most Water</title><link>https://example.com/docs/algs/leetcode/11_container_with_most_water/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/11_container_with_most_water/</guid><description>Description # You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).
Find two lines that together with the x-axis form a container, such that the container contains the most water.
Return the maximum amount of water a container can store.
Notice that you may not slant the container.</description></item><item><title>0015. 3 Sum</title><link>https://example.com/docs/algs/leetcode/15_3sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/15_3sum/</guid><description>Description # Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
Notice that the solution set must not contain duplicate triplets.
Solutions # Two Pointer # 注意这里其实并没有说不能更改原数组，那么我们可以对原数组先排个序，然后遍历数组，每次遍历到数 x，从 x 的后面的子数组找出两个和为-x 的数即可。 这里可以注意到右以下几个优化技巧：
遍历的时候只需要遍历到倒数第三个即可。 由于限制了不能重复，那么遍历时候对于重复出现的数字需要跳过，策略是，从第二个数字开始，如果这个数字和前一个数字相同，则跳过这个数字，继续遍历下一个。 如果当前固定的数 x 是个正数，那么也可以直接跳过这个数，因为既然数组已经排好序了，那么后面的数都只会比 x 大，他们的和也比 x 大 那么如何在子数组中查找-x 呢，可以在子数组中使用双指针，假设一个下标是 i 另一个是 j，那么如果二者之和大于 target，则 j 前移，否则 i 后移。 i 和 j 移动的过程中需要注意，二者均需要跳过重复数字 func threeSum(nums []int) [][]int { return solution(nums) } func solution(nums []int) [][]int { var res [][]int size := len(nums) if size &amp;lt; 3 { return res } sort.</description></item><item><title>0016. 3Sum Closest</title><link>https://example.com/docs/algs/leetcode/16_3sum_closest/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/16_3sum_closest/</guid><description>Description # Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.
Return the sum of the three integers.
You may assume that each input would have exactly one solution.
Solutions # Two Pointer # 这个解法是题主一开始想到的解法，时间复杂度比较高，提交的结果也不如人意，不过还是可以 AC 的。
func threeSumClosest(nums []int, target int) int { var res int sort.Ints(nums) size, diff := len(nums), math.MaxInt for idx, _ := range nums { left, right := idx + 1, size - 1 for left &amp;lt; right { sum := nums[left] + nums[right] + nums[idx] if sum == target { return target } // 注意这这里要使用绝对差 if abs(target - sum) &amp;lt; diff { diff = abs(target - sum) res = sum } if sum &amp;gt; target { right-- } else { left++ } } } return res } func abs(a int) int { if a &amp;lt; 0 { return -a } return a } 下面是上面的方法优化之后的版本：</description></item><item><title>0018. 4 Sum</title><link>https://example.com/docs/algs/leetcode/18_4sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/18_4sum/</guid><description>Description # Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:
0 &amp;lt;= a, b, c, d &amp;lt; n a, b, c, and d are distinct. nums[a] + nums[b] + nums[c] + nums[d] == target You may return the answer in any order. Solutions # Two Pointers # 这里也没有什么比较好的想法，只好使用跟 3Sum 差不多的解法：还是先将数组排个序，然后使用双指针来进行查找。不过需要注意的是，这里要求a、b、c 和 d都是不同的，那么也就意味着需要进行去重处理。怎么进行去重呢？这里因为要求四个数都不相同，所以去重策略也是相对比较简单的，直接跳过重复元素即可。
func fourSum(nums []int, target int) [][]int { var res [][]int size := len(nums) sort.</description></item><item><title>0026. remove duplicated from sorted array</title><link>https://example.com/docs/algs/leetcode/26_remove_duplicates_from_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/26_remove_duplicates_from_sorted_array/</guid><description>Description # Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.
Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result.</description></item><item><title>0076. Minimum Window Substring</title><link>https://example.com/docs/algs/leetcode/76_minimum_window_substring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/76_minimum_window_substring/</guid><description>Description # Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string &amp;ldquo;&amp;rdquo;.
The testcases will be generated such that the answer is unique.
A substring is a contiguous sequence of characters within the string.
Solutions # Sliding Window # 这里应该很容易可以看出需要使用滑动窗口来做，但是与一般的滑动窗口不同的是，这里的滑动窗口中可以包含一些不在字符串 t 中的字符。另外还需要注意的是，窗口中字符的出现顺序不需要和 t 一致，但是出现次数需要一致。</description></item><item><title>0125. Valid Palindrome</title><link>https://example.com/docs/algs/leetcode/125_valid_palindrome/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/125_valid_palindrome/</guid><description>Description # A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.
Given a string s, return true if it is a palindrome, or false otherwise.
Solutions # Two Pointer # 简单题，去除非数字字母的字符之后直接判断即可。
func isPalindrome(s string) bool { var rs []rune for _, r := range s { // skip none-alphanumeric characters if !</description></item><item><title>0141. Linked List Cycle</title><link>https://example.com/docs/algs/leetcode/141_Linked-List-Cycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/141_Linked-List-Cycle/</guid><description>Description # Given head, the head of a linked list, determine if the linked list has a cycle in it.
There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail&amp;rsquo;s next pointer is connected to. Note that pos is not passed as a parameter.</description></item><item><title>0142. Linked List Cycle II</title><link>https://example.com/docs/algs/leetcode/142_linked_list_cycle_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/142_linked_list_cycle_ii/</guid><description>Description # Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.
There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail&amp;rsquo;s next pointer is connected to (0-indexed). It is -1 if there is no cycle.</description></item><item><title>0160. Intersection of Two Linked Lists</title><link>https://example.com/docs/algs/leetcode/160_intersection_of_two_linked_lists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/160_intersection_of_two_linked_lists/</guid><description>Description # Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.
Solutions # Hash Table # 首先很容易想到哈希表的解法。
func getIntersectionNode(headA, headB *ListNode) *ListNode { if headA == nil || headB == nil { return nil } dict := make(map[*ListNode]bool) dummyA , dummyB := headA, headB for dummyA != nil { dict[dummyA] = true dummyA = dummyA.</description></item><item><title>0167. Two Sum II - Input Array Is Sorted</title><link>https://example.com/docs/algs/leetcode/167_two_sum_ii_input_array_is_sorted/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/167_two_sum_ii_input_array_is_sorted/</guid><description>Description # Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &amp;lt;= index1 &amp;lt; index2 &amp;lt;= numbers.length.
Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.
The tests are generated such that there is exactly one solution.</description></item><item><title>0283. Moving Zeroes</title><link>https://example.com/docs/algs/leetcode/283_moving_zeroes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/283_moving_zeroes/</guid><description>Description # Given an integer array nums, move all 0&amp;rsquo;s to the end of it while maintaining the relative order of the non-zero elements.
Note that you must do this in-place without making a copy of the array.
Solutions # Two Pointer # 简单题，直接上代码：
func moveZeroes(nums []int) { size := len(nums) if size &amp;lt;= 1 { return } left, right := 0, 0 for right &amp;lt; size { if nums[right] !</description></item><item><title>0328. Odd Even Linked List</title><link>https://example.com/docs/algs/leetcode/328_odd_even_linked_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/328_odd_even_linked_list/</guid><description>Description # Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.
The first node is considered odd, and the second node is even, and so on.
Note that the relative order inside both the even and odd groups should remain as it was in the input.
You must solve the problem in O(1) extra space complexity and O(n) time complexity.</description></item><item><title>0424. Longest Repeating Character Replacement</title><link>https://example.com/docs/algs/leetcode/424_longest_repeating_character_replacement/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/424_longest_repeating_character_replacement/</guid><description>Description # You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.
Return the length of the longest substring containing the same letter you can get after performing the above operations.
Solutions # Sliding Window # 这个题题主又不会了，在网上看到可以使用滑动窗口来解。假设没有 k 的限制，也就是说可以替换任意多次，把一个字符串变为只有只有一个字符重复的字符串需要的最少置换次数是多少呢？其实就是扫描一遍字符串，记录出现次数最多的字符串的出现个数k，然后用总长度减去 k ，所得值即为最少置换次数。
而如果带上了 k，那么就要满足: 子字符串的长度减去该子字符串中出现次数最多的字符的长度要小于等于 k。具体做法：</description></item><item><title>0485. Max Consecutive Ones</title><link>https://example.com/docs/algs/leetcode/485_max_consecutive_ones/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/485_max_consecutive_ones/</guid><description>Description # Given a binary array nums, return the maximum number of consecutive 1&amp;rsquo;s in the array.
Solutions # Two Pointers # 这个就是一个简单题啦，使用双指针来做就好了,直接看代码就好。
func findMaxConsecutiveOnes(nums []int) int { res, size, left, right := 0, len(nums), 0, 0 for right &amp;lt; size { // right 一直往右走，直到找到第一个非 1 的数才停下来 for right &amp;lt; size &amp;amp;&amp;amp; nums[right] == 1 { right++ res = max(res, right - left) } // 跳过所有非 1 的数，同时更新 left 指向第一个 1 for right &amp;lt; size &amp;amp;&amp;amp; nums[right] !</description></item><item><title>0647. Palindromic Substrings</title><link>https://example.com/docs/algs/leetcode/647_palindromic_substrings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/647_palindromic_substrings/</guid><description>Description # Given a string s, return the number of palindromic substrings in it.
A string is a palindrome when it reads the same backward as forward.
A substring is a contiguous sequence of characters within the string.
Solutions # Two Pointer # 回文串的解法都是相对比较单一的，这里还是沿用老套路：遍历字符串中的每个位置，检查以这个位置为中心，或者以这个位置和前一个位置为中心的字符是否能组成回文串，检查的时候把 res 传到子函数中去，这样就可以更新 res 。
func countSubstrings(s string) int { var res int size := len(s) for i := 0; i &amp;lt; size; i++ { findPalindrome(s, i,i,size,&amp;amp;res) findPalindrome(s,i-1,i,size,&amp;amp;res) } return res } func findPalindrome(s string, left,right,size int, res *int) { for left &amp;gt;= 0 &amp;amp;&amp;amp; right &amp;lt; size { if s[left] !</description></item><item><title>0876. Median of the Linked List</title><link>https://example.com/docs/algs/leetcode/876_median_of_the_linked_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/876_median_of_the_linked_list/</guid><description>Description # Given the head of a singly linked list, return the middle node of the linked list.
If there are two middle nodes, return the second middle node.
Solutions # 使用快慢指针法，最后返回慢指针指向的节点即可。
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func middleNode(head *ListNode) *ListNode { slow, fast := head, head // 注意这里的判断条件 for fast != nil &amp;amp;&amp;amp; fast.</description></item><item><title>1429. First Unique Number</title><link>https://example.com/docs/algs/leetcode/1429_first_unique_number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1429_first_unique_number/</guid><description>Description # You have a queue of integers, you need to retrieve the first unique integer in the queue.
Implement the FirstUnique class:
FirstUnique(int[] nums) Initializes the object with the numbers in the queue. int showFirstUnique() returns the value of the first unique integer of the queue, and returns -1 if there is no such integer. void add(int value) insert value to the queue. Solutions # 可以这么做： 维护一个哈希表，哈希表的 key 为数字，value 为一个Pair， Pair 中存储 key 在数组中的下标以及该数字的出现次数。然后再创建一个 queue， 将所有出现次数为 1 的数字按照在队列中的出现顺序入队。 调用 showFirstUnique 的时候， 从队列中取出元素，检查在哈希表中该元素的出现次数是否为 1，如果不是，则持续出对队，直到找到第一个出现次数为 1 的元素，然后将该元素输出。add 的时候，将该元素在哈希表中的对应次数加 1，并检查队头元素是否为该元素，如果是， 则将该元素出队即可。</description></item><item><title>1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit</title><link>https://example.com/docs/algs/leetcode/1438_longest_continuous_subarray_with_absolute_diff_less_than_or_equal_to_limit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1438_longest_continuous_subarray_with_absolute_diff_less_than_or_equal_to_limit/</guid><description>Description # Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit.
Solutions # TODO</description></item></channel></rss>