<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Two Pointer on Interview</title><link>https://example.com/tags/Two-Pointer/</link><description>Recent content in Two Pointer on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/Two-Pointer/index.xml" rel="self" type="application/rss+xml"/><item><title>0141. Linked List Cycle</title><link>https://example.com/docs/algs/leetcode/141_Linked-List-Cycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/141_Linked-List-Cycle/</guid><description>Description # Given head, the head of a linked list, determine if the linked list has a cycle in it.
There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail&amp;rsquo;s next pointer is connected to. Note that pos is not passed as a parameter.</description></item><item><title>0142. Linked List Cycle II</title><link>https://example.com/docs/algs/leetcode/142_linked_list_cycle_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/142_linked_list_cycle_ii/</guid><description>Description # Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.
There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail&amp;rsquo;s next pointer is connected to (0-indexed).</description></item><item><title>0160. Intersection of Two Linked Lists</title><link>https://example.com/docs/algs/leetcode/160_intersection_of_two_linked_lists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/160_intersection_of_two_linked_lists/</guid><description>Description # Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.
Solutions # Hash Table # 首先很容易想到哈希表的解法。
func getIntersectionNode(headA, headB *ListNode) *ListNode { if headA == nil || headB == nil { return nil } dict := make(map[*ListNode]bool) dummyA , dummyB := headA, headB for dummyA !</description></item><item><title>0328. Odd Even Linked List</title><link>https://example.com/docs/algs/leetcode/328_odd_even_linked_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/328_odd_even_linked_list/</guid><description>Description # Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.
The first node is considered odd, and the second node is even, and so on.
Note that the relative order inside both the even and odd groups should remain as it was in the input.
You must solve the problem in O(1) extra space complexity and O(n) time complexity.</description></item><item><title>0876. Median of the Linked List</title><link>https://example.com/docs/algs/leetcode/876_median_of_the_linked_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/876_median_of_the_linked_list/</guid><description>Description # Given the head of a singly linked list, return the middle node of the linked list.
If there are two middle nodes, return the second middle node.
Solutions # 使用快慢指针法，最后返回慢指针指向的节点即可。
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func middleNode(head *ListNode) *ListNode { slow, fast := head, head // 注意这里的判断条件 for fast !</description></item><item><title>1429. First Unique Number</title><link>https://example.com/docs/algs/leetcode/1429_first_unique_number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1429_first_unique_number/</guid><description>Description # You have a queue of integers, you need to retrieve the first unique integer in the queue.
Implement the FirstUnique class:
- FirstUnique(int[] nums) Initializes the object with the numbers in the queue.
int showFirstUnique() returns the value of the first unique integer of the queue, and returns -1 if there is no such integer. - void add(int value) insert value to the queue. Solutions # 可以这么做： 维护一个哈希表，哈希表的 key 为数字，value 为一个Pair， Pair 中存储 key 在数组中的下标以及该数字的出现次数。然后再创建一个 queue， 将所有出现次数为 1 的数字按照在队列中的出现顺序入队。 调用 showFirstUnique 的时候， 从队列中取出元素，检查在哈希表中该元素的出现次数是否为 1，如果不是，则持续出对队，直到找到第一个出现次数为 1 的元素，然后将该元素输出。add 的时候，将该元素在哈希表中的对应次数加 1，并检查队头元素是否为该元素，如果是， 则将该元素出队即可。</description></item></channel></rss>