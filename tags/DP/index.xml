<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DP on Interview</title><link>https://example.com/tags/DP/</link><description>Recent content in DP on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/DP/index.xml" rel="self" type="application/rss+xml"/><item><title>0091. Decode Ways</title><link>https://example.com/docs/algs/leetcode/91_decode_ways/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/91_decode_ways/</guid><description>Description # A message containing letters from A-Z can be encoded into numbers using the following mapping:
&amp;lsquo;A&amp;rsquo; -&amp;gt; &amp;ldquo;1&amp;rdquo; &amp;lsquo;B&amp;rsquo; -&amp;gt; &amp;ldquo;2&amp;rdquo; &amp;hellip; &amp;lsquo;Z&amp;rsquo; -&amp;gt; &amp;ldquo;26&amp;rdquo; To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, &amp;ldquo;11106&amp;rdquo; can be mapped into:
&amp;ldquo;AAJF&amp;rdquo; with the grouping (1 1 10 6) &amp;ldquo;KJF&amp;rdquo; with the grouping (11 10 6) Note that the grouping (1 11 06) is invalid because &amp;ldquo;06&amp;rdquo; cannot be mapped into &amp;lsquo;F&amp;rsquo; since &amp;ldquo;6&amp;rdquo; is different from &amp;ldquo;06&amp;rdquo;.</description></item><item><title>0120. Triangle</title><link>https://example.com/docs/algs/leetcode/120_triangle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/120_triangle/</guid><description>Description # Given a triangle array, return the minimum path sum from top to bottom.
For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.
Solutions # Brute Force # 题主首先想出了贪心的解法，但是因为”局部最优并不代表全局最优“，所以没能通过，不过还是贴一下代码：
func minimumTotal(triangle [][]int) int { size := len(triangle) arr := make([]int, size+1) var start int for i := 1; i &amp;lt;= size; i++ { if start + 1 &amp;lt; len(triangle[i-1]) &amp;amp;&amp;amp; triangle[i-1][start+1] &amp;lt; triangle[i-1][start] { start = start + 1 } arr[i] = dp[i-1] + triangle[i-1][start] } return arr[size] } 既然上面的贪心不行，那么使用递归来试试呢？于是楼主又写出了下面的解法：</description></item><item><title>0303. Range Sum Query - Immutable</title><link>https://example.com/docs/algs/leetcode/303_range_sum_query_immutable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/303_range_sum_query_immutable/</guid><description>Solutions # Brute Force &amp;amp; Memorial # 本来题主以为这里考的是使用记忆化数组来避免重复计算，结果一提交结果，发现自己还是太天真了&amp;hellip;
type NumArray struct { nums []int dict map[string]int } func Constructor(nums []int) NumArray { return NumArray{nums, make(map[string]int)} } func (this *NumArray) SumRange(left int, right int) int { if left == right { return (*this).nums[left] } if left &amp;gt; right { return 0 } target := string(left) + string(right) if _, ok := (*this).dict[target]; ok { return (*this).dict[target] } res := this.nums[left] + this.</description></item><item><title>0304. Range Sum Query 2D - Immutable</title><link>https://example.com/docs/algs/leetcode/304_range_sum_query_2d_immutable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/304_range_sum_query_2d_immutable/</guid><description>Description # Given a 2D matrix matrix, handle multiple queries of the following type:
Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2). Implement the NumMatrix class:
NumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix. int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).</description></item><item><title>0354. Russian Doll Envelopes</title><link>https://example.com/docs/algs/leetcode/354_russian_doll_envelopes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/354_russian_doll_envelopes/</guid><description>Description # You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.
One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope&amp;rsquo;s width and height.
Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).
Note: You cannot rotate an envelope.</description></item><item><title>0474. Ones and Zeroes</title><link>https://example.com/docs/algs/leetcode/474_ones_and_zeroes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/474_ones_and_zeroes/</guid><description>Description # You are given an array of binary strings strs and two integers m and n.
Return the size of the largest subset of strs such that there are at most m 0&amp;rsquo;s and n 1&amp;rsquo;s in the subset.
A set x is a subset of a set y if all elements of x are also elements of y.
Solutions # 这里很难想到要用动态规划吧。假设 dp[i][j] 表示一个能包含 i 个 0 和 j 个 1 的子集中的字符串个数。则当扫描到字符串str[i]时，统计其中出现0 位 zeros，1 为 ones。则 \(dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones]&amp;#43;1)\) 。</description></item></channel></rss>