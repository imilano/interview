<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Search on Interview</title><link>https://example.com/tags/Search/</link><description>Recent content in Search on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/Search/index.xml" rel="self" type="application/rss+xml"/><item><title>0033. Search in Rotated Sorted Array</title><link>https://example.com/docs/algs/leetcode/33_search_in_rotated_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/33_search_in_rotated_array/</guid><description>Description # There is an integer array nums sorted in ascending order (with distinct values).
Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], &amp;hellip;, nums[n-1], nums[0], nums[1], &amp;hellip;, nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].
Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.</description></item><item><title>0034. Find First and Last Position of Element in Sorted Array</title><link>https://example.com/docs/algs/leetcode/34_find_first_and_last_position_of_element_in_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/34_find_first_and_last_position_of_element_in_sorted_array/</guid><description>Description # Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.
If target is not found in the array, return [-1, -1].
You must write an algorithm with O(log n) runtime complexity.
Solutions # Binary Search # 二分查找再加上中间扩散，很容易想出来。
func searchRange(nums []int, target int) []int { res := []int{-1, -1} size := len(nums) if size == 0 { return res } left, right := 0, size -1 for left &amp;lt;= right { mid := (left+right)/2 if nums[mid] == target { l,r := mid, mid res[0] = l res[1] = r for l &amp;gt;= 0 &amp;amp;&amp;amp; nums[l] == target { res[0] = l l-- } for r &amp;lt; size &amp;amp;&amp;amp; nums[r] == target { res[1] = r r++ } break } else if nums[mid] &amp;gt; target { right = mid -1 } else if nums[mid] &amp;lt; target { left = mid + 1 } } return res } 在最坏情况下，比如数组中所有数字均相同，则时间复杂度会退化为 \( \Omircon(n) \) 。下面是优化之后的解法。</description></item><item><title>0074. Search a 2D Matrix</title><link>https://example.com/docs/algs/leetcode/74_search_a_2d_matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/74_search_a_2d_matrix/</guid><description> Description # Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:
Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.
Solutions # Binary Search # 这题的二分解法真的比较巧妙。这里首先具备了两个特征：每一行从左向右递增，每一列从上到下递增。那么我们可以从第一列最后一个元素开始进行搜索，如果target 比当前元素要小，那么如果target 要存在，就只能在当前行上边，于是row-1；如果target比当前元素要大，那么如果该元素存在的话，智能在当前列右侧，于是col+1。按照以上规则进行遍历即可。
func searchMatrix(matrix [][]int, target int) bool { m, n := len(matrix), len(matrix[0]) row, col := m-1, 0 for row &amp;gt;= 0 &amp;amp;&amp;amp; col &amp;lt; n { if matrix[row][col] == target { return true } if matrix[row][col] &amp;lt; target { col++ } // 上面的 if 语句可能会导致这里出现越界访问，所以要加上 col &amp;lt; n if col &amp;lt; n &amp;amp;&amp;amp; matrix[row][col] &amp;gt; target { row-- } } return false }</description></item><item><title>0162. Find Peak Element</title><link>https://example.com/docs/algs/leetcode/162_find_peak_element/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/162_find_peak_element/</guid><description>Description # A peak element is an element that is strictly greater than its neighbors.
Given an integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.
You may imagine that nums[-1] = nums[n] = -∞.
You must write an algorithm that runs in \( Omicron(\log n) \) time.
Solutions # One Pass Iteration # 这里可以通过一次数组的一次遍历来完成。为了方便，我们可以在头部和尾部分别添加上一个最小值，这样能够减少一些边界值判断。当然，这种方法并不符合题目要求的 \( \Omicron(n\log n) \) 的要求。</description></item><item><title>0240. Search a 2D Matrix II</title><link>https://example.com/docs/algs/leetcode/240_search_a_2d_matrix_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/240_search_a_2d_matrix_ii/</guid><description> Description # Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:
Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom.
Solutions # Binary Search # 这个题使用跟 74 题一样的解法完全可以解决。
这题的二分解法真的比较巧妙。这里首先具备了两个特征：每一行从左向右递增，每一列从上到下递增。那么我们可以从第一列最后一个元素开始进行搜索，如果target 比当前元素要小，那么如果target 要存在，就只能在当前行上边，于是row-1；如果target比当前元素要大，那么如果该元素存在的话，智能在当前列右侧，于是col+1。按照以上规则进行遍历即可。
func searchMatrix(matrix [][]int, target int) bool { m,n := len(matrix), len(matrix[0]) row, col := m - 1, 0 for row &amp;gt;= 0 &amp;amp;&amp;amp; col &amp;lt; n { if matrix[row][col] == target { return true } if matrix[row][col] &amp;lt; target { col++ } if col &amp;lt; n &amp;amp;&amp;amp; matrix[row][col] &amp;gt; target { row-- } } return false }</description></item><item><title>0278. First Bad Version</title><link>https://example.com/docs/algs/leetcode/278_first_bad_version/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/278_first_bad_version/</guid><description>Description # You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.
Suppose you have n versions [1, 2, &amp;hellip;, n] and you want to find out the first bad one, which causes all the following ones to be bad.</description></item><item><title>0528. Random Pick with Weight</title><link>https://example.com/docs/algs/leetcode/528_random_pick_with_weight/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/528_random_pick_with_weight/</guid><description>Description # You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith index.
You need to implement the function pickIndex(), which randomly picks an index in the range [0, w.length - 1] (inclusive) and returns it. The probability of picking an index i is w[i] / sum(w).
For example, if w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.</description></item><item><title>0540. Single Element in a Sorted Array</title><link>https://example.com/docs/algs/leetcode/540_single_element_in_a_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/540_single_element_in_a_sorted_array/</guid><description>Description # You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.
Return the single element that appears only once.
Your solution must run in \(\Omicron(\log n) {{ &amp;lt; /katex &amp;gt;}} time and {{ &amp;lt; katex &amp;gt; \Omicron(1) {{ &amp;lt; /katex &amp;gt; }}} space. ### Bit Manipulation 这个题一眼看到，首先想到的就是使用异或操作，因为异或会导致相同的元素相互抵消为零，所以最后只会剩下哪个只出现一次的元素。 ```go func singleNonDuplicate(nums []int) int { var res int for _, num := range nums { res ^= num } return res } ``` ### Binary Search 这里因为数组有序，并且题目也要求 &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;/katex/katex.</description></item><item><title>1060. Missing Element in Sorted Array</title><link>https://example.com/docs/algs/leetcode/1060_missing_element_in_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1060_missing_element_in_sorted_array/</guid><description>Description # Given an array containing n distinct numbers taken from 0, 1, 2, &amp;hellip;, n, find the one that is missing from the array.
For example, Given nums = [0, 1, 3] return 2.
Note: Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?
Solutions # Math # 这个题还是很简单的，首先需要求出求出 [0,n] 的累和，然后用这个累和减去数组中出现的每个数，最后剩下的数就是结果。
func missingNumber(nums []int) int { size := len(nums) res := (1 + n)*n/2 for _, num := range nums { res -= num } return num } Bit Manipulation # 这个题也可以使用异或来做。既然从 0 到 n 中缺了一个，那么我们就可以使用从 0 到 n 的每个数字来跟数组中的数字进行异或操作，最后的那个数字肯定就是缺的那个数字啦。</description></item><item><title>1095. Find in Mountain Array</title><link>https://example.com/docs/algs/leetcode/1095_find_in_mountain_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1095_find_in_mountain_array/</guid><description>Description # (This problem is an interactive problem.)
You may recall that an array arr is a mountain array if and only if:
arr.length &amp;gt;= 3 There exists some i with 0 &amp;lt; i &amp;lt; arr.length - 1 such that: arr[0] &amp;lt; arr[1] &amp;lt; &amp;hellip; &amp;lt; arr[i - 1] &amp;lt; arr[i] arr[i] &amp;gt; arr[i + 1] &amp;gt; &amp;hellip; &amp;gt; arr[arr.length - 1] Given a mountain array mountainArr, return the minimum index such that mountainArr.</description></item><item><title>1300. Sum of Mutated Array Closest to Target</title><link>https://example.com/docs/algs/leetcode/1300_sum_of_mutated_array_closest_to_target/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1300_sum_of_mutated_array_closest_to_target/</guid><description>Description # Given an integer array arr and a target value target, return the integer value such that when we change all the integers larger than value in the given array to be equal to value, the sum of the array gets as close as possible (in absolute difference) to target.
In case of a tie, return the minimum such integer.
Notice that the answer is not neccesarilly a number from arr.</description></item></channel></rss>