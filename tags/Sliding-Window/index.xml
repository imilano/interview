<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sliding Window on Interview</title><link>https://example.com/tags/Sliding-Window/</link><description>Recent content in Sliding Window on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/Sliding-Window/index.xml" rel="self" type="application/rss+xml"/><item><title>0003. Longest Substring Without Repeating Characters</title><link>https://example.com/docs/algs/leetcode/03_longest_substring_without_repeatng_characters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/03_longest_substring_without_repeatng_characters/</guid><description>Description # Given a string s, find the length of the longest substring without repeating characters.
Solutions # Hash Table # 中间扩散法，时间复杂度会比较高，因为会有很多的重复扫描。核心思想是，遍历一次字符串，然后对于每个遍历到的位置，从中心向两侧进行扫描，扫描时使用一个 map 来记录那些已经出现过的字符；在一侧扫描过程中，如果发现该字符已经出现过，则停止扫描该侧。最后 map 的长度即为以该字符为中心的不重复字符的长度。
// 对于每个位置的字符，从中间向两侧扫描；使用一个 map 记录已经出现过的字符。在一侧扫描过程中，如果该字符已经出现过，则停止扫描该侧。 // 最后 map 的长度即为以该字符为中心的不重复字符的长度 func lengthOfLongestSubstringSolution1(s string) int { // handle empty string var res int if len(s) &amp;lt;= 1 { return len(s) } for i := 0; i &amp;lt; len(s); i++ { res = max(res, helper(s, i)) } return res } func helper(s string, mid int) int { left, right := mid-1, mid+1 dict := make(map[byte]bool) dict[s[mid]] = true for left &amp;gt; 0 { _, ok := dict[s[left]] if ok { break } dict[s[left]] = true left-- } for right &amp;lt; len(s) { _, ok := dict[s[right]] if ok { break } dict[s[right]] = true right++ } return len(dict) } Sliding Window &amp;amp; Hash Table # 很明显也可以使用滑动窗口配合 Hash Table 的方式来解题。首先固定滑动窗口的左边界，然后将滑动窗口的右边界向右滑动，每滑动一个位置，就检查该位置的字符是否有在当前滑动窗口中出现过(也就是说，既要检查该字符是否在 Hash Table 中出现过，还要检查最近一次出现的下标是否位于滑动窗口之内)，如果出现过，则更新滑动串口左边界。另外，每次遍历都需要更新当前滑动窗口的最大长度。</description></item><item><title>0076. Minimum Window Substring</title><link>https://example.com/docs/algs/leetcode/76_minimum_window_substring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/76_minimum_window_substring/</guid><description>Description # Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string &amp;ldquo;&amp;rdquo;.
The testcases will be generated such that the answer is unique.
A substring is a contiguous sequence of characters within the string.
Solutions # Sliding Window # 这里应该很容易可以看出需要使用滑动窗口来做，但是与一般的滑动窗口不同的是，这里的滑动窗口中可以包含一些不在字符串 t 中的字符。另外还需要注意的是，窗口中字符的出现顺序不需要和 t 一致，但是出现次数需要一致。</description></item><item><title>0424. Longest Repeating Character Replacement</title><link>https://example.com/docs/algs/leetcode/424_longest_repeating_character_replacement/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/424_longest_repeating_character_replacement/</guid><description>Description # You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.
Return the length of the longest substring containing the same letter you can get after performing the above operations.
Solutions # Sliding Window # 这个题题主又不会了，在网上看到可以使用滑动窗口来解。假设没有 k 的限制，也就是说可以替换任意多次，把一个字符串变为只有只有一个字符重复的字符串需要的最少置换次数是多少呢？其实就是扫描一遍字符串，记录出现次数最多的字符串的出现个数k，然后用总长度减去 k ，所得值即为最少置换次数。
而如果带上了 k，那么就要满足: 子字符串的长度减去该子字符串中出现次数最多的字符的长度要小于等于 k。具体做法：</description></item><item><title>0485. Max Consecutive Ones</title><link>https://example.com/docs/algs/leetcode/485_max_consecutive_ones/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/485_max_consecutive_ones/</guid><description>Description # Given a binary array nums, return the maximum number of consecutive 1&amp;rsquo;s in the array.
Solutions # Two Pointers # 这个就是一个简单题啦，使用双指针来做就好了,直接看代码就好。
func findMaxConsecutiveOnes(nums []int) int { res, size, left, right := 0, len(nums), 0, 0 for right &amp;lt; size { // right 一直往右走，直到找到第一个非 1 的数才停下来 for right &amp;lt; size &amp;amp;&amp;amp; nums[right] == 1 { right++ res = max(res, right - left) } // 跳过所有非 1 的数，同时更新 left 指向第一个 1 for right &amp;lt; size &amp;amp;&amp;amp; nums[right] !</description></item><item><title>0487. Max Consecutive Ones II</title><link>https://example.com/docs/algs/leetcode/487_max_consecutive_ones_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/487_max_consecutive_ones_ii/</guid><description>Description # Given a binary array, find the maximum number of consecutive 1s in this array if you can flip at most one 0.
Example 1:
Input: [1,0,1,1,0] Output: 4 Explanation: Flip the first zero will get the the maximum number of consecutive 1s. After flipping, the maximum number of consecutive 1s is 4.
Note:
The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000</description></item><item><title>0643. Maximum Average Subarray I</title><link>https://example.com/docs/algs/leetcode/643_maximum_average_subarray_i_/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/643_maximum_average_subarray_i_/</guid><description>Description # You are given an integer array nums consisting of n elements, and an integer k.
Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted.
Solutions # Sliding Window # 这题没什么难度，可以用一个固定长度的队列来模拟滑动窗口即可。
func findMaxAverage(nums []int, k int) float64 { var queue []int res, size, sum := math.</description></item><item><title>1004. Max Consecutive Ones III</title><link>https://example.com/docs/algs/leetcode/1004_max_consecutive_ones_iii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1004_max_consecutive_ones_iii/</guid><description>Description # Given a binary array nums and an integer k, return the maximum number of consecutive 1&amp;rsquo;s in the array if you can flip at most k 0&amp;rsquo;s.
Solutions # Sliding Window # 这题一看就是要用滑动窗口来解啦，但是窗口的边界一定要控制好。题主初始写出了下面的解法，结果只通过了部分case，调来调去总是有一部分 case 不能照顾到。
func longestOnes(nums []int, k int) int { res, size, left, right,cnt := 0, len(nums), 0, 0, 0 for right &amp;lt; size { // 如果 0 的数量比 k 小，那么继续扩大右边界 for right &amp;lt; size &amp;amp;&amp;amp; cnt &amp;lt;= k { if nums[right] == 0 { cnt++ } // 更新窗口值 res = max(res, right - left) right++ } // 缩小左边界 for left &amp;lt; right &amp;amp;&amp;amp; cnt &amp;gt; k { if nums[left] == 0 { cnt-- } left++ } } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a } 于是题主最后还是去看了网上大神的解答，发现其实是自己搞复杂了，这个题完全没有必要写得像上面那么复杂。可以维护一个窗口 [left,right] 来容纳至少k个0。当遇到了0，就累加 zero 的个数，然后判断如果此时0的个数大于k，则右移左边界left，如果移除掉的 nums[left] 为0，那么 zero 自减1。如果不大于k，则用窗口中数字的个数来更新 res。</description></item><item><title>1658. Minimum Operations to Reduce X to Zero</title><link>https://example.com/docs/algs/leetcode/1658_minimum_operations_to_reduce_x_to_zero/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1658_minimum_operations_to_reduce_x_to_zero/</guid><description>Description # You are given an integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x. Note that this modifies the array for future operations.
Return the minimum number of operations to reduce x to exactly 0 if it is possible, otherwise, return -1.
Solutions # Backtrace # 这是题主一开始想出来的解法，直接暴力回溯，但是超时了。仔细分析一下，发现时间复杂度确很高得离谱&amp;hellip;</description></item><item><title>1695. Maximum Erasure Value</title><link>https://example.com/docs/algs/leetcode/1695_maximum_erasure_value/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1695_maximum_erasure_value/</guid><description>Description # You are given an array of positive integers nums and want to erase a subarray containing unique elements. The score you get by erasing the subarray is equal to the sum of its elements.
Return the maximum score you can get by erasing exactly one subarray.
An array b is called to be a subarray of a if it forms a contiguous subsequence of a, that is, if it is equal to a[l],a[l+1],&amp;hellip;,a[r] for some (l,r).</description></item></channel></rss>