<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Heap on Interview</title><link>https://example.com/tags/Heap/</link><description>Recent content in Heap on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/Heap/index.xml" rel="self" type="application/rss+xml"/><item><title>0023. Merge K Sorted List</title><link>https://example.com/docs/algs/leetcode/23_merge_k_sorted_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/23_merge_k_sorted_list/</guid><description>Description # You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.
Merge all the linked-lists into one sorted linked-list and return it.
Solutions # Min Heap # 很简单的想法，使用最小堆即可。
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeKLists(lists []*ListNode) *ListNode { return mergeKListsSolution1(lists) } // 使用最小堆，将所有的节点数据都插入到最小堆中，然后再把所有元素从最小堆中弹出 func mergeKListsSolution1(lists []*ListNode) *ListNode { var minHeap MinHeapArr heap.</description></item><item><title>0313. Super Ugly Number</title><link>https://example.com/docs/algs/leetcode/313_super_ugly_number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/313_super_ugly_number/</guid><description>Description # A super ugly number is a positive integer whose prime factors are in the array primes.
Given an integer n and an array of integers primes, return the nth super ugly number.
The nth super ugly number is guaranteed to fit in a 32-bit signed integer.
Solutions # K Pointer # 这个题可以用第 264 题的解法来解。区别是，第 264 题中我们只有三个因子，但是这里的因子是不固定的，那么我们只需要使用一个 map 来充当 264 题中的多指针即可。
关于为什么使用多指针就可以，这里参见一个 LeetCode 上的 回答:
这道题一开始死活不明白三指针到底是怎么用的。后来突然就想明白了：
例如 n = 10， primes = [2, 3, 5]。 打印出丑数列表：1, 2, 3, 4, 5, 6, 8, 9, 10, 12 首先一定要知道，后面的丑数一定由前面的丑数乘以2，或者乘以3，或者乘以5得来。例如，8,9,10,12一定是1, 2, 3, 4, 5, 6乘以2,3,5三个质数中的某一个得到。</description></item><item><title>0347. Top K Frequent Elements</title><link>https://example.com/docs/algs/leetcode/347_top_k_frequent_elements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/347_top_k_frequent_elements/</guid><description>Description # Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.
Solutions # Hash Table &amp;amp; Sort # 这里首先使用 map 来统计每个元素出现的次数，然后将元素和其出现的次数组成一个 pair 对，根据每个 pair 对的元素出现次数对 pair 对进行排序，最后取前 k 个即可。
func topKFrequent(nums []int, k int) []int { dict := make(map[int]int) for _, num := range nums { dict[num]++ } type Pair struct { num int cnt int } var pairs []Pair for key, cnt := range dict { pairs = append(pairs, Pair{key, cnt}) } sort.</description></item><item><title>0378. Kth Smallest Element in a Sorted Matrix</title><link>https://example.com/docs/algs/leetcode/378_kth_smallest_element_in_a_sorted_matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/378_kth_smallest_element_in_a_sorted_matrix/</guid><description>Description # Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix.
Note that it is the kth smallest element in the sorted order, not the kth distinct element.
You must find a solution with a memory complexity better than \( \Omicron(n^2) \) Solutions # 这里可以使用最小堆，遍历矩阵，不断往堆中加入元素，遍历完之后，取堆中第 k 个元素就可。或者使用一个大小为 k 的最大堆，当堆中元素数量不足 k 时，将元素入堆，当堆中元素比 k 大时，将堆顶元素出堆即可。</description></item><item><title>0767. Reorganize String</title><link>https://example.com/docs/algs/leetcode/767_reorganizing_string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/767_reorganizing_string/</guid><description>Description # Given a string s, rearrange the characters of s so that any two adjacent characters are not the same.
Return any possible rearrangement of s or return &amp;quot;&amp;quot; if not possible.
Solutions # 这里的解法还是很巧妙的，需要注意一下。
type Pair struct { char byte cnt int } func reorganizeString(s string) string { dict := make(map[byte]int) for idx, _ := range s { dict[s[idx]]++ } var maxHeap MaxHeap heap.Init(&amp;amp;maxHeap) for char, cnt := range dict { if cnt &amp;gt; (len(s)+1)/2 { return &amp;#34;&amp;#34; } heap.</description></item><item><title>0973. K Closest Points to Origin</title><link>https://example.com/docs/algs/leetcode/973_k_closest_points_to_origin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/973_k_closest_points_to_origin/</guid><description>Description # Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).
The distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x1 - x2)2 + (y1 - y2)2).
You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).</description></item></channel></rss>