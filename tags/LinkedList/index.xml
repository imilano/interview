<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LinkedList on Interview</title><link>https://example.com/tags/LinkedList/</link><description>Recent content in LinkedList on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/LinkedList/index.xml" rel="self" type="application/rss+xml"/><item><title>0141. Linked List Cycle</title><link>https://example.com/docs/algs/leetcode/141_Linked-List-Cycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/141_Linked-List-Cycle/</guid><description>Description # Given head, the head of a linked list, determine if the linked list has a cycle in it.
There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail&amp;rsquo;s next pointer is connected to. Note that pos is not passed as a parameter.</description></item><item><title>0142. Linked List Cycle II</title><link>https://example.com/docs/algs/leetcode/142_linked_list_cycle_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/142_linked_list_cycle_ii/</guid><description>Description # Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.
There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail&amp;rsquo;s next pointer is connected to (0-indexed). It is -1 if there is no cycle.</description></item><item><title>0146. LRU Cache</title><link>https://example.com/docs/algs/leetcode/146_lru_cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/146_lru_cache/</guid><description>Description # Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.
Implement the LRUCache class:
LRUCache(int capacity) Initialize the LRU cache with positive size capacity. int get(int key) Return the value of the key if the key exists, otherwise return -1. void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache.</description></item><item><title>0160. Intersection of Two Linked Lists</title><link>https://example.com/docs/algs/leetcode/160_intersection_of_two_linked_lists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/160_intersection_of_two_linked_lists/</guid><description>Description # Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.
Solutions # Hash Table # 首先很容易想到哈希表的解法。
func getIntersectionNode(headA, headB *ListNode) *ListNode { if headA == nil || headB == nil { return nil } dict := make(map[*ListNode]bool) dummyA , dummyB := headA, headB for dummyA != nil { dict[dummyA] = true dummyA = dummyA.</description></item><item><title>0206. Reverse Linked List</title><link>https://example.com/docs/algs/leetcode/206_reverse_linked_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/206_reverse_linked_list/</guid><description>Description # Given the head of a singly linked list, reverse the list, and return the reversed list.
Solutions # Iterative # 迭代法，但是要注意虚拟头节点的使用。
func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } dummy := new(ListNode) cur := head for cur != nil { tail := dummy.Next next := cur.Next dummy.Next = cur cur.Next = tail cur = next } return dummy.Next } Recursive # 这里递归法如何反转节点也是需要十分注意的。</description></item><item><title>0328. Odd Even Linked List</title><link>https://example.com/docs/algs/leetcode/328_odd_even_linked_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/328_odd_even_linked_list/</guid><description>Description # Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.
The first node is considered odd, and the second node is even, and so on.
Note that the relative order inside both the even and odd groups should remain as it was in the input.
You must solve the problem in O(1) extra space complexity and O(n) time complexity.</description></item><item><title>0876. Median of the Linked List</title><link>https://example.com/docs/algs/leetcode/876_median_of_the_linked_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/876_median_of_the_linked_list/</guid><description>Description # Given the head of a singly linked list, return the middle node of the linked list.
If there are two middle nodes, return the second middle node.
Solutions # 使用快慢指针法，最后返回慢指针指向的节点即可。
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func middleNode(head *ListNode) *ListNode { slow, fast := head, head // 注意这里的判断条件 for fast != nil &amp;amp;&amp;amp; fast.</description></item></channel></rss>