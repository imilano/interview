<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Binary Search on Interview</title><link>https://example.com/tags/Binary-Search/</link><description>Recent content in Binary Search on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/Binary-Search/index.xml" rel="self" type="application/rss+xml"/><item><title>0033. Search in Rotated Sorted Array</title><link>https://example.com/docs/algs/leetcode/33_search_in_rotated_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/33_search_in_rotated_array/</guid><description>Description # There is an integer array nums sorted in ascending order (with distinct values).
Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], &amp;hellip;, nums[n-1], nums[0], nums[1], &amp;hellip;, nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].
Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.</description></item><item><title>0034. Find First and Last Position of Element in Sorted Array</title><link>https://example.com/docs/algs/leetcode/34_find_first_and_last_position_of_element_in_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/34_find_first_and_last_position_of_element_in_sorted_array/</guid><description>Description # Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.
If target is not found in the array, return [-1, -1].
You must write an algorithm with O(log n) runtime complexity.
Solutions # Binary Search # 二分查找再加上中间扩散，很容易想出来。
func searchRange(nums []int, target int) []int { res := []int{-1, -1} size := len(nums) if size == 0 { return res } left, right := 0, size -1 for left &amp;lt;= right { mid := (left+right)/2 if nums[mid] == target { l,r := mid, mid res[0] = l res[1] = r for l &amp;gt;= 0 &amp;amp;&amp;amp; nums[l] == target { res[0] = l l-- } for r &amp;lt; size &amp;amp;&amp;amp; nums[r] == target { res[1] = r r++ } break } else if nums[mid] &amp;gt; target { right = mid -1 } else if nums[mid] &amp;lt; target { left = mid + 1 } } return res } 在最坏情况下，比如数组中所有数字均相同，则时间复杂度会退化为 \( \Omircon(n) \) 。下面是优化之后的解法。</description></item><item><title>0069. Sqrt(x)</title><link>https://example.com/docs/algs/leetcode/69_sqrtx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/69_sqrtx/</guid><description> Description # Given a non-negative integer x, compute and return the square root of x.
Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.
Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.
Solutions # 使用二分法快速进行快速查找：
func mySqrt(x int) int { if x &amp;lt;= 1 { return x } low, high := 0, x for low &amp;lt; high { mid := (low+high)/2 if mid * mid == x { return mid } else if mid * mid &amp;gt; x { high = mid } else { low = mid + 1 } } return high - 1 }</description></item><item><title>0074. Search a 2D Matrix</title><link>https://example.com/docs/algs/leetcode/74_search_a_2d_matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/74_search_a_2d_matrix/</guid><description> Description # Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:
Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.
Solutions # Binary Search # 这题的二分解法真的比较巧妙。这里首先具备了两个特征：每一行从左向右递增，每一列从上到下递增。那么我们可以从第一列最后一个元素开始进行搜索，如果target 比当前元素要小，那么如果target 要存在，就只能在当前行上边，于是row-1；如果target比当前元素要大，那么如果该元素存在的话，智能在当前列右侧，于是col+1。按照以上规则进行遍历即可。
func searchMatrix(matrix [][]int, target int) bool { m, n := len(matrix), len(matrix[0]) row, col := m-1, 0 for row &amp;gt;= 0 &amp;amp;&amp;amp; col &amp;lt; n { if matrix[row][col] == target { return true } if matrix[row][col] &amp;lt; target { col++ } // 上面的 if 语句可能会导致这里出现越界访问，所以要加上 col &amp;lt; n if col &amp;lt; n &amp;amp;&amp;amp; matrix[row][col] &amp;gt; target { row-- } } return false }</description></item><item><title>0162. Find Peak Element</title><link>https://example.com/docs/algs/leetcode/162_find_peak_element/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/162_find_peak_element/</guid><description>Description # A peak element is an element that is strictly greater than its neighbors.
Given an integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.
You may imagine that nums[-1] = nums[n] = -∞.
You must write an algorithm that runs in \( Omicron(\log n) \) time.
Solutions # One Pass Iteration # 这里可以通过一次数组的一次遍历来完成。为了方便，我们可以在头部和尾部分别添加上一个最小值，这样能够减少一些边界值判断。当然，这种方法并不符合题目要求的 \( \Omicron(n\log n) \) 的要求。</description></item><item><title>0278. First Bad Version</title><link>https://example.com/docs/algs/leetcode/278_first_bad_version/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/278_first_bad_version/</guid><description>Description # You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.
Suppose you have n versions [1, 2, &amp;hellip;, n] and you want to find out the first bad one, which causes all the following ones to be bad.</description></item><item><title>1095. Find in Mountain Array</title><link>https://example.com/docs/algs/leetcode/1095_find_in_mountain_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1095_find_in_mountain_array/</guid><description>Description # (This problem is an interactive problem.)
You may recall that an array arr is a mountain array if and only if:
arr.length &amp;gt;= 3 There exists some i with 0 &amp;lt; i &amp;lt; arr.length - 1 such that: arr[0] &amp;lt; arr[1] &amp;lt; &amp;hellip; &amp;lt; arr[i - 1] &amp;lt; arr[i] arr[i] &amp;gt; arr[i + 1] &amp;gt; &amp;hellip; &amp;gt; arr[arr.length - 1] Given a mountain array mountainArr, return the minimum index such that mountainArr.</description></item></channel></rss>