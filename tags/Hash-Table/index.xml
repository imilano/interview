<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hash Table on Interview</title><link>https://example.com/tags/Hash-Table/</link><description>Recent content in Hash Table on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/Hash-Table/index.xml" rel="self" type="application/rss+xml"/><item><title>0001. Two Sum</title><link>https://example.com/docs/algs/leetcode/01_two_sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/01_two_sum/</guid><description>Description # Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.
Solutions # Hash Table # 这里因为答案唯一，那么也就意味着数组里的元素是唯一的，所以可以使用 map 来做，只需要一次遍历即可，具体看下面代码就好。
func twoSum(nums []int, target int) []int { dict := make(map[int]int) for idx, num := range nums{ t := target - num if exist(dict, t) { return []int{idx, dict[t]} } dict[num] = idx } return nil } func exist(dict map[int]int, target int) bool { if _, ok := dict[target]; ok { return true } return false } Sort &amp;amp;&amp;amp; Two Pointer # 这里也可以使用排序来做，根据值进行排序，但是需要保存该值对应的下标。排好序之后可以使用双指针，一个 left 指向开头，一个 right 指向结尾，计算二者和，如果小于 target，则 left++，否则 right++，直到二者之和等于 target 即可。思路大概就这样，代码就不写了。</description></item><item><title>0003. Longest Substring Without Repeating Characters</title><link>https://example.com/docs/algs/leetcode/03_longest_substring_without_repeatng_characters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/03_longest_substring_without_repeatng_characters/</guid><description>Description # Given a string s, find the length of the longest substring without repeating characters.
Solutions # Hash Table # 中间扩散法，时间复杂度会比较高，因为会有很多的重复扫描。核心思想是，遍历一次字符串，然后对于每个遍历到的位置，从中心向两侧进行扫描，扫描时使用一个 map 来记录那些已经出现过的字符；在一侧扫描过程中，如果发现该字符已经出现过，则停止扫描该侧。最后 map 的长度即为以该字符为中心的不重复字符的长度。
// 对于每个位置的字符，从中间向两侧扫描；使用一个 map 记录已经出现过的字符。在一侧扫描过程中，如果该字符已经出现过，则停止扫描该侧。 // 最后 map 的长度即为以该字符为中心的不重复字符的长度 func lengthOfLongestSubstringSolution1(s string) int { // handle empty string var res int if len(s) &amp;lt;= 1 { return len(s) } for i := 0; i &amp;lt; len(s); i++ { res = max(res, helper(s, i)) } return res } func helper(s string, mid int) int { left, right := mid-1, mid+1 dict := make(map[byte]bool) dict[s[mid]] = true for left &amp;gt; 0 { _, ok := dict[s[left]] if ok { break } dict[s[left]] = true left-- } for right &amp;lt; len(s) { _, ok := dict[s[right]] if ok { break } dict[s[right]] = true right++ } return len(dict) } Sliding Window &amp;amp; Hash Table # 很明显也可以使用滑动窗口配合 Hash Table 的方式来解题。首先固定滑动窗口的左边界，然后将滑动窗口的右边界向右滑动，每滑动一个位置，就检查该位置的字符是否有在当前滑动窗口中出现过(也就是说，既要检查该字符是否在 Hash Table 中出现过，还要检查最近一次出现的下标是否位于滑动窗口之内)，如果出现过，则更新滑动串口左边界。另外，每次遍历都需要更新当前滑动窗口的最大长度。</description></item><item><title>0015. 3 Sum</title><link>https://example.com/docs/algs/leetcode/15_3sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/15_3sum/</guid><description>Description # Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
Notice that the solution set must not contain duplicate triplets.
Solutions # Two Pointer # 注意这里其实并没有说不能更改原数组，那么我们可以对原数组先排个序，然后遍历数组，每次遍历到数 x，从 x 的后面的子数组找出两个和为-x 的数即可。 这里可以注意到右以下几个优化技巧：
遍历的时候只需要遍历到倒数第三个即可。 由于限制了不能重复，那么遍历时候对于重复出现的数字需要跳过，策略是，从第二个数字开始，如果这个数字和前一个数字相同，则跳过这个数字，继续遍历下一个。 如果当前固定的数 x 是个正数，那么也可以直接跳过这个数，因为既然数组已经排好序了，那么后面的数都只会比 x 大，他们的和也比 x 大 那么如何在子数组中查找-x 呢，可以在子数组中使用双指针，假设一个下标是 i 另一个是 j，那么如果二者之和大于 target，则 j 前移，否则 i 后移。 i 和 j 移动的过程中需要注意，二者均需要跳过重复数字 func threeSum(nums []int) [][]int { return solution(nums) } func solution(nums []int) [][]int { var res [][]int size := len(nums) if size &amp;lt; 3 { return res } sort.</description></item><item><title>0041. First Missing Positive</title><link>https://example.com/docs/algs/leetcode/41_first_msssing_positive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/41_first_msssing_positive/</guid><description>Description # Given an unsorted integer array nums, return the smallest missing positive integer.
You must implement an algorithm that runs in O(n) time and uses constant extra space.
Solutions # Hash Table # 可以使用一个 hash table 记录所以出现的值，然后找出当前值中的最大值。然后从 1 到最大值开始遍历，如果出现一个不在 hash table 中的数，则将该数返回即可。如果所有数都出现在了 hash table 中，那么返回最大值加 1 即可。但是最后这里需要注意的是，有可能整个数组都是负数，这样的话会导致前面的判断失效，所以返回值应该最小要返回 1.
func firstMissingPositive(nums []int) int { dict := make(map[int]bool) curMax := nums[0] for _, num := range nums { dict[num] = true if num &amp;gt; curMax { curMax = num } } for i := 1; i &amp;lt;= curMax; i++ { if _, ok := dict[i]; !</description></item><item><title>0049. Group Anagrams</title><link>https://example.com/docs/algs/leetcode/49_group_anagrams/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/49_group_anagrams/</guid><description>Description # Given an array of strings strs, group the anagrams together. You can return the answer in any order.
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
Solutions # 简单的方法就是，对具有相同字母以及字母出现次数也相同的字符串进行排序时，其排序结果都是一样的。所以可以创建一个 map，其中 key 为字符串的排序，value 为具有这样一个排序结果的字符串数组。
func groupAnagrams(strs []string) [][]string { var res [][]string m := make(map[string][]string) for _, str := range strs { str_splited := strings.</description></item><item><title>0050. Pow(x, n)</title><link>https://example.com/docs/algs/leetcode/50_powxn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/50_powxn/</guid><description> Description # Implement pow(x, n), which calculates x raised to the power n (i.e., xn).
Solutions # Map # 可以使用快速幂以及记忆化数组，单独使用快速幂会导致超时，所以需要配合记忆化数组使用。
func myPow(x float64, n int) float64 { if x == 0 { return 0 } if n == 0 { return 1 } var negative bool if n &amp;lt; 0 { negative = true n = -n } dict := make(map[int]float64) dict[0], dict[1] = 1, x res := helper(x, n, &amp;amp;dict) if negative { return 1 / res } return res } func helper(x float64, n int, dict *map[int]float64) float64 { if value, ok := (*dict)[n]; ok { return value } res := helper(x, n/2, dict) * helper(x, n/2, dict) * helper(x, n%2, dict) (*dict)[n] = res return res }</description></item><item><title>0128. Longest Consecurive Sequence</title><link>https://example.com/docs/algs/leetcode/128_longest_consecutive_sequence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/128_longest_consecutive_sequence/</guid><description> Description # Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.
You must write an algorithm that runs in O(n) time.
Solutions # 使用一个集合存入所有的数字，然后遍历数组中的每个数字，如果其在集合中存在，那么将其移除，然后 pre 再自减 1，直至pre 不在集合之中，对 next 采用同样的方法，那么 next - pre -1 就是当前数字的最长连续序列。之所以要移除数字，是为了避免重复计算。比如说对于 4、3、2，如果计算 4 的时候不把 3 和 2 移除掉，那么计算 3 和 2 的时候就会出现重复计算的情况。
func longestConsecutive(nums []int) int { var res int dict := make(map[int]bool) for _, num := range nums { dict[num] = true } for _, num := range nums { left, right := num -1, num + 1 for dict[left] == true { delete(dict, left) left-- } for dict[right] == true { delete(dict, right) right++ } res = max(res, right-left-1) } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a }</description></item><item><title>0133. Clone Graph</title><link>https://example.com/docs/algs/leetcode/133_clone_graph/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/133_clone_graph/</guid><description>Description # Given a reference of a node in a connected undirected graph.
Return a deep copy (clone) of the graph.
Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.
class Node { public int val; public List&amp;lt;Node&amp;gt; neighbors; } Test case format:
For simplicity, each node&amp;rsquo;s value is the same as the node&amp;rsquo;s index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on.</description></item><item><title>0141. Linked List Cycle</title><link>https://example.com/docs/algs/leetcode/141_Linked-List-Cycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/141_Linked-List-Cycle/</guid><description>Description # Given head, the head of a linked list, determine if the linked list has a cycle in it.
There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail&amp;rsquo;s next pointer is connected to. Note that pos is not passed as a parameter.</description></item><item><title>0142. Linked List Cycle II</title><link>https://example.com/docs/algs/leetcode/142_linked_list_cycle_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/142_linked_list_cycle_ii/</guid><description>Description # Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.
There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail&amp;rsquo;s next pointer is connected to (0-indexed). It is -1 if there is no cycle.</description></item><item><title>0146. LRU Cache</title><link>https://example.com/docs/algs/leetcode/146_lru_cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/146_lru_cache/</guid><description>Description # Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.
Implement the LRUCache class:
LRUCache(int capacity) Initialize the LRU cache with positive size capacity. int get(int key) Return the value of the key if the key exists, otherwise return -1. void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache.</description></item><item><title>0160. Intersection of Two Linked Lists</title><link>https://example.com/docs/algs/leetcode/160_intersection_of_two_linked_lists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/160_intersection_of_two_linked_lists/</guid><description>Description # Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.
Solutions # Hash Table # 首先很容易想到哈希表的解法。
func getIntersectionNode(headA, headB *ListNode) *ListNode { if headA == nil || headB == nil { return nil } dict := make(map[*ListNode]bool) dummyA , dummyB := headA, headB for dummyA != nil { dict[dummyA] = true dummyA = dummyA.</description></item><item><title>0277. Find the Celebrity</title><link>https://example.com/docs/algs/leetcode/277_find_the_celebrity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/277_find_the_celebrity/</guid><description>Description # Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.
Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: &amp;ldquo;Hi, A.</description></item><item><title>0314. Binary Tree Vertical Order Traversal</title><link>https://example.com/docs/algs/leetcode/314_binary_tree_vertical_order_traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/314_binary_tree_vertical_order_traversal/</guid><description>Description # Given a binary tree, return the vertical order traversal of its nodes&amp;rsquo; values. (ie, from top to bottom, column by column).
If two nodes are in the same row and column, the order should be from left to right.
Solutions # Level Order Traversal # 这里可以隐约看出来是要使用层序遍历，但是与一般的层序遍历的稍微有点不同。这里的主要思想是：对每个节点赋予一个值 col，然后对于其左节点，col 减 1，对于右节点， col 加 1。这样的话，同一列的节点都会有同一个值 col。在入队的时候，不仅需要将节点入队，还需要将节点的 row 入队，二者可以组成一个 pair。
func vericalOrder(root *TreeNode) [][]int { if root == nil { return nil } var res [][]int type pair struct { Node *TreeNode Col int } // 层序遍历需要用到的队列 var queue []pair // 记录每个 col 上有哪些节点 dict := make(map[int]*TreeNode) queue = append(queue, pair{root, 0}) for len(queue) !</description></item><item><title>0318. Maximum Product of Word Lengths</title><link>https://example.com/docs/algs/leetcode/318_maximum_product_of_word_lengths/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/318_maximum_product_of_word_lengths/</guid><description> Description # Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0.
Solutions # \( \Omicron (n^2) \) 的解法，相当于暴力求解了，因为限定了字符串中只会出现小写字符，而小写字符只有 26 个，那么就可以一个 32 位的 int 值 mask 来记录每个字符是否出现过，然后不同字符的 mask 之间进行相与，如果与的结果为 0，说明这两个字符没有重叠字符，那么就更新结果。
func maxProduct(words []string) int { var res int size := len(words) dict := make(map[int]int, size) for i := 0; i &amp;lt; size; i++ { for _, r := range words[i] { dict[i] |= 1 &amp;lt;&amp;lt; (int(r) - int(&amp;#39;a&amp;#39;)) } for j := 0; j &amp;lt; i; j++ { if (dict[i] &amp;amp; dict[j]) == 0 { res = max(res, len(words[i]) * len(words[j])) } } } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a }</description></item><item><title>0347. Top K Frequent Elements</title><link>https://example.com/docs/algs/leetcode/347_top_k_frequent_elements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/347_top_k_frequent_elements/</guid><description>Description # Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.
Solutions # Hash Table &amp;amp; Sort # 这里首先使用 map 来统计每个元素出现的次数，然后将元素和其出现的次数组成一个 pair 对，根据每个 pair 对的元素出现次数对 pair 对进行排序，最后取前 k 个即可。
func topKFrequent(nums []int, k int) []int { dict := make(map[int]int) for _, num := range nums { dict[num]++ } type Pair struct { num int cnt int } var pairs []Pair for key, cnt := range dict { pairs = append(pairs, Pair{key, cnt}) } sort.</description></item><item><title>0349. Intersection of Two Arrays</title><link>https://example.com/docs/algs/leetcode/349_intersection_of_two_arrays/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/349_intersection_of_two_arrays/</guid><description> Description # Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.
Solutoins # 简单题，只需要使用 map 即可。
func intersection(nums1 []int, nums2 []int) []int { d1,d2 := make(map[int]int), make(map[int]int) for _, num := range nums1 { d1[num]++ } for _, num := range nums2 { d2[num]++ } var res []int for key, _ := range d1 { if _, ok := d2[key]; ok { res = append(res, key) } } return res }</description></item><item><title>0350. Intersection of Two Arrays II</title><link>https://example.com/docs/algs/leetcode/350_intersection_of_two_arrays_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/350_intersection_of_two_arrays_ii/</guid><description> Description # Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.
Solutions # 这里跟 349 题的区别是，一个元素可能会出现多次，所以我们在统计完两个书中的元素的出现次数之后，需要确定把该元素放几次到结果数组中，那么需要放几次呢？这个次数应该跟该元素在两个数组中出现的最小次数相等。
func intersect(nums1 []int, nums2 []int) []int { d1,d2 := make(map[int]int), make(map[int]int) for _, num := range nums1 { d1[num]++ } for _, num := range nums2 { d2[num]++ } var res []int for key, value := range d1 { if cnt, ok := d2[key]; ok { m := min(cnt, value) for i := 0; i &amp;lt; m; i++ { res = append(res, key) } } } return res } func min(a,b int) int { if a &amp;lt; b { return a } return b }</description></item><item><title>0380. Insert Delete GetRandom O(1)</title><link>https://example.com/docs/algs/leetcode/380_insert_delete_getrandom_O1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/380_insert_delete_getrandom_O1/</guid><description>Description # Implement the RandomizedSet class:
RandomizedSet() Initializes the RandomizedSet object. bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise. bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise. int getRandom() Returns a random element from the current set of elements (it&amp;rsquo;s guaranteed that at least one element exists when this method is called).</description></item><item><title>0409. Longest Palindrome</title><link>https://example.com/docs/algs/leetcode/409_longest_palindrome/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/409_longest_palindrome/</guid><description> Description # Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.
Letters are case sensitive, for example, &amp;ldquo;Aa&amp;rdquo; is not considered a palindrome here.
Solutions # Hash Table # 回文串有两种形式，一种是xxyy，另一种是xxyzz，也就是说，两边的字符需要出现偶数次，那么这里就可以转换为统计出现偶数次的字符的数量。在统计的过程中，如果发现有一个字符出现了奇数次，那么这个奇数次的字符就可以放在回文串的中心，那么就需要记录一下，最后在结果上加上 1.
func longestPalindrome(s string) int { // 统计每个字符出现的次数 size := len(s) dict := make(map[byte]int) for i := 0; i &amp;lt; size; i++ { dict[s[i]]++ } var res int var addMid bool for _, num := range dict { res += num // 如果出现了奇数次，那么只取最大的偶数，也就是要减去 1 // 如果只是出现了一次的话，那么这里相当于没有加 if num % 2 == 1 { res -= 1 // 回文串有两种类型，一种是中间一个字符然后两边对称的形式， // 也就是说，如果有一个字符出现了奇数次，那么最后可以考虑把这个字符加上。 addMid = true } } if addMid { res += 1 } return res }</description></item><item><title>0454. 4 Sum II</title><link>https://example.com/docs/algs/leetcode/454_4sum_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/454_4sum_ii/</guid><description> Description # Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:
0 &amp;lt;= i, j, k, l &amp;lt; n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0 Solutions # Hash Table &amp;amp;&amp;amp; Divide # 首先题主肯定是写了一个四重循环，提交上去然后不出意外的超时了（笑。
然后经过一波搜索，发现可以这么做：这里使用的也算是分治思想，与其直接写一个四重循环，那么我们可以写两个二重循环，这样就可以有效降低时间复杂度。首先使用一个 map 记录 A 数组和 B 数组中每个元素组合之和出现的次数，然后再遍历 C 和 D，求出 C 和 D 当前元素组合的和，然后判断其相反数有没有在 map 中出现，如果出现了，则在结果上加上其出现的次数即可。不得不说，这个解法还是很巧妙的。
func fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int { var res int dict := make(map[int]int) for _, num1 := range nums1 { for _, num2 := range nums2 { dict[num1+num2]++ } } for _, num1 := range nums3 { for _, num2 := range nums4 { if cnt,ok := dict[-num1-num2]; ok { res += cnt } } } return res }</description></item><item><title>0745. Prefix and Suffix Search</title><link>https://example.com/docs/algs/leetcode/745_prefix_and_suffix_search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/745_prefix_and_suffix_search/</guid><description>Description # Design a special dictionary with some words that searchs the words in it by a prefix and a suffix.
Implement the WordFilter class:
WordFilter(string[] words) Initializes the object with the words in the dictionary. f(string prefix, string suffix) Returns the index of the word in the dictionary, which has the prefix prefix and the suffix suffix. If there is more than one valid index, return the largest of them.</description></item><item><title>0752. Open the Lock</title><link>https://example.com/docs/algs/leetcode/752_open_the_lock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/752_open_the_lock/</guid><description>Description # You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: &amp;lsquo;0&amp;rsquo;, &amp;lsquo;1&amp;rsquo;, &amp;lsquo;2&amp;rsquo;, &amp;lsquo;3&amp;rsquo;, &amp;lsquo;4&amp;rsquo;, &amp;lsquo;5&amp;rsquo;, &amp;lsquo;6&amp;rsquo;, &amp;lsquo;7&amp;rsquo;, &amp;lsquo;8&amp;rsquo;, &amp;lsquo;9&amp;rsquo;. The wheels can rotate freely and wrap around: for example we can turn &amp;lsquo;9&amp;rsquo; to be &amp;lsquo;0&amp;rsquo;, or &amp;lsquo;0&amp;rsquo; to be &amp;lsquo;9&amp;rsquo;. Each move consists of turning one wheel one slot.
The lock initially starts at &amp;lsquo;0000&amp;rsquo;, a string representing the state of the 4 wheels.</description></item><item><title>0820. Short Encoding of Words</title><link>https://example.com/docs/algs/leetcode/820_short_encoding_of_words/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/820_short_encoding_of_words/</guid><description> Description # Solutions # Hash Table # 这道题给了我们一个单词数组，让我们对其编码，不同的单词之间加入#号，每个单词的起点放在一个坐标数组内，终点就是#号，能合并的单词要进行合并，问输入字符串的最短长度。题意不难理解，难点在于如何合并单词，我们观察题目的那个例子，me和time是能够合并的，只要标清楚其实位置，time的起始位置是0，me的起始位置是2，那么根据#号位置的不同就可以顺利的取出me和time。需要注意的是，如果me换成im，或者tim的话，就不能合并了，因为我们是要从起始位置到#号之前所有的字符都要取出来。
这里使用 Hash Table 来做，将所有的单词先放到这个Hash Table 中。原理是对于每个单词，我们遍历其所有的后缀，比如time，那么就遍历ime，me，e，然后看 Hash Table 中是否存在这些后缀，有的话就删掉，那么 Hash Table 中的 me 就会被删掉，这样保证了留下来的单词不可能再合并了，最后再加上每个单词的长度到结果 res，并且同时要加上 # 号的长度。
func minimumLengthEncoding(words []string) int { // 先将每个单词放进 hash 表中 dict := make(map[string]bool) for _, word := range words { dict[word] = true } // 对于 words 中的每个单词，找到其每个后缀，查看该后缀是否在 dict 中，如果在的话，则从 dict 中将该后缀删除 for _, word := range words { size := len(word) for i := 1; i &amp;lt; size; i++ { if _, ok := dict[word[i:]]; ok { delete(dict, word[i:]) } } } // 最后 dict 中剩下来的字符串都是不能合并的字符串，因为每个字符串和周围的字符串都要有一个#分隔，最后一个位置也需要一个#分隔， // 所以可以遍历 dict 中剩下的每个字符串，将其长度加 1 放到 res 中 var res int for word, _ := range dict { res += len(word) + 1 } return res }</description></item><item><title>0895. Max Frequency Stack</title><link>https://example.com/docs/algs/leetcode/895_max_frequency_stack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/895_max_frequency_stack/</guid><description>Description # Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.
Implement the FreqStack class:
FreqStack() constructs an empty frequency stack. void push(int val) pushes an integer val onto the top of the stack. int pop() removes and returns the most frequent element in the stack. If there is a tie for the most frequent element, the element closest to the stack&amp;rsquo;s top is removed and returned.</description></item><item><title>1086. High Five</title><link>https://example.com/docs/algs/leetcode/1086_high_five/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1086_high_five/</guid><description>Description # Given a list of the scores of different students, items, where items[i] = [IDi, scorei] represents one score from a student with IDi, calculate each student&amp;rsquo;s top five average.
Return the answer as an array of pairs result, where result[j] = [IDj, topFiveAveragej] represents the student with IDj and their top five average. Sort result by IDj in increasing order.
A student&amp;rsquo;s top five average is calculated by taking the sum of their top five scores and dividing it by 5 using integer division.</description></item><item><title>1268. Search Suggestions System</title><link>https://example.com/docs/algs/leetcode/1268_search_suggestions_system/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1268_search_suggestions_system/</guid><description>Description # You are given an array of strings products and a string searchWord.
Design a system that suggests at most three product names from products after each character of searchWord is typed. Suggested products should have common prefix with searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products.
Return a list of lists of the suggested products after each character of searchWord is typed.</description></item><item><title>1461. Check If a String Contains All Binary Codes of Size K</title><link>https://example.com/docs/algs/leetcode/1461_check_if_a_string_contains_all_binary_codes_of_size_k/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1461_check_if_a_string_contains_all_binary_codes_of_size_k/</guid><description>Description # Given a binary string s and an integer k, return true if every binary code of length k is a substring of s. Otherwise, return false.
Solutions # Brute Force # 下面是题主一开始想出来的方法，可惜最后几个用例过于变态，所以超时了。
func hasAllCodes(s string, k int) bool { size := len(s) if size &amp;lt; k { return false } // golang 格式化打印字符串，%04b 这个格式化字符串能够将数字转换为二进制表示，并且当表示字符串长度小于 4 时，能够自动在前面增加 0 作为 padding。 fmtStr := &amp;#34;%0&amp;#34; + strconv.Itoa(k) + &amp;#34;b&amp;#34; maxEle := int(math.</description></item></channel></rss>