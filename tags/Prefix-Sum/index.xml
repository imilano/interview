<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Prefix Sum on Interview</title><link>https://example.com/tags/Prefix-Sum/</link><description>Recent content in Prefix Sum on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/Prefix-Sum/index.xml" rel="self" type="application/rss+xml"/><item><title>0303. Range Sum Query - Immutable</title><link>https://example.com/docs/algs/leetcode/303_range_sum_query_immutable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/303_range_sum_query_immutable/</guid><description>Solutions # Brute Force &amp;amp; Memorial # 本来题主以为这里考的是使用记忆化数组来避免重复计算，结果一提交结果，发现自己还是太天真了&amp;hellip;
type NumArray struct { nums []int dict map[string]int } func Constructor(nums []int) NumArray { return NumArray{nums, make(map[string]int)} } func (this *NumArray) SumRange(left int, right int) int { if left == right { return (*this).nums[left] } if left &amp;gt; right { return 0 } target := string(left) + string(right) if _, ok := (*this).dict[target]; ok { return (*this).dict[target] } res := this.nums[left] + this.</description></item><item><title>0304. Range Sum Query - Mutable</title><link>https://example.com/docs/algs/leetcode/307_range_sum_query_mutable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/307_range_sum_query_mutable/</guid><description>Description # Given an integer array nums, handle multiple queries of the following types:
Update the value of an element in nums.
Calculate the sum of the elements of nums between indices left and right inclusive where left &amp;lt;= right. Implement the NumArray class:
NumArray(int[] nums) Initializes the object with the integer array nums.
void update(int index, int val) Updates the value of nums[index] to be val.
int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.</description></item><item><title>0304. Range Sum Query 2D - Immutable</title><link>https://example.com/docs/algs/leetcode/304_range_sum_query_2d_immutable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/304_range_sum_query_2d_immutable/</guid><description>Description # Given a 2D matrix matrix, handle multiple queries of the following type:
Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2). Implement the NumMatrix class:
NumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix. int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).</description></item><item><title>0560. Subarray Sum Equals K</title><link>https://example.com/docs/algs/leetcode/560_subarray_sum_equals_k/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/560_subarray_sum_equals_k/</guid><description> Description # Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.
A subarray is a contiguous non-empty sequence of elements within an array.
Solutions # Prefix Sum # 这个题可以使用前缀和的技巧来解决。前缀和相关的介绍可以看 这里。
func subarraySum(nums []int, k int) int { var res int size := len(nums) prefix := make([]int, size+1) // 计算前缀和 idx := 1 for _, num := range nums { prefix[idx] = prefix[idx-1] + num idx++ } // 计算子数组 for i := 1; i &amp;lt;= size; i++ { for j := 0; j &amp;lt; i; j++ { if prefix[i] - prefix[j] == k { res++ } } } return res }</description></item><item><title>1423. Maximum Points You Can Obrain fron Cards</title><link>https://example.com/docs/algs/leetcode/1423_maximum_points_you_can_obtain_from_cards/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1423_maximum_points_you_can_obtain_from_cards/</guid><description>Description # There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints.
In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards.
Your score is the sum of the points of the cards you have taken.
Given the integer array cardPoints and the integer k, return the maximum score you can obtain.</description></item><item><title>1658. Minimum Operations to Reduce X to Zero</title><link>https://example.com/docs/algs/leetcode/1658_minimum_operations_to_reduce_x_to_zero/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1658_minimum_operations_to_reduce_x_to_zero/</guid><description>Description # You are given an integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x. Note that this modifies the array for future operations.
Return the minimum number of operations to reduce x to exactly 0 if it is possible, otherwise, return -1.
Solutions # Backtrace # 这是题主一开始想出来的解法，直接暴力回溯，但是超时了。仔细分析一下，发现时间复杂度确很高得离谱&amp;hellip;</description></item></channel></rss>