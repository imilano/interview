<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Math on Interview</title><link>https://example.com/tags/Math/</link><description>Recent content in Math on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/Math/index.xml" rel="self" type="application/rss+xml"/><item><title>0062. Unique Paths</title><link>https://example.com/docs/algs/leetcode/62_unique_paths/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/62_unique_paths/</guid><description>Description # There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.
Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.</description></item><item><title>0066. Plus One</title><link>https://example.com/docs/algs/leetcode/66_plus_one/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/66_plus_one/</guid><description>Description # You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0&amp;rsquo;s.
Increment the large integer by one and return the resulting array of digits.
Solutions # 简单题，直接计算即可。
func plusOne(digits []int) []int { size := len(digits) if size == 0 { return digits } carry := 1 for i := size-1; i &amp;gt;= 0; i-- { sum := digits[i] + carry carry = sum / 10 digits[i] = sum % 10 } if carry &amp;gt; 0 { digits = append([]int{carry}, digits.</description></item><item><title>0069. Sqrt(x)</title><link>https://example.com/docs/algs/leetcode/69_sqrtx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/69_sqrtx/</guid><description> Description # Given a non-negative integer x, compute and return the square root of x.
Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.
Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.
Solutions # Binary Search # 使用二分法进行快速查找。开头就去除掉一些 corner case 的话，后面整体逻辑写起来就会更加的清晰。
func mySqrt(x int) int { if x &amp;lt;= 1 { return x } low, high := 0, x for low &amp;lt; high { mid := (low+high)/2 if mid * mid == x { return mid } else if mid * mid &amp;gt; x { high = mid } else { low = mid + 1 } } // 注意这里为什么返回的是 high - 1 return high - 1 }</description></item><item><title>0070. Climbing Stairs</title><link>https://example.com/docs/algs/leetcode/70_climing_stairs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/70_climing_stairs/</guid><description> Descriptioin # You are climbing a staircase. It takes n steps to reach the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
Solutions # 斐波那契数列问题，不多说。
func climbStairs(n int) int { if n &amp;lt;= 2 { return n } FMinusOne, FMinusTwo := 2, 1 for i := 3; i &amp;lt;= n; i++ { fn := FMinusOne + FMinusTwo FMinusTwo = FMinusOne FMinusOne = fn } return FMinusOne }</description></item><item><title>0263. Ugly Number</title><link>https://example.com/docs/algs/leetcode/263_ugly_number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/263_ugly_number/</guid><description> Description # An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.
Given an integer n, return true if n is an ugly number.
Solutions # 如果一个数是丑数，那么它的因子必然只有 2、3、5 这三个，那么如果 n 能够被它的这些因子整除，那就不断的缩小 n，最后检查 n 不断被整除后的 n 其是否等于 1 即可。
func isUgly(n int) bool { if n &amp;lt;= 0 { return false } if n &amp;lt;= 6 { return true } for n % 2 == 0 { n /= 2 } for n %3 == 0 { n /= 3 } for n % 5 == 0 { n /= 5 } return n == 1 }</description></item><item><title>0268. Missing Number</title><link>https://example.com/docs/algs/leetcode/268_missing_number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/268_missing_number/</guid><description> Description # Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.
Solutions # 这题很简单，只需要使用求和公式来进行计算就可以了。直接给出代码。
func missingNumber(nums []int) int { n := len(nums) sum := (0+n) * (n+1)/2 for _, num := range nums { sum -= num } return sum }</description></item><item><title>0362. Design Hit Counter</title><link>https://example.com/docs/algs/leetcode/367_valid_perfect_square/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/367_valid_perfect_square/</guid><description> Description # Given a positive integer num, write a function which returns True if num is a perfect square else False.
Follow up: Do not use any built-in library function such as sqrt.
Solutions # Binary Search # 这里跟 69 题其实是完全一样的解法，需要注意的是，在开始的时候去除掉一些 corner case 能够让后面的整体逻辑更清晰一些。
func isPerfectSquare(num int) bool { if num &amp;lt;= 1 { return true } left, right := 0, num for left &amp;lt; right { mid := left + (right - left)/2 res := mid * mid if res == num { return true } if res &amp;gt; num { right = mid } else { left = mid + 1 } } return false }</description></item><item><title>0453. Minimum Moves to Equal Array Elements</title><link>https://example.com/docs/algs/leetcode/453_minimum_moves_to_equal_array_elements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/453_minimum_moves_to_equal_array_elements/</guid><description>Description # Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.
In one move, you can increment n - 1 elements of the array by 1.
Solutions # Math # 这题的意思就是，对于一个长度为 n 的数组，每次可以给 n-1 个数组加 1，问最少要多少次，才能让整个数组的数字相等。那这里要给哪些数字加 1 呢？很明显可以想到，每次都需要给最小的 n-1 个数加 1，这也就意味着，每次 move 都需要排序来找出最小的 n - 1 个数。可惜的是，依照上面的思路，是无法通过 OJ 的。
这里的解法比较 tricky，其实给 n-1 个数字加 1，就等同于给最大的数字减去 1. 那么每次 move 对最小的 n - 1 个数字加 1，就相当于每次 move 对最大的那个数减 1，那么问题也就转化为，求每个数字跟最小数字之间的差值，然后对这写差值进行累加即可。</description></item><item><title>1332. Remove Palindromic Subsequences</title><link>https://example.com/docs/algs/leetcode/1332_remove_palindromic_subsequence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1332_remove_palindromic_subsequence/</guid><description>Description # You are given a string s consisting only of letters &amp;lsquo;a&amp;rsquo; and &amp;lsquo;b&amp;rsquo;. In a single step you can remove one palindromic subsequence from s.
Return the minimum number of steps to make the given string empty.
A string is a subsequence of a given string if it is generated by deleting some characters of a given string without changing its order. Note that a subsequence does not necessarily need to be contiguous.</description></item><item><title>1342. Number of Steps to Reduce a Number to Zero</title><link>https://example.com/docs/algs/leetcode/1342_number_of_steps_to_reduce_a_number_to_zero/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1342_number_of_steps_to_reduce_a_number_to_zero/</guid><description> Description # Given an integer num, return the number of steps to reduce it to zero.
In one step, if the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.
Solutions # 这题太简单了，没什么好说的，直接上代码。
func numberOfSteps(num int) int { var res int for num != 0 { if num%2 == 0 { num /= 2 } else { num -= 1 } res++ } return res }</description></item><item><title>1689. Partitioning Into Minimum Number of Deci-Binary Numbers</title><link>https://example.com/docs/algs/leetcode/1689_partitioning_into_minimum_number_of_deci-binary_numbers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1689_partitioning_into_minimum_number_of_deci-binary_numbers/</guid><description>Description # A decimal number is called deci-binary if each of its digits is either 0 or 1 without any leading zeros. For example, 101 and 1100 are deci-binary, while 112 and 3001 are not.
Given a string n that represents a positive decimal integer, return the minimum number of positive deci-binary numbers needed so that they sum up to n.
Solutions # 这题题主以为是要用动态规划之类的解法来做，结果想了好一会都没想出来，然后到网上去搜大神们答案，于是搜到了 这个。看完答案，我只想说，人和人真的，天壤之别&amp;hellip;
这里的解法浓缩成一句话就是：答案就是 n 这个字符串中最大的数字（指 0-9 之间）。翻译一下大佬的证明就是：</description></item></channel></rss>