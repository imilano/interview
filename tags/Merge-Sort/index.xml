<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Merge Sort on Interview</title><link>https://example.com/tags/Merge-Sort/</link><description>Recent content in Merge Sort on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/Merge-Sort/index.xml" rel="self" type="application/rss+xml"/><item><title>0021. Merge Two Sorted List</title><link>https://example.com/docs/algs/leetcode/21_merge_two_sorted_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/21_merge_two_sorted_list/</guid><description>Description # You are given the heads of two sorted linked lists list1 and list2.
Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.
Return the head of the merged linked list.
Solutions # 简单题，不多说了，参考归并排序思想。
Merge Sort # func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode { res := new(ListNode) node := res dummyHead1, dummyHead2 := list1, list2 for dummyHead1 !</description></item><item><title>0023. Merge K Sorted List</title><link>https://example.com/docs/algs/leetcode/23_merge_k_sorted_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/23_merge_k_sorted_list/</guid><description>Description # You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.
Merge all the linked-lists into one sorted linked-list and return it.
Solutions # Min Heap # 很简单的想法，使用最小堆即可。
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeKLists(lists []*ListNode) *ListNode { return mergeKListsSolution1(lists) } // 使用最小堆，将所有的节点数据都插入到最小堆中，然后再把所有元素从最小堆中弹出 func mergeKListsSolution1(lists []*ListNode) *ListNode { var minHeap MinHeapArr heap.</description></item><item><title>0088. Merge Sorted Array</title><link>https://example.com/docs/algs/leetcode/88_merge_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/88_merge_sorted_array/</guid><description>Description # You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.
Merge nums1 and nums2 into a single array sorted in non-decreasing order.
The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored.</description></item><item><title>0148. Sort List</title><link>https://example.com/docs/algs/leetcode/148_sort_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/148_sort_list/</guid><description>Description # Given the head of a linked list, return the list after sorting it in ascending order.
Solutions # 第一个想法很简单，先扫描一遍链表，把扫描到的值记录到数组，然后对数组进行排序，最后再把排序结果赋值给原链表即可。时间复杂度 \(\Omicron(n\log n)\) , 空间复杂度 \($\Omicron(n)$\) 。
方法二，可以用插入排序的思想。维持一个排好序的链表，从头结点开始扫描，每扫描到一个节点，就将其插入到这个有序链表中去。这样空间复杂度就是 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n^2)$\) 。
follow up 但是这里要求的是时间复杂度 \($\Omicron(n\log n)$\) ，空间复杂度 \($\Omicron(1)$\) ，那很明显上述解法都不满足。这里竟然可以用归并排序，归并排序的时间复杂度是 \($\Omicron(n\logn)$\) ，归并排序又分为自顶向下和自底向上两种，前者空间复杂度是 \($\Omicron(\log n)$\) （因为栈深度），后者可以达到 \($\Omicron(1)$\) 。
这里是自顶向下的解法，需要注意的是，在 getMiddle 函数中将 middle 节点和前一个节点断开是一个非常重要的操作。
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func sortList(head *ListNode) *ListNode { return mergeSortUpDown(head) } func mergeSortUpDown(head *ListNode) *ListNode { if head == nil || head.</description></item></channel></rss>