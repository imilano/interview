<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Array on Interview</title><link>https://example.com/tags/Array/</link><description>Recent content in Array on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/Array/index.xml" rel="self" type="application/rss+xml"/><item><title>0026. remove duplicated from sorted array</title><link>https://example.com/docs/algs/leetcode/26_remove_duplicates_from_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/26_remove_duplicates_from_sorted_array/</guid><description>Description # Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.
Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result.</description></item><item><title>0036. Valid Sudoku</title><link>https://example.com/docs/algs/leetcode/36_valid_sudoku/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/36_valid_sudoku/</guid><description>Description # Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Solutions # 一个是要注意如何快速创建三维数组，另一个是要注意如何进行坐标转换。
func isValidSudoku(board [][]byte) bool { size := 9 // 一次性将所有行和列创建完毕 row, col := make([][]int, size), make([][]int, size) for i := 0; i &amp;lt; size; i++ { row[i], col[i] = make([]int, size), make([]int, size) } // 表示 9 个gird，么个 grid 有 9 个元素.</description></item><item><title>0041. First Missing Positive</title><link>https://example.com/docs/algs/leetcode/41_first_msssing_positive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/41_first_msssing_positive/</guid><description>Description # Given an unsorted integer array nums, return the smallest missing positive integer.
You must implement an algorithm that runs in O(n) time and uses constant extra space.
Solutions # Hash Table # 可以使用一个 hash table 记录所以出现的值，然后找出当前值中的最大值。然后从 1 到最大值开始遍历，如果出现一个不在 hash table 中的数，则将该数返回即可。如果所有数都出现在了 hash table 中，那么返回最大值加 1 即可。但是最后这里需要注意的是，有可能整个数组都是负数，这样的话会导致前面的判断失效，所以返回值应该最小要返回 1.
func firstMissingPositive(nums []int) int { dict := make(map[int]bool) curMax := nums[0] for _, num := range nums { dict[num] = true if num &amp;gt; curMax { curMax = num } } for i := 1; i &amp;lt;= curMax; i++ { if _, ok := dict[i]; !</description></item><item><title>0042. Traping Rain Water</title><link>https://example.com/docs/algs/leetcode/42_traping_rain_water/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/42_traping_rain_water/</guid><description>Description # Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.
detail see: https://leetcode.com/problems/trapping-rain-water/
Solutions # Array # 使用两个数组扫描两趟，第一个数组 fromLeft 从左到右扫描，记录到目前为止遇到的最大值，第二个数组fromRight 从右向左扫描，记录当前为止遇到的最大值。最后扫描一下这两个数组，对于每个位置 i，取 fromLeft 和 fromRight 二者中的较小者与当前 height[i] 的差值作为当前格子所能盛水量。
func trap(nums []int) int { var res int size := len(nums) if size &amp;lt;= 1 { return res } curMax := nums[0] fromLeft := make([]int, size) for idx, num := range nums { curMax = max(num, curMax) fromLeft[idx] = curMax } curMax = nums[size-1] fromRight := make([]int, size) for i := size-1; i &amp;gt;= 0; i-- { curMax = max(nums[i], curMax) fromRight[i] = curMax } for i := 0; i &amp;lt; size; i++ { res += min(fromLeft[i], fromRight[i]) - nums[i] } return res } func min(a,b int) int { if a &amp;lt; b { return a } return b } func max(a,b int) int { if a &amp;lt; b { return b } return a } 还有一种解法，就是先找出整个数组的最大值，这个最大值将整个数组切分为两部分，然后分别处理左半边和右半边。处理单边的时候，记录自己当前遇到的历史最大值，如果当前值比历史最大值要大，则更新历史最大值为当前值；否则的话说明历史最大值比当前值要大，那么当前值是可以盛水的，则更新结果盛水量。为什么只需要记录当前历史最大值就可以了呢，毕竟能不能盛水其实要靠两边而不是一边啊？答案是我我们已经找出了整个数组的最大值，那么当前的历史最大值只会比整个数组的最大值要小，能盛多少水完全取决于较短的一方（参考短板理论），所以只需要维持一个最大值即可。</description></item><item><title>0048. Rotate Image</title><link>https://example.com/docs/algs/leetcode/48_rotate_image/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/48_rotate_image/</guid><description>Description # You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.
Solutions # 补充几个矩阵变换公式： - 主对角线对折： arr[i][j] = arr[j][i] - 副对角线对折： arr[i][j] = arr[n-j-1][n-i-1] go for i := 0; i &amp;lt; n; i++ { for j := 0; j &amp;lt; n-i; j++ { matrix[i][j], matrix[n-j-1][n-i-1] = matrix[n-j-1][n-i-1], matrix[i][j] } } - 横向对折： arr[i][j] = arr[n-i-1][j] - 纵向对折： arr[i][j] = arr[i][n-j-1]</description></item><item><title>0054. Spiral Matrix</title><link>https://example.com/docs/algs/leetcode/54_spiral_matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/54_spiral_matrix/</guid><description> Description # Given an m x n matrix, return all elements of the matrix in spiral order.
Solutions # 其实就是顺时针旋转打印数组。
func spiralOrder(matrix [][]int) []int { var res []int m, n := len(matrix), len(matrix[0]) up, bottom, left, right := 0, m-1, 0, n - 1 for up &amp;lt;= bottom &amp;amp;&amp;amp; left &amp;lt;= right { for i := left; i &amp;lt;= right; i++ { res = append(res, matrix[up][i]) } up++ if up &amp;gt; bottom { break } for i := up; i &amp;lt;= bottom; i++ { res = append(res, matrix[i][right]) } right-- if right &amp;lt; left { break } for i := right; i &amp;gt;= left; i-- { res = append(res, matrix[bottom][i]) } bottom-- if bottom &amp;lt; up { break } for i := bottom; i &amp;gt;= up;i-- { res = append(res, matrix[i][left]) } left++ if left &amp;gt; right { break } } return res }</description></item><item><title>0056. Merge Intervals</title><link>https://example.com/docs/algs/leetcode/56_merge_intervals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/56_merge_intervals/</guid><description>Description # Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.
Solutions # 典型的区间合并问题。
首先先对区间按照开始时间从小到大进行排序，然后使用一个指针 cur 指向当前 intervals 数组遍历到的位置，使用一个指针 tail 指向 res 数组最后一个元素。然后开始对 intervals 数组进行遍历，如果当前遍历到的区间跟 res 数组的最后一个区间没有重叠，则直接将这个区间插入 res 数组，然后 tail 自增；否则的话就合并区间，更新 res[tail] 的结束时间；每次遍历结束，cur 自增。
func merge(intervals [][]int) [][]int { var res [][]int size := len(intervals) if size &amp;lt;= 1 { return intervals } sort.</description></item><item><title>0088. Merge Sorted Array</title><link>https://example.com/docs/algs/leetcode/88_merge_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/88_merge_sorted_array/</guid><description>Description # You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.
Merge nums1 and nums2 into a single array sorted in non-decreasing order.
The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored.</description></item><item><title>0162. Find Peak Element</title><link>https://example.com/docs/algs/leetcode/162_find_peak_element/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/162_find_peak_element/</guid><description>Description # A peak element is an element that is strictly greater than its neighbors.
Given an integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.
You may imagine that nums[-1] = nums[n] = -∞.
You must write an algorithm that runs in \( Omicron(\log n) \) time.
Solutions # One Pass Iteration # 这里可以通过一次数组的一次遍历来完成。为了方便，我们可以在头部和尾部分别添加上一个最小值，这样能够减少一些边界值判断。当然，这种方法并不符合题目要求的 \( \Omicron(n\log n) \) 的要求。</description></item><item><title>0167. Two Sum II - Input Array Is Sorted</title><link>https://example.com/docs/algs/leetcode/167_two_sum_ii_input_array_is_sorted/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/167_two_sum_ii_input_array_is_sorted/</guid><description>Description # Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &amp;lt;= index1 &amp;lt; index2 &amp;lt;= numbers.length.
Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.
The tests are generated such that there is exactly one solution.</description></item><item><title>0350. Intersection of Two Arrays II</title><link>https://example.com/docs/algs/leetcode/350_intersection_of_two_arrays_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/350_intersection_of_two_arrays_ii/</guid><description> Description # Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.
Solutions # 这里跟 349 题的区别是，一个元素可能会出现多次，所以我们在统计完两个书中的元素的出现次数之后，需要确定把该元素放几次到结果数组中，那么需要放几次呢？这个次数应该跟该元素在两个数组中出现的最小次数相等。
func intersect(nums1 []int, nums2 []int) []int { d1,d2 := make(map[int]int), make(map[int]int) for _, num := range nums1 { d1[num]++ } for _, num := range nums2 { d2[num]++ } var res []int for key, value := range d1 { if cnt, ok := d2[key]; ok { m := min(cnt, value) for i := 0; i &amp;lt; m; i++ { res = append(res, key) } } } return res } func min(a,b int) int { if a &amp;lt; b { return a } return b }</description></item><item><title>0380. Insert Delete GetRandom O(1)</title><link>https://example.com/docs/algs/leetcode/380_insert_delete_getrandom_O1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/380_insert_delete_getrandom_O1/</guid><description>Solutions # Hash Table &amp;amp; Array # 这里使用一个 Hash Table 和一个数组，Hash Table 存储的是值和该值在数组中的下标。这里稍微有点 tricky 的是，删除的时候，不是直接在 Hash Table 中删除该元素，而是在数组中将该元素和尾元素调换位置，然后删除尾元素。 这样所有操作都能达到 \( \Omicron(1) \) 的时间复杂度。
import &amp;#34;math/rand&amp;#34; type RandomizedSet struct { dict map[int]int nums []int } func Constructor() RandomizedSet { return RandomizedSet{dict: make(map[int]int), nums: []int{}} } func (this *RandomizedSet) Insert(val int) bool { var present bool if _, ok := (*this).dict[val]; !ok { present = true size := len((*this).nums) (*this).nums = append((*this).</description></item><item><title>0540. Single Element in a Sorted Array</title><link>https://example.com/docs/algs/leetcode/540_single_element_in_a_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/540_single_element_in_a_sorted_array/</guid><description>Description # You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.
Return the single element that appears only once.
Your solution must run in \(\Omicron(\log n) {{ &amp;lt; /katex &amp;gt;}} time and {{ &amp;lt; katex &amp;gt; \Omicron(1) {{ &amp;lt; /katex &amp;gt; }}} space. ### Bit Manipulation 这个题一眼看到，首先想到的就是使用异或操作，因为异或会导致相同的元素相互抵消为零，所以最后只会剩下哪个只出现一次的元素。 ```go func singleNonDuplicate(nums []int) int { var res int for _, num := range nums { res ^= num } return res } ``` ### Binary Search 这里因为数组有序，并且题目也要求 &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;/katex/katex.</description></item><item><title>0560. Subarray Sum Equals K</title><link>https://example.com/docs/algs/leetcode/560_subarray_sum_equals_k/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/560_subarray_sum_equals_k/</guid><description> Description # Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.
A subarray is a contiguous non-empty sequence of elements within an array.
Solutions # Prefix Sum # 这个题可以使用前缀和的技巧来解决。前缀和相关的介绍可以看 这里。
func subarraySum(nums []int, k int) int { var res int size := len(nums) prefix := make([]int, size+1) // 计算前缀和 idx := 1 for _, num := range nums { prefix[idx] = prefix[idx-1] + num idx++ } // 计算子数组 for i := 1; i &amp;lt;= size; i++ { for j := 0; j &amp;lt; i; j++ { if prefix[i] - prefix[j] == k { res++ } } } return res }</description></item><item><title>0643. Maximum Average Subarray I</title><link>https://example.com/docs/algs/leetcode/643_maximum_average_subarray_i_/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/643_maximum_average_subarray_i_/</guid><description>Description # You are given an integer array nums consisting of n elements, and an integer k.
Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted.
Solutions # Sliding Window # 这题没什么难度，可以用一个固定长度的队列来模拟滑动窗口即可。
func findMaxAverage(nums []int, k int) float64 { var queue []int res, size, sum := math.</description></item><item><title>0867. Transpose Matrix</title><link>https://example.com/docs/algs/leetcode/867_transpose_matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/867_transpose_matrix/</guid><description> Description # Given a 2D integer array matrix, return the transpose of matrix.
The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix&amp;rsquo;s row and column indices.
Solutions # 简言之就是需要行列倒置。
func transpose(matrix [][]int) [][]int { m,n := len(matrix),len(matrix[0]) res := make([][]int, n) for idx, _ := range res { res[idx] = make([]int, m) } for i := 0; i &amp;lt; m; i++ { for j := 0; j &amp;lt; n; j++ { res[j][i] = matrix[i][j] } } return res }</description></item><item><title>1480. Running Sum of 1d Array</title><link>https://example.com/docs/algs/leetcode/1480_running_sum_of_1d_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1480_running_sum_of_1d_array/</guid><description> Description # Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]).
Return the running sum of nums.
Solutions # 简单题，直接看代码就好了。
func runningSum(nums []int) []int { var res []int var pre int for _, num := range nums { pre += num res = append(res, pre) } return res }</description></item></channel></rss>