<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Array on Interview</title><link>https://example.com/tags/Array/</link><description>Recent content in Array on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/Array/index.xml" rel="self" type="application/rss+xml"/><item><title>0026. remove duplicated from sorted array</title><link>https://example.com/docs/algs/leetcode/26_remove_duplicates_from_sorted_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/26_remove_duplicates_from_sorted_array/</guid><description>Description # Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.
Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result.</description></item><item><title>0036. Valid Sudoku</title><link>https://example.com/docs/algs/leetcode/36_valid_sudoku/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/36_valid_sudoku/</guid><description>Description # Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Solutions # 一个是要注意如何快速创建三维数组，另一个是要注意如何进行坐标转换。</description></item><item><title>0041. First Missing Positive</title><link>https://example.com/docs/algs/leetcode/41_first_msssing_positive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/41_first_msssing_positive/</guid><description>Description # Given an unsorted integer array nums, return the smallest missing positive integer.
You must implement an algorithm that runs in O(n) time and uses constant extra space.
Solutions # Hash Table # 可以使用一个 hash table 记录所以出现的值，然后找出当前值中的最大值。然后从 1 到最大值开始遍历，如果出现一个不在 hash table 中的数，则将该数返回即可。如果所有数都出现在了 hash table 中，那么返回最大值加 1 即可。但是最后这里需要注意的是，有可能整个数组都是负数，这样的话会导致前面的判断失效，所以返回值应该最小要返回 1.
func firstMissingPositive(nums []int) int { dict := make(map[int]bool) curMax := nums[0] for _, num := range nums { dict[num] = true if num &amp;gt; curMax { curMax = num } } for i := 1; i &amp;lt;= curMax; i++ { if _, ok := dict[i]; !</description></item><item><title>0042. Traping Rain Water</title><link>https://example.com/docs/algs/leetcode/42_traping_rain_water/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/42_traping_rain_water/</guid><description>Description # Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.
detail see: https://leetcode.com/problems/trapping-rain-water/
Solutions # Array # 使用两个数组扫描两趟，第一个数组 fromLeft 从左到右扫描，记录到目前为止遇到的最大值，第二个数组fromRight 从右向左扫描，记录当前为止遇到的最大值。最后扫描一下这两个数组，对于每个位置 i，取 fromLeft 和 fromRight 二者中的较小者与当前 height[i] 的差值作为当前格子所能盛水量。
func trap(nums []int) int { var res int size := len(nums) if size &amp;lt;= 1 { return res } curMax := nums[0] fromLeft := make([]int, size) for idx, num := range nums { curMax = max(num, curMax) fromLeft[idx] = curMax } curMax = nums[size-1] fromRight := make([]int, size) for i := size-1; i &amp;gt;= 0; i-- { curMax = max(nums[i], curMax) fromRight[i] = curMax } for i := 0; i &amp;lt; size; i++ { res += min(fromLeft[i], fromRight[i]) - nums[i] } return res } func min(a,b int) int { if a &amp;lt; b { return a } return b } func max(a,b int) int { if a &amp;lt; b { return b } return a } 还有一种解法，就是先找出整个数组的最大值，这个最大值将整个数组切分为两部分，然后分别处理左半边和右半边。处理单边的时候，记录自己当前遇到的历史最大值，如果当前值比历史最大值要大，则更新历史最大值为当前值；否则的话说明历史最大值比当前值要大，那么当前值是可以盛水的，则更新结果盛水量。为什么只需要记录当前历史最大值就可以了呢，毕竟能不能盛水其实要靠两边而不是一边啊？答案是我我们已经找出了整个数组的最大值，那么当前的历史最大值只会比整个数组的最大值要小，能盛多少水完全取决于较短的一方（参考短板理论），所以只需要维持一个最大值即可。</description></item><item><title>0048. Rotate Image</title><link>https://example.com/docs/algs/leetcode/48_rotate_image/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/48_rotate_image/</guid><description>Description # You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.
Solutions # 补充几个矩阵变换公式： - 主对角线对折： arr[i][j] = arr[j][i] - 副对角线对折： arr[i][j] = arr[n-j-1][n-i-1] go for i := 0; i &amp;lt; n; i++ { for j := 0; j &amp;lt; n-i; j++ { matrix[i][j], matrix[n-j-1][n-i-1] = matrix[n-j-1][n-i-1], matrix[i][j] } } - 横向对折： arr[i][j] = arr[n-i-1][j] - 纵向对折： arr[i][j] = arr[i][n-j-1]</description></item><item><title>0054. Spiral Matrix</title><link>https://example.com/docs/algs/leetcode/54_spiral_matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/54_spiral_matrix/</guid><description>Description # Given an m x n matrix, return all elements of the matrix in spiral order.
Solutions # 其实就是顺时针旋转打印数组。
func spiralOrder(matrix [][]int) []int { var res []int m, n := len(matrix), len(matrix[0]) up, bottom, left, right := 0, m-1, 0, n - 1 for up &amp;lt;= bottom &amp;amp;&amp;amp; left &amp;lt;= right { for i := left; i &amp;lt;= right; i++ { res = append(res, matrix[up][i]) } up++ if up &amp;gt; bottom { break } for i := up; i &amp;lt;= bottom; i++ { res = append(res, matrix[i][right]) } right-- if right &amp;lt; left { break } for i := right; i &amp;gt;= left; i-- { res = append(res, matrix[bottom][i]) } bottom-- if bottom &amp;lt; up { break } for i := bottom; i &amp;gt;= up;i-- { res = append(res, matrix[i][left]) } left++ if left &amp;gt; right { break } } return res }</description></item><item><title>0380. Insert Delete GetRandom O(1)</title><link>https://example.com/docs/algs/leetcode/380_insert_delete_getrandom_O1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/380_insert_delete_getrandom_O1/</guid><description>Solutions # Hash Table &amp;amp; Array # 这里使用一个 Hash Table 和一个数组，Hash Table 存储的是值和该值在数组中的下标。这里稍微有点 tricky 的是，删除的时候，不是直接在 Hash Table 中删除该元素，而是在数组中将该元素和尾元素调换位置，然后删除尾元素。 这样所有操作都能达到 \( \Omicron(1) \) 的时间复杂度。
import &amp;#34;math/rand&amp;#34; type RandomizedSet struct { dict map[int]int nums []int } func Constructor() RandomizedSet { return RandomizedSet{dict: make(map[int]int), nums: []int{}} } func (this *RandomizedSet) Insert(val int) bool { var present bool if _, ok := (*this).</description></item></channel></rss>