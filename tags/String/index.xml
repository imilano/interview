<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>String on Interview</title><link>https://example.com/tags/String/</link><description>Recent content in String on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/String/index.xml" rel="self" type="application/rss+xml"/><item><title>0003. Longest Substring Without Repeating Characters</title><link>https://example.com/docs/algs/leetcode/03_longest_substring_without_repeatng_characters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/03_longest_substring_without_repeatng_characters/</guid><description>Description # Given a string s, find the length of the longest substring without repeating characters.
Solutions # Hash Table # 中间扩散法，时间复杂度会比较高，因为会有很多的重复扫描。核心思想是，遍历一次字符串，然后对于每个遍历到的位置，从中心向两侧进行扫描，扫描时使用一个 map 来记录那些已经出现过的字符；在一侧扫描过程中，如果发现该字符已经出现过，则停止扫描该侧。最后 map 的长度即为以该字符为中心的不重复字符的长度。
// 对于每个位置的字符，从中间向两侧扫描；使用一个 map 记录已经出现过的字符。在一侧扫描过程中，如果该字符已经出现过，则停止扫描该侧。 // 最后 map 的长度即为以该字符为中心的不重复字符的长度 func lengthOfLongestSubstringSolution1(s string) int { // handle empty string var res int if len(s) &amp;lt;= 1 { return len(s) } for i := 0; i &amp;lt; len(s); i++ { res = max(res, helper(s, i)) } return res } func helper(s string, mid int) int { left, right := mid-1, mid+1 dict := make(map[byte]bool) dict[s[mid]] = true for left &amp;gt; 0 { _, ok := dict[s[left]] if ok { break } dict[s[left]] = true left-- } for right &amp;lt; len(s) { _, ok := dict[s[right]] if ok { break } dict[s[right]] = true right++ } return len(dict) } Sliding Window &amp;amp; Hash Table # 很明显也可以使用滑动窗口配合 Hash Table 的方式来解题。首先固定滑动窗口的左边界，然后将滑动窗口的右边界向右滑动，每滑动一个位置，就检查该位置的字符是否有在当前滑动窗口中出现过(也就是说，既要检查该字符是否在 Hash Table 中出现过，还要检查最近一次出现的下标是否位于滑动窗口之内)，如果出现过，则更新滑动串口左边界。另外，每次遍历都需要更新当前滑动窗口的最大长度。</description></item><item><title>0028. Implement strStr</title><link>https://example.com/docs/algs/leetcode/28_implement_strStr/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/28_implement_strStr/</guid><description>Description # Implement strStr().
Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Solutions # 太简单了在，直接看代码即可。
func strStr(haystack string, needle string) int { var pos int size := len(haystack) targetSize := len(needle) if size == 0 || targetSize == 0 { return pos } var start int pos = -1 for start &amp;lt; size { if haystack[start] !</description></item><item><title>0038. Count and Say</title><link>https://example.com/docs/algs/leetcode/38_count_and_say/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/38_count_and_say/</guid><description>Descrition # The count-and-say sequence is a sequence of digit strings defined by the recursive formula:
countAndSay(1) = &amp;ldquo;1&amp;rdquo; countAndSay(n) is the way you would &amp;ldquo;say&amp;rdquo; the digit string from countAndSay(n-1), which is then converted into a different digit string. To determine how you &amp;ldquo;say&amp;rdquo; a digit string, split it into the minimal number of groups so that each group is a contiguous section all of the same character. Then for each group, say the number of characters, then say the character.</description></item><item><title>0049. Group Anagrams</title><link>https://example.com/docs/algs/leetcode/49_group_anagrams/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/49_group_anagrams/</guid><description>Description # Given an array of strings strs, group the anagrams together. You can return the answer in any order.
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
Solutions # 简单的方法就是，对具有相同字母以及字母出现次数也相同的字符串进行排序时，其排序结果都是一样的。所以可以创建一个 map，其中 key 为字符串的排序，value 为具有这样一个排序结果的字符串数组。
func groupAnagrams(strs []string) [][]string { var res [][]string m := make(map[string][]string) for _, str := range strs { str_splited := strings.</description></item><item><title>0091. Decode Ways</title><link>https://example.com/docs/algs/leetcode/91_decode_ways/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/91_decode_ways/</guid><description>Description # A message containing letters from A-Z can be encoded into numbers using the following mapping:
&amp;lsquo;A&amp;rsquo; -&amp;gt; &amp;ldquo;1&amp;rdquo; &amp;lsquo;B&amp;rsquo; -&amp;gt; &amp;ldquo;2&amp;rdquo; &amp;hellip; &amp;lsquo;Z&amp;rsquo; -&amp;gt; &amp;ldquo;26&amp;rdquo; To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, &amp;ldquo;11106&amp;rdquo; can be mapped into:
&amp;ldquo;AAJF&amp;rdquo; with the grouping (1 1 10 6) &amp;ldquo;KJF&amp;rdquo; with the grouping (11 10 6) Note that the grouping (1 11 06) is invalid because &amp;ldquo;06&amp;rdquo; cannot be mapped into &amp;lsquo;F&amp;rsquo; since &amp;ldquo;6&amp;rdquo; is different from &amp;ldquo;06&amp;rdquo;.</description></item><item><title>0179. Largest Number</title><link>https://example.com/docs/algs/leetcode/179_largest_numbe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/179_largest_numbe/</guid><description>Description # Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.
Since the result may be very large, so you need to return a string instead of an integer.
Solutions # 这里的解法需要十分注意，跟一般的排序是有区别的。
import ( &amp;#34;strconv&amp;#34; &amp;#34;sort&amp;#34; &amp;#34;strings&amp;#34; ) func largestNumber(nums []int) string { var rs []string for _, num := range nums { rs = append(rs, strconv.Itoa(num)) } // 这里应该进行连接排序 sort.</description></item><item><title>0318. Maximum Product of Word Lengths</title><link>https://example.com/docs/algs/leetcode/318_maximum_product_of_word_lengths/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/318_maximum_product_of_word_lengths/</guid><description> Description # Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0.
Solutions # \( \Omicron (n^2) \) 的解法，相当于暴力求解了，因为限定了字符串中只会出现小写字符，而小写字符只有 26 个，那么就可以一个 32 位的 int 值 mask 来记录每个字符是否出现过，然后不同字符的 mask 之间进行相与，如果与的结果为 0，说明这两个字符没有重叠字符，那么就更新结果。
func maxProduct(words []string) int { var res int size := len(words) dict := make(map[int]int, size) for i := 0; i &amp;lt; size; i++ { for _, r := range words[i] { dict[i] |= 1 &amp;lt;&amp;lt; (int(r) - int(&amp;#39;a&amp;#39;)) } for j := 0; j &amp;lt; i; j++ { if (dict[i] &amp;amp; dict[j]) == 0 { res = max(res, len(words[i]) * len(words[j])) } } } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a }</description></item><item><title>0474. Ones and Zeroes</title><link>https://example.com/docs/algs/leetcode/474_ones_and_zeroes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/474_ones_and_zeroes/</guid><description>Description # You are given an array of binary strings strs and two integers m and n.
Return the size of the largest subset of strs such that there are at most m 0&amp;rsquo;s and n 1&amp;rsquo;s in the subset.
A set x is a subset of a set y if all elements of x are also elements of y.
Solutions # 这里很难想到要用动态规划吧。假设 dp[i][j] 表示一个能包含 i 个 0 和 j 个 1 的子集中的字符串个数。则当扫描到字符串str[i]时，统计其中出现0 位 zeros，1 为 ones。则 \(dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones]&amp;#43;1)\) 。</description></item><item><title>0767. Reorganize String</title><link>https://example.com/docs/algs/leetcode/767_reorganizing_string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/767_reorganizing_string/</guid><description>Description # Given a string s, rearrange the characters of s so that any two adjacent characters are not the same.
Return any possible rearrangement of s or return &amp;quot;&amp;quot; if not possible.
Solutions # 这里的解法还是很巧妙的，需要注意一下。
type Pair struct { char byte cnt int } func reorganizeString(s string) string { dict := make(map[byte]int) for idx, _ := range s { dict[s[idx]]++ } var maxHeap MaxHeap heap.Init(&amp;amp;maxHeap) for char, cnt := range dict { if cnt &amp;gt; (len(s)+1)/2 { return &amp;#34;&amp;#34; } heap.</description></item><item><title>1461. Check If a String Contains All Binary Codes of Size K</title><link>https://example.com/docs/algs/leetcode/1461_check_if_a_string_contains_all_binary_codes_of_size_k/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1461_check_if_a_string_contains_all_binary_codes_of_size_k/</guid><description>Description # Given a binary string s and an integer k, return true if every binary code of length k is a substring of s. Otherwise, return false.
Solutions # Brute Force # 下面是题主一开始想出来的方法，可惜最后几个用例过于变态，所以超时了。
func hasAllCodes(s string, k int) bool { size := len(s) if size &amp;lt; k { return false } // golang 格式化打印字符串，%04b 这个格式化字符串能够将数字转换为二进制表示，并且当表示字符串长度小于 4 时，能够自动在前面增加 0 作为 padding。 fmtStr := &amp;#34;%0&amp;#34; + strconv.Itoa(k) + &amp;#34;b&amp;#34; maxEle := int(math.</description></item></channel></rss>