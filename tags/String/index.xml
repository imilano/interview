<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>String on Interview</title><link>https://example.com/tags/String/</link><description>Recent content in String on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/String/index.xml" rel="self" type="application/rss+xml"/><item><title>0003. Longest Substring Without Repeating Characters</title><link>https://example.com/docs/algs/leetcode/03_longest_substring_without_repeatng_characters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/03_longest_substring_without_repeatng_characters/</guid><description>Description # Given a string s, find the length of the longest substring without repeating characters.
Solutions # Hash Table # 中间扩散法，时间复杂度会比较高，因为会有很多的重复扫描。核心思想是，遍历一次字符串，然后对于每个遍历到的位置，从中心向两侧进行扫描，扫描时使用一个 map 来记录那些已经出现过的字符；在一侧扫描过程中，如果发现该字符已经出现过，则停止扫描该侧。最后 map 的长度即为以该字符为中心的不重复字符的长度。
// 对于每个位置的字符，从中间向两侧扫描；使用一个 map 记录已经出现过的字符。在一侧扫描过程中，如果该字符已经出现过，则停止扫描该侧。 // 最后 map 的长度即为以该字符为中心的不重复字符的长度 func lengthOfLongestSubstringSolution1(s string) int { // handle empty string var res int if len(s) &amp;lt;= 1 { return len(s) } for i := 0; i &amp;lt; len(s); i++ { res = max(res, helper(s, i)) } return res } func helper(s string, mid int) int { left, right := mid-1, mid+1 dict := make(map[byte]bool) dict[s[mid]] = true for left &amp;gt; 0 { _, ok := dict[s[left]] if ok { break } dict[s[left]] = true left-- } for right &amp;lt; len(s) { _, ok := dict[s[right]] if ok { break } dict[s[right]] = true right++ } return len(dict) } Sliding Window &amp;amp; Hash Table # 很明显也可以使用滑动窗口配合 Hash Table 的方式来解题。首先固定滑动窗口的左边界，然后将滑动窗口的右边界向右滑动，每滑动一个位置，就检查该位置的字符是否有在当前滑动窗口中出现过(也就是说，既要检查该字符是否在 Hash Table 中出现过，还要检查最近一次出现的下标是否位于滑动窗口之内)，如果出现过，则更新滑动串口左边界。另外，每次遍历都需要更新当前滑动窗口的最大长度。</description></item><item><title>0005. Longest Palindrome Substring</title><link>https://example.com/docs/algs/leetcode/05_longest_palindrome_substring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/05_longest_palindrome_substring/</guid><description>Description # Given a string s, return the longest palindromic substring in s.
Solutions # 中心扩散 # 题主首先想到的是中心扩散方法。核心思想就是遍历以此字符串，然后对于遍历到的每个位置，找出以这个位置为中心能找到的最长回文串。需要注意的是，一个回文串可能是偶数长度，也可能是奇数长度。如果是奇数长度，那么就需要以 i 为中心来对左右进行扩散；而如果是偶数长度，那么就需要以 i 和 i-1 为中心来进行扩散。
func longestPalindrome(s string) string { size := len(s) if size &amp;lt;= 1 { return s } var res string for i := 0; i &amp;lt; size; i++ { // 最长回文串可能会出现在以 i 为中心对称的子串上，也可能出现在以 i 和 i - 1 为中心的子串上 r1 := longestPalindromeHelper(s, i, i, size) r2 := longestPalindromeHelper(s, i-1, i, size) res = getMaxString(r1, r2, res) } return res } func longestPalindromeHelper(s string, left, right, size int) string { var res string for left &amp;gt;= 0 &amp;amp;&amp;amp; right &amp;lt; size { if s[left] == s[right] { // res 放在这里更新，这样的话，就不用写判断 left 和 right 是否有效的逻辑了 res = s[left : right+1] left-- right++ } else { break } } return res } func getMaxString(a, b, s string) string { if len(a) &amp;lt; len(b) { if len(b) &amp;lt; len(s) { return s } else { return b } } else { if len(a) &amp;lt; len(s) { return s } else { return a } } } Longest Common Stirng # 将输入字符串逆转之后，原问题就可以转换为求最长公共子串(leetcode 第 718 题)的问题。</description></item><item><title>0028. Implement strStr</title><link>https://example.com/docs/algs/leetcode/28_implement_strStr/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/28_implement_strStr/</guid><description>Description # Implement strStr().
Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Solutions # 太简单了在，直接看代码即可。
func strStr(haystack string, needle string) int { var pos int size := len(haystack) targetSize := len(needle) if size == 0 || targetSize == 0 { return pos } var start int pos = -1 for start &amp;lt; size { if haystack[start] !</description></item><item><title>0038. Count and Say</title><link>https://example.com/docs/algs/leetcode/38_count_and_say/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/38_count_and_say/</guid><description>Descrition # The count-and-say sequence is a sequence of digit strings defined by the recursive formula:
countAndSay(1) = &amp;ldquo;1&amp;rdquo; countAndSay(n) is the way you would &amp;ldquo;say&amp;rdquo; the digit string from countAndSay(n-1), which is then converted into a different digit string. To determine how you &amp;ldquo;say&amp;rdquo; a digit string, split it into the minimal number of groups so that each group is a contiguous section all of the same character. Then for each group, say the number of characters, then say the character.</description></item><item><title>0049. Group Anagrams</title><link>https://example.com/docs/algs/leetcode/49_group_anagrams/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/49_group_anagrams/</guid><description>Description # Given an array of strings strs, group the anagrams together. You can return the answer in any order.
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
Solutions # 简单的方法就是，对具有相同字母以及字母出现次数也相同的字符串进行排序时，其排序结果都是一样的。所以可以创建一个 map，其中 key 为字符串的排序，value 为具有这样一个排序结果的字符串数组。
func groupAnagrams(strs []string) [][]string { var res [][]string m := make(map[string][]string) for _, str := range strs { str_splited := strings.</description></item><item><title>0066. Plus One</title><link>https://example.com/docs/algs/leetcode/66_plus_one/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/66_plus_one/</guid><description>Description # You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0&amp;rsquo;s.
Increment the large integer by one and return the resulting array of digits.
Solutions # 简单题，直接计算即可。
func plusOne(digits []int) []int { size := len(digits) if size == 0 { return digits } carry := 1 for i := size-1; i &amp;gt;= 0; i-- { sum := digits[i] + carry carry = sum / 10 digits[i] = sum % 10 } if carry &amp;gt; 0 { digits = append([]int{carry}, digits.</description></item><item><title>0091. Decode Ways</title><link>https://example.com/docs/algs/leetcode/91_decode_ways/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/91_decode_ways/</guid><description>Description # A message containing letters from A-Z can be encoded into numbers using the following mapping:
&amp;lsquo;A&amp;rsquo; -&amp;gt; &amp;ldquo;1&amp;rdquo; &amp;lsquo;B&amp;rsquo; -&amp;gt; &amp;ldquo;2&amp;rdquo; &amp;hellip; &amp;lsquo;Z&amp;rsquo; -&amp;gt; &amp;ldquo;26&amp;rdquo; To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, &amp;ldquo;11106&amp;rdquo; can be mapped into:
&amp;ldquo;AAJF&amp;rdquo; with the grouping (1 1 10 6) &amp;ldquo;KJF&amp;rdquo; with the grouping (11 10 6) Note that the grouping (1 11 06) is invalid because &amp;ldquo;06&amp;rdquo; cannot be mapped into &amp;lsquo;F&amp;rsquo; since &amp;ldquo;6&amp;rdquo; is different from &amp;ldquo;06&amp;rdquo;.</description></item><item><title>0125. Valid Palindrome</title><link>https://example.com/docs/algs/leetcode/125_valid_palindrome/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/125_valid_palindrome/</guid><description>Description # A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.
Given a string s, return true if it is a palindrome, or false otherwise.
Solutions # Two Pointer # 简单题，去除非数字字母的字符之后直接判断即可。
func isPalindrome(s string) bool { var rs []rune for _, r := range s { // skip none-alphanumeric characters if !</description></item><item><title>0179. Largest Number</title><link>https://example.com/docs/algs/leetcode/179_largest_numbe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/179_largest_numbe/</guid><description>Description # Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.
Since the result may be very large, so you need to return a string instead of an integer.
Solutions # 这里的解法需要十分注意，跟一般的排序是有区别的。
import ( &amp;#34;strconv&amp;#34; &amp;#34;sort&amp;#34; &amp;#34;strings&amp;#34; ) func largestNumber(nums []int) string { var rs []string for _, num := range nums { rs = append(rs, strconv.Itoa(num)) } // 这里应该进行连接排序 sort.</description></item><item><title>0318. Maximum Product of Word Lengths</title><link>https://example.com/docs/algs/leetcode/318_maximum_product_of_word_lengths/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/318_maximum_product_of_word_lengths/</guid><description> Description # Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0.
Solutions # \( \Omicron (n^2) \) 的解法，相当于暴力求解了，因为限定了字符串中只会出现小写字符，而小写字符只有 26 个，那么就可以一个 32 位的 int 值 mask 来记录每个字符是否出现过，然后不同字符的 mask 之间进行相与，如果与的结果为 0，说明这两个字符没有重叠字符，那么就更新结果。
func maxProduct(words []string) int { var res int size := len(words) dict := make(map[int]int, size) for i := 0; i &amp;lt; size; i++ { for _, r := range words[i] { dict[i] |= 1 &amp;lt;&amp;lt; (int(r) - int(&amp;#39;a&amp;#39;)) } for j := 0; j &amp;lt; i; j++ { if (dict[i] &amp;amp; dict[j]) == 0 { res = max(res, len(words[i]) * len(words[j])) } } } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a }</description></item><item><title>0409. Longest Palindrome</title><link>https://example.com/docs/algs/leetcode/409_longest_palindrome/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/409_longest_palindrome/</guid><description> Description # Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.
Letters are case sensitive, for example, &amp;ldquo;Aa&amp;rdquo; is not considered a palindrome here.
Solutions # Hash Table # 回文串有两种形式，一种是xxyy，另一种是xxyzz，也就是说，两边的字符需要出现偶数次，那么这里就可以转换为统计出现偶数次的字符的数量。在统计的过程中，如果发现有一个字符出现了奇数次，那么这个奇数次的字符就可以放在回文串的中心，那么就需要记录一下，最后在结果上加上 1.
func longestPalindrome(s string) int { // 统计每个字符出现的次数 size := len(s) dict := make(map[byte]int) for i := 0; i &amp;lt; size; i++ { dict[s[i]]++ } var res int var addMid bool for _, num := range dict { res += num // 如果出现了奇数次，那么只取最大的偶数，也就是要减去 1 // 如果只是出现了一次的话，那么这里相当于没有加 if num % 2 == 1 { res -= 1 // 回文串有两种类型，一种是中间一个字符然后两边对称的形式， // 也就是说，如果有一个字符出现了奇数次，那么最后可以考虑把这个字符加上。 addMid = true } } if addMid { res += 1 } return res }</description></item><item><title>0474. Ones and Zeroes</title><link>https://example.com/docs/algs/leetcode/474_ones_and_zeroes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/474_ones_and_zeroes/</guid><description>Description # You are given an array of binary strings strs and two integers m and n.
Return the size of the largest subset of strs such that there are at most m 0&amp;rsquo;s and n 1&amp;rsquo;s in the subset.
A set x is a subset of a set y if all elements of x are also elements of y.
Solutions # 这里很难想到要用动态规划吧。假设 dp[i][j] 表示一个能包含 i 个 0 和 j 个 1 的子集中的字符串个数。则当扫描到字符串str[i]时，统计其中出现0 位 zeros，1 为 ones。则 \(dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones]&amp;#43;1)\) 。</description></item><item><title>0583. Delete Operations for Two Strings</title><link>https://example.com/docs/algs/leetcode/583_delete_operation_for_two_strings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/583_delete_operation_for_two_strings/</guid><description>Description # Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same.
In one step, you can delete exactly one character in either string.
Solutions # DP # 求最少的删除步数来使两个字符串一致，其实就是求两个字符串的最长公共子序列（注意，子序列意味着可以不连续），最少的步数就是二者的长度之和减去最长公共子序列的两倍。所以问题就是如何求两个字符串的最长公共子序列。定义 dp[i][j] 表示 str1（假设长度为m）的前i个字符和str2（假设长度为n）的前j个字符的最长公共子序列的长度，根据这个定义，我们最求所求的值就是dp[m][n]，那么我们应该申请的数组就是 (m+1) * (n+1)的二维数组。
当 str1[i] 和 str2[j] 相等时，dp[i][j] 的值取决于str1的前i-1个i个字符和str2的前j个字符的最长公共子序列，也就是说， dp[i][j] = dp[i-1][j-1] + 1; 当 str1[i] 和 str2[j] 不相等时， 由于所求的时最大长度，dp[i][j] 的值就继承于 dp[i-1][j] 和 dp[i][j-1]中的较大者。 而对于初始条件，可以轻松得到， dp[0][j] = dp[i][0] = 0。</description></item><item><title>0647. Palindromic Substrings</title><link>https://example.com/docs/algs/leetcode/647_palindromic_substrings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/647_palindromic_substrings/</guid><description>Description # Given a string s, return the number of palindromic substrings in it.
A string is a palindrome when it reads the same backward as forward.
A substring is a contiguous sequence of characters within the string.
Solutions # Two Pointer # 回文串的解法都是相对比较单一的，这里还是沿用老套路：遍历字符串中的每个位置，检查以这个位置为中心，或者以这个位置和前一个位置为中心的字符是否能组成回文串，检查的时候把 res 传到子函数中去，这样就可以更新 res 。
func countSubstrings(s string) int { var res int size := len(s) for i := 0; i &amp;lt; size; i++ { findPalindrome(s, i,i,size,&amp;amp;res) findPalindrome(s,i-1,i,size,&amp;amp;res) } return res } func findPalindrome(s string, left,right,size int, res *int) { for left &amp;gt;= 0 &amp;amp;&amp;amp; right &amp;lt; size { if s[left] !</description></item><item><title>0718. Maximum Length of Repeated Subarray</title><link>https://example.com/docs/algs/leetcode/718_maximum_length_of_repeated_subarray/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/718_maximum_length_of_repeated_subarray/</guid><description> Description # Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays.
Solutions # Dynamic Programming # 定义 dp[i][j]表示 nums1 中以 i 为结尾的子数组和 nums2 中以 j 为结尾的子数组当前的匹配的最长公共子数组的长度。如果 nums1[i] == num2[j]，说明当前两个数字相同，那么当前最长公共子数组的长度就是 nums1 以 i-1 为结尾的子数组和 nums2 以 j-1 为结尾的子数组的最长公共子数组的长度加 1，即 dp[i][j] = dp[i-1][j-1] + 1；否则说明二者当前无公共子子数组或者公共子数组在当前位置不连续，则dp[i][j] = 0。
func findLength(nums1 []int, nums2 []int) int { m,n := len(nums1), len(nums2) dp := make([][]int, m+1) for idx, _ := range dp { dp[idx] = make([]int, n + 1) } var res int for i := 1; i &amp;lt;= m;i++ { for j := 1; j &amp;lt;= n; j++ { if nums1[i-1] == nums2[j-1] { dp[i][j] = dp[i-1][j-1] + 1 res = max(res, dp[i][j]) } else { dp[i][j] = 0 } } } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a }</description></item><item><title>0745. Prefix and Suffix Search</title><link>https://example.com/docs/algs/leetcode/745_prefix_and_suffix_search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/745_prefix_and_suffix_search/</guid><description>Description # Design a special dictionary with some words that searchs the words in it by a prefix and a suffix.
Implement the WordFilter class:
WordFilter(string[] words) Initializes the object with the words in the dictionary. f(string prefix, string suffix) Returns the index of the word in the dictionary, which has the prefix prefix and the suffix suffix. If there is more than one valid index, return the largest of them.</description></item><item><title>0767. Reorganize String</title><link>https://example.com/docs/algs/leetcode/767_reorganizing_string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/767_reorganizing_string/</guid><description>Description # Given a string s, rearrange the characters of s so that any two adjacent characters are not the same.
Return any possible rearrangement of s or return &amp;quot;&amp;quot; if not possible.
Solutions # 这里的解法还是很巧妙的，需要注意一下。
type Pair struct { char byte cnt int } func reorganizeString(s string) string { dict := make(map[byte]int) for idx, _ := range s { dict[s[idx]]++ } var maxHeap MaxHeap heap.Init(&amp;amp;maxHeap) for char, cnt := range dict { if cnt &amp;gt; (len(s)+1)/2 { return &amp;#34;&amp;#34; } heap.</description></item><item><title>0820. Short Encoding of Words</title><link>https://example.com/docs/algs/leetcode/820_short_encoding_of_words/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/820_short_encoding_of_words/</guid><description> Description # Solutions # Hash Table # 这道题给了我们一个单词数组，让我们对其编码，不同的单词之间加入#号，每个单词的起点放在一个坐标数组内，终点就是#号，能合并的单词要进行合并，问输入字符串的最短长度。题意不难理解，难点在于如何合并单词，我们观察题目的那个例子，me和time是能够合并的，只要标清楚其实位置，time的起始位置是0，me的起始位置是2，那么根据#号位置的不同就可以顺利的取出me和time。需要注意的是，如果me换成im，或者tim的话，就不能合并了，因为我们是要从起始位置到#号之前所有的字符都要取出来。
这里使用 Hash Table 来做，将所有的单词先放到这个Hash Table 中。原理是对于每个单词，我们遍历其所有的后缀，比如time，那么就遍历ime，me，e，然后看 Hash Table 中是否存在这些后缀，有的话就删掉，那么 Hash Table 中的 me 就会被删掉，这样保证了留下来的单词不可能再合并了，最后再加上每个单词的长度到结果 res，并且同时要加上 # 号的长度。
func minimumLengthEncoding(words []string) int { // 先将每个单词放进 hash 表中 dict := make(map[string]bool) for _, word := range words { dict[word] = true } // 对于 words 中的每个单词，找到其每个后缀，查看该后缀是否在 dict 中，如果在的话，则从 dict 中将该后缀删除 for _, word := range words { size := len(word) for i := 1; i &amp;lt; size; i++ { if _, ok := dict[word[i:]]; ok { delete(dict, word[i:]) } } } // 最后 dict 中剩下来的字符串都是不能合并的字符串，因为每个字符串和周围的字符串都要有一个#分隔，最后一个位置也需要一个#分隔， // 所以可以遍历 dict 中剩下的每个字符串，将其长度加 1 放到 res 中 var res int for word, _ := range dict { res += len(word) + 1 } return res }</description></item><item><title>1048. Longest String Chain</title><link>https://example.com/docs/algs/leetcode/1048_longest_string_chain/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1048_longest_string_chain/</guid><description>Description # You are given an array of words where each word consists of lowercase English letters.
wordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB.
For example, &amp;quot;abc&amp;quot; is a predecessor of &amp;quot;abac&amp;quot;, while &amp;quot;cba&amp;quot; is not a predecessor of &amp;quot;bcad&amp;quot;. A word chain is a sequence of words [word1, word2, .</description></item><item><title>1062. Longest Repeating Substring</title><link>https://example.com/docs/algs/leetcode/1062_longest_repeating_substring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1062_longest_repeating_substring/</guid><description> Description # Given a string S, find out the length of the longest repeating substring(s). Return 0 if no repeating substring exists.
Solutions # Dynamic Programming # 这种什么最长、最大的题目，当然是使用 DP 来解啦，不过题主想了好一会也没想到该怎么定义状态方程，只好上网去看各路大神怎么搞的：这里定了 dp[i][j] 表示 s 中以第 i 个字符为结尾的子串为和以第 j 个字符为结尾的子串的最大公共后缀的长度。当s[i] == s[j] 时，dp[i][j] = dp[i-1][j-1] + 1；否则，dp[i][j] = 0。在 dp 更新的过程中，不断保存最大值即可。
这里 DP 的递推式跟「718. Maximum Length of Repeated Subarray」是一致的。
func longestRepeatingSubstring(s string) int { res,size := math.MinInt, len(s) dp := make([]int, size + 1) for idx, _ := range dp { dp[idx] = make([]int, size + 1) } for i := 1; i &amp;lt;= size; i++ { for j := 1; j &amp;lt;i;j++ { if s[i-1] == s[j-1] { dp[i][j] = dp[i-1][j-1] + 1 } res = max(res, dp[i][j]) } } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a }</description></item><item><title>1461. Check If a String Contains All Binary Codes of Size K</title><link>https://example.com/docs/algs/leetcode/1461_check_if_a_string_contains_all_binary_codes_of_size_k/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1461_check_if_a_string_contains_all_binary_codes_of_size_k/</guid><description>Description # Given a binary string s and an integer k, return true if every binary code of length k is a substring of s. Otherwise, return false.
Solutions # Brute Force # 下面是题主一开始想出来的方法，可惜最后几个用例过于变态，所以超时了。
func hasAllCodes(s string, k int) bool { size := len(s) if size &amp;lt; k { return false } // golang 格式化打印字符串，%04b 这个格式化字符串能够将数字转换为二进制表示，并且当表示字符串长度小于 4 时，能够自动在前面增加 0 作为 padding。 fmtStr := &amp;#34;%0&amp;#34; + strconv.Itoa(k) + &amp;#34;b&amp;#34; maxEle := int(math.</description></item><item><title>1689. Partitioning Into Minimum Number of Deci-Binary Numbers</title><link>https://example.com/docs/algs/leetcode/1689_partitioning_into_minimum_number_of_deci-binary_numbers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1689_partitioning_into_minimum_number_of_deci-binary_numbers/</guid><description>Description # A decimal number is called deci-binary if each of its digits is either 0 or 1 without any leading zeros. For example, 101 and 1100 are deci-binary, while 112 and 3001 are not.
Given a string n that represents a positive decimal integer, return the minimum number of positive deci-binary numbers needed so that they sum up to n.
Solutions # 这题题主以为是要用动态规划之类的解法来做，结果想了好一会都没想出来，然后到网上去搜大神们答案，于是搜到了 这个。看完答案，我只想说，人和人真的，天壤之别&amp;hellip;
这里的解法浓缩成一句话就是：答案就是 n 这个字符串中最大的数字（指 0-9 之间）。翻译一下大佬的证明就是：</description></item></channel></rss>