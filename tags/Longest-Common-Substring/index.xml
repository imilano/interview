<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Longest Common Substring on Interview</title><link>https://example.com/tags/Longest-Common-Substring/</link><description>Recent content in Longest Common Substring on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/Longest-Common-Substring/index.xml" rel="self" type="application/rss+xml"/><item><title>0005. Longest Palindrome Substring</title><link>https://example.com/docs/algs/leetcode/05_longest_palindrome_substring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/05_longest_palindrome_substring/</guid><description>Description # Given a string s, return the longest palindromic substring in s.
Solutions # 中心扩散 # 题主首先想到的是中心扩散方法。核心思想就是遍历以此字符串，然后对于遍历到的每个位置，找出以这个位置为中心能找到的最长回文串。需要注意的是，一个回文串可能是偶数长度，也可能是奇数长度。如果是奇数长度，那么就需要以 i 为中心来对左右进行扩散；而如果是偶数长度，那么就需要以 i 和 i-1 为中心来进行扩散。
func longestPalindrome(s string) string { size := len(s) if size &amp;lt;= 1 { return s } var res string for i := 0; i &amp;lt; size; i++ { // 最长回文串可能会出现在以 i 为中心对称的子串上，也可能出现在以 i 和 i - 1 为中心的子串上 r1 := longestPalindromeHelper(s, i, i, size) r2 := longestPalindromeHelper(s, i-1, i, size) res = getMaxString(r1, r2, res) } return res } func longestPalindromeHelper(s string, left, right, size int) string { var res string for left &amp;gt;= 0 &amp;amp;&amp;amp; right &amp;lt; size { if s[left] == s[right] { // res 放在这里更新，这样的话，就不用写判断 left 和 right 是否有效的逻辑了 res = s[left : right+1] left-- right++ } else { break } } return res } func getMaxString(a, b, s string) string { if len(a) &amp;lt; len(b) { if len(b) &amp;lt; len(s) { return s } else { return b } } else { if len(a) &amp;lt; len(s) { return s } else { return a } } } Longest Common Stirng # 将输入字符串逆转之后，原问题就可以转换为求最长公共子串(leetcode 第 718 题)的问题。</description></item><item><title>0718. Maximum Length of Repeated Subarray</title><link>https://example.com/docs/algs/leetcode/718_maximum_length_of_repeated_subarray/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/718_maximum_length_of_repeated_subarray/</guid><description> Description # Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays.
Solutions # Dynamic Programming # 定义 dp[i][j]表示 nums1 中以 i 为结尾的子数组和 nums2 中以 j 为结尾的子数组当前的匹配的最长公共子数组的长度。如果 nums1[i] == num2[j]，说明当前两个数字相同，那么当前最长公共子数组的长度就是 nums1 以 i-1 为结尾的子数组和 nums2 以 j-1 为结尾的子数组的最长公共子数组的长度加 1，即 dp[i][j] = dp[i-1][j-1] + 1；否则说明二者当前无公共子子数组或者公共子数组在当前位置不连续，则dp[i][j] = 0。
func findLength(nums1 []int, nums2 []int) int { m,n := len(nums1), len(nums2) dp := make([][]int, m+1) for idx, _ := range dp { dp[idx] = make([]int, n + 1) } var res int for i := 1; i &amp;lt;= m;i++ { for j := 1; j &amp;lt;= n; j++ { if nums1[i-1] == nums2[j-1] { dp[i][j] = dp[i-1][j-1] + 1 res = max(res, dp[i][j]) } else { dp[i][j] = 0 } } } return res } func max(a,b int) int { if a &amp;lt; b { return b } return a }</description></item></channel></rss>