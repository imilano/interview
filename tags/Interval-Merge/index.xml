<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Interval Merge on Interview</title><link>https://example.com/tags/Interval-Merge/</link><description>Recent content in Interval Merge on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/Interval-Merge/index.xml" rel="self" type="application/rss+xml"/><item><title>0056. Merge Intervals</title><link>https://example.com/docs/algs/leetcode/56_merge_intervals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/56_merge_intervals/</guid><description>Description # Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.
Solutions # 典型的区间合并问题。
首先先对区间按照开始时间从小到大进行排序，然后使用一个指针 cur 指向当前 intervals 数组遍历到的位置，使用一个指针 tail 指向 res 数组最后一个元素。然后开始对 intervals 数组进行遍历，如果当前遍历到的区间跟 res 数组的最后一个区间没有重叠，则直接将这个区间插入 res 数组，然后 tail 自增；否则的话就合并区间，更新 res[tail] 的结束时间；每次遍历结束，cur 自增。
func merge(intervals [][]int) [][]int { var res [][]int size := len(intervals) if size &amp;lt;= 1 { return intervals } sort.</description></item></channel></rss>