<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Iterative on Interview</title><link>https://example.com/tags/Iterative/</link><description>Recent content in Iterative on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/Iterative/index.xml" rel="self" type="application/rss+xml"/><item><title>0104. Maximum Depth of Binary Tree</title><link>https://example.com/docs/algs/leetcode/104_maximum_depth_of_binary_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/104_maximum_depth_of_binary_tree/</guid><description>Description # Given the root of a binary tree, return its maximum depth.
A binary tree&amp;rsquo;s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
Solutions # Recursive # 简单题，无需多说。
func maxDepth(root *TreeNode) int { if root == nil { return 0 } return max(maxDepth(root.Left), maxDepth(root.Right)) + 1 } func max(a,b int) int { if a &amp;lt; b { return b } return a } Iterative # 这里只需要使用层次遍历，看最多可以遍历几层即可。</description></item><item><title>0111. Minimum Depth of Binary Tree</title><link>https://example.com/docs/algs/leetcode/111_minimum_depth_of_binary_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/111_minimum_depth_of_binary_tree/</guid><description>Description # Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.
A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.
Solutions # Iterative # 只需要简单的层次遍历，终止条件就是当队列中出现一个左右子节点均为空节点的节点即可。
type TreeNode struct { Val int Left *TreeNode Right *TreeNode } func minDepth(root *TreeNode) int { if root == nil { return 0 } var queue []*TreeNode = []*TreeNode{root} var depth int for len(queue) !</description></item><item><title>0235. Lowest Common Ancestor of Binary Search Tree</title><link>https://example.com/docs/algs/leetcode/235_lowest_common_ancestor_of_a_binary_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/235_lowest_common_ancestor_of_a_binary_tree/</guid><description>Description # Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”
Solutions # Recursive # 这题很简单，因为 BST 本身就具备有序的性质，所以我们只需要抓住这个性质来进行遍历即可。首先我们假设 p 比 q 要小，那么对于递归遍历到的每个节点 root， 如果 root 的值大于最大 q 的值，那么说明最小公共节点一并比 root 要小，我们需要往root 的左子树进行查找；如果 root 的值小于最小值 p 的值，那么说明最小公共祖先一定比 p 要大，那么我们需要往 p 的右节点进行查找；否则，说明 root 的值刚好结余 p 和 q 之间，此时 root 就是我们所查找的最小公共组节点，返回 root 即可。</description></item></channel></rss>