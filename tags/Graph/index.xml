<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Graph on Interview</title><link>https://example.com/tags/Graph/</link><description>Recent content in Graph on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/Graph/index.xml" rel="self" type="application/rss+xml"/><item><title>0130. Surrounded Regions</title><link>https://example.com/docs/algs/leetcode/130_surrounded_regions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/130_surrounded_regions/</guid><description> Description # Given an m x n matrix board containing &amp;lsquo;X&amp;rsquo; and &amp;lsquo;O&amp;rsquo;, capture all regions that are 4-directionally surrounded by &amp;lsquo;X&amp;rsquo;.
A region is captured by flipping all &amp;lsquo;O&amp;rsquo;s into &amp;lsquo;X&amp;rsquo;s in that surrounded region.
Solutions # DFS # 这个题的难点在于，对于从边上的&amp;rsquo;O&amp;rsquo;为起点的所有可达的&amp;rsquo;O&amp;rsquo;，在最后的结果中要保留。那么也就是所，在遍历中，需要对从边上的&amp;rsquo;O&amp;rsquo;可达到的所有&amp;rsquo;O&amp;rsquo;做一个特殊处理。这里首先遍历四条边，如果当前点是&amp;rsquo;O&amp;rsquo;，那么从当前点开始进行DFS，对于每个可达的&amp;rsquo;O&amp;rsquo;点，都将其设置为&amp;rsquo;Y&amp;rsquo;，表示这个点不需要处理。上面的处理结束之后，剩下的&amp;rsquo;O&amp;rsquo;都是需要处理的&amp;rsquo;O&amp;rsquo;，那么只需要再遍历一遍矩阵，将每个‘O’设置为&amp;rsquo;X&amp;rsquo;,同事将那么设置为&amp;rsquo;Y&amp;rsquo;的点还原为&amp;rsquo;O&amp;rsquo;即可。
var dirs [][]int = [][]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}} func solve(board [][]byte) { rows, cols := len(board), len(board[0]) // 先从边上的每个 &amp;#39;o&amp;#39;开始遍历，将其可达的所有 &amp;#39;o&amp;#39;都标记为 &amp;#39;y&amp;#39; for i := 0; i &amp;lt; rows; i++ { if board[i][cols-1] == &amp;#39;O&amp;#39; { dfs(board, i, cols-1, rows, cols) } if board[i][0] == &amp;#39;O&amp;#39; { dfs(board, i, 0, rows, cols) } } for i := 0; i &amp;lt; cols; i++ { if board[0][i] == &amp;#39;O&amp;#39; { dfs(board, 0, i, rows, cols) } if board[rows-1][i] == &amp;#39;O&amp;#39; { dfs(board, rows-1, i, rows, cols) } } for i := 0; i &amp;lt; rows; i++ { for j := 0; j &amp;lt; cols; j++ { // 对于剩余的每个 &amp;#39;o&amp;#39;，将其变为 &amp;#39;x&amp;#39; if board[i][j] == &amp;#39;O&amp;#39; { board[i][j] = &amp;#39;X&amp;#39; } // 将每个&amp;#39;y&amp;#39;还原为&amp;#39;o&amp;#39; if board[i][j] == &amp;#39;Y&amp;#39; { board[i][j] = &amp;#39;O&amp;#39; } } } } func dfs(board [][]byte, row, col, rows, cols int) { if row &amp;lt; 0 || row &amp;gt;= rows || col &amp;lt; 0 || col &amp;gt;= cols || board[row][col] == &amp;#39;X&amp;#39; || board[row][col] == &amp;#39;Y&amp;#39; { return } if board[row][col] == &amp;#39;O&amp;#39; { board[row][col] = &amp;#39;Y&amp;#39; } for _, dir := range dirs { dfs(board, row+dir[0], col + dir[1], rows, cols) } }</description></item><item><title>0133. Clone Graph</title><link>https://example.com/docs/algs/leetcode/133_clone_graph/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/133_clone_graph/</guid><description>Description # Given a reference of a node in a connected undirected graph.
Return a deep copy (clone) of the graph.
Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.
class Node { public int val; public List&amp;lt;Node&amp;gt; neighbors; } Test case format:
For simplicity, each node&amp;rsquo;s value is the same as the node&amp;rsquo;s index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on.</description></item></channel></rss>