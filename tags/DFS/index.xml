<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DFS on Interview</title><link>https://example.com/tags/DFS/</link><description>Recent content in DFS on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/DFS/index.xml" rel="self" type="application/rss+xml"/><item><title>0130. Surrounded Regions</title><link>https://example.com/docs/algs/leetcode/130_surrounded_regions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/130_surrounded_regions/</guid><description> Description # Given an m x n matrix board containing &amp;lsquo;X&amp;rsquo; and &amp;lsquo;O&amp;rsquo;, capture all regions that are 4-directionally surrounded by &amp;lsquo;X&amp;rsquo;.
A region is captured by flipping all &amp;lsquo;O&amp;rsquo;s into &amp;lsquo;X&amp;rsquo;s in that surrounded region.
Solutions # DFS # 这个题的难点在于，对于从边上的&amp;rsquo;O&amp;rsquo;为起点的所有可达的&amp;rsquo;O&amp;rsquo;，在最后的结果中要保留。那么也就是所，在遍历中，需要对从边上的&amp;rsquo;O&amp;rsquo;可达到的所有&amp;rsquo;O&amp;rsquo;做一个特殊处理。这里首先遍历四条边，如果当前点是&amp;rsquo;O&amp;rsquo;，那么从当前点开始进行DFS，对于每个可达的&amp;rsquo;O&amp;rsquo;点，都将其设置为&amp;rsquo;Y&amp;rsquo;，表示这个点不需要处理。上面的处理结束之后，剩下的&amp;rsquo;O&amp;rsquo;都是需要处理的&amp;rsquo;O&amp;rsquo;，那么只需要再遍历一遍矩阵，将每个‘O’设置为&amp;rsquo;X&amp;rsquo;,同事将那么设置为&amp;rsquo;Y&amp;rsquo;的点还原为&amp;rsquo;O&amp;rsquo;即可。
var dirs [][]int = [][]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}} func solve(board [][]byte) { rows, cols := len(board), len(board[0]) // 先从边上的每个 &amp;#39;o&amp;#39;开始遍历，将其可达的所有 &amp;#39;o&amp;#39;都标记为 &amp;#39;y&amp;#39; for i := 0; i &amp;lt; rows; i++ { if board[i][cols-1] == &amp;#39;O&amp;#39; { dfs(board, i, cols-1, rows, cols) } if board[i][0] == &amp;#39;O&amp;#39; { dfs(board, i, 0, rows, cols) } } for i := 0; i &amp;lt; cols; i++ { if board[0][i] == &amp;#39;O&amp;#39; { dfs(board, 0, i, rows, cols) } if board[rows-1][i] == &amp;#39;O&amp;#39; { dfs(board, rows-1, i, rows, cols) } } for i := 0; i &amp;lt; rows; i++ { for j := 0; j &amp;lt; cols; j++ { // 对于剩余的每个 &amp;#39;o&amp;#39;，将其变为 &amp;#39;x&amp;#39; if board[i][j] == &amp;#39;O&amp;#39; { board[i][j] = &amp;#39;X&amp;#39; } // 将每个&amp;#39;y&amp;#39;还原为&amp;#39;o&amp;#39; if board[i][j] == &amp;#39;Y&amp;#39; { board[i][j] = &amp;#39;O&amp;#39; } } } } func dfs(board [][]byte, row, col, rows, cols int) { if row &amp;lt; 0 || row &amp;gt;= rows || col &amp;lt; 0 || col &amp;gt;= cols || board[row][col] == &amp;#39;X&amp;#39; || board[row][col] == &amp;#39;Y&amp;#39; { return } if board[row][col] == &amp;#39;O&amp;#39; { board[row][col] = &amp;#39;Y&amp;#39; } for _, dir := range dirs { dfs(board, row+dir[0], col + dir[1], rows, cols) } }</description></item><item><title>0133. Clone Graph</title><link>https://example.com/docs/algs/leetcode/133_clone_graph/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/133_clone_graph/</guid><description>Description # Given a reference of a node in a connected undirected graph.
Return a deep copy (clone) of the graph.
Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.
class Node { public int val; public List&amp;lt;Node&amp;gt; neighbors; } Test case format:
For simplicity, each node&amp;rsquo;s value is the same as the node&amp;rsquo;s index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on.</description></item><item><title>0200. Number of Islands</title><link>https://example.com/docs/algs/leetcode/200_number_of_islands/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/200_number_of_islands/</guid><description>Description # Given an m x n 2D binary grid grid which represents a map of &amp;lsquo;1&amp;rsquo;s (land) and &amp;lsquo;0&amp;rsquo;s (water), return the number of islands.
An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
Solutions # DFS # 典型的 DFS 应用。这里跟求一个图中有多少个连通分量一样，因为每个方格只能是 &amp;lsquo;0&amp;rsquo; 或者 &amp;lsquo;1&amp;rsquo;，所以我们可以在遍历的时候直接把已经遍历过的地方都设为'0&amp;rsquo;。如果不想污染原数组，那么就用一个 map 来记录该位置是否被遍历过即可。
func numIslands(grid [][]byte) int { row, col := len(grid), len(grid[0]) var res int for i := 0; i &amp;lt; row; i++ { for j := 0; j &amp;lt; col; j++ { if grid[i][j] !</description></item><item><title>0310. Minimum Height Tree</title><link>https://example.com/docs/algs/leetcode/310_minimum_height_trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/310_minimum_height_trees/</guid><description>Description # A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.
Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root.</description></item><item><title>0417. Pacific Atlantic Water Flow</title><link>https://example.com/docs/algs/leetcode/417_pacific_atlantic_water_flow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/417_pacific_atlantic_water_flow/</guid><description>Description # There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island&amp;rsquo;s left and top edges, and the Atlantic Ocean touches the island&amp;rsquo;s right and bottom edges.
The island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).</description></item><item><title>0490. The Maze</title><link>https://example.com/docs/algs/leetcode/490_the_maze/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/490_the_maze/</guid><description>Description # There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won&amp;rsquo;t stop rolling until hitting a wall. When the ball stops, it could choose the next direction.
Given the ball&amp;rsquo;s start position, the destination and the maze, determine whether the ball could stop at the destination.
The maze is represented by a binary 2D array.</description></item><item><title>1091. Shortest Path in Binary Matrix</title><link>https://example.com/docs/algs/leetcode/1091_shortest_path_in_binary_matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1091_shortest_path_in_binary_matrix/</guid><description>Description # Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1.
A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:
All the visited cells of the path are 0. All the adjacent cells of the path are 8-directionally connected (i.</description></item></channel></rss>