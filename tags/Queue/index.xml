<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Queue on Interview</title><link>https://example.com/tags/Queue/</link><description>Recent content in Queue on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/Queue/index.xml" rel="self" type="application/rss+xml"/><item><title>0225. Implement Stack using Queues</title><link>https://example.com/docs/algs/leetcode/225_implement_stack_using_queues/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/225_implement_stack_using_queues/</guid><description>Description # Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).
Implement the MyStack class:
void push(int x) Pushes element x to the top of the stack. int pop() Removes the element on the top of the stack and returns it. int top() Returns the element on the top of the stack. boolean empty() Returns true if the stack is empty, false otherwise.</description></item><item><title>0232. Implement Queue using Stacks</title><link>https://example.com/docs/algs/leetcode/232_implement_queue_using_stacks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/232_implement_queue_using_stacks/</guid><description>Description # Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).
Implement the MyQueue class:
void push(int x) Pushes element x to the back of the queue. int pop() Removes the element from the front of the queue and returns it. int peek() Returns the element at the front of the queue.</description></item><item><title>0264. Ugly Number II</title><link>https://example.com/docs/algs/leetcode/264_ugly_number_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/264_ugly_number_ii/</guid><description>Description # An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.
Given an integer n, return the nth ugly number.
Solutions # 下面这种是错误的解法，下面的逻辑意味着丑数只能从 2 的幂、3 的幂以及 5 的幂中出现，但是 6 并不属于上述任何一种，但是 6 也是幂。
func nthUglyNumber(n int) int { if n &amp;lt;= 6 { return n } res := 1 i2,i3,i5 := 1,1,1 for i := 2; i &amp;lt; n; i++ { res = min(i2*2, min(i3*3, i5*5)) // 错误做法。按照下面的逻辑，丑数只能从 2 的幂，3 的幂以及 5 的幂中出现，这个逻辑是不对的。 if res /2 == i2 { i2 *= 2 } if res / 3 == i3 { i3 *= 3 } if res / 5 == i5 { i5 *= 5 } } return res } func min(a,b int) int { if a &amp;lt; b { return a } return b } 下面这个才是正确的解法，这个解法是从已有丑数中找出下一个最小的丑数。</description></item><item><title>0281. Zigzag Iterator</title><link>https://example.com/docs/algs/leetcode/281_zigzag_iterator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/281_zigzag_iterator/</guid><description>Description # Given two 1d vectors, implement an iterator to return their elements alternately.
For example, given two 1d vectors:
v1 = [1, 2] v2 = [3, 4, 5, 6] By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1, 3, 2, 4, 5, 6].
Follow up: What if you are given k 1d vectors? How well can your code be extended to such cases?</description></item><item><title>0346. Moving Average from Data Stream</title><link>https://example.com/docs/algs/leetcode/346_moving_average_from_data_stream/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/346_moving_average_from_data_stream/</guid><description>Description # Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.
Example: &amp;rsquo;&amp;rsquo;&amp;rsquo; MovingAverage m = new MovingAverage(3); m.next(1) = 1 m.next(10) = (1 + 10) / 2 m.next(3) = (1 + 10 + 3) / 3 m.next(5) = (10 + 3 + 5) / 3 &amp;rsquo;''
Solutions # 很明显是使用队列啦。
type MovingAverage struct { nums []int size int sum int } /** Initialize your data structure here.</description></item><item><title>0362. Design Hit Counter</title><link>https://example.com/docs/algs/leetcode/362_design_hit_counter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/362_design_hit_counter/</guid><description>Description # Design a hit counter which counts the number of hits received in the past 5 minutes.
Each function accepts a timestamp parameter (in seconds granularity) and you may assume that calls are being made to the system in chronological order (ie, the timestamp is monotonically increasing). You may assume that the earliest timestamp starts at 1.
It is possible that several hits arrive roughly at the same time.</description></item><item><title>1429. First Unique Number</title><link>https://example.com/docs/algs/leetcode/1429_first_unique_number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1429_first_unique_number/</guid><description>Description # You have a queue of integers, you need to retrieve the first unique integer in the queue.
Implement the FirstUnique class:
FirstUnique(int[] nums) Initializes the object with the numbers in the queue. int showFirstUnique() returns the value of the first unique integer of the queue, and returns -1 if there is no such integer. void add(int value) insert value to the queue. Solutions # 可以这么做： 维护一个哈希表，哈希表的 key 为数字，value 为一个Pair， Pair 中存储 key 在数组中的下标以及该数字的出现次数。然后再创建一个 queue， 将所有出现次数为 1 的数字按照在队列中的出现顺序入队。 调用 showFirstUnique 的时候， 从队列中取出元素，检查在哈希表中该元素的出现次数是否为 1，如果不是，则持续出对队，直到找到第一个出现次数为 1 的元素，然后将该元素输出。add 的时候，将该元素在哈希表中的对应次数加 1，并检查队头元素是否为该元素，如果是， 则将该元素出队即可。</description></item></channel></rss>