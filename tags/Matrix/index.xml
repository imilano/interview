<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Matrix on Interview</title><link>https://example.com/tags/Matrix/</link><description>Recent content in Matrix on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/Matrix/index.xml" rel="self" type="application/rss+xml"/><item><title>0036. Valid Sudoku</title><link>https://example.com/docs/algs/leetcode/36_valid_sudoku/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/36_valid_sudoku/</guid><description>Description # Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Solutions # 一个是要注意如何快速创建三维数组，另一个是要注意如何进行坐标转换。
func isValidSudoku(board [][]byte) bool { size := 9 // 一次性将所有行和列创建完毕 row, col := make([][]int, size), make([][]int, size) for i := 0; i &amp;lt; size; i++ { row[i], col[i] = make([]int, size), make([]int, size) } // 表示 9 个gird，么个 grid 有 9 个元素.</description></item><item><title>0048. Rotate Image</title><link>https://example.com/docs/algs/leetcode/48_rotate_image/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/48_rotate_image/</guid><description>Description # You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.
Solutions # 补充几个矩阵变换公式： - 主对角线对折： arr[i][j] = arr[j][i] - 副对角线对折： arr[i][j] = arr[n-j-1][n-i-1] go for i := 0; i &amp;lt; n; i++ { for j := 0; j &amp;lt; n-i; j++ { matrix[i][j], matrix[n-j-1][n-i-1] = matrix[n-j-1][n-i-1], matrix[i][j] } } - 横向对折： arr[i][j] = arr[n-i-1][j] - 纵向对折： arr[i][j] = arr[i][n-j-1]</description></item><item><title>0064. Minimum Path Sum</title><link>https://example.com/docs/algs/leetcode/64_minimum_path_sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/64_minimum_path_sum/</guid><description>Description # Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.
Note: You can only move either down or right at any point in time.
Solutions # DP # 这题跟第 120. Triangle 解法几乎一样。相比之下，这题要简单一些。这里很明显需要使用 DP，并且状态转移方程也是很明确的 dp[i][j] += min(dp[i-1][j], dp[i][j-1])，也就是说，当前位置的值只能从左边移动过来或者上边移动过来。特例情况就是第一行跟第一列，这个地方只有一种移动方向，所以需要特别处理一下。
func minPathSum(grid [][]int) int { m, n := len(grid), len(grid[0]) // corner case for i := 1; i &amp;lt; m ;i++ { grid[i][0] += grid[i-1][0] } for i := 1; i &amp;lt; n; i++ { grid[0][i] += grid[0][i-1] } for i := 1; i &amp;lt; m; i++ { for j := 1; j &amp;lt; n; j++ { grid[i][j] += min(grid[i-1][j], grid[i][j-1]) } } return grid[m-1][n-1] } func min(a,b int) int { if a &amp;lt; b { return a } return b } 当然，如果你不想污染原数组，那么也可以创建一个新的二维数组来做 DP 数组。</description></item><item><title>0130. Surrounded Regions</title><link>https://example.com/docs/algs/leetcode/130_surrounded_regions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/130_surrounded_regions/</guid><description> Description # Given an m x n matrix board containing &amp;lsquo;X&amp;rsquo; and &amp;lsquo;O&amp;rsquo;, capture all regions that are 4-directionally surrounded by &amp;lsquo;X&amp;rsquo;.
A region is captured by flipping all &amp;lsquo;O&amp;rsquo;s into &amp;lsquo;X&amp;rsquo;s in that surrounded region.
Solutions # DFS # 这个题的难点在于，对于从边上的&amp;rsquo;O&amp;rsquo;为起点的所有可达的&amp;rsquo;O&amp;rsquo;，在最后的结果中要保留。那么也就是所，在遍历中，需要对从边上的&amp;rsquo;O&amp;rsquo;可达到的所有&amp;rsquo;O&amp;rsquo;做一个特殊处理。这里首先遍历四条边，如果当前点是&amp;rsquo;O&amp;rsquo;，那么从当前点开始进行DFS，对于每个可达的&amp;rsquo;O&amp;rsquo;点，都将其设置为&amp;rsquo;Y&amp;rsquo;，表示这个点不需要处理。上面的处理结束之后，剩下的&amp;rsquo;O&amp;rsquo;都是需要处理的&amp;rsquo;O&amp;rsquo;，那么只需要再遍历一遍矩阵，将每个‘O’设置为&amp;rsquo;X&amp;rsquo;,同事将那么设置为&amp;rsquo;Y&amp;rsquo;的点还原为&amp;rsquo;O&amp;rsquo;即可。
var dirs [][]int = [][]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}} func solve(board [][]byte) { rows, cols := len(board), len(board[0]) // 先从边上的每个 &amp;#39;o&amp;#39;开始遍历，将其可达的所有 &amp;#39;o&amp;#39;都标记为 &amp;#39;y&amp;#39; for i := 0; i &amp;lt; rows; i++ { if board[i][cols-1] == &amp;#39;O&amp;#39; { dfs(board, i, cols-1, rows, cols) } if board[i][0] == &amp;#39;O&amp;#39; { dfs(board, i, 0, rows, cols) } } for i := 0; i &amp;lt; cols; i++ { if board[0][i] == &amp;#39;O&amp;#39; { dfs(board, 0, i, rows, cols) } if board[rows-1][i] == &amp;#39;O&amp;#39; { dfs(board, rows-1, i, rows, cols) } } for i := 0; i &amp;lt; rows; i++ { for j := 0; j &amp;lt; cols; j++ { // 对于剩余的每个 &amp;#39;o&amp;#39;，将其变为 &amp;#39;x&amp;#39; if board[i][j] == &amp;#39;O&amp;#39; { board[i][j] = &amp;#39;X&amp;#39; } // 将每个&amp;#39;y&amp;#39;还原为&amp;#39;o&amp;#39; if board[i][j] == &amp;#39;Y&amp;#39; { board[i][j] = &amp;#39;O&amp;#39; } } } } func dfs(board [][]byte, row, col, rows, cols int) { if row &amp;lt; 0 || row &amp;gt;= rows || col &amp;lt; 0 || col &amp;gt;= cols || board[row][col] == &amp;#39;X&amp;#39; || board[row][col] == &amp;#39;Y&amp;#39; { return } if board[row][col] == &amp;#39;O&amp;#39; { board[row][col] = &amp;#39;Y&amp;#39; } for _, dir := range dirs { dfs(board, row+dir[0], col + dir[1], rows, cols) } }</description></item><item><title>0200. Number of Islands</title><link>https://example.com/docs/algs/leetcode/200_number_of_islands/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/200_number_of_islands/</guid><description>Description # Given an m x n 2D binary grid grid which represents a map of &amp;lsquo;1&amp;rsquo;s (land) and &amp;lsquo;0&amp;rsquo;s (water), return the number of islands.
An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
Solutions # DFS # 典型的 DFS 应用。这里跟求一个图中有多少个连通分量一样，因为每个方格只能是 &amp;lsquo;0&amp;rsquo; 或者 &amp;lsquo;1&amp;rsquo;，所以我们可以在遍历的时候直接把已经遍历过的地方都设为'0&amp;rsquo;。如果不想污染原数组，那么就用一个 map 来记录该位置是否被遍历过即可。
func numIslands(grid [][]byte) int { row, col := len(grid), len(grid[0]) var res int for i := 0; i &amp;lt; row; i++ { for j := 0; j &amp;lt; col; j++ { if grid[i][j] !</description></item><item><title>0240. Search a 2D Matrix II</title><link>https://example.com/docs/algs/leetcode/240_search_a_2d_matrix_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/240_search_a_2d_matrix_ii/</guid><description> Description # Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:
Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom.
Solutions # Binary Search # 这个题使用跟 74 题一样的解法完全可以解决。
这题的二分解法真的比较巧妙。这里首先具备了两个特征：每一行从左向右递增，每一列从上到下递增。那么我们可以从第一列最后一个元素开始进行搜索，如果target 比当前元素要小，那么如果target 要存在，就只能在当前行上边，于是row-1；如果target比当前元素要大，那么如果该元素存在的话，智能在当前列右侧，于是col+1。按照以上规则进行遍历即可。
func searchMatrix(matrix [][]int, target int) bool { m,n := len(matrix), len(matrix[0]) row, col := m - 1, 0 for row &amp;gt;= 0 &amp;amp;&amp;amp; col &amp;lt; n { if matrix[row][col] == target { return true } if matrix[row][col] &amp;lt; target { col++ } if col &amp;lt; n &amp;amp;&amp;amp; matrix[row][col] &amp;gt; target { row-- } } return false }</description></item><item><title>0277. Find the Celebrity</title><link>https://example.com/docs/algs/leetcode/277_find_the_celebrity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/277_find_the_celebrity/</guid><description>Description # Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.
Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: &amp;ldquo;Hi, A.</description></item><item><title>0378. Kth Smallest Element in a Sorted Matrix</title><link>https://example.com/docs/algs/leetcode/378_kth_smallest_element_in_a_sorted_matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/378_kth_smallest_element_in_a_sorted_matrix/</guid><description>Description # Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix.
Note that it is the kth smallest element in the sorted order, not the kth distinct element.
You must find a solution with a memory complexity better than \( \Omicron(n^2) \) Solutions # 这里可以使用最小堆，遍历矩阵，不断往堆中加入元素，遍历完之后，取堆中第 k 个元素就可。或者使用一个大小为 k 的最大堆，当堆中元素数量不足 k 时，将元素入堆，当堆中元素比 k 大时，将堆顶元素出堆即可。</description></item><item><title>0417. Pacific Atlantic Water Flow</title><link>https://example.com/docs/algs/leetcode/417_pacific_atlantic_water_flow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/417_pacific_atlantic_water_flow/</guid><description>Description # There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island&amp;rsquo;s left and top edges, and the Atlantic Ocean touches the island&amp;rsquo;s right and bottom edges.
The island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).</description></item><item><title>0490. The Maze</title><link>https://example.com/docs/algs/leetcode/490_the_maze/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/490_the_maze/</guid><description>Description # There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won&amp;rsquo;t stop rolling until hitting a wall. When the ball stops, it could choose the next direction.
Given the ball&amp;rsquo;s start position, the destination and the maze, determine whether the ball could stop at the destination.
The maze is represented by a binary 2D array.</description></item><item><title>0542. 01 Matrix</title><link>https://example.com/docs/algs/leetcode/542_01_matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/542_01_matrix/</guid><description>Description # Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.
The distance between two adjacent cells is 1.
Solutions # BFS # 这里很容易能够想出 BFS 的解法，然后代码不难写。但是在题主写好并提交之后，在最后一个 case 上超时了，题主一看这个 case 的结构，心想不超时才怪呢&amp;hellip;.
主要思路就是，如果一个格子是 0，那么该格子的距离肯定是 0。而如果该格子是 1，那么其距离就是对该格子进行 BFS 的距离。超时代码如下：
var dirs [][]int = [][]int{{1, 0}, {-1, 0}, {0, 1}, {0, -1}} func updateMatrix(mat [][]int) [][]int { // 初始化结果数组，将每个位置的值都设置为最大值 rows, cols := len(mat), len(mat[0]) res := make([][]int, rows) for idx, _ := range res { arr := make([]int, cols) for i := 0; i &amp;lt; cols; i++ { arr[i] = math.</description></item><item><title>0867. Transpose Matrix</title><link>https://example.com/docs/algs/leetcode/867_transpose_matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/867_transpose_matrix/</guid><description> Description # Given a 2D integer array matrix, return the transpose of matrix.
The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix&amp;rsquo;s row and column indices.
Solutions # 简言之就是需要行列倒置。
func transpose(matrix [][]int) [][]int { m,n := len(matrix),len(matrix[0]) res := make([][]int, n) for idx, _ := range res { res[idx] = make([]int, m) } for i := 0; i &amp;lt; m; i++ { for j := 0; j &amp;lt; n; j++ { res[j][i] = matrix[i][j] } } return res }</description></item><item><title>1091. Shortest Path in Binary Matrix</title><link>https://example.com/docs/algs/leetcode/1091_shortest_path_in_binary_matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1091_shortest_path_in_binary_matrix/</guid><description>Description # Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1.
A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:
All the visited cells of the path are 0. All the adjacent cells of the path are 8-directionally connected (i.</description></item></channel></rss>