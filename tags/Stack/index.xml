<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Stack on Interview</title><link>https://example.com/tags/Stack/</link><description>Recent content in Stack on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/Stack/index.xml" rel="self" type="application/rss+xml"/><item><title>0020. Valid Parentheses</title><link>https://example.com/docs/algs/leetcode/20_valid_parentheses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/20_valid_parentheses/</guid><description> Description # Given a string s containing just the characters &amp;lsquo;(&amp;rsquo;, &amp;lsquo;)&amp;rsquo;, &amp;lsquo;{&amp;rsquo;, &amp;lsquo;}&amp;rsquo;, &amp;lsquo;[&amp;rsquo; and &amp;lsquo;]&amp;rsquo;, determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Solutions # 简单题，直接使用栈即可。
func isValid(s string) bool { var stack []byte size := len(s) for i := 0; i &amp;lt; size; i++ { if s[i] == &amp;#39;(&amp;#39; || s[i] == &amp;#39;[&amp;#39; || s[i] == &amp;#39;{&amp;#39; { stack = append(stack, s[i]) } else { cap := len(stack) if cap == 0 { return false } tail := stack[cap-1] if s[i] == &amp;#39;)&amp;#39; &amp;amp;&amp;amp; tail == &amp;#39;(&amp;#39; || s[i] ==&amp;#39;]&amp;#39; &amp;amp;&amp;amp; tail == &amp;#39;[&amp;#39; || s[i] == &amp;#39;}&amp;#39; &amp;amp;&amp;amp; tail == &amp;#39;{&amp;#39; { stack = stack[:cap-1] } else { return false } } } return len(stack) == 0 }</description></item><item><title>0092. Reverse Linked List II</title><link>https://example.com/docs/algs/leetcode/92_reverse_linked_list_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/92_reverse_linked_list_ii/</guid><description>Description # Given the head of a singly linked list and two integers left and right where left &amp;lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list.
Solutions # 使用头插法来翻转节点：先找到待翻转节点的前一个节点pre，pre 的下一个几点就是要翻转的第一个节点 cur，使用一个节点 t 表示 cur 的下一个节点，防止断链。然后将 cur 连接到 t 的下一个节点上，然后将 t 的下一个节点设置为 cur，然后再将 pre 指向 t，这样就完成了一个节点的翻转，然后继续翻转下面的节点即可。
func reverseBetween(head *ListNode, left int, right int) *ListNode { if head == nil || right &amp;lt; left { return nil } // 试用 dummy 防止出现需要翻转第一个节点的情况 dummy := new(ListNode) dummy.</description></item><item><title>0150. Evaluate Reverse Polish Notation</title><link>https://example.com/docs/algs/leetcode/150_evaluate_reverse_polish_notation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/150_evaluate_reverse_polish_notation/</guid><description>Description # Evaluate the value of an arithmetic expression in Reverse Polish Notation.
Valid operators are +, -, *, and /. Each operand may be an integer or another expression.
Note that division between two integers should truncate toward zero.
It is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.</description></item><item><title>0155. Min Stack</title><link>https://example.com/docs/algs/leetcode/155_min_stack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/155_min_stack/</guid><description>Desctiption # Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
Implement the MinStack class:
MinStack() initializes the stack object. void push(int val) pushes the element val onto the stack. void pop() removes the element on the top of the stack. int top() gets the top element of the stack. int getMin() retrieves the minimum element in the stack. Solutions # 除了维持一个正常的栈来维持压入的元素之外，还需要维持一个单调递减栈当前的最小数。具体做法是，当压入一个元素的时候，如果单调栈中元素为空，则直接压入元素到单调栈中；如果单调中元素不为空，那么又分为单调栈顶元素比当前压入元素大还是小两种情况，如果栈顶元素比当前压入元素大，那么将当前压入元素压入单调栈；如果栈顶元素比当前压入元素小，那么再次压入栈顶元素。弹出时，除了对正常栈进行弹出之外，还需要对单调栈进行弹出操作。getMin 函数直接返回单调栈顶元素即可。</description></item><item><title>0162. Find Peak Element</title><link>https://example.com/docs/algs/leetcode/162_find_peak_element/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/162_find_peak_element/</guid><description>Description # A peak element is an element that is strictly greater than its neighbors.
Given an integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.
You may imagine that nums[-1] = nums[n] = -∞.
You must write an algorithm that runs in \( Omicron(\log n) \) time.
Solutions # One Pass Iteration # 这里可以通过一次数组的一次遍历来完成。为了方便，我们可以在头部和尾部分别添加上一个最小值，这样能够减少一些边界值判断。当然，这种方法并不符合题目要求的 \( \Omicron(n\log n) \) 的要求。</description></item><item><title>0206. Reverse Linked List</title><link>https://example.com/docs/algs/leetcode/206_reverse_linked_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/206_reverse_linked_list/</guid><description>Description # Given the head of a singly linked list, reverse the list, and return the reversed list.
Solutions # Iterative # 迭代法，但是要注意虚拟头节点的使用。
func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } dummy := new(ListNode) cur := head for cur != nil { tail := dummy.Next next := cur.Next dummy.Next = cur cur.Next = tail cur = next } return dummy.Next } Recursive # 这里递归法如何反转节点也是需要十分注意的。</description></item><item><title>0224. Basic Calculator</title><link>https://example.com/docs/algs/leetcode/224_basic_calculator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/224_basic_calculator/</guid><description>Description # Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.
Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().
Solutions # 第一个想法就是，可以先把中缀表达式转换为后缀表达式，然后再对后缀表达式进行计算，这样就会简单很多。那么问题是，如果将一个带有括号的中缀表达式转换为后缀表达式呢？这里的精简版算法如下：
声明 Q：输出队列 声明 S：操作符栈 遍历中缀表达式中的每一个 token x： - 如果 x 是一个操作数，则直接将 x 追加到输出队列 Q 末尾，否则往下检查； - 如果 x 是一个左括号&amp;#34;(&amp;#34;，则将 x 压入操作符栈，否则往下检查； - 如果 x 是一个操作符： - 如果操作符栈 S 栈顶为一个优先级大于等于 x 的操作符，则将 S 栈顶的操作符弹出并且追加到输出队列 Q 末尾，最后将 x 压入栈顶； - 如果操作符栈 S 栈顶为一个优先级小于等于 x 的操作符，或者不为操作符（这里只可能是左括号&amp;#34;（&amp;#34;）,则直接将 x 压入栈顶即可。 - 如果 x 是一个右括号，则将操作符栈 S 栈顶往下到第一个左括号之间的元素以此弹出炳且追加到输出队列末尾，然后将左括号丢弃，右括号也不用入栈。注意，如果栈到底后仍然没有找到左括号，则说明表达式不合法，左右括号不匹配。 最后将栈 S 中得到的元素全部依次弹出并且入队 Q 即可。 TODO</description></item><item><title>0225. Implement Stack using Queues</title><link>https://example.com/docs/algs/leetcode/225_implement_stack_using_queues/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/225_implement_stack_using_queues/</guid><description>Description # Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).
Implement the MyStack class:
void push(int x) Pushes element x to the top of the stack. int pop() Removes the element on the top of the stack and returns it. int top() Returns the element on the top of the stack. boolean empty() Returns true if the stack is empty, false otherwise.</description></item><item><title>0227. Basic Calculator II</title><link>https://example.com/docs/algs/leetcode/227_basic_calculator_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/227_basic_calculator_ii/</guid><description>Description # Given a string s which represents an expression, evaluate this expression and return its value.
The integer division should truncate toward zero.
You may assume that the given expression is always valid. All intermediate results will be in the range of \([-2^31, 2^31 - 1]\) .
Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().
Solutions # 这个题目因为不涉及乘除法，相比第 224 题就简单很多了，老老实实使用栈来求值就好了。这里也可以先将中缀表达式转换为后缀表达式，然后再对后缀表达式进行求值。</description></item><item><title>0735. Asteroid Collisiion</title><link>https://example.com/docs/algs/leetcode/735_asteroid_collision/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/735_asteroid_collision/</guid><description>Description # We are given an array asteroids of integers representing asteroids in a row.
For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.
Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode.</description></item><item><title>0895. Max Frequency Stack</title><link>https://example.com/docs/algs/leetcode/895_max_frequency_stack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/895_max_frequency_stack/</guid><description>Description # Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.
Implement the FreqStack class:
FreqStack() constructs an empty frequency stack. void push(int val) pushes an integer val onto the top of the stack. int pop() removes and returns the most frequent element in the stack. If there is a tie for the most frequent element, the element closest to the stack&amp;rsquo;s top is removed and returned.</description></item><item><title>1047. Remove All Adjacent Duplicates in String</title><link>https://example.com/docs/algs/leetcode/1047_remove_all_duplicated_in_string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1047_remove_all_duplicated_in_string/</guid><description>Description # You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.
We repeatedly make duplicate removals on s until we no longer can.
Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique.
Solutions # 很容易想到用栈。这里需要注意的是，对于&amp;quot;abbaca&amp;quot;这样的字符，移除之后的结果是 “ca”，而不是“abaca”喔，这里的删除是指一旦连续两个字符相同，那么把这两个字符都删去，而不是只保留一个。
func removeDuplicates(s string) string { size := len(s) if size &amp;lt;= 1 { return s } var stack []rune for _, r := range s { size = len(stack) if size == 0 || stack[size-1] !</description></item><item><title>1209. Remove All Adjacent Duplicates in String</title><link>https://example.com/docs/algs/leetcode/1209_remove_all_adjacent_duplicates_in_string_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1209_remove_all_adjacent_duplicates_in_string_ii/</guid><description>Description # You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, causing the left and the right side of the deleted substring to concatenate together.
We repeatedly make k duplicate removals on s until we no longer can.
Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.</description></item><item><title>1249. Minimum Remove to Make Valid Parentheses</title><link>https://example.com/docs/algs/leetcode/1249_minimum_remove_to_make_valid_parentheses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1249_minimum_remove_to_make_valid_parentheses/</guid><description>Description # Given a string s of &amp;lsquo;(&amp;rsquo; , &amp;lsquo;)&amp;rsquo; and lowercase English characters.
Your task is to remove the minimum number of parentheses ( &amp;lsquo;(&amp;rsquo; or &amp;lsquo;)&amp;rsquo;, in any positions ) so that the resulting parentheses string is valid and return any valid string.
Formally, a parentheses string is valid if and only if:
It is the empty string, contains only lowercase characters, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string.</description></item><item><title>1472. Design Browser History</title><link>https://example.com/docs/algs/leetcode/1472_design_browser_history/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1472_design_browser_history/</guid><description>Description # You have a browser of one tab where you start on the homepage and you can visit another url, get back in the history number of steps or move forward in the history number of steps.
Implement the BrowserHistory class:
BrowserHistory(string homepage) Initializes the object with the homepage of the browser. void visit(string url) Visits url from the current page. It clears up all the forward history. string back(int steps) Move steps back in history.</description></item></channel></rss>