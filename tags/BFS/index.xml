<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>BFS on Interview</title><link>https://example.com/tags/BFS/</link><description>Recent content in BFS on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/BFS/index.xml" rel="self" type="application/rss+xml"/><item><title>0102. Binary Tree Level Order Traversal</title><link>https://example.com/docs/algs/leetcode/102_binary_tree_level_order_traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/102_binary_tree_level_order_traversal/</guid><description>Description # Given the root of a binary tree, return the level order traversal of its nodes&amp;rsquo; values. (i.e., from left to right, level by level).
Solutions # 层次遍历，使用队列来做即可。
func levelOrder(root *TreeNode) [][]int { var res [][]int if root == nil { return res } queue := new(Queue) queue.Push(root) for queue.Len() != 0 { size := queue.Len() var arr []int for size != 0 { ele := queue.Pop().(*TreeNode) size -= 1 if ele == nil { continue } arr = append(arr, ele.</description></item><item><title>0103. Binary Tree ZigZag Level Order Traversal</title><link>https://example.com/docs/algs/leetcode/103_binary_tree_zigzag_level_order_traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/103_binary_tree_zigzag_level_order_traversal/</guid><description>Description # Given the root of a binary tree, return the zigzag level order traversal of its nodes&amp;rsquo; values. (i.e., from left to right, then right to left for the next level and alternate between).
Solutions # 简单题，使用队列进行层次遍历即可。
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func zigzagLevelOrder(root *TreeNode) [][]int { var res [][]int if root == nil { return res } var queue []*TreeNode queue = append(queue, root) var flag bool for len(queue) !</description></item><item><title>0130. Surrounded Regions</title><link>https://example.com/docs/algs/leetcode/130_surrounded_regions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/130_surrounded_regions/</guid><description> Description # Given an m x n matrix board containing &amp;lsquo;X&amp;rsquo; and &amp;lsquo;O&amp;rsquo;, capture all regions that are 4-directionally surrounded by &amp;lsquo;X&amp;rsquo;.
A region is captured by flipping all &amp;lsquo;O&amp;rsquo;s into &amp;lsquo;X&amp;rsquo;s in that surrounded region.
Solutions # DFS # 这个题的难点在于，对于从边上的&amp;rsquo;O&amp;rsquo;为起点的所有可达的&amp;rsquo;O&amp;rsquo;，在最后的结果中要保留。那么也就是所，在遍历中，需要对从边上的&amp;rsquo;O&amp;rsquo;可达到的所有&amp;rsquo;O&amp;rsquo;做一个特殊处理。这里首先遍历四条边，如果当前点是&amp;rsquo;O&amp;rsquo;，那么从当前点开始进行DFS，对于每个可达的&amp;rsquo;O&amp;rsquo;点，都将其设置为&amp;rsquo;Y&amp;rsquo;，表示这个点不需要处理。上面的处理结束之后，剩下的&amp;rsquo;O&amp;rsquo;都是需要处理的&amp;rsquo;O&amp;rsquo;，那么只需要再遍历一遍矩阵，将每个‘O’设置为&amp;rsquo;X&amp;rsquo;,同事将那么设置为&amp;rsquo;Y&amp;rsquo;的点还原为&amp;rsquo;O&amp;rsquo;即可。
var dirs [][]int = [][]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}} func solve(board [][]byte) { rows, cols := len(board), len(board[0]) // 先从边上的每个 &amp;#39;o&amp;#39;开始遍历，将其可达的所有 &amp;#39;o&amp;#39;都标记为 &amp;#39;y&amp;#39; for i := 0; i &amp;lt; rows; i++ { if board[i][cols-1] == &amp;#39;O&amp;#39; { dfs(board, i, cols-1, rows, cols) } if board[i][0] == &amp;#39;O&amp;#39; { dfs(board, i, 0, rows, cols) } } for i := 0; i &amp;lt; cols; i++ { if board[0][i] == &amp;#39;O&amp;#39; { dfs(board, 0, i, rows, cols) } if board[rows-1][i] == &amp;#39;O&amp;#39; { dfs(board, rows-1, i, rows, cols) } } for i := 0; i &amp;lt; rows; i++ { for j := 0; j &amp;lt; cols; j++ { // 对于剩余的每个 &amp;#39;o&amp;#39;，将其变为 &amp;#39;x&amp;#39; if board[i][j] == &amp;#39;O&amp;#39; { board[i][j] = &amp;#39;X&amp;#39; } // 将每个&amp;#39;y&amp;#39;还原为&amp;#39;o&amp;#39; if board[i][j] == &amp;#39;Y&amp;#39; { board[i][j] = &amp;#39;O&amp;#39; } } } } func dfs(board [][]byte, row, col, rows, cols int) { if row &amp;lt; 0 || row &amp;gt;= rows || col &amp;lt; 0 || col &amp;gt;= cols || board[row][col] == &amp;#39;X&amp;#39; || board[row][col] == &amp;#39;Y&amp;#39; { return } if board[row][col] == &amp;#39;O&amp;#39; { board[row][col] = &amp;#39;Y&amp;#39; } for _, dir := range dirs { dfs(board, row+dir[0], col + dir[1], rows, cols) } }</description></item><item><title>0133. Clone Graph</title><link>https://example.com/docs/algs/leetcode/133_clone_graph/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/133_clone_graph/</guid><description>Description # Given a reference of a node in a connected undirected graph.
Return a deep copy (clone) of the graph.
Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.
class Node { public int val; public List&amp;lt;Node&amp;gt; neighbors; } Test case format:
For simplicity, each node&amp;rsquo;s value is the same as the node&amp;rsquo;s index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on.</description></item><item><title>0207. Course Scheduler</title><link>https://example.com/docs/algs/leetcode/207_course_scheduler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/207_course_scheduler/</guid><description>Description # There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.
For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1. Return true if you can finish all courses.</description></item><item><title>0210. Course Scheduler II</title><link>https://example.com/docs/algs/leetcode/210_course_scheduler_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/210_course_scheduler_ii/</guid><description>Description # There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.
For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1. Return the ordering of courses you should take to finish all courses.</description></item><item><title>0310. Minimum Height Tree</title><link>https://example.com/docs/algs/leetcode/310_minimum_height_trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/310_minimum_height_trees/</guid><description>Description # A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.
Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root.</description></item><item><title>0314. Binary Tree Vertical Order Traversal</title><link>https://example.com/docs/algs/leetcode/314_binary_tree_vertical_order_traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/314_binary_tree_vertical_order_traversal/</guid><description>Description # Given a binary tree, return the vertical order traversal of its nodes&amp;rsquo; values. (ie, from top to bottom, column by column).
If two nodes are in the same row and column, the order should be from left to right.
Solutions # Level Order Traversal # 这里可以隐约看出来是要使用层序遍历，但是与一般的层序遍历的稍微有点不同。这里的主要思想是：对每个节点赋予一个值 col，然后对于其左节点，col 减 1，对于右节点， col 加 1。这样的话，同一列的节点都会有同一个值 col。在入队的时候，不仅需要将节点入队，还需要将节点的 row 入队，二者可以组成一个 pair。
func vericalOrder(root *TreeNode) [][]int { if root == nil { return nil } var res [][]int type pair struct { Node *TreeNode Col int } // 层序遍历需要用到的队列 var queue []pair // 记录每个 col 上有哪些节点 dict := make(map[int]*TreeNode) queue = append(queue, pair{root, 0}) for len(queue) !</description></item><item><title>0366. Find Leaves of Binary Tree</title><link>https://example.com/docs/algs/leetcode/366_find_leaves_of_binary_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/366_find_leaves_of_binary_tree/</guid><description>Description # Given a binary tree, collect a tree&amp;rsquo;s nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty.
Example:
Input: [1,2,3,4,5]
1 / \ 2 3 / \ 4 5 Output: [[4,5,3],[2],[1]]
Solutions # BFS # 这个题要求，每次都把叶节点给出调，然后再剩下的树中再把叶节点除掉，重复上述过程直到数中没有节点为止。仔细观察一下，你会发现，每次除掉的都是出度为 0 的节点。反过来说，如果你将这个树视作一个以叶节点为出发点的图，那么这个问题就会变成一个拓扑排序题。如果你能这么想，那问题也就很简单了。首先先将这个树视作一个以叶节点为出发点、以根节点为结束点的的有向图，然后统计每个节点的入度，每次把入度为 0 的节点放到数组中，然后将从该节点可达的节点的入度减去 1.循环上述过程即可，典型的拓扑排序问题。
同样是上面的思路，但是可以不把这个图视作有向图，可以视作无向图，然后对无向图的每个节点统计出入度，上面的入度为 0 的条件可以替换为入度为 1 。
Golang 本身没有 set， 确实很让人蛋疼。
func findLeaves(root *TreeNode) [][]int { if root == nil { return nil } // 将树视为无向图，从根节点开始进行 BFS，对于每条边，统计两个节点的入度。 // 然后将入度为 1 的节点入队(因为无向图入度为 1 表示该节点为叶节点)，开始进行无向图的拓扑排序。 degree := make(map[int]map[int]bool) var queue []*TreeNode queue = append(queue, root) for len(queue) !</description></item><item><title>0490. The Maze</title><link>https://example.com/docs/algs/leetcode/490_the_maze/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/490_the_maze/</guid><description>Description # There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won&amp;rsquo;t stop rolling until hitting a wall. When the ball stops, it could choose the next direction.
Given the ball&amp;rsquo;s start position, the destination and the maze, determine whether the ball could stop at the destination.
The maze is represented by a binary 2D array.</description></item><item><title>0542. 01 Matrix</title><link>https://example.com/docs/algs/leetcode/542_01_matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/542_01_matrix/</guid><description>Description # Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.
The distance between two adjacent cells is 1.
Solutions # BFS # 这里很容易能够想出 BFS 的解法，然后代码不难写。但是在题主写好并提交之后，在最后一个 case 上超时了，题主一看这个 case 的结构，心想不超时才怪呢&amp;hellip;.
主要思路就是，如果一个格子是 0，那么该格子的距离肯定是 0。而如果该格子是 1，那么其距离就是对该格子进行 BFS 的距离。超时代码如下：
var dirs [][]int = [][]int{{1, 0}, {-1, 0}, {0, 1}, {0, -1}} func updateMatrix(mat [][]int) [][]int { // 初始化结果数组，将每个位置的值都设置为最大值 rows, cols := len(mat), len(mat[0]) res := make([][]int, rows) for idx, _ := range res { arr := make([]int, cols) for i := 0; i &amp;lt; cols; i++ { arr[i] = math.</description></item><item><title>0752. Open the Lock</title><link>https://example.com/docs/algs/leetcode/752_open_the_lock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/752_open_the_lock/</guid><description>Description # You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: &amp;lsquo;0&amp;rsquo;, &amp;lsquo;1&amp;rsquo;, &amp;lsquo;2&amp;rsquo;, &amp;lsquo;3&amp;rsquo;, &amp;lsquo;4&amp;rsquo;, &amp;lsquo;5&amp;rsquo;, &amp;lsquo;6&amp;rsquo;, &amp;lsquo;7&amp;rsquo;, &amp;lsquo;8&amp;rsquo;, &amp;lsquo;9&amp;rsquo;. The wheels can rotate freely and wrap around: for example we can turn &amp;lsquo;9&amp;rsquo; to be &amp;lsquo;0&amp;rsquo;, or &amp;lsquo;0&amp;rsquo; to be &amp;lsquo;9&amp;rsquo;. Each move consists of turning one wheel one slot.
The lock initially starts at &amp;lsquo;0000&amp;rsquo;, a string representing the state of the 4 wheels.</description></item><item><title>1091. Shortest Path in Binary Matrix</title><link>https://example.com/docs/algs/leetcode/1091_shortest_path_in_binary_matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/1091_shortest_path_in_binary_matrix/</guid><description>Description # Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1.
A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:
All the visited cells of the path are 0. All the adjacent cells of the path are 8-directionally connected (i.</description></item></channel></rss>