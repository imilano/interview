<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>BFS on Interview</title><link>https://example.com/tags/BFS/</link><description>Recent content in BFS on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/BFS/index.xml" rel="self" type="application/rss+xml"/><item><title>0102. Binary Tree Level Order Traversal</title><link>https://example.com/docs/algs/leetcode/102_binary_tree_level_order_traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/102_binary_tree_level_order_traversal/</guid><description>Description # Given the root of a binary tree, return the level order traversal of its nodes&amp;rsquo; values. (i.e., from left to right, level by level).
Solutions # 层次遍历，使用队列来做即可。
func levelOrder(root *TreeNode) [][]int { var res [][]int if root == nil { return res } queue := new(Queue) queue.Push(root) for queue.Len() != 0 { size := queue.Len() var arr []int for size != 0 { ele := queue.Pop().(*TreeNode) size -= 1 if ele == nil { continue } arr = append(arr, ele.</description></item><item><title>0103. Binary Tree ZigZag Level Order Traversal</title><link>https://example.com/docs/algs/leetcode/103_binary_tree_zigzag_level_order_traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/103_binary_tree_zigzag_level_order_traversal/</guid><description>Description # Given the root of a binary tree, return the zigzag level order traversal of its nodes&amp;rsquo; values. (i.e., from left to right, then right to left for the next level and alternate between).
Solutions # 简单题，使用队列进行层次遍历即可。
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func zigzagLevelOrder(root *TreeNode) [][]int { var res [][]int if root == nil { return res } var queue []*TreeNode queue = append(queue, root) var flag bool for len(queue) !</description></item><item><title>0130. Surrounded Regions</title><link>https://example.com/docs/algs/leetcode/130_surrounded_regions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/130_surrounded_regions/</guid><description> Description # Given an m x n matrix board containing &amp;lsquo;X&amp;rsquo; and &amp;lsquo;O&amp;rsquo;, capture all regions that are 4-directionally surrounded by &amp;lsquo;X&amp;rsquo;.
A region is captured by flipping all &amp;lsquo;O&amp;rsquo;s into &amp;lsquo;X&amp;rsquo;s in that surrounded region.
Solutions # DFS # 这个题的难点在于，对于从边上的&amp;rsquo;O&amp;rsquo;为起点的所有可达的&amp;rsquo;O&amp;rsquo;，在最后的结果中要保留。那么也就是所，在遍历中，需要对从边上的&amp;rsquo;O&amp;rsquo;可达到的所有&amp;rsquo;O&amp;rsquo;做一个特殊处理。这里首先遍历四条边，如果当前点是&amp;rsquo;O&amp;rsquo;，那么从当前点开始进行DFS，对于每个可达的&amp;rsquo;O&amp;rsquo;点，都将其设置为&amp;rsquo;Y&amp;rsquo;，表示这个点不需要处理。上面的处理结束之后，剩下的&amp;rsquo;O&amp;rsquo;都是需要处理的&amp;rsquo;O&amp;rsquo;，那么只需要再遍历一遍矩阵，将每个‘O’设置为&amp;rsquo;X&amp;rsquo;,同事将那么设置为&amp;rsquo;Y&amp;rsquo;的点还原为&amp;rsquo;O&amp;rsquo;即可。
var dirs [][]int = [][]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}} func solve(board [][]byte) { rows, cols := len(board), len(board[0]) // 先从边上的每个 &amp;#39;o&amp;#39;开始遍历，将其可达的所有 &amp;#39;o&amp;#39;都标记为 &amp;#39;y&amp;#39; for i := 0; i &amp;lt; rows; i++ { if board[i][cols-1] == &amp;#39;O&amp;#39; { dfs(board, i, cols-1, rows, cols) } if board[i][0] == &amp;#39;O&amp;#39; { dfs(board, i, 0, rows, cols) } } for i := 0; i &amp;lt; cols; i++ { if board[0][i] == &amp;#39;O&amp;#39; { dfs(board, 0, i, rows, cols) } if board[rows-1][i] == &amp;#39;O&amp;#39; { dfs(board, rows-1, i, rows, cols) } } for i := 0; i &amp;lt; rows; i++ { for j := 0; j &amp;lt; cols; j++ { // 对于剩余的每个 &amp;#39;o&amp;#39;，将其变为 &amp;#39;x&amp;#39; if board[i][j] == &amp;#39;O&amp;#39; { board[i][j] = &amp;#39;X&amp;#39; } // 将每个&amp;#39;y&amp;#39;还原为&amp;#39;o&amp;#39; if board[i][j] == &amp;#39;Y&amp;#39; { board[i][j] = &amp;#39;O&amp;#39; } } } } func dfs(board [][]byte, row, col, rows, cols int) { if row &amp;lt; 0 || row &amp;gt;= rows || col &amp;lt; 0 || col &amp;gt;= cols || board[row][col] == &amp;#39;X&amp;#39; || board[row][col] == &amp;#39;Y&amp;#39; { return } if board[row][col] == &amp;#39;O&amp;#39; { board[row][col] = &amp;#39;Y&amp;#39; } for _, dir := range dirs { dfs(board, row+dir[0], col + dir[1], rows, cols) } }</description></item><item><title>0133. Clone Graph</title><link>https://example.com/docs/algs/leetcode/133_clone_graph/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/133_clone_graph/</guid><description>Description # Given a reference of a node in a connected undirected graph.
Return a deep copy (clone) of the graph.
Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.
class Node { public int val; public List&amp;lt;Node&amp;gt; neighbors; } Test case format:
For simplicity, each node&amp;rsquo;s value is the same as the node&amp;rsquo;s index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on.</description></item><item><title>0314. Binary Tree Vertical Order Traversal</title><link>https://example.com/docs/algs/leetcode/314_binary_tree_vertical_order_traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/314_binary_tree_vertical_order_traversal/</guid><description>Description # Given a binary tree, return the vertical order traversal of its nodes&amp;rsquo; values. (ie, from top to bottom, column by column).
If two nodes are in the same row and column, the order should be from left to right.
Solutions # Level Order Traversal # 这里可以隐约看出来是要使用层序遍历，但是与一般的层序遍历的稍微有点不同。这里的主要思想是：对每个节点赋予一个值 col，然后对于其左节点，col 减 1，对于右节点， col 加 1。这样的话，同一列的节点都会有同一个值 col。在入队的时候，不仅需要将节点入队，还需要将节点的 row 入队，二者可以组成一个 pair。
func vericalOrder(root *TreeNode) [][]int { if root == nil { return nil } var res [][]int type pair struct { Node *TreeNode Col int } // 层序遍历需要用到的队列 var queue []pair // 记录每个 col 上有哪些节点 dict := make(map[int]*TreeNode) queue = append(queue, pair{root, 0}) for len(queue) !</description></item><item><title>0490. The Maze</title><link>https://example.com/docs/algs/leetcode/490_the_maze/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/490_the_maze/</guid><description>Description # There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won&amp;rsquo;t stop rolling until hitting a wall. When the ball stops, it could choose the next direction.
Given the ball&amp;rsquo;s start position, the destination and the maze, determine whether the ball could stop at the destination.
The maze is represented by a binary 2D array.</description></item><item><title>0752. Open the Lock</title><link>https://example.com/docs/algs/leetcode/752_open_the_lock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/752_open_the_lock/</guid><description>Description # You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: &amp;lsquo;0&amp;rsquo;, &amp;lsquo;1&amp;rsquo;, &amp;lsquo;2&amp;rsquo;, &amp;lsquo;3&amp;rsquo;, &amp;lsquo;4&amp;rsquo;, &amp;lsquo;5&amp;rsquo;, &amp;lsquo;6&amp;rsquo;, &amp;lsquo;7&amp;rsquo;, &amp;lsquo;8&amp;rsquo;, &amp;lsquo;9&amp;rsquo;. The wheels can rotate freely and wrap around: for example we can turn &amp;lsquo;9&amp;rsquo; to be &amp;lsquo;0&amp;rsquo;, or &amp;lsquo;0&amp;rsquo; to be &amp;lsquo;9&amp;rsquo;. Each move consists of turning one wheel one slot.
The lock initially starts at &amp;lsquo;0000&amp;rsquo;, a string representing the state of the 4 wheels.</description></item></channel></rss>