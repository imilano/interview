<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>BFS on Interview</title><link>https://example.com/tags/BFS/</link><description>Recent content in BFS on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/BFS/index.xml" rel="self" type="application/rss+xml"/><item><title>0102. Binary Tree Level Order Traversal</title><link>https://example.com/docs/algs/leetcode/102_binary_tree_level_order_traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/102_binary_tree_level_order_traversal/</guid><description>Description # Given the root of a binary tree, return the level order traversal of its nodes&amp;rsquo; values. (i.e., from left to right, level by level).
Solutions # 层次遍历，使用队列来做即可。
func levelOrder(root *TreeNode) [][]int { var res [][]int if root == nil { return res } queue := new(Queue) queue.Push(root) for queue.Len() != 0 { size := queue.Len() var arr []int for size != 0 { ele := queue.Pop().(*TreeNode) size -= 1 if ele == nil { continue } arr = append(arr, ele.</description></item><item><title>0103. Binary Tree ZigZag Level Order Traversal</title><link>https://example.com/docs/algs/leetcode/103_binary_tree_zigzag_level_order_traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/103_binary_tree_zigzag_level_order_traversal/</guid><description>Description # Given the root of a binary tree, return the zigzag level order traversal of its nodes&amp;rsquo; values. (i.e., from left to right, then right to left for the next level and alternate between).
Solutions # 简单题，使用队列进行层次遍历即可。
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func zigzagLevelOrder(root *TreeNode) [][]int { var res [][]int if root == nil { return res } var queue []*TreeNode queue = append(queue, root) var flag bool for len(queue) !</description></item><item><title>0133. Clone Graph</title><link>https://example.com/docs/algs/leetcode/133_clone_graph/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/133_clone_graph/</guid><description>Description # Given a reference of a node in a connected undirected graph.
Return a deep copy (clone) of the graph.
Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.
class Node { public int val; public List&amp;lt;Node&amp;gt; neighbors; } Test case format:
For simplicity, each node&amp;rsquo;s value is the same as the node&amp;rsquo;s index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on.</description></item><item><title>0314. Binary Tree Vertical Order Traversal</title><link>https://example.com/docs/algs/leetcode/314_binary_tree_vertical_order_traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/314_binary_tree_vertical_order_traversal/</guid><description>Description # Given a binary tree, return the vertical order traversal of its nodes&amp;rsquo; values. (ie, from top to bottom, column by column).
If two nodes are in the same row and column, the order should be from left to right.
Solutions # Level Order Traversal # 这里可以隐约看出来是要使用层序遍历，但是与一般的层序遍历的稍微有点不同。这里的主要思想是：对每个节点赋予一个值 col，然后对于其左节点，col 减 1，对于右节点， col 加 1。这样的话，同一列的节点都会有同一个值 col。在入队的时候，不仅需要将节点入队，还需要将节点的 row 入队，二者可以组成一个 pair。
func vericalOrder(root *TreeNode) [][]int { if root == nil { return nil } var res [][]int type pair struct { Node *TreeNode Col int } // 层序遍历需要用到的队列 var queue []pair // 记录每个 col 上有哪些节点 dict := make(map[int]*TreeNode) queue = append(queue, pair{root, 0}) for len(queue) !</description></item></channel></rss>