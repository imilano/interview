<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sort on Interview</title><link>https://example.com/tags/Sort/</link><description>Recent content in Sort on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/Sort/index.xml" rel="self" type="application/rss+xml"/><item><title>0001. Two Sum</title><link>https://example.com/docs/algs/leetcode/01_two_sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/01_two_sum/</guid><description>Description # Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.
Solutions # Hash Table # 这里因为答案唯一，那么也就意味着数组里的元素是唯一的，所以可以使用 map 来做，只需要一次遍历即可，具体看下面代码就好。
func twoSum(nums []int, target int) []int { dict := make(map[int]int) for idx, num := range nums{ t := target - num if exist(dict, t) { return []int{idx, dict[t]} } dict[num] = idx } return nil } func exist(dict map[int]int, target int) bool { if _, ok := dict[target]; ok { return true } return false } Sort &amp;amp;&amp;amp; Two Pointer # 这里也可以使用排序来做，根据值进行排序，但是需要保存该值对应的下标。排好序之后可以使用双指针，一个 left 指向开头，一个 right 指向结尾，计算二者和，如果小于 target，则 left++，否则 right++，直到二者之和等于 target 即可。思路大概就这样，代码就不写了。</description></item><item><title>0021. Merge Two Sorted List</title><link>https://example.com/docs/algs/leetcode/21_merge_two_sorted_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/21_merge_two_sorted_list/</guid><description>Description # You are given the heads of two sorted linked lists list1 and list2.
Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.
Return the head of the merged linked list.
Solutions # 简单题，不多说了，参考归并排序思想。
Merge Sort # func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode { res := new(ListNode) node := res dummyHead1, dummyHead2 := list1, list2 for dummyHead1 !</description></item><item><title>0027. Remove Element</title><link>https://example.com/docs/algs/leetcode/27_remove_element/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/27_remove_element/</guid><description>Description # Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.
Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result.</description></item><item><title>0148. Sort List</title><link>https://example.com/docs/algs/leetcode/148_sort_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/148_sort_list/</guid><description>Description # Given the head of a linked list, return the list after sorting it in ascending order.
Solutions # 第一个想法很简单，先扫描一遍链表，把扫描到的值记录到数组，然后对数组进行排序，最后再把排序结果赋值给原链表即可。时间复杂度 \(\Omicron(n\log n)\) , 空间复杂度 \($\Omicron(n)$\) 。
方法二，可以用插入排序的思想。维持一个排好序的链表，从头结点开始扫描，每扫描到一个节点，就将其插入到这个有序链表中去。这样空间复杂度就是 \($\Omicron(1)$\) ，时间复杂度 \($\Omicron(n^2)$\) 。
follow up 但是这里要求的是时间复杂度 \($\Omicron(n\log n)$\) ，空间复杂度 \($\Omicron(1)$\) ，那很明显上述解法都不满足。这里竟然可以用归并排序，归并排序的时间复杂度是 \($\Omicron(n\logn)$\) ，归并排序又分为自顶向下和自底向上两种，前者空间复杂度是 \($\Omicron(\log n)$\) （因为栈深度），后者可以达到 \($\Omicron(1)$\) 。
这里是自顶向下的解法，需要注意的是，在 getMiddle 函数中将 middle 节点和前一个节点断开是一个非常重要的操作。
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func sortList(head *ListNode) *ListNode { return mergeSortUpDown(head) } func mergeSortUpDown(head *ListNode) *ListNode { if head == nil || head.</description></item><item><title>0179. Largest Number</title><link>https://example.com/docs/algs/leetcode/179_largest_numbe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/179_largest_numbe/</guid><description>Description # Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.
Since the result may be very large, so you need to return a string instead of an integer.
Solutions # 这里的解法需要十分注意，跟一般的排序是有区别的。
import ( &amp;#34;strconv&amp;#34; &amp;#34;sort&amp;#34; &amp;#34;strings&amp;#34; ) func largestNumber(nums []int) string { var rs []string for _, num := range nums { rs = append(rs, strconv.Itoa(num)) } // 这里应该进行连接排序 sort.</description></item><item><title>0215. Kth Largest Element in an Array</title><link>https://example.com/docs/algs/leetcode/215_kth_largest_element_in_an_arrary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/215_kth_largest_element_in_an_arrary/</guid><description>Description # Given an integer array nums and an integer k, return the kth largest element in the array.
Note that it is the kth largest element in the sorted order, not the kth distinct element.
Solutions # Heap # 创建一个 k 个大小的最小堆，首先先将前 k 个元素压入堆中，而后面的元素只有当其比堆顶元素要大的时候才可以入堆。最后堆顶元素即为所求。
import ( &amp;#34;container/heap&amp;#34; ) func findKthLargest(nums []int, k int) int { return findKthLargestUsingSort(nums, 0, len(nums)-1, k) } // 解法1， 使用最大堆来解 func findKthLargestUsingHeap(nums []int, k int) int { var maxHeap MaxHeap heap.</description></item><item><title>0347. Top K Frequent Elements</title><link>https://example.com/docs/algs/leetcode/347_top_k_frequent_elements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/347_top_k_frequent_elements/</guid><description>Description # Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.
Solutions # Hash Table &amp;amp; Sort # 这里首先使用 map 来统计每个元素出现的次数，然后将元素和其出现的次数组成一个 pair 对，根据每个 pair 对的元素出现次数对 pair 对进行排序，最后取前 k 个即可。
func topKFrequent(nums []int, k int) []int { dict := make(map[int]int) for _, num := range nums { dict[num]++ } type Pair struct { num int cnt int } var pairs []Pair for key, cnt := range dict { pairs = append(pairs, Pair{key, cnt}) } sort.</description></item><item><title>0973. K Closest Points to Origin</title><link>https://example.com/docs/algs/leetcode/973_k_closest_points_to_origin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/973_k_closest_points_to_origin/</guid><description>Description # Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).
The distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x1 - x2)2 + (y1 - y2)2).
You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).</description></item></channel></rss>