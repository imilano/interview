<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Recursive on Interview</title><link>https://example.com/tags/Recursive/</link><description>Recent content in Recursive on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/Recursive/index.xml" rel="self" type="application/rss+xml"/><item><title>0022. Generate Parentheses</title><link>https://example.com/docs/algs/leetcode/22_generate_parentheses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/22_generate_parentheses/</guid><description> Description # Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
Solutions # Recursive # 参见： https://leetcode-cn.com/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/
使用两个变量 left 和 right 来表示「左括号使用了集合」和「右括号使用了几个」，通过分析可以得到以下结论： - 只有当left 和 right 都比 n 小的时候，才产生分支。 - 产生左分支的时候，只看当前还有左括号可用 - 产生右分支的时候，还受到左括号数量的限制，left 要大于 right 的时候，才可以产生分支。否则就是无效分支，可以直接返回。 - 在左边和右边的括号数都等于 n 的时候结算。
func generateParenthesis(n int) []string { var res []string if n == 0 { return res } generateParenthesisHelper(n, 0,0,&amp;#34;&amp;#34;, &amp;amp;res) return res } func generateParenthesisHelper(n, left, right int, cur string, res *[]string) { if left == n &amp;amp;&amp;amp; right == n { *res = append(*res, cur) return } // 剪枝 if left &amp;lt; right { return } if left &amp;lt; n { generateParenthesisHelper(n, left+1, right, cur + &amp;#34;(&amp;#34;, res) } if right &amp;lt; n { generateParenthesisHelper(n, left, right+1, cur + &amp;#34;)&amp;#34;, res) } }</description></item><item><title>0091. Decode Ways</title><link>https://example.com/docs/algs/leetcode/91_decode_ways/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/91_decode_ways/</guid><description>Description # A message containing letters from A-Z can be encoded into numbers using the following mapping:
&amp;lsquo;A&amp;rsquo; -&amp;gt; &amp;ldquo;1&amp;rdquo; &amp;lsquo;B&amp;rsquo; -&amp;gt; &amp;ldquo;2&amp;rdquo; &amp;hellip; &amp;lsquo;Z&amp;rsquo; -&amp;gt; &amp;ldquo;26&amp;rdquo; To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, &amp;ldquo;11106&amp;rdquo; can be mapped into:
&amp;ldquo;AAJF&amp;rdquo; with the grouping (1 1 10 6) &amp;ldquo;KJF&amp;rdquo; with the grouping (11 10 6) Note that the grouping (1 11 06) is invalid because &amp;ldquo;06&amp;rdquo; cannot be mapped into &amp;lsquo;F&amp;rsquo; since &amp;ldquo;6&amp;rdquo; is different from &amp;ldquo;06&amp;rdquo;.</description></item><item><title>0092. Reverse Linked List II</title><link>https://example.com/docs/algs/leetcode/92_reverse_linked_list_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/92_reverse_linked_list_ii/</guid><description>Description # Given the head of a singly linked list and two integers left and right where left &amp;lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list.
Solutions # 使用头插法来翻转节点：先找到待翻转节点的前一个节点pre，pre 的下一个几点就是要翻转的第一个节点 cur，使用一个节点 t 表示 cur 的下一个节点，防止断链。然后将 cur 连接到 t 的下一个节点上，然后将 t 的下一个节点设置为 cur，然后再将 pre 指向 t，这样就完成了一个节点的翻转，然后继续翻转下面的节点即可。
func reverseBetween(head *ListNode, left int, right int) *ListNode { if head == nil || right &amp;lt; left { return nil } // 试用 dummy 防止出现需要翻转第一个节点的情况 dummy := new(ListNode) dummy.</description></item><item><title>0101. Symmetric Tree</title><link>https://example.com/docs/algs/leetcode/101_symmetric_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/101_symmetric_tree/</guid><description>Description # Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).
Solutions # Recursive # 简单题，左子树的左节点的值要等于右子树的右子树的右节点的值，左子树的右节点的值要等于右子树的左节点的值。
func isSymmetric(root *TreeNode) bool { return helper(root, root) } func helper(root1, root2 *TreeNode) bool { if root1 == nil &amp;amp;&amp;amp; root2 == nil { return true } if root1 == nil || root2 == nil { return false } if root1.Val != root2.</description></item><item><title>0104. Maximum Depth of Binary Tree</title><link>https://example.com/docs/algs/leetcode/104_maximum_depth_of_binary_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/104_maximum_depth_of_binary_tree/</guid><description>Description # Given the root of a binary tree, return its maximum depth.
A binary tree&amp;rsquo;s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
Solutions # Recursive # 简单题，无需多说。
func maxDepth(root *TreeNode) int { if root == nil { return 0 } return max(maxDepth(root.Left), maxDepth(root.Right)) + 1 } func max(a,b int) int { if a &amp;lt; b { return b } return a } Iterative # 这里只需要使用层次遍历，看最多可以遍历几层即可。</description></item><item><title>0124. Binary Tree Maximum Path Sum</title><link>https://example.com/docs/algs/leetcode/124_binary_tree_maximum_path_sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/124_binary_tree_maximum_path_sum/</guid><description>Description # A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.
The path sum of a path is the sum of the node&amp;rsquo;s values in the path.
Given the root of a binary tree, return the maximum path sum of any non-empty path.</description></item><item><title>0206. Reverse Linked List</title><link>https://example.com/docs/algs/leetcode/206_reverse_linked_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/206_reverse_linked_list/</guid><description>Description # Given the head of a singly linked list, reverse the list, and return the reversed list.
Solutions # Iterative # 迭代法，但是要注意虚拟头节点的使用。
func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } dummy := new(ListNode) cur := head for cur != nil { tail := dummy.Next next := cur.Next dummy.Next = cur cur.Next = tail cur = next } return dummy.Next } Recursive # 这里递归法如何反转节点也是需要十分注意的。</description></item><item><title>0226. Invert Binary Tree</title><link>https://example.com/docs/algs/leetcode/226_invert_binary_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/226_invert_binary_tree/</guid><description>Description # Given the root of a binary tree, invert the tree, and return its root.
Solutions # Recursive # 太简单了，递归交换每个节点的左右子节点即可。
func invertTree(root *TreeNode) *TreeNode { if root == nil || root.Left == nil &amp;amp;&amp;amp; root.Right == nil { return root } left, right := invertTree(root.Left), invertTree(root.Right) root.Left, root.Right = right, left return root } Iterative # 或者也可以用中序遍历的的迭代方式。
func invertTreeIterative(root *TreeNode) *TreeNode { if root == nil { return nil } var queue []*TreeNode queue = append(queue, root) for len(queue) !</description></item><item><title>0235. Lowest Common Ancestor of Binary Search Tree</title><link>https://example.com/docs/algs/leetcode/235_lowest_common_ancestor_of_a_binary_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/235_lowest_common_ancestor_of_a_binary_tree/</guid><description>Description # Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”
Solutions # Recursive # 这题很简单，因为 BST 本身就具备有序的性质，所以我们只需要抓住这个性质来进行遍历即可。首先我们假设 p 比 q 要小，那么对于递归遍历到的每个节点 root， 如果 root 的值大于最大 q 的值，那么说明最小公共节点一并比 root 要小，我们需要往root 的左子树进行查找；如果 root 的值小于最小值 p 的值，那么说明最小公共祖先一定比 p 要大，那么我们需要往 p 的右节点进行查找；否则，说明 root 的值刚好结余 p 和 q 之间，此时 root 就是我们所查找的最小公共组节点，返回 root 即可。</description></item><item><title>0236. Lowest Common Ancestor of Binary Tree</title><link>https://example.com/docs/algs/leetcode/236_lowest_common_ancestor_of_binary_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/236_lowest_common_ancestor_of_binary_tree/</guid><description>Description # Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”
Solutions # Recursive # 这里如果是一棵二叉排序树，那么问题就会简单很多，但是这里只是普通的二叉树，所以稍微就会稍微难一点。注释都写在代码中了，判断的过程值得好好体会一下。</description></item><item><title>0543. Diameter of Binary Tree</title><link>https://example.com/docs/algs/leetcode/543_diameter_of_binary_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/543_diameter_of_binary_tree/</guid><description>Description # Given the root of a binary tree, return the length of the diameter of the tree.
The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.
The length of a path between two nodes is represented by the number of edges between them.
Solutions # Recursive # 这是题主一开始想出来的方法：用一个全局变量 res 代表直径最大值，然后分别当前节点计算左右子树的最大高度，然后比较左右子树再加上当前节点拼起来的树的最大直径与 res 的大小，根据比较结果来更新 res。写得稍微有点复杂。</description></item></channel></rss>