<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Recursive on Interview</title><link>https://example.com/tags/Recursive/</link><description>Recent content in Recursive on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/Recursive/index.xml" rel="self" type="application/rss+xml"/><item><title>0091. Decode Ways</title><link>https://example.com/docs/algs/leetcode/91_decode_ways/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/91_decode_ways/</guid><description>Description # A message containing letters from A-Z can be encoded into numbers using the following mapping:
&amp;lsquo;A&amp;rsquo; -&amp;gt; &amp;ldquo;1&amp;rdquo; &amp;lsquo;B&amp;rsquo; -&amp;gt; &amp;ldquo;2&amp;rdquo; &amp;hellip; &amp;lsquo;Z&amp;rsquo; -&amp;gt; &amp;ldquo;26&amp;rdquo; To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, &amp;ldquo;11106&amp;rdquo; can be mapped into:
&amp;ldquo;AAJF&amp;rdquo; with the grouping (1 1 10 6) &amp;ldquo;KJF&amp;rdquo; with the grouping (11 10 6) Note that the grouping (1 11 06) is invalid because &amp;ldquo;06&amp;rdquo; cannot be mapped into &amp;lsquo;F&amp;rsquo; since &amp;ldquo;6&amp;rdquo; is different from &amp;ldquo;06&amp;rdquo;.</description></item><item><title>0092. Reverse Linked List II</title><link>https://example.com/docs/algs/leetcode/92_reverse_linked_list_ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/92_reverse_linked_list_ii/</guid><description>Description # Given the head of a singly linked list and two integers left and right where left &amp;lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list.
Solutions # 使用头插法来翻转节点：先找到待翻转节点的前一个节点pre，pre 的下一个几点就是要翻转的第一个节点 cur，使用一个节点 t 表示 cur 的下一个节点，防止断链。然后将 cur 连接到 t 的下一个节点上，然后将 t 的下一个节点设置为 cur，然后再将 pre 指向 t，这样就完成了一个节点的翻转，然后继续翻转下面的节点即可。
func reverseBetween(head *ListNode, left int, right int) *ListNode { if head == nil || right &amp;lt; left { return nil } // 试用 dummy 防止出现需要翻转第一个节点的情况 dummy := new(ListNode) dummy.</description></item><item><title>0206. Reverse Linked List</title><link>https://example.com/docs/algs/leetcode/206_reverse_linked_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/206_reverse_linked_list/</guid><description>Description # Given the head of a singly linked list, reverse the list, and return the reversed list.
Solutions # Iterative # 迭代法，但是要注意虚拟头节点的使用。
func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } dummy := new(ListNode) cur := head for cur != nil { tail := dummy.Next next := cur.</description></item></channel></rss>