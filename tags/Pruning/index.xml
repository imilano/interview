<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pruning on Interview</title><link>https://example.com/tags/Pruning/</link><description>Recent content in Pruning on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/Pruning/index.xml" rel="self" type="application/rss+xml"/><item><title>0015. 3 Sum</title><link>https://example.com/docs/algs/leetcode/15_3sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/15_3sum/</guid><description>Description # Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
Notice that the solution set must not contain duplicate triplets.
Solutions # Two Pointer # 注意这里其实并没有说不能更改原数组，那么我们可以对原数组先排个序，然后遍历数组，每次遍历到数 x，从 x 的后面的子数组找出两个和为-x 的数即可。 这里可以注意到右以下几个优化技巧：
遍历的时候只需要遍历到倒数第三个即可。 由于限制了不能重复，那么遍历时候对于重复出现的数字需要跳过，策略是，从第二个数字开始，如果这个数字和前一个数字相同，则跳过这个数字，继续遍历下一个。 如果当前固定的数 x 是个正数，那么也可以直接跳过这个数，因为既然数组已经排好序了，那么后面的数都只会比 x 大，他们的和也比 x 大 那么如何在子数组中查找-x 呢，可以在子数组中使用双指针，假设一个下标是 i 另一个是 j，那么如果二者之和大于 target，则 j 前移，否则 i 后移。 i 和 j 移动的过程中需要注意，二者均需要跳过重复数字 func threeSum(nums []int) [][]int { return solution(nums) } func solution(nums []int) [][]int { var res [][]int size := len(nums) if size &amp;lt; 3 { return res } sort.</description></item></channel></rss>