<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Binary Tree on Interview</title><link>https://example.com/tags/Binary-Tree/</link><description>Recent content in Binary Tree on Interview</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/tags/Binary-Tree/index.xml" rel="self" type="application/rss+xml"/><item><title>0102. Binary Tree Level Order Traversal</title><link>https://example.com/docs/algs/leetcode/102_binary_tree_level_order_traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/102_binary_tree_level_order_traversal/</guid><description>Description # Given the root of a binary tree, return the level order traversal of its nodes&amp;rsquo; values. (i.e., from left to right, level by level).
Solutions # 层次遍历，使用队列来做即可。
func levelOrder(root *TreeNode) [][]int { var res [][]int if root == nil { return res } queue := new(Queue) queue.Push(root) for queue.Len() != 0 { size := queue.Len() var arr []int for size != 0 { ele := queue.Pop().(*TreeNode) size -= 1 if ele == nil { continue } arr = append(arr, ele.</description></item><item><title>0103. Binary Tree ZigZag Level Order Traversal</title><link>https://example.com/docs/algs/leetcode/103_binary_tree_zigzag_level_order_traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/103_binary_tree_zigzag_level_order_traversal/</guid><description>Description # Given the root of a binary tree, return the zigzag level order traversal of its nodes&amp;rsquo; values. (i.e., from left to right, then right to left for the next level and alternate between).
Solutions # 简单题，使用队列进行层次遍历即可。
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func zigzagLevelOrder(root *TreeNode) [][]int { var res [][]int if root == nil { return res } var queue []*TreeNode queue = append(queue, root) var flag bool for len(queue) !</description></item><item><title>0124. Binary Tree Maximum Path Sum</title><link>https://example.com/docs/algs/leetcode/124_binary_tree_maximum_path_sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/124_binary_tree_maximum_path_sum/</guid><description>Description # A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.
The path sum of a path is the sum of the node&amp;rsquo;s values in the path.
Given the root of a binary tree, return the maximum path sum of any non-empty path.</description></item><item><title>0314. Binary Tree Vertical Order Traversal</title><link>https://example.com/docs/algs/leetcode/314_binary_tree_vertical_order_traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/314_binary_tree_vertical_order_traversal/</guid><description>Description # Given a binary tree, return the vertical order traversal of its nodes&amp;rsquo; values. (ie, from top to bottom, column by column).
If two nodes are in the same row and column, the order should be from left to right.
Solutions # Level Order Traversal # 这里可以隐约看出来是要使用层序遍历，但是与一般的层序遍历的稍微有点不同。这里的主要思想是：对每个节点赋予一个值 col，然后对于其左节点，col 减 1，对于右节点， col 加 1。这样的话，同一列的节点都会有同一个值 col。在入队的时候，不仅需要将节点入队，还需要将节点的 row 入队，二者可以组成一个 pair。
func vericalOrder(root *TreeNode) [][]int { if root == nil { return nil } var res [][]int type pair struct { Node *TreeNode Col int } // 层序遍历需要用到的队列 var queue []pair // 记录每个 col 上有哪些节点 dict := make(map[int]*TreeNode) queue = append(queue, pair{root, 0}) for len(queue) !</description></item><item><title>0366. Find Leaves of Binary Tree</title><link>https://example.com/docs/algs/leetcode/366_find_leaves_of_binary_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/366_find_leaves_of_binary_tree/</guid><description>Description # Given a binary tree, collect a tree&amp;rsquo;s nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty.
Example:
Input: [1,2,3,4,5]
1 / \ 2 3 / \ 4 5 Output: [[4,5,3],[2],[1]]
Solutions # BFS # 这个题要求，每次都把叶节点给出调，然后再剩下的树中再把叶节点除掉，重复上述过程直到数中没有节点为止。仔细观察一下，你会发现，每次除掉的都是出度为 0 的节点。反过来说，如果你将这个树视作一个以叶节点为出发点的图，那么这个问题就会变成一个拓扑排序题。如果你能这么想，那问题也就很简单了。首先先将这个树视作一个以叶节点为出发点、以根节点为结束点的的有向图，然后统计每个节点的入度，每次把入度为 0 的节点放到数组中，然后将从该节点可达的节点的入度减去 1.循环上述过程即可，典型的拓扑排序问题。
同样是上面的思路，但是可以不把这个图视作有向图，可以视作无向图，然后对无向图的每个节点统计出入度，上面的入度为 0 的条件可以替换为入度为 1 。
Golang 本身没有 set， 确实很让人蛋疼。
func findLeaves(root *TreeNode) [][]int { if root == nil { return nil } // 将树视为无向图，从根节点开始进行 BFS，对于每条边，统计两个节点的入度。 // 然后将入度为 1 的节点入队(因为无向图入度为 1 表示该节点为叶节点)，开始进行无向图的拓扑排序。 degree := make(map[int]map[int]bool) var queue []*TreeNode queue = append(queue, root) for len(queue) !</description></item><item><title>0543. Diameter of Binary Tree</title><link>https://example.com/docs/algs/leetcode/543_diameter_of_binary_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/543_diameter_of_binary_tree/</guid><description>Description # Given the root of a binary tree, return the length of the diameter of the tree.
The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.
The length of a path between two nodes is represented by the number of edges between them.
Solutions # Recursive # 这是题主一开始想出来的方法：用一个全局变量 res 代表直径最大值，然后分别当前节点计算左右子树的最大高度，然后比较左右子树再加上当前节点拼起来的树的最大直径与 res 的大小，根据比较结果来更新 res。写得稍微有点复杂。</description></item><item><title>0968. Binary Tree Cameras</title><link>https://example.com/docs/algs/leetcode/968_binary_tree_cameras/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/docs/algs/leetcode/968_binary_tree_cameras/</guid><description>Description # You are given the root of a binary tree. We install cameras on the tree nodes where each camera at a node can monitor its parent, itself, and its immediate children.
Return the minimum number of cameras needed to monitor all nodes of the tree.
Solutions # Greedy Algorithms # 这种 hard 题，题主肯定是不会做的啦（囧�� ），所以只好求助于网上大神了：
这里先考虑把相机放在什么位置上能看到的节点最多（这样的话相机数量就会最少）？能放在叶节点吗？显然不能，叶节点最多只能看到两个节点；能放到根节点吗？根节点最多也只能看到 3 个。最优解是放在叶节点的父节点上，这样最多就可以看到四个节点。所以策略是先找到叶节点，然后在其父节点上放相机，同时标记父节点的父节点为被拍到了的状态。这样就有三种不同的状态，用 0 表示当前节点是叶节点，用 1 表示当前节点是叶节点的父节点并且放置了相机，用 2 表示当前节点是叶节点的爷爷节点，并且被相机拍到了。这里使用一个全局变量 res 记录相机个数。在递归过程中，若当前节点不存在，则返回 2，空节点也可以看做被相机拍到了。否则对相机左右节点递归调用，若二者中有一个返回 0，则当前节点至少有一个节点是叶节点，需要在当前位置放置一个相机，res 自增 1，并返回 1；如果左右节点的返回值中有一个为 1，说明左右节点中至少有一个已经放上了相机，当前节点已经被拍到了，返回 2。若都不是，则说明当前节点是叶节点，返回 0。在主函数中，若对根节点调用递归的返回值是 0，说明这个树只有一个节点或者根节点的左右节点没有子节点或者根节点就是叶节点，此时没有办法，只能在根节点上也放一个相机，否则不用加。</description></item></channel></rss>