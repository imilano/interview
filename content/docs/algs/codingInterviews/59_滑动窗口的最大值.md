---
title: 59. 滑动窗口的最大值
weight: 10
---

## Description
> 给定一个长度为 n 的数组 nums 和滑动窗口的大小 size ，找出所有滑动窗口里数值的最大值。
> 
> 例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。

## Solutions

### Dequeue

使用一个单调递减的单调队列来做。维持一个最大长度为 size 的单调队列，每当遍历到当前元素 i，如果当前元素 nums[i] 比队列尾部元素要大，则不断将队列尾部元素出队，直到队列为空或者当前元素 nums[i] 比队尾元素要小，然后将当前元素入队。这样的话，队列中要么维持着一个最大值，要么顶多维持着 size 个相对递减的连续值。然后检查队首元素是否过期，如果过期，则将队首元素出队，因为我们每次顶多入队一个，所以每次遍历也顶多只会有一个元素过期。最后检查当前窗口长度是否达到 size，如果达到了，则将队列首部元素入队即可。
```go
// 可以使用单调递减的单调队列来实现
func maxInWindows( num []int ,  size int ) []int {
    // write code here
    var res []int
    n := len(num)
    if size < 1 || n < 1 {
        return res
    }
    
    var queue []int
    for i := 0; i < n; i++ {
        // 如果当前遍历到的元素比队尾元素要大，则不断将队尾元素出队
        curLen := len(queue)
        for curLen > 0 && num[i] > num[queue[curLen-1]] {
            curLen--
            queue = queue[:curLen]
        }
        
        queue = append(queue, i)
		// 如果当前队首元素滑出左边界，则将其删除
        if queue[0] + size <= i {
            queue = queue[1:]
        }
        
		// 如果当前已经构成了一个有效的滑动窗口，则将当前最大值存入结果
        if size <= i+1 {
            res = append(res, num[queue[0]])
        }
    } 
    
    return res
}
```

