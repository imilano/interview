---
title: 31. 栈的压入弹出序列
weight: 10
---

## Description

> 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。

## Solutions

### 栈模拟

新建一个栈来模拟出栈序列。使用一个指针 inPos 指向当前入栈序列的单签入栈元素，使用另一个指针 outPos 指向出栈序列当前应该出栈的元素，然后开始模拟出入栈。
- 首先，如果当前栈顶元素和出栈序列匹配，则出栈栈顶元素，并且将 outPos 右移，直到二者不匹配或者栈为空
- 将 inPos 指针指向的入栈序列的元素入栈，然后将 inPos 右移。
- 不断循环上述过程，直到入栈序列中的所有元素都入栈。
- 最后判断是否出栈序列中的所有元素都已经匹配完成即可。
```go
func IsPopOrder( pushV []int ,  popV []int ) bool {
    // write code here
    size := len(pushV)
    if size == 0 {
        return true
    }
    var stack []int
    stack = append(stack, pushV[0])
    inPos, outPos := 1, 0
	// 为什么这里的循环用的是 <= ，而不是 < ？
	// 因为有可能我们一直从入栈序列中入栈的操作，直到所有元素都已经入栈。如果只使用 < 符号的话，
	// 我们就无法判断出栈序列是否和栈顶元素匹配（当然你也可以在 for 循环之后再加上这一步，只不过加
	// 上这个=号之后可以少写一点代码）.
    for inPos <= size {
        // 如果栈顶元素和出栈序列当前元素匹配，则可以一直出栈
        s := len(stack)
        for s > 0 && popV[outPos] == stack[s-1] {
            stack = stack[:s-1]
            s--
            outPos++
        }
        
		// 为什么这里要有个 break ?
		// 很明显，当入栈序列已经全部入栈了时，我们需要跳出这个循环
        if inPos == size {
            break
        }
        
        // 当前栈中没有元素和出栈序列匹配，或者栈已经为空，则将入栈序列入栈
        stack = append(stack, pushV[inPos])
        inPos++
    }
    
    // 入栈序列遍历完之后，如果此时栈中的元素个数为0，则说明是有效序列；
    // 否则如果栈中还有元素，则说明是无效序列。
    return len(stack) == 0 && outPos == size
}
```
