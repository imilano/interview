[{"id":0,"href":"/docs/algs/","title":"Algorithms","section":"Docs","content":"这里是我刷过的一些算法题，在这里整理一下方便以后复习。主要包括了《剑指 Offer》和 leetcode 的一些题目。\n"},{"id":1,"href":"/docs/algs/basic/","title":"Basic","section":"Algorithms","content":"这里是一些基础知识。\n排序 # 冒泡排序 堆排序 插入排序 归并排序 快速排序 选择排序 希尔排序 树 # 前序遍历 中序遍历 后续遍历 层次遍历 "},{"id":2,"href":"/docs/algs/codingInterviews/","title":"Coding Interviews","section":"Algorithms","content":"这里是一些《剑指 Offer》的刷题题解。\n数据结构 # 链表 # 题目 难度 技巧 特别关注 备注 6. 从尾到头打印链表 简单 栈、递归 No 简单题，无需过多关注 24. 反转链表 简单 递归 YES 这里需要注意如何进行反转 25. 合并两个排序的链表 简单 归并 No 52. 两个链表的第一个公共节点 简单 YES 这里的解题思想需要注意一下 23. 链表中环的入口节点 中等 哈希表、快慢指针 YES 首先需要注意如何进行环检测，如何判断环终止；其次需要注意如何找到环的入口节点 22. 链表中倒数最后 k 个节点 简单 快慢指针 No 35. 复杂链表的复制 难 哈希表 YES 链表或者图的复制就非常适合用哈希表来做 76. 删除链表中重复的节点 中等 链表、虚拟头结点 YES 链表的删除要非常注意虚拟头结点的使用 18. 删除链表的节点 简单 虚拟头结点 YES 链表删除要注意虚拟头节点的使用 树 # 题目 难度 技巧 特别关注 备注 55. 二叉树的深度 简单 No 77. 按之字形顺序打印二叉树 中等 层次遍历 Yes 54. 二叉搜索树的第 k 个节点 中等 中序遍历 YES 7. 重建二叉树 中等 递归 YES 注意划分边界 26. 树的子结构 中等 递归 YES 注意如何又将每个子节点作为一个子问题来进行处理 27. 二叉树的镜像 简单 递归 No 32. 从上往下打印二叉树 简单 层次遍历 No 33. 二叉搜索树的后序遍历序列 中等 后序遍历、分治 YES 82. 二叉树中和为某一值的路径（一） 简单 回溯 No 34. 二叉树中和为某一值的路径（二） 中等 回溯 YES 36. 二叉搜索树与双向链表 中等 BST YES 这个题需要注意，尤其是怎么确定 head 节点，以及 pre 节点的选择，还有就是怎么将 pre 节点和当前节点做连接。题目本身其实并不算难，就是中序遍历，但是问题就是一些边界条件的考量，在这里尤其需要注意。 79. 判断是不是平衡二叉树 简单 平衡树、递归 YES 这里需要注意平衡树的定义：不仅根节点是平衡树，左右子树也需要是平衡树。这里跟 26 题差不多，都是需要将每个子节点有单独作为一个子问题来进行求解。 8. 二叉树的下一个节点 中等 中序遍历 YES 注意这里的分析过程，很值得学习 28. 对称的二叉树 简单 递归 No 78. 把二叉树打印成多行 简单 层次遍历 No 37. 序列化二叉树 难 先序遍历、层次遍历 YES 这个题目的层次遍历方法值得好好再看一次 84. 二叉树和为某一值的路径III 中等 递归 YES 注意这里跟 79、26 题其实是同一个模式，都是将每一个子节点又作为一个子问题来进行求解 86. 在二叉树中找到两个节点的最近公共祖先 中等 递归 YES 注意这里是如何判断递归终止以及返回条件的， 这个题也很值得留意 68. 二叉搜索树的最近公共祖先 简单 递归、BST YES 注意这里跟 86 题的相似性，这个题的解法也很值得注意 队列 \u0026amp; 栈 # 题目 难度 技巧 特别关注 备注 9. 双栈实现队列 简单 栈 No 30. 包含 Min 函数的栈 简单 栈 YES 注意这里是如何构造一个的单调栈的 31. 栈的压入弹出序列 中等 栈 YES 73. 翻转单词序列 简单 字符串 YES 貌似众多涉及到翻转的问题都可以通过全局翻转，然后再局部翻转来实现 59. 滑动窗口的最大值 难 单调队列 YES 注意这里是如何构造单调队列的 算法 # 搜索算法 # 题目 难度 技巧 特别关注 备注 53. 数字在升序数组中出现的次数 简单 二分查找、中心扩散 No 4. 二维数组中的查找 简单 剪枝 YES 注意这里是如何充分利用给出的条件的 11. 旋转数组中的最小数字 简单 二分 YES 注意这里是如何使用二分来缩小边界的 38. 字符串的排列 中等 回溯 YES 使用基于交换的全排列的思想来做，但是需要注意permute 函数中是如何选择下一个起始位置的 动态规划 # 题目 难度 技巧 特别关注 备注 42. 连续子数组的最大值 简单 动态规划 YES Kadane 方法 85. 连续子数组的最大值II middle 动态规划 YES Kadane 方法 69. 跳台阶 简单 动态规划 YES 经典问题 10. 斐波那契数列 简单 动态规划 No 经典问题 19. 正则表达式匹配 难 动态规划 YES 暂时跳过 71. 跳台阶扩展问题 简单 动态规划 YES 其实也是一道找规律题 70. 矩形覆盖 中等 动态规划 YES 实际上是数学归纳法再加上找规律 63. 买卖股票的最好时机 简单 动态规划 YES 47. 礼物的最大价值 中等 动态规划 YES 注意几个技巧：复用原数组、开辟一个(m+1)*(n+1)的数组可以简化运算 48. 最长不含重复字符的子字符串 滑动窗口 YES 注意这里的滑动窗口解法以及涉及到的几个 corner case 46. 把数字翻译成字符串 中等 动态规划、递归 YES 回溯 # 题目 难度 技巧 特别关注 备注 12. 矩阵中的路径 中等 回溯 YES 注意这个技巧：直接使用原数组来标记特定点是否访问过，而不用再新开数组 13. 机器人的运动范围 难 回溯 YES 排序 # 题目 难度 技巧 特别关注 备注 3. 数组中重复的数字 简单 哈希表 No 51. 数组中的逆序对 中等 归并排序 YES 这里借助了归并排序的思想，核心是：两个无序或有序的区间的逆序对数是一致的，但是有序区间更贱方便计算。 40. 最小的 k 个数 中等 堆、快排 No 41. 数据流中的中位数 难 堆 YES 注意这里如果维持两个堆的元素数量，以让左边大根堆的元素数量至多比右边小根堆多 1 位运算 # 题目 难度 技巧 特别关注 备注 65. 不用加减乘除做加法 简单 位运算 YES 注意这里的位运算技巧 15. 二进制中 1 的个数 简单 位运算 No 16. 数值的整数次方 中等 递归 No 56. 数组中只出现一次的两个数字 中等 哈希表、位运算 YES 这里的分析很有意思，注意这个分组技巧 模拟 # 题目 难度 技巧 特别关注 备注 29. 顺时针打印矩阵 简单 YES 注意这里是如何判断重叠的 61. 扑克牌顺子 简单 数组 No 67. 把字符串转换成整数 中等 字符串 No 稍微有些繁杂，先跳过 20. 表示数值的字符串 难 字符串 No 稍微有些繁杂，先跳过 其他算法 # 题目 难度 技巧 特别关注 备注 66. 构建乘积数组 简单 数组 No 50. 第一个只出现一次的字符 简单 哈希表 No 5. 替换空格 简单 字符串 No 21. 调整数组顺序使奇数位于偶数前面 中等 Array No 39. 数组中出现次数超过一半的数字 简单 No 43. 整数中 1 出现的次数 中等 数学 Yes 繁杂，暂时先跳过 45. 把数组排成最小的数 中等 排序，字符串 YES 这里的排序思路很值得注意 49. 丑数 中等 三指针 YES 这里的三指针思想很值得注意 74. 和为 S 的连续整数序列 中等 YES 17. 打印从 1 到最大的 n 位数 简单 No 81. 调整数组顺序使奇数位于偶数前面 简单 No 57. 和为 S 的两个数字 简单 双指针 No 74. 和为 S 的连续正数序列 中等 滑动窗口、双指针 YES 注意这里的起始条件以及滑动技巧 58. 左旋转字符串 中等 字符串，多次翻转 YES 多注意字符串多次翻转的技巧 75. 字符流中第一个不重复的字符 中等 字符串、队列 YES 注意这里队列的使用 14. 剪绳子 中等 剪枝、DP YES 注意这里递归的使用以及 DP 的思想 "},{"id":3,"href":"/docs/algs/leetcode/","title":"Leetcode","section":"Algorithms","content":"这里是一些 LeetCode 的刷题题解。\nData structure # Stack # Problem Difficulty Method Redo Comment 155. Min Stack easy Stack、Monotone Stack No 150. Evalute Reverse Polish Notation medium Stack No 简单题，无需多看 224. Basic Calculator hard Stack YES 题目为难题，暂时跳过。注意这里是如何将中缀表达式转换为后缀表达式的 227. Basic Calculator medium Stack YES 稍微有点耗时，先跳过 20. Valid Parentheses easy Stack No 1472. Design Browser History medium Stack No 1047. Remove All Adjacent Duplicates in String easy Stack No 1249. Minimum Remove to Make Valid Parentheses medium Stack Yes 735. Asteroid Collision medium Stack Yes Heap # Problem Difficulty Method Redo Comment 973. K Closest Points to Origin medium Sort、 Heap No 要看到本质问题，然后解决本质问题。 347. Top K Frequent Elements medium Sort、 Hash Table、Heap No 23. Merge K Sorted Lists medium Sort、 Heap No 378. Kth Smallest Element in a Sorted Matrix medium Heap、Max Heap YES 这个题一开始没有想到堆的解法，还是需要注意一下 767. Reorganize String medium Heap、Sort YES 这里的解法还是比较巧妙的，需要多注意一下 1642.Furthest Building you can Reach medium Heap、Priority Queue YES 这里的解法很巧妙，需要注意一下 215. Kth Largest Element in an Array medium Heap、Quick Select YES 这里的 Quick Select 算法需要熟练一下 Queue # Problem Difficulty Method Redo Comment 225. Implement Stack using Queues easy Queue No 简单题，不需要多看 346. Moving Average from Data Stream easy Queue No 简单题，不需要多看 281. ZigZag Iterator medium Queue YES 注意这里的队列的使用，还是挺妙的 1429. First Unique Number unknown Queue、 Hash Table No 362. Design Hit Counter unknown Queue No 264. Ugly Number II medium Queue YES 第一次做的时候做了一个错误解法，还是要注意丑数是怎么推出来的 1642.Furthest Building you can Reach medium Heap、Priority Queue YES 这里的解法很巧妙，需要注意一下 542. 01 Matrix medium BFS YES 一个复杂的 case 完全可以让正确的算法不能 AC，所以就解题而言，先要把复杂的 case 给进行优先处理，或者算法的实现要考虑复杂 case 的情况 Hash Table # Problem Difficulty Method Redo Comment 1. Two Sum easy Hash Table、Sort、Two Pointer No 146. LRU Cache medium Double Linked List、Hash Table YES 在双向链表中添加 dummyHead 和 dummyTail 能够避免很多条件判断 128. Longest Consecutive Sequence medium Hash Table YES 注意考虑为什么这里可以把遍历过的元素删除掉 380. Insert Delete GetRandom O(1) medium Hash Table、Array YES 注意这里删除元素的 tricky 部分 1461. Check If a String Contans All Binary Codes of Size K medium Hash Table、String YES 这里首先要注意怎么一步一步从暴力算法开始进行优化，然后逐渐过渡到使用 map 来做记忆化的；另外还需要注意 golang 的格式化字符串 padding 方法 349. Intersection of Two Arrays easy Hash Table No 350. Intersection of Two Arrays II easy Hash Table No 1086. High Five easy Hash Table、Sort No 692. Top K Frequent Words medium Sort、 Hash Table No 895. Max Frequency Stack hard Hash Table、Stack YES 这里的解法很巧妙，需要注意一下 745. Prefix and Suffix Search hard Hash Table、String YES 有时间暴力解法也是没问题的 1268. Search Suggestions System medium Hash Table、String、Trie Tree YES 这里的剪枝算法需要注意一下 409. Longest Palindrome easy Hash Table、String YES 这里的解法，要注意一下 820. Short Encoding of Words medium Hash Table、String YES 这里的思路比较巧妙 454. 4Sum II medium Hash Table、Divide YES 这里降低时间复杂度的思想比较巧妙，值得学习 277. Find the Celebrity medium Hash Table、Graph YES 这里的图论思想很值得思考 138. Copy List With Random Pointer medium Hash Table、List YES 列表、图拷贝都需要结合哈希表来做 Graph # Problem Difficulty Method Redo Comment 277. Find the Celebrity medium Hash Table、Graph YES 这里的图论思想很值得思考 200. Number of Islands medium DFS、Graph YES 133. Clone Graph medium DFS、BFS YES 这里 map 的用法很巧妙 490. The Maze medium BFS、DFS YES 这也算是 BFS 的变体应用，也可以从这里总结出一个 pattern 出来 130. Surrounding Regions medium DFS、BFS YES 反向思考 1091. Shortest Path in Binary Matrix medium DFS、BFS YES 这个题有很多注意点需要看：一个是迷宫遍历的变体，另一个是数字转换为字符串的坑 417. Pacific Atlantic Water Flow medium DFS YES 这个题的思路很有用，另外也有几个遍历技巧值得注意 207. Course Scheduler medium BFS、DFS、Topological Sorting YES 这里是典型的拓扑排序的解法 210. Course Scheduler II medium BFS、DFS、Topological Sorting YES 注意拓扑排序中是什么时候需要加入节点 Linked List # Problem Difficulty Method Redo Comment 160. Intersection of Two Linked Lists easy Two Pointer、 Hash Table YES 注意可能会出现无交点的情况 206. Reverse Linked List easy Stack、Recursive YES 注意这里的递归法中，如何反转节点 876. Middle of the Linked List easy Two Pointer YES 注意这里是如何判断中间节点的 141. Linked List Cycle easy Hash Table、 Two Pointer YES 注意这里的快慢指针解法 142. Linked List Cycle II medium Linked List、Hash Table、Two Pointer YES 注意这里的快慢指针解法 92. Reverse Linked List II medium Linked List、 Stack YES 注意这里是如何使用指针来进行翻转的 328. Odd Even Linked List medium Linked List、 Two Pointer YES 注意这里是如何连接节点的 146. LRU Cache medium Double Linked List、Hash Table YES 在双向链表中添加 dummyHead 和 dummyTail 能够避免很多条件判断 String # Problem Difficulty Method Redo Comment 28. Implement strStr easy None No 44. Wildcard Matching hard Recusive No 318. Maximum Product of Word Lengths medium Hash Table Yes 这里的解法很精妙，使用了一个 int 来做记录，提升了性能 1332. Remove Palindromic Subsequences easy String、Palindrome YES 这里是一个脑筋急转弯 1689. Partitioning Into Minimum Number Of Deci-Binary Numbers medium String、 Math YES 这里的解法很巧妙，如果没有答案里的特殊方法，肯定是很难解出来的 Array # Problem Difficulty Method Redo Comment 36. Valid Sudoku medium None YES 注意这里如何创建三维数组，以及坐标的转换 41. First Missing Positive Hard HashTable, Array YES 注意 while 循环是如何交换元素的，以及 while 循环为什么不能用 if 语句代替 54. Spiral Matrix medium Array YES 73. Set Matrix Zeroes medium 记忆化方法 YES 注意这里是如何复用原数组以及采用的记忆化方法 1480. Running Sum of 1d Array easy Array No 简单题，不用再多看了 867. Transpose Matrix easy Array、Matrix No 简单题，不需要多看了 167. Two Sum II - Input Array Is Sorted medium Array、Two Pointer No 简单题，无需多看 Tree # Problem Difficulty Method Redo Comment 102. Binary Tree Level Order Traversal medium Binary Tree、BFS No 基础题，必须要会做 103. Binary Tree ZigZag Level Order Traversal medium Binary Tree、BFS NO 简单题，解法跟 102 题一致 314. Binary Tree Vertical Order Traversal medium Binary Tree、BFS YES 这里是 BFS 的应用之一，这里我一开始没想出编号的方法 752. Open the Lock medium BFS YES 这里是迷宫遍历的变体，用到的几个 trick 需要注意一下 543. Diameter of Binary Tree easy Recursive NO 310. Minimum Height Tree medium BFS YES 这里首先注意 BFS 的终止条件，这里与一般的 BFS 不太相同；第二注意如何将 BFS 应用到无向图 366. Find Leaves of Binary Tree medium BFS YES 这个题的解法与 310 题差不多，其实都是图的拓扑排序的问题，而且 310 和 366 都是针对无向图进行的拓扑排序，还是很值得关注的 124. Binary Tree Maximum Path Sum hard Tree、Branch Pruning YES 这里的剪枝过程比较值得关注 226. Invert Binary Tree easy Recursive NO 101. Symmetic Tree easy Recursive No 236. Lowest Common Ancestor of Binary Tree medium Recursive、Binary Tree YES 这里的分析过程需要注意 235. Lowest Common Ancestor of Binary Search Tree medium Recursive、Iterative YES 这里需要注意的是如何将递归思路转换为迭代的思路 104. Max Depth of Binary Tree easy Recursive、Iterative YES 这里的迭代解法需要注意一下 559. Maximum Depth of N-ary Tree easy Iterative No 这里实际上就是 104 题的扩展版 111. Minimum Depth of Binary Tree easy Recursive、Iterative No 这里需要注意递归解法的遍历终止条件 572. Subtree of Another Tree easy Recursive Yes 注意这里 SameTree 的写法 230. Kth Smallest Element in a BST medium Tree、 Inorder Traversal No Search # Bianry Search # Problem Difficulty Method Redo Comment 33. Search in Rotated Sorted Array medium binary search YES 34. Find First and Last Position of Element in Sorted Array medium binary search YES 注意这里的第二种解法，也就是二分查找中如何确定边界的问题 162. Find Peak Element medium Binary search、Monotone Stack、Array YES 这里二分的解法还是太 tricky 了 278. First Bad Version easy Binary Search No 简单题，直接过 74. Search a 2D Matrix medium Binary Search、Matrix YES 这题的二分解法很巧妙 240. Search a 2D Matrix II medium Binary Search、Matrix YES 这个题的解法跟 74 题完全一致 540. Single Element in a Sorted Array medium Binary Search、Array YES 这里的隐式二分真的太巧妙了，需要注意一下 69. Sqrt(x) easy Binary Search YES 注意这里的边界是如何区分的；开头去掉一些 corner case的话，会让主逻辑更清晰一些 367. Valid Perfect Square easy Binary Search YES 注意这里的边界是如何区分的，以及这里与 69 题的相似性 528. Random Pick with Weight medium Binary Search YES 这里首先需要注意的是随机数的选择方法；其次需要注意的是，sum 数组的下标需要与原数组下标匹配（针对本题答案而言） Problem Difficulty Method Redo 21. Merge Two Sorted List medium Merge Sort No 22. Generate Parentheses medium Prune, Recursive YES 26. Remove Duplicates from Sorted Array easy No Math # Bit Manipulation # Problem Difficulty Method Redo Comment 29. Divide Two Integers medium Bit manipulation YES 191. Number of 1 Bits easy Bit manipulation No 这题太简单了，没什么好说的 1342. Number of Steps to Reduce a Number to Zero easy Bit manipulation No 太简单了，不用再看 1060. Missing Number in Sorted Array easy Bit manipulation、Math、Binary Search YES Math Computation # Problem Difficulty Method Redo Comment 268. Missing Number easy Math No 简单题，直接略过 263. Ugly Number easy Math YES 这里还是需要稍微注意一下n 的范围是怎么一步步缩小的 453. Minimum Moves to Equal Array Elements medium Math YES 这里的解法比较 tricky，比较难想得是如何从与 n-1 个数打交道转换为只需要与一个数打交道 462. Minimum Moves to Equal Array Elements medium Math YES 这里为什么使用中位数就行，而使用平均数就不可以呢 Dynamic Programming # Problem Difficulty Method Redo Comment 42. Traping Rain Water medium DP, Stack YES 474. Ones and Zeroes medium DP YES 这里的递推式还是想不太出来，注意遍历的方向 354. Russian Doll Envelopes hard DP YES 注意这里更最长递增子序列问题的相似性 303. Range Sum Query - Immutable easy DP、Prefix Sum YES 注意这里前缀和的解法 304. Range Sum Query 2D - Immutable medium DP、Prefix Sum YES 注意这里的坐标变换是如何进行的 120. Triangle medium DP YES 注意这里 DP 方法中复用原数组的技巧 64. Minimum Path Sum medium DP YES 这个题跟 120 题的解法几乎完全一致 ，注意这里使用到的套路 583. Delete Operations for Two Strings medium DP YES 这题的 DP 解法跟 1143 题是完全一致的，都是求解最长公共子序列 1048. Longest String Chain medium DP YES 5. Longest Palindrome Substring medium DP YES 要注意这里的 DP 解法；另外，单个字符串的最长的公共串/序列问题，尝试看看能不能转换为两个字符串的公共子串/序列问题 718. Maximum Length of Repeated Subarray medium DP YES 注意如何将这里的解法用到第5 题中 1062. Longest Repeating Substring medium DP YES 这个题的递推式跟 718 题完全一致 Prefix Sum # Problem Difficulty Method Redo Comment 303. Range Sum Query - Immutable easy DP、Prefix Sum YES 注意这里前缀和的解法 304. Range Sum Query 2D - Immutable medium DP、Prefix Sum YES 注意这里的坐标变换是如何进行的 560. Subarray Sum Equals K medium Prefix Sum No 主要会前缀和的技巧，那么这里就不是很难 307. Range Query Sum - Mutable medium Prefix Sum No 1423. Maximum Points You Can Obrain from Cards medium Prefix Sum、DP YES 注意这个题怎么转换为前缀和来做，并且要注意 res 的初始值 Sort # Problem Difficulty Method Redo Comment 21. Merge Two Sorted List medium Merge Sort No 148. Sort List medium Merge Sort YES 注意这里的自底向上方法；以及自顶向下方法中，要注意断开 middle 和它之前节点的连接 56. Merge Intervals medium Sort YES 179. Largest Number Medium Sort YES 这里的做法需要十分注意，一般可能注意不到 75. Sort Colors medium Bubble Sort、 Count Sort No 215. Kth Largest Element medium Heap、Quick Select YES 这里要非常注意快速选择算法 4. Median of Two Sorted Arrays hard Heap YES 这个题太难了 973. K Closest Points to Origin medium Sort、 Heap No 要看到本质问题，然后解决本质问题。 88. Merge Sorted Array easy Sort、 Merge Sort No 692. Top K Frequent Words medium Sort、 Hash Table No 1647. Minimum Deletions to Make Character Frequencies Unique medium Greedy algorithm、Sort YES 这里的贪心会比价隐晦一些 Two Pointers # Problem Difficulty Method Redo Comment 876. Middle of the Linked List easy Two Pointer No 注意这里 for 循环结束遍历的终止条件 27. Remove Elements easy Two Pointer No 125. Valid Palindrome easy Two Pointer No 简单题，直接跳过即可 1. Two Sum easy Two Pointer、Hash Table No 注意一下这里的哈希表的解法 167. Two Sum II medium Two Pointer No 15. 3Sum medium Two Pointer、Hash Table Yes 注意这里是如何进行减枝的 16. 3Sum Closest medium Two Pointer Yes 注意这里如何进行减枝 18. 4Sum medium Two Pointer YES 注意这里是如何去重的，在最后两个 for 循环中对重复元素去重的技巧要注意一下 11. Container with Most Water medium Yes 这里移动指针的方式有一点贪心的味道 283. Moving Zeroes easy Two Pointer No 26. Remove Duplicates from Sorted Array easy Two Pointer No 395. Longest Substring with At Least K Repeating Characters medium Two Pointer YES 这个题暂时跳过一下 424. Longest Repeating Character Replacement medium Two Pointer、 Sliding Window YES 这里的滑动窗口/双指针的解法是非常巧妙的，值得好好学习 ，尤其是怎么来做类推，来把问题细化 76. Minimum Window Substring hard Sliding Window、Two Pointer YES 这里的滑动窗口解法比较巧妙，尤其是 hash table 的使用；还有这里的分析方法也需要注意一下 485. Max Consecutive Ones easy Two Pointer No 简答题，很快就能有思路 Backtrace # Problem Difficulty Method Redo Comment 51. N-Queens hard Backtrace YES 惭愧，这个经典的问题自己已经忘了它的解法了 52. N-Queues II hard Backtrace YES 这个题跟 51 题的解法是完全一致的。51 题中因为是从上到下对每一行进行的回溯，所以已经做了一个去重的操作 Sliding Window # Problem Difficulty Method Redo Comment 3. Longest Substring Without Repeating Character medium sliding window、Hash Table、String YES 注意这里滑动窗口中左边界的确定，以及左边界 left 的初值和移动方向 1658. Minimum Operations to Reduce X to Zero medium Sliding window、Prefix Sum、Backtrace YES 首先要注意这里是怎么逐步对前缀和方法进行优化的；其次要注意这里的滑动窗口解法，也算是滑动窗口中的一中 pattern 了 1695. Maximum Erasure Value medium Sliding Window、 Hash Table YES 这里其实跟第 3 题是一样的 643. Maximum Average Subarray I easy Sliding Window YES 这题没什么难度，但是要注意两个 if 语句的顺序，不能颠倒 424. Longest Repeating Character Replacement medium Two Pointer、 Sliding Window YES 这里的滑动窗口/双指针的解法是非常巧妙的，值得好好学习 ，尤其是怎么来做类推，来把问题细化 76. Minimum Window Substring hard Sliding Window、Two Pointer YES 这里的滑动窗口解法比较巧妙，尤其是 hash table 的使用；还有这里的分析方法也需要注意一下 487. Max Consecutive Ones II medium Sliding Window、Two Pointer YES 这里的解法跟 1004 题是一样的 1004. Max Consecutive Ones III medium Sliding Window、Two Pointer YES Greedy Algorithms # Problem Difficulty Method Redo Comment 968. Binary Tree Cameras hard greedy algorithm YES 这里其实就有点像是一个递归再配合上状态机的转移 630. Course Schedule III hard Greedy algorithm YES 这里的关键其实还是在于最大堆与贪心算法的结合 665. Non-decreasing Array medium Greedy algorithm YES 这里的贪心有些隐晦，不易发现 1647. Minimum Deletions to Make Character Frequencies Unique medium Greedy algorithm、Sort YES 这里的贪心会比价隐晦一些 Divide and Conquer # Problem Difficulty Method Redo Comment 454. 4Sum II medium Hash Table、Divide YES 这里降低时间复杂度的思想比较巧妙，值得学习 "},{"id":4,"href":"/docs/algs/others/","title":"Others","section":"Algorithms","content":"这里是一些在面试中碰到的其他的题目。\n"},{"id":5,"href":"/docs/algs/leetcode/01_two_sum/","title":"0001. Two Sum","section":"Leetcode","content":" Description # Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nSolutions # Hash Table # 这里因为答案唯一，那么也就意味着数组里的元素是唯一的，所以可以使用 map 来做，只需要一次遍历即可，具体看下面代码就好。\nfunc twoSum(nums []int, target int) []int { dict := make(map[int]int) for idx, num := range nums{ t := target - num if exist(dict, t) { return []int{idx, dict[t]} } dict[num] = idx } return nil } func exist(dict map[int]int, target int) bool { if _, ok := dict[target]; ok { return true } return false } Sort \u0026amp;\u0026amp; Two Pointer # 这里也可以使用排序来做，根据值进行排序，但是需要保存该值对应的下标。排好序之后可以使用双指针，一个 left 指向开头，一个 right 指向结尾，计算二者和，如果小于 target，则 left++，否则 right++，直到二者之和等于 target 即可。思路大概就这样，代码就不写了。\n"},{"id":6,"href":"/docs/algs/leetcode/03_longest_substring_without_repeatng_characters/","title":"0003. Longest Substring Without Repeating Characters","section":"Leetcode","content":" Description # Given a string s, find the length of the longest substring without repeating characters.\nSolutions # Hash Table # 中间扩散法，时间复杂度会比较高，因为会有很多的重复扫描。核心思想是，遍历一次字符串，然后对于每个遍历到的位置，从中心向两侧进行扫描，扫描时使用一个 map 来记录那些已经出现过的字符；在一侧扫描过程中，如果发现该字符已经出现过，则停止扫描该侧。最后 map 的长度即为以该字符为中心的不重复字符的长度。\n// 对于每个位置的字符，从中间向两侧扫描；使用一个 map 记录已经出现过的字符。在一侧扫描过程中，如果该字符已经出现过，则停止扫描该侧。 // 最后 map 的长度即为以该字符为中心的不重复字符的长度 func lengthOfLongestSubstringSolution1(s string) int { // handle empty string var res int if len(s) \u0026lt;= 1 { return len(s) } for i := 0; i \u0026lt; len(s); i++ { res = max(res, helper(s, i)) } return res } func helper(s string, mid int) int { left, right := mid-1, mid+1 dict := make(map[byte]bool) dict[s[mid]] = true for left \u0026gt; 0 { _, ok := dict[s[left]] if ok { break } dict[s[left]] = true left-- } for right \u0026lt; len(s) { _, ok := dict[s[right]] if ok { break } dict[s[right]] = true right++ } return len(dict) } Sliding Window \u0026amp; Hash Table # 很明显也可以使用滑动窗口配合 Hash Table 的方式来解题。首先固定滑动窗口的左边界，然后将滑动窗口的右边界向右滑动，每滑动一个位置，就检查该位置的字符是否有在当前滑动窗口中出现过(也就是说，既要检查该字符是否在 Hash Table 中出现过，还要检查最近一次出现的下标是否位于滑动窗口之内)，如果出现过，则更新滑动串口左边界。另外，每次遍历都需要更新当前滑动窗口的最大长度。\nfunc lengthOfLongestSubstring(s string) int { // 用于存储字符以及该字符最近出现的下标位置 dict := make(map[byte]int) // pre 表示滑动窗口左边界，其指向有效窗口的前一个位置 res, pre, size := 0, -1, len(s) for i := 0; i \u0026lt; size; i++ { // 更新窗口不能放在这里。考虑「i 的出现引入了重复字符」以及「i 的出现没有引入重复字符」这两种情况下， // 两种情况下窗口的更新策略应该是不同的，这么写会导致二者共用一个更新策略，那很明显是错误的。 // res = max(res, i - pre) // idx \u0026gt; pre 保证了出现的字符一定是位于滑动窗口中的，而不是那些之前已经出现过的不在滑动窗口中的字符 if idx, ok := dict[s[i]]; ok \u0026amp;\u0026amp; idx \u0026gt; pre { // 更新窗口不能放在这里。考虑当整个字符串都没有重复字符串的情况下，放在这里会导致窗口值永远不会更新 // res = max(res, i - pre) // 更新滑动窗口左边界 pre = idx } // 更新最大窗口值。因为 pre 始终指向的左边界的前一个位置，所以使用 i - pre 即可 res = max(res, i - pre) // 更新当前字符的最近出现位置 dict[s[i]] = i } return res } func max(a,b int) int { if a \u0026lt; b { return b } return a } "},{"id":7,"href":"/docs/algs/leetcode/05_longest_palindrome_substring/","title":"0005. Longest Palindrome Substring","section":"Leetcode","content":" Description # Given a string s, return the longest palindromic substring in s.\nSolutions # 中心扩散 # 题主首先想到的是中心扩散方法。核心思想就是遍历以此字符串，然后对于遍历到的每个位置，找出以这个位置为中心能找到的最长回文串。需要注意的是，一个回文串可能是偶数长度，也可能是奇数长度。如果是奇数长度，那么就需要以 i 为中心来对左右进行扩散；而如果是偶数长度，那么就需要以 i 和 i-1 为中心来进行扩散。\nfunc longestPalindrome(s string) string { size := len(s) if size \u0026lt;= 1 { return s } var res string for i := 0; i \u0026lt; size; i++ { // 最长回文串可能会出现在以 i 为中心对称的子串上，也可能出现在以 i 和 i - 1 为中心的子串上 r1 := longestPalindromeHelper(s, i, i, size) r2 := longestPalindromeHelper(s, i-1, i, size) res = getMaxString(r1, r2, res) } return res } func longestPalindromeHelper(s string, left, right, size int) string { var res string for left \u0026gt;= 0 \u0026amp;\u0026amp; right \u0026lt; size { if s[left] == s[right] { // res 放在这里更新，这样的话，就不用写判断 left 和 right 是否有效的逻辑了 res = s[left : right+1] left-- right++ } else { break } } return res } func getMaxString(a, b, s string) string { if len(a) \u0026lt; len(b) { if len(b) \u0026lt; len(s) { return s } else { return b } } else { if len(a) \u0026lt; len(s) { return s } else { return a } } } Longest Common Stirng # 将输入字符串逆转之后，原问题就可以转换为求最长公共子串(leetcode 第 718 题)的问题。\nDynamic Programming # 定义 dp[j][i] 表示\nfunc longestPalindrome(s string) string { size := len(s) dp := make([][]bool, size) for idx, _ := range dp { dp[idx] = make([]bool, size) } left, step := 0, 1 for i := 0; i \u0026lt; size; i++ { dp[i][i] = true for j := 0; j \u0026lt; size; j++ { dp[j][i] = s[i] == s[j] \u0026amp;\u0026amp; (i-j \u0026lt;= 1 || dp[j+1][i-1]) if dp[j][i] \u0026amp;\u0026amp; step \u0026lt; i - j + 1 { left = j step = i - j + 1 } } } return s[left: left+step] } "},{"id":8,"href":"/docs/algs/leetcode/11_container_with_most_water/","title":"0011. Container with Most Water","section":"Leetcode","content":" Description # You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\nReturn the maximum amount of water a container can store.\nNotice that you may not slant the container.\nSolutions # Two Pointers # 使用两个指针 i、j分别指向起点中终点，此时容器的盛水量 res=整个数组的长度*min（起点高度nums[i]，终点高度nums[j]）。接下来继续遍历，保留最大的 res 即可。 那么如何遍历呢 ，也就是所，i 和 j 如何移动呢。这里的想法是，最大盛水量取决于短板高度，如果要取得最大盛水量，那么就需要弥补短板，那么也就说，只需要高度以较低的一方移动即可。 当高度相等时，理论上移动任何一方都是可以的，我们可以固定移动左边，也可以固定移动右边。\nfunc maxArea(height []int) int { var res int size := len(height) left, right := 0, size -1 for left \u0026lt;right { res = max(res, min(height[left], height[right]) * (right - left)) if height[left] \u0026lt; height[right] { left++ } else { right-- } } return res } func max(a,b int) int { if a \u0026lt; b { return b } return a } func min(a,b int) int { if a \u0026lt; b { return a } return b } "},{"id":9,"href":"/docs/algs/leetcode/15_3sum/","title":"0015. 3 Sum","section":"Leetcode","content":" Description # Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.\nSolutions # Two Pointer # 注意这里其实并没有说不能更改原数组，那么我们可以对原数组先排个序，然后遍历数组，每次遍历到数 x，从 x 的后面的子数组找出两个和为-x 的数即可。 这里可以注意到右以下几个优化技巧：\n遍历的时候只需要遍历到倒数第三个即可。 由于限制了不能重复，那么遍历时候对于重复出现的数字需要跳过，策略是，从第二个数字开始，如果这个数字和前一个数字相同，则跳过这个数字，继续遍历下一个。 如果当前固定的数 x 是个正数，那么也可以直接跳过这个数，因为既然数组已经排好序了，那么后面的数都只会比 x 大，他们的和也比 x 大 那么如何在子数组中查找-x 呢，可以在子数组中使用双指针，假设一个下标是 i 另一个是 j，那么如果二者之和大于 target，则 j 前移，否则 i 后移。 i 和 j 移动的过程中需要注意，二者均需要跳过重复数字 func threeSum(nums []int) [][]int { return solution(nums) } func solution(nums []int) [][]int { var res [][]int size := len(nums) if size \u0026lt; 3 { return res } sort.Ints(nums) if nums[0] \u0026gt; 0 || nums[size-1] \u0026lt; 0 { return res } for i := 0; i \u0026lt; size-2; i++ { // 正数不需要再遍历 if nums[i] \u0026gt; 0 { break } // 跳过重复数字 if i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] { continue } j, k := i+1, size-1 target := 0 - nums[i] for j \u0026lt; k { sum := nums[j] + nums[k] if sum == target { res = append(res, []int{nums[i], nums[j], nums[k]}) // 跳过重复 for j \u0026lt; k \u0026amp;\u0026amp; nums[j] == nums[j+1] { j++ } for j \u0026lt; k \u0026amp;\u0026amp; nums[k] == nums[k-1] { k-- } // 注意跳过重复之后还需要改变下标 j++ k-- } else if sum \u0026lt; target { j++ } else if sum \u0026gt; target { k-- } } } return res } Hash Table \u0026amp;\u0026amp; Sort # 这是题主借鉴上面的一点思路，使用哈希表和排序写出来的方法。\nfunc threeSum(nums []int) [][]int { size := len(nums) if size \u0026lt; 3 { return nil } // 因为不对顺序有要求，所以可以直接进行排序 sort.Ints(nums) var res [][]int dict := make(map[string]bool) for i := 0; i \u0026lt; size; i++ { // 跳过重复元素 if i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] { continue } // 如果当前元素是正数，因为后面的元素都大于等于当前元素，所以三者和无法为 0 if nums[i] \u0026gt; 0 { break } left, right := i + 1, size - 1 for left \u0026lt; right { r := nums[left] + nums[right] if r == -nums[i] { // 这里不能直接使用 string 来将数字转换为字符串，因为对于负数，这样转换的结果是不正确的 t := strconv.Itoa(nums[i]) + strconv.Itoa(nums[left]) + strconv.Itoa(nums[right]) if _, ok := dict[t]; !ok { // 这里不能使用 continue 语句，因为如果出现[0,0,0,0]这样的组合，使用 continue 语句会导致死循环 // continue res = append(res, []int{nums[i], nums[left], nums[right]}) dict[t] = true } } if r \u0026lt; -nums[i] { left++ } else { right-- } } } return res } "},{"id":10,"href":"/docs/algs/leetcode/16_3sum_closest/","title":"0016. 3Sum Closest","section":"Leetcode","content":" Description # Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\nReturn the sum of the three integers.\nYou may assume that each input would have exactly one solution.\nSolutions # Two Pointer # 这个解法是题主一开始想到的解法，时间复杂度比较高，提交的结果也不如人意，不过还是可以 AC 的。\nfunc threeSumClosest(nums []int, target int) int { var res int sort.Ints(nums) size, diff := len(nums), math.MaxInt for idx, _ := range nums { left, right := idx + 1, size - 1 for left \u0026lt; right { sum := nums[left] + nums[right] + nums[idx] if sum == target { return target } // 注意这这里要使用绝对差 if abs(target - sum) \u0026lt; diff { diff = abs(target - sum) res = sum } if sum \u0026gt; target { right-- } else { left++ } } } return res } func abs(a int) int { if a \u0026lt; 0 { return -a } return a } 下面是上面的方法优化之后的版本：\nfunc abs(a int) int { if a \u0026gt;= 0 { return a } return -a } // optimized func threeSumClosest(nums []int, target int) int { res := math.MaxInt16 if len(nums) \u0026lt;= 2 { return 0 } sort.Ints(nums) for i := 0 ; i\u0026lt; len(nums)-2;i++ { left,right := i+1,len(nums)-1 for left \u0026lt; right { sum := nums[i] + nums[left] + nums[right] if sum == target { return target } if sum \u0026gt; target { right-- } else { left++ } // 这里的会比较巧妙 if abs(target-sum) \u0026lt; abs(target-res) { res = sum } } } return res } "},{"id":11,"href":"/docs/algs/leetcode/18_4sum/","title":"0018. 4 Sum","section":"Leetcode","content":" Description # Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n0 \u0026lt;= a, b, c, d \u0026lt; n a, b, c, and d are distinct. nums[a] + nums[b] + nums[c] + nums[d] == target You may return the answer in any order. Solutions # Two Pointers # 这里也没有什么比较好的想法，只好使用跟 3Sum 差不多的解法：还是先将数组排个序，然后使用双指针来进行查找。不过需要注意的是，这里要求a、b、c 和 d都是不同的，那么也就意味着需要进行去重处理。怎么进行去重呢？这里因为要求四个数都不相同，所以去重策略也是相对比较简单的，直接跳过重复元素即可。\nfunc fourSum(nums []int, target int) [][]int { var res [][]int size := len(nums) sort.Ints(nums) for i := 0; i \u0026lt; size - 3; i++ { // skip duplicate if i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] { continue } for j := i + 1; j \u0026lt; size - 2; j++ { // skip duplicate if j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j-1] { continue } left, right := j + 1, size - 1 for left \u0026lt; right { sum := nums[i] + nums[j] + nums[left] + nums[right] if sum == target { res = append(res, []int{nums[i], nums[j], nums[left], nums[right]}) // skip duplicates for left \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left+1] { left++ } // skip duplicates for left \u0026lt; right \u0026amp;\u0026amp; nums[right] == nums[right-1] { right-- } left++ right-- } else if sum \u0026lt; target { left++ } else { right-- } } } } return res } "},{"id":12,"href":"/docs/algs/leetcode/20_valid_parentheses/","title":"0020. Valid Parentheses","section":"Leetcode","content":" Description # Given a string s containing just the characters \u0026lsquo;(\u0026rsquo;, \u0026lsquo;)\u0026rsquo;, \u0026lsquo;{\u0026rsquo;, \u0026lsquo;}\u0026rsquo;, \u0026lsquo;[\u0026rsquo; and \u0026lsquo;]\u0026rsquo;, determine if the input string is valid.\nAn input string is valid if:\nOpen brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Solutions # 简单题，直接使用栈即可。\nfunc isValid(s string) bool { var stack []byte size := len(s) for i := 0; i \u0026lt; size; i++ { if s[i] == \u0026#39;(\u0026#39; || s[i] == \u0026#39;[\u0026#39; || s[i] == \u0026#39;{\u0026#39; { stack = append(stack, s[i]) } else { cap := len(stack) if cap == 0 { return false } tail := stack[cap-1] if s[i] == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; tail == \u0026#39;(\u0026#39; || s[i] ==\u0026#39;]\u0026#39; \u0026amp;\u0026amp; tail == \u0026#39;[\u0026#39; || s[i] == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; tail == \u0026#39;{\u0026#39; { stack = stack[:cap-1] } else { return false } } } return len(stack) == 0 } "},{"id":13,"href":"/docs/algs/leetcode/21_merge_two_sorted_list/","title":"0021. Merge Two Sorted List","section":"Leetcode","content":" Description # You are given the heads of two sorted linked lists list1 and list2.\nMerge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\nReturn the head of the merged linked list.\nSolutions # 简单题，不多说了，参考归并排序思想。\nMerge Sort # func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode { res := new(ListNode) node := res dummyHead1, dummyHead2 := list1, list2 for dummyHead1 != nil \u0026amp;\u0026amp; dummyHead2 != nil { t := new(ListNode) if dummyHead1.Val \u0026lt;= dummyHead2.Val { t.Val = dummyHead1.Val dummyHead1 = dummyHead1.Next } else { t.Val = dummyHead2.Val dummyHead2 = dummyHead2.Next } node.Next = t node = node.Next } for dummyHead1 != nil { t := new(ListNode) t.Val = dummyHead1.Val node.Next = t node = node.Next dummyHead1 = dummyHead1.Next } for dummyHead2 != nil { t := new(ListNode) t.Val = dummyHead2.Val node.Next = t node = node.Next dummyHead2 = dummyHead2.Next } return res.Next } "},{"id":14,"href":"/docs/algs/leetcode/22_generate_parentheses/","title":"0022. Generate Parentheses","section":"Leetcode","content":" Description # Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\nSolutions # Recursive # 参见： https://leetcode-cn.com/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/\n使用两个变量 left 和 right 来表示「左括号使用了集合」和「右括号使用了几个」，通过分析可以得到以下结论： - 只有当left 和 right 都比 n 小的时候，才产生分支。 - 产生左分支的时候，只看当前还有左括号可用 - 产生右分支的时候，还受到左括号数量的限制，left 要大于 right 的时候，才可以产生分支。否则就是无效分支，可以直接返回。 - 在左边和右边的括号数都等于 n 的时候结算。\nfunc generateParenthesis(n int) []string { var res []string if n == 0 { return res } generateParenthesisHelper(n, 0,0,\u0026#34;\u0026#34;, \u0026amp;res) return res } func generateParenthesisHelper(n, left, right int, cur string, res *[]string) { if left == n \u0026amp;\u0026amp; right == n { *res = append(*res, cur) return } // 剪枝 if left \u0026lt; right { return } if left \u0026lt; n { generateParenthesisHelper(n, left+1, right, cur + \u0026#34;(\u0026#34;, res) } if right \u0026lt; n { generateParenthesisHelper(n, left, right+1, cur + \u0026#34;)\u0026#34;, res) } } "},{"id":15,"href":"/docs/algs/leetcode/23_merge_k_sorted_list/","title":"0023. Merge K Sorted List","section":"Leetcode","content":" Description # You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it.\nSolutions # Min Heap # 很简单的想法，使用最小堆即可。\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeKLists(lists []*ListNode) *ListNode { return mergeKListsSolution1(lists) } // 使用最小堆，将所有的节点数据都插入到最小堆中，然后再把所有元素从最小堆中弹出 func mergeKListsSolution1(lists []*ListNode) *ListNode { var minHeap MinHeapArr heap.Init(\u0026amp;minHeap) for _, list := range lists { t := list for t != nil { heap.Push(\u0026amp;minHeap, t.Val) t = t.Next } } res := new(ListNode) node := res for len(minHeap) \u0026gt; 0 { val := heap.Pop(\u0026amp;minHeap).(int) t := new(ListNode) t.Val = val node.Next = t node = node.Next } return res.Next } type MinHeapArr []int func (h MinHeapArr) Len() int { return len(h) } func (h MinHeapArr) Less(i, j int) bool { return h[i] \u0026lt; h[j] } func (h MinHeapArr) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *MinHeapArr) Push(x interface{}) { *h = append(*h, x.(int)) } func (h *MinHeapArr) Pop() interface{} { size := len(*h) res := (*h)[size-1] *h = (*h)[:size-1] return res } func (h *MinHeapArr) Top() interface{} { // TODO return nil } "},{"id":16,"href":"/docs/algs/leetcode/26_remove_duplicates_from_sorted_array/","title":"0026. remove duplicated from sorted array","section":"Leetcode","content":" Description # Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nSolution # 简单题。使用一个 pos 指针指向当前不重复元素应该存储的位置，然后遍历数组，对于重复元素则跳过，知道遇到不重复元素位置，将该元素放到 pos 处，然后让 pos 和 start 都自增，然后继续遍历\nfunc removeDuplicates(nums []int) int { size := len(nums) if size \u0026lt;= 1 { return size } start, pos := 1, 1 for start \u0026lt; size { for start \u0026lt; size \u0026amp;\u0026amp; nums[start] == nums[start-1] { start++ } if start \u0026lt; size { nums[pos] = nums[start] pos++ } start++ } return pos } "},{"id":17,"href":"/docs/algs/leetcode/27_remove_element/","title":"0027. Remove Element","section":"Leetcode","content":" Description # Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nSolutions # 参考比较排序挪位置的想法，使用双指针进行进行排序和挪位置即可。\nfunc removeElement(nums []int, val int) int { size := len(nums) start, end := 0, size -1 for start \u0026lt;= end { if nums[start] != val { start++ continue } for i := start+1; i \u0026lt;= end; i++ { nums[i-1] = nums[i] } end-- } return end+1 } "},{"id":18,"href":"/docs/algs/leetcode/28_implement_strStr/","title":"0028. Implement strStr","section":"Leetcode","content":" Description # Implement strStr().\nGiven two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\nSolutions # 太简单了在，直接看代码即可。\nfunc strStr(haystack string, needle string) int { var pos int size := len(haystack) targetSize := len(needle) if size == 0 || targetSize == 0 { return pos } var start int pos = -1 for start \u0026lt; size { if haystack[start] != needle[0] { start++ continue } if start + targetSize \u0026lt;= size \u0026amp;\u0026amp; haystack[start: start+targetSize] == needle { pos = start break } start++ } return pos } "},{"id":19,"href":"/docs/algs/leetcode/29_divide_two_integers/","title":"0029. Divide Two Integers","section":"Leetcode","content":" Description # Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\nThe integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\nReturn the quotient after dividing dividend by divisor.\nNote: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\nSolutions # Subtraction # 俗话说得好，\u0026ldquo;计算中的除法都是通过减法来完成的\u0026rdquo;。 :)\n很不幸，下面这个解法超时了. :)\nfunc divide(dividend int, divisor int) int { var quotient int if dividend == 0 { return quotient } negative := true if dividend \u0026gt; 0 \u0026amp;\u0026amp; divisor \u0026gt; 0 || dividend \u0026lt; 0 \u0026amp;\u0026amp; divisor \u0026lt; 0 { negative = false } dividend, divisor = abs(dividend), abs(divisor) for dividend \u0026gt; 0 { dividend -= divisor if dividend \u0026gt;= 0 { quotient++ } if negative \u0026amp;\u0026amp; dividend \u0026gt; 0 \u0026amp;\u0026amp; quotient \u0026gt;= int(math.MaxInt32) + 1 { return int(math.MinInt32) } if !negative \u0026amp;\u0026amp; dividend \u0026gt; 0 \u0026amp;\u0026amp; quotient \u0026gt;= int(math.MaxInt32) { return int(math.MaxInt32) } } if negative { return -quotient } return quotient } func abs(a int) int { if a \u0026lt; 0 { return -a } return a } "},{"id":20,"href":"/docs/algs/leetcode/33_search_in_rotated_array/","title":"0033. Search in Rotated Sorted Array","section":"Leetcode","content":" Description # There is an integer array nums sorted in ascending order (with distinct values).\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 \u0026lt;= k \u0026lt; nums.length) such that the resulting array is [nums[k], nums[k+1], \u0026hellip;, nums[n-1], nums[0], nums[1], \u0026hellip;, nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\nYou must write an algorithm with O(log n) runtime complexity.\nSolutions # Binary Search # 引用别人的话：\n将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。 此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环.\n还是使用二分查找的方法来。首先，如果这个数组翻转了，那么至少有有一侧是占多数数字的，具体那哪一侧还要进一步判断。经过举例观察可以看到，如果中间数小于右边的数，那么右边一定是有序的；如果中间数大于右边的数，那么左半段是有序的。那么我们只需要在有序的区间内进行二分查找即可。详见代码。\nfunc search(nums []int, target int) int { size := len(nums) left, right := 0, size-1 for left \u0026lt;= right { mid := left + (right-left)/2 if nums[mid] == target { return mid } if nums[mid] \u0026lt; nums[right] { // 如果右半边有序，则对右半边进行二分 if nums[mid] \u0026lt; target \u0026amp;\u0026amp; nums[right] \u0026gt;= target { left = mid + 1 } else { right = mid - 1 } } else { // 如果左半边有序，则对左半边进行二分 if nums[left] \u0026lt;= target \u0026amp;\u0026amp; nums[mid] \u0026gt; target { right = mid -1 } else { left = mid + 1 } } } return -1 } "},{"id":21,"href":"/docs/algs/leetcode/34_find_first_and_last_position_of_element_in_sorted_array/","title":"0034. Find First and Last Position of Element in Sorted Array","section":"Leetcode","content":" Description # Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\nIf target is not found in the array, return [-1, -1].\nYou must write an algorithm with O(log n) runtime complexity.\nSolutions # Binary Search # 二分查找再加上中间扩散，很容易想出来。\nfunc searchRange(nums []int, target int) []int { res := []int{-1, -1} size := len(nums) if size == 0 { return res } left, right := 0, size -1 for left \u0026lt;= right { mid := (left+right)/2 if nums[mid] == target { l,r := mid, mid res[0] = l res[1] = r for l \u0026gt;= 0 \u0026amp;\u0026amp; nums[l] == target { res[0] = l l-- } for r \u0026lt; size \u0026amp;\u0026amp; nums[r] == target { res[1] = r r++ } break } else if nums[mid] \u0026gt; target { right = mid -1 } else if nums[mid] \u0026lt; target { left = mid + 1 } } return res } 在最坏情况下，比如数组中所有数字均相同，则时间复杂度会退化为 \\( \\Omircon(n) \\) 。下面是优化之后的解法。\nfunc searchRange(nums []int, target int) []int { res := []int{-1, -1} size := len(nums) left, right := 0, size -1 // find left position first for left \u0026lt; right { mid := (left+right)/2 if nums[mid] \u0026lt; target { left = mid + 1 } else { right = mid } } if left \u0026gt;= size || nums[left] != target { return res } // find right positon res[0] = left right = size for left \u0026lt; right { mid := (left + right)/2 if nums[mid] \u0026lt;= target { left = mid + 1 } else { right = mid } } res[1] = right-1 return res } "},{"id":22,"href":"/docs/algs/leetcode/36_valid_sudoku/","title":"0036. Valid Sudoku","section":"Leetcode","content":" Description # Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\nEach row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Solutions # 一个是要注意如何快速创建三维数组，另一个是要注意如何进行坐标转换。\nfunc isValidSudoku(board [][]byte) bool { size := 9 // 一次性将所有行和列创建完毕 row, col := make([][]int, size), make([][]int, size) for i := 0; i \u0026lt; size; i++ { row[i], col[i] = make([]int, size), make([]int, size) } // 表示 9 个gird，么个 grid 有 9 个元素. 最后创建出来的是一个 grid[3][3][9] 的三维数组 grid := make([][][]int, 3) for idx, _ := range grid { grid[idx] = make([][]int, 3) for i, _ := range grid[idx] { grid[idx][i] = make([]int, size) } } // 下面这种创建三维数组的方式太繁琐了 // for i := 0; i \u0026lt; 3; i++ { // grid[i] = make([][]int, 3) // } // for i := 0; i \u0026lt; 3; i++ { // for j := 0; j \u0026lt; 3; j++ { // grid[i][j] = make([]int, size) // } // } for i := 0; i \u0026lt; size; i++ { for j := 0; j \u0026lt; size; j++ { if board[i][j] == \u0026#39;.\u0026#39; { continue } // 之所以要减去 1，是为了将值控制在 0-8 之内，避免数组访问越界 index := int(board[i][j] - \u0026#39;0\u0026#39; - 1) row[i][index]++ col[j][index]++ grid[i/3][j/3][index]++ if row[i][index] \u0026gt; 1 || col[j][index] \u0026gt; 1 || grid[i/3][j/3][index] \u0026gt; 1 { return false } } } return true } "},{"id":23,"href":"/docs/algs/leetcode/38_count_and_say/","title":"0038. Count and Say","section":"Leetcode","content":" Descrition # The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\ncountAndSay(1) = \u0026ldquo;1\u0026rdquo; countAndSay(n) is the way you would \u0026ldquo;say\u0026rdquo; the digit string from countAndSay(n-1), which is then converted into a different digit string. To determine how you \u0026ldquo;say\u0026rdquo; a digit string, split it into the minimal number of groups so that each group is a contiguous section all of the same character. Then for each group, say the number of characters, then say the character. To convert the saying into a digit string, replace the counts with a number and concatenate every saying.\nSolutions # 统计每个字符出现的次数即可。\nfunc countAndSay(n int) string { if n == 0 { return \u0026#34;0\u0026#34; } res := \u0026#34;1\u0026#34; for n-1 \u0026gt; 0 { cur := \u0026#34;\u0026#34; // 统计 res 中每个字符出现的次数，然后将再将次数和该字符拼接到 cur 上，最后将 cur 赋值给 res size := len(res) for i := 0; i \u0026lt; size; i++ { cnt := 1 for i + 1 \u0026lt; size \u0026amp;\u0026amp; res[i] == res[i+1] { cnt++ i++ } cur += strconv.Itoa(cnt) + string(res[i]) } res = cur n-- } return res } "},{"id":24,"href":"/docs/algs/leetcode/41_first_msssing_positive/","title":"0041. First Missing Positive","section":"Leetcode","content":" Description # Given an unsorted integer array nums, return the smallest missing positive integer.\nYou must implement an algorithm that runs in O(n) time and uses constant extra space.\nSolutions # Hash Table # 可以使用一个 hash table 记录所以出现的值，然后找出当前值中的最大值。然后从 1 到最大值开始遍历，如果出现一个不在 hash table 中的数，则将该数返回即可。如果所有数都出现在了 hash table 中，那么返回最大值加 1 即可。但是最后这里需要注意的是，有可能整个数组都是负数，这样的话会导致前面的判断失效，所以返回值应该最小要返回 1.\nfunc firstMissingPositive(nums []int) int { dict := make(map[int]bool) curMax := nums[0] for _, num := range nums { dict[num] = true if num \u0026gt; curMax { curMax = num } } for i := 1; i \u0026lt;= curMax; i++ { if _, ok := dict[i]; !ok { return i } } return max(1, curMax + 1) } func max(a, b int) int { if a \u0026lt; b { return b } return a } 进一步的，其实没必要遍历那么多数，只需要遍历 n 个数即可，n 为数组长度，上述改进版如下：\nfunc firstMissingPositive(nums []int) int { dict := make(map[int]bool) for _, num := range nums { dict[num] = true } n := len(nums) for i := 1; i \u0026lt;= n; i++ { if _, ok := dict[i]; !ok { return i } } return max(1, n+1) } func max(a, b int) int { if a \u0026lt; b { return b } return a } Array # 因为对空间复杂度有要求，所以上述的 hash table 的方法应该不能满足要求。这里的思路就是复用原数组，我们希望 nums[0]=1, nums[1] = 2, nums[i] = i+1。那么就需要遍历一次数组，遍历过程中如果发现 nums[i] != i+1, 也就是 nums[nums[i]-1] != nums[i]，那么我们就交换这两个元素。 最后扫描一遍数组，如果发现 nums[i] != i+1， 那么说明 i + 1 不在数组中，直接返回 i+1 即可。如果遍历完了发现从 1 到 n （为什么是 n，因为下标 0 存放的是 1，那么下标 n-1 存放的是 n）都在数组中，那么最后只需要返回 n+1 即可。\nfunc firstMissingPositive(nums []int) int { n := len(nums) for i := 0; i \u0026lt; n; i++ { // 注意这里是 while 循环，因为 nums[nums[i]-1] 和 nums[i] 交换的时候已经改变了 nums[i] 的值了 // 所以这个 while 循环不能简单的用 if 来代替 for nums[i] \u0026gt; 0 \u0026amp;\u0026amp; nums[i] \u0026lt;= n \u0026amp;\u0026amp; nums[nums[i]-1] != nums[i] { nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1] } } for i := 0; i \u0026lt; n; i++ { if nums[i] != i+1 { return i+1 } } return n+1 } "},{"id":25,"href":"/docs/algs/leetcode/42_traping_rain_water/","title":"0042. Traping Rain Water","section":"Leetcode","content":" Description # Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\ndetail see: https://leetcode.com/problems/trapping-rain-water/\nSolutions # Array # 使用两个数组扫描两趟，第一个数组 fromLeft 从左到右扫描，记录到目前为止遇到的最大值，第二个数组fromRight 从右向左扫描，记录当前为止遇到的最大值。最后扫描一下这两个数组，对于每个位置 i，取 fromLeft 和 fromRight 二者中的较小者与当前 height[i] 的差值作为当前格子所能盛水量。\nfunc trap(nums []int) int { var res int size := len(nums) if size \u0026lt;= 1 { return res } curMax := nums[0] fromLeft := make([]int, size) for idx, num := range nums { curMax = max(num, curMax) fromLeft[idx] = curMax } curMax = nums[size-1] fromRight := make([]int, size) for i := size-1; i \u0026gt;= 0; i-- { curMax = max(nums[i], curMax) fromRight[i] = curMax } for i := 0; i \u0026lt; size; i++ { res += min(fromLeft[i], fromRight[i]) - nums[i] } return res } func min(a,b int) int { if a \u0026lt; b { return a } return b } func max(a,b int) int { if a \u0026lt; b { return b } return a } 还有一种解法，就是先找出整个数组的最大值，这个最大值将整个数组切分为两部分，然后分别处理左半边和右半边。处理单边的时候，记录自己当前遇到的历史最大值，如果当前值比历史最大值要大，则更新历史最大值为当前值；否则的话说明历史最大值比当前值要大，那么当前值是可以盛水的，则更新结果盛水量。为什么只需要记录当前历史最大值就可以了呢，毕竟能不能盛水其实要靠两边而不是一边啊？答案是我我们已经找出了整个数组的最大值，那么当前的历史最大值只会比整个数组的最大值要小，能盛多少水完全取决于较短的一方（参考短板理论），所以只需要维持一个最大值即可。\n// 先找到数组中的最大值，这个最大值将数组分为左右两部分，然后分别计算左边的所能盛的水和右边所能盛的水 func trap(nums []int) int { var res int size := len(nums) if size \u0026lt;= 1 { return res } // 找到当前最大高度，这个高度将数组一分为二 var maxHeight int for idx, value := range nums { if nums[maxHeight] \u0026lt; value { maxHeight = idx } } // 处理左半边 peakL := nums[0] // 存储当前扫描到的历史 left := 0 for left \u0026lt; maxHeight { // 当前元素更大，则更新历史最大值 if nums[left] \u0026gt; peakL { peakL = nums[left] } else { // 历史最大值还是大于当前元素，则可以盛水 res += peakL - nums[left] } left++ } // 处理右半边 peakR := nums[size-1] right := size-1 for right \u0026gt; maxHeight { if nums[right] \u0026gt; peakR { peakR = nums[right] } else { res += peakR - nums[right] } right-- } return res } "},{"id":26,"href":"/docs/algs/leetcode/44_wildcard_matching/","title":"0044. Wildcard Matching","section":"Leetcode","content":" Description # Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for \u0026lsquo;?\u0026rsquo; and \u0026lsquo;*\u0026rsquo; where:\n\u0026lsquo;?\u0026rsquo; Matches any single character. \u0026lsquo;*\u0026rsquo; Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial).\nSolutions # TODO\n"},{"id":27,"href":"/docs/algs/leetcode/46_permutations/","title":"0046. Permutations","section":"Leetcode","content":" Description # Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\nSolutions # Array(swap) # 基于交换进行 permutate 即可。\nfunc permute(nums []int) [][]int { var res [][]int size := len(nums) helper(0, size, nums, \u0026amp;res) return res } func helper(start,size int, nums []int, res *[][]int) { if start \u0026gt;= size { tmp := make([]int, size) copy(tmp, nums) *res = append(*res, tmp) return } for i := start; i \u0026lt; size; i++ { nums[i], nums[start] = nums[start], nums[i] // 注意这里是 start + 1， 而不是 i helper(start+1, size, nums, res) nums[i], nums[start] = nums[start], nums[i] } } "},{"id":28,"href":"/docs/algs/leetcode/48_rotate_image/","title":"0048. Rotate Image","section":"Leetcode","content":" Description # You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\nSolutions # 补充几个矩阵变换公式： - 主对角线对折： arr[i][j] = arr[j][i] - 副对角线对折： arr[i][j] = arr[n-j-1][n-i-1] go for i := 0; i \u0026lt; n; i++ { for j := 0; j \u0026lt; n-i; j++ { matrix[i][j], matrix[n-j-1][n-i-1] = matrix[n-j-1][n-i-1], matrix[i][j] } } - 横向对折： arr[i][j] = arr[n-i-1][j] - 纵向对折： arr[i][j] = arr[i][n-j-1]\n// 先左右对折，再根据副对角线对折 func rotate(matrix [][]int) { m := len(matrix) // 左右对折 for i := 0; i \u0026lt; m; i++ { left, right := 0, m-1 for left \u0026lt; right { matrix[i][left], matrix[i][right] = matrix[i][right], matrix[i][left] left++ right-- } } // 副对角线对折 for i := 0; i \u0026lt; m ;i++ { for j := 0; j \u0026lt; m-i ;j++ { matrix[i][j], matrix[m-j-1][m-i-1] = matrix[m-j-1][m-i-1], matrix[i][j] } } } "},{"id":29,"href":"/docs/algs/leetcode/49_group_anagrams/","title":"0049. Group Anagrams","section":"Leetcode","content":" Description # Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\nSolutions # 简单的方法就是，对具有相同字母以及字母出现次数也相同的字符串进行排序时，其排序结果都是一样的。所以可以创建一个 map，其中 key 为字符串的排序，value 为具有这样一个排序结果的字符串数组。\nfunc groupAnagrams(strs []string) [][]string { var res [][]string m := make(map[string][]string) for _, str := range strs { str_splited := strings.Split(str, \u0026#34;\u0026#34;) sort.Strings(str_splited) s := strings.Join(str_splited, \u0026#34;\u0026#34;) m[s] = append(m[s], str) } for _, strs := range m { res = append(res, strs) } return res } "},{"id":30,"href":"/docs/algs/leetcode/50_powxn/","title":"0050. Pow(x, n)","section":"Leetcode","content":" Description # Implement pow(x, n), which calculates x raised to the power n (i.e., xn).\nSolutions # Map # 可以使用快速幂以及记忆化数组，单独使用快速幂会导致超时，所以需要配合记忆化数组使用。\nfunc myPow(x float64, n int) float64 { if x == 0 { return 0 } if n == 0 { return 1 } var negative bool if n \u0026lt; 0 { negative = true n = -n } dict := make(map[int]float64) dict[0], dict[1] = 1, x res := helper(x, n, \u0026amp;dict) if negative { return 1 / res } return res } func helper(x float64, n int, dict *map[int]float64) float64 { if value, ok := (*dict)[n]; ok { return value } res := helper(x, n/2, dict) * helper(x, n/2, dict) * helper(x, n%2, dict) (*dict)[n] = res return res } "},{"id":31,"href":"/docs/algs/leetcode/51_n_queens/","title":"0051. N Queens","section":"Leetcode","content":" Description # The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\nEach solution contains a distinct board configuration of the n-queens\u0026rsquo; placement, where \u0026lsquo;Q\u0026rsquo; and \u0026lsquo;.\u0026rsquo; both indicate a queen and an empty space, respectively.\nSolutions # Backtrace # N-皇后问题，就是一个棋盘上放置 N 个皇后，然后要保证当前行、当前列、主对角线和副对角线上都没有皇后。很惭愧，本科和硕士阶段都学过问题，但是现在都忘了。\nN-皇后问题一般使用回溯来解决。\nfunc solveNQueens(n int) [][]string { // 将棋盘全部初始化为点 var res [][]string board := make([][]string, n) for idx, _ := range board { board[idx] = make([]string, n) } for i := 0; i \u0026lt; n ;i++ { for j := 0; j \u0026lt; n; j++ { board[i][j] = \u0026#34;.\u0026#34; } } // 从第一行开始回溯 backtrace(0, n, \u0026amp;res, \u0026amp;board) return res } func backtrace(curRow, rows int, res *[][]string, board *[][]string) { // 递归终止条件 if curRow == rows { // 注意这里不能使用 make 来做预创建 var tmp []string for i := 0; i \u0026lt; curRow; i++ { t := strings.Join((*board)[i],\u0026#34;\u0026#34;) tmp = append(tmp, t) } *res = append(*res, tmp) return } // 遍历这一行的每一列，检查当前棋盘是否合法，如果合法，则将当前格子置为 Queen for i := 0; i \u0026lt; rows; i++ { if isValid(*board, curRow, i, rows) { (*board)[curRow][i] = \u0026#34;Q\u0026#34; backtrace(curRow+1, rows, res, board) (*board)[curRow][i] = \u0026#34;.\u0026#34; } } } func isValid(board [][]string, curRow int, curCol int, rows int) bool { // 查看这个列合不合法 for i := 0; i \u0026lt; curRow; i++ { if board[i][curCol] == \u0026#34;Q\u0026#34; { return false } } // 查看主对角线合不合法 for i, j := curRow - 1, curCol - 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; i,j = i -1, j -1 { if board[i][j] == \u0026#34;Q\u0026#34; { return false } } // 查看副对角线合不合法 for i, j := curRow - 1 , curCol + 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; rows; i,j = i-1, j+1 { if board[i][j] == \u0026#34;Q\u0026#34; { return false } } return true } "},{"id":32,"href":"/docs/algs/leetcode/52_n_queens_ii/","title":"0052. N Queens II","section":"Leetcode","content":" Description # The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return the number of distinct solutions to the n-queens puzzle.\nSolutions # 这题跟 51 题的解法其实是一致的，区别只是这里求的是一个计数值。\nfunc totalNQueens(n int) int { // 将棋盘全部初始化为点 var res int board := make([][]string, n) for idx, _ := range board { board[idx] = make([]string, n) } for i := 0; i \u0026lt; n ;i++ { for j := 0; j \u0026lt; n; j++ { board[i][j] = \u0026#34;.\u0026#34; } } // 从第一行开始回溯 backtrace(0, n, \u0026amp;res, \u0026amp;board) return res } func backtrace(curRow, rows int, res *int, board *[][]string) { // 递归终止条件 if curRow == rows { *res += 1 return } // 遍历这一行的每一列，检查当前棋盘是否合法，如果合法，则将当前格子置为 Queen for i := 0; i \u0026lt; rows; i++ { if isValid(*board, curRow, i, rows) { (*board)[curRow][i] = \u0026#34;Q\u0026#34; backtrace(curRow+1, rows, res, board) (*board)[curRow][i] = \u0026#34;.\u0026#34; } } } func isValid(board [][]string, curRow int, curCol int, rows int) bool { // 查看这个列合不合法 for i := 0; i \u0026lt; curRow; i++ { if board[i][curCol] == \u0026#34;Q\u0026#34; { return false } } // 查看主对角线合不合法 for i, j := curRow - 1, curCol - 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; i,j = i -1, j -1 { if board[i][j] == \u0026#34;Q\u0026#34; { return false } } // 查看副对角线合不合法 for i, j := curRow - 1 , curCol + 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; rows; i,j = i-1, j+1 { if board[i][j] == \u0026#34;Q\u0026#34; { return false } } return true } "},{"id":33,"href":"/docs/algs/leetcode/53_maximum_subarray/","title":"0053. Maximum Subarray","section":"Leetcode","content":" Description # Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\nA subarray is a contiguous part of an array.\nSolutions # Kadane # Kadane 算法，最优子结构性质，当前位置的和取决于前一个位置的子数组和以及当前元素。\ndef max_subarray(arr): max_sum_so_far, sum_ending_here = arr[0], arr[0] for e in range(arr[1:]): sum_ending_here = max(e, sum_ending_here + e) max_sum_so_far = max(max_sum_so_far, sum_ending_here) return max_sum_so_far 如果数组中有负数，并且允许返回长度为 0 的子数列，则该问题可以改为：\ndef max_subarray(arr): max_sum_so_far, sum_ending_here = 0, 0 for e in range(arr): sum_ending_here = max(sum_ending_here + e, e) max_sum_so_far = max(max_sum_so_far, sum_ending_here) return max_sum_so_far 完整代码是：\nfunc maxSubArray(nums []int) int { size := len(nums) if size == 0 { return 0 } res, curSum := nums[0], nums[0] for i := 1; i \u0026lt; size; i++ { curSum = max(curSum+nums[i], nums[i]) res = max(res, curSum) } return res } func max(a,b int) int { if a \u0026gt; b { return a } return b } DP # 定义 dp[i] 表示以 i 为结尾的连续子数组的最大和，则很明显，dp[i] 的值受到 dp[i-1] 和 array[i] 的影响，稍微一想即可得到转态转移方程： \\($dp[i] = \\max (dp[i-1] \u0026#43; array[i], array[i])$\\) func maxSubArray(nums []int) int { // write code here size := len(nums) if size == 0 { return 0 } res := nums[0] dp := make([]int, size) dp[0] = array[0] for i := 1; i \u0026lt; size; i++ { dp[i] = max(dp[i-1]+nums[i], nums[i]) res = max(res, dp[i]) } return res } func max(a,b int) int { if a \u0026lt; b { return b } return a } "},{"id":34,"href":"/docs/algs/leetcode/54_spiral_matrix/","title":"0054. Spiral Matrix","section":"Leetcode","content":" Description # Given an m x n matrix, return all elements of the matrix in spiral order.\nSolutions # 其实就是顺时针旋转打印数组。\nfunc spiralOrder(matrix [][]int) []int { var res []int m, n := len(matrix), len(matrix[0]) up, bottom, left, right := 0, m-1, 0, n - 1 for up \u0026lt;= bottom \u0026amp;\u0026amp; left \u0026lt;= right { for i := left; i \u0026lt;= right; i++ { res = append(res, matrix[up][i]) } up++ if up \u0026gt; bottom { break } for i := up; i \u0026lt;= bottom; i++ { res = append(res, matrix[i][right]) } right-- if right \u0026lt; left { break } for i := right; i \u0026gt;= left; i-- { res = append(res, matrix[bottom][i]) } bottom-- if bottom \u0026lt; up { break } for i := bottom; i \u0026gt;= up;i-- { res = append(res, matrix[i][left]) } left++ if left \u0026gt; right { break } } return res } "},{"id":35,"href":"/docs/algs/leetcode/55_jump_game/","title":"0055. Jump Game","section":"Leetcode","content":" Description # You are given an integer array nums. You are initially positioned at the array\u0026rsquo;s first index, and each element in the array represents your maximum jump length at that position.\nReturn true if you can reach the last index, or false otherwise.\nSolutions # Recursive # 很容易想到递归的办法，但是也很容易就超时了 :)\nfunc canJump(nums []int) bool { size := len(nums) if helper(0, size, nums) { return true } return false } func helper(start int, size int, nums []int) bool { if start \u0026gt;= size -1 { return true } for i := 1; i \u0026lt;= nums[start]; i++ { if helper(start+i, size, nums) { return true } } return false } Greedy # 使用一个变量 remianed 表示当前剩余的跳力（指从当前节点最多还可以跳几步），然后使用一个值 maxDst 表示当前能够跳到的最远距离。每遍历到一个节点，判断是否能跳到当前节点，也就是 i 是否大于 Dst，如果大于，则说明跳不到当前节点，则可以直接返回 false； 否则说明能跳到当前节点，然后根据当前节点的跳力更新当前节点的最大跳力以及能跳到的最远距离。\nfunc canJump(nums []int) bool { size := len(nums) var remained, maxDst int for i := 0; i \u0026lt; size; i++ { // 跳不到当前节点 if i \u0026gt; maxDst { return false } // 剩余的最大跳力 remained = max(nums[i], remained) // 从当前节点跳是否能跳更远的距离 maxDst = max(maxDst, i + remained) remained-- } return true } func max(a, b int) int { if a \u0026lt; b { return b } return a } DP # 维护一个dp数组，其中dp[i]表示到达i位置所剩余的跳力，若到达某个位置时跳力为负，则说明无法到达该位置。\n当前位置的跳力跟上一个位置的跳力以及上一个位置剩余的跳力有关，所以当前位置的剩余跳力和当前位置新的跳力中较大的那个数决定了当前能达到的最远距离，而下一个位置的剩余跳力等于当前位置的跳力减去1，所以 dp[i] = max(dp[i-1], nums[i-1]) - 1。如果当前dp为负，则说明无法抵达当前位置，返回false。\nfunc canJump(nums []int) bool { size := len(nums) dp := make([]int, size) for i := 1; i \u0026lt; size; i++ { dp[i] = max(dp[i-1], nums[i-1]) - 1 if dp[i] \u0026lt; 0 { return false } } return true } func max(a, b int) int { if a \u0026lt; b { return b } return a } "},{"id":36,"href":"/docs/algs/leetcode/56_merge_intervals/","title":"0056. Merge Intervals","section":"Leetcode","content":" Description # Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\nSolutions # 典型的区间合并问题。\n首先先对区间按照开始时间从小到大进行排序，然后使用一个指针 cur 指向当前 intervals 数组遍历到的位置，使用一个指针 tail 指向 res 数组最后一个元素。然后开始对 intervals 数组进行遍历，如果当前遍历到的区间跟 res 数组的最后一个区间没有重叠，则直接将这个区间插入 res 数组，然后 tail 自增；否则的话就合并区间，更新 res[tail] 的结束时间；每次遍历结束，cur 自增。\nfunc merge(intervals [][]int) [][]int { var res [][]int size := len(intervals) if size \u0026lt;= 1 { return intervals } sort.Slice(intervals, func(i,j int)bool { return intervals[i][0] \u0026lt; intervals[j][0] }) res = append(res, intervals[0]) var tail int cur := 1 for cur \u0026lt; size { // 如果开始时间相等，或者 cur 的开始时间小于 tail 的结束时间，则说明有重叠，则需要合并 if intervals[cur][0] \u0026lt;= res[tail][1] || intervals[cur][0] == res[tail][0]{ res[tail][1] = max(res[tail][1], intervals[cur][1]) } else { // 如果没有重叠，则直接插入 res = append(res, intervals[cur]) tail++ } cur++ } return res } //*************** util **************** func min(a,b int) int { if a \u0026lt; b { return a } return b } func max(a,b int) int { if a \u0026lt; b { return b } return a } "},{"id":37,"href":"/docs/algs/leetcode/62_unique_paths/","title":"0062. Unique Paths","section":"Leetcode","content":" Description # There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\nGiven the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\nThe test cases are generated so that the answer will be less than or equal to 2 * 109.\nSolutions # DP # 假设 dp[i][j] 表示到达[i,j] 这个位置的路径数，则很明显，dp[i][j] 的值只会受到 dp[i-1][j] 和 dp[i][j-1] 影响，进而可以进一步得到递推公式 dp[i][j] = dp[i-1][j] + dp[i][j-1]。 base case 的话，第一行第一列的路径应该为 1， 即 dp[i][0] = dp[0][j] = 1。最后 dp[m-1][n-1]即为所求。\nfunc uniquePaths(m int, n int) int { // corner case if m == 1 || n == 1 { return 1 } dp := make([][]int, m) for idx, _ :=range dp { dp[idx] = make([]int, n) } //corner case for i := 0; i \u0026lt; m; i++ { dp[i][0] = 1 } for i := 0; i \u0026lt; n; i++ { dp[0][i] = 1 } for i := 1; i \u0026lt; m ; i++ { for j := 1; j \u0026lt; n; j++ { dp[i][j] = dp[i-1][j] + dp[i][j-1] } } return dp[m-1][n-1] } Math # 这里也可使用排列组合的方法来做。对于一个 m 行 n 类的矩阵，要想从左上角到达右下角，那么必须需要向下走 m-1 步，向右走 n-1 步， 那么也就是说，我们需要从 m-1+n-2 的步数里面，跳出 m -1 个向下的步数和 n-1 个向右的步数。既然想到这里，那么这个问题就很好解决了，直接使用排列组合公式即可。\nfunc uniquePaths(m int, n int) int { // corner case if m == 1 || n == 1 { return 1 } // 确保 n 是较小的那一个，不然下面的算法会导致溢出，进而导致错误的结算结果 if n \u0026gt; m { n,m = m, n } // 计算排列组合 C_n_(m-1+n-1) res := 1 for i := 0; i \u0026lt; n-1; i++ { res *= (n-1+m-1-i) res /= (i+1) } return res } "},{"id":38,"href":"/docs/algs/leetcode/64_minimum_path_sum/","title":"0064. Minimum Path Sum","section":"Leetcode","content":" Description # Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\nSolutions # DP # 这题跟第 120. Triangle 解法几乎一样。相比之下，这题要简单一些。这里很明显需要使用 DP，并且状态转移方程也是很明确的 dp[i][j] += min(dp[i-1][j], dp[i][j-1])，也就是说，当前位置的值只能从左边移动过来或者上边移动过来。特例情况就是第一行跟第一列，这个地方只有一种移动方向，所以需要特别处理一下。\nfunc minPathSum(grid [][]int) int { m, n := len(grid), len(grid[0]) // corner case for i := 1; i \u0026lt; m ;i++ { grid[i][0] += grid[i-1][0] } for i := 1; i \u0026lt; n; i++ { grid[0][i] += grid[0][i-1] } for i := 1; i \u0026lt; m; i++ { for j := 1; j \u0026lt; n; j++ { grid[i][j] += min(grid[i-1][j], grid[i][j-1]) } } return grid[m-1][n-1] } func min(a,b int) int { if a \u0026lt; b { return a } return b } 当然，如果你不想污染原数组，那么也可以创建一个新的二维数组来做 DP 数组。\n"},{"id":39,"href":"/docs/algs/leetcode/66_plus_one/","title":"0066. Plus One","section":"Leetcode","content":" Description # You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0\u0026rsquo;s.\nIncrement the large integer by one and return the resulting array of digits.\nSolutions # 简单题，直接计算即可。\nfunc plusOne(digits []int) []int { size := len(digits) if size == 0 { return digits } carry := 1 for i := size-1; i \u0026gt;= 0; i-- { sum := digits[i] + carry carry = sum / 10 digits[i] = sum % 10 } if carry \u0026gt; 0 { digits = append([]int{carry}, digits...) } return digits } "},{"id":40,"href":"/docs/algs/leetcode/69_sqrtx/","title":"0069. Sqrt(x)","section":"Leetcode","content":" Description # Given a non-negative integer x, compute and return the square root of x.\nSince the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.\nNote: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.\nSolutions # Binary Search # 使用二分法进行快速查找。开头就去除掉一些 corner case 的话，后面整体逻辑写起来就会更加的清晰。\nfunc mySqrt(x int) int { if x \u0026lt;= 1 { return x } low, high := 0, x for low \u0026lt; high { mid := (low+high)/2 if mid * mid == x { return mid } else if mid * mid \u0026gt; x { high = mid } else { low = mid + 1 } } // 注意这里为什么返回的是 high - 1 return high - 1 } "},{"id":41,"href":"/docs/algs/leetcode/70_climing_stairs/","title":"0070. Climbing Stairs","section":"Leetcode","content":" Descriptioin # You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\nSolutions # 斐波那契数列问题，不多说。\nfunc climbStairs(n int) int { if n \u0026lt;= 2 { return n } FMinusOne, FMinusTwo := 2, 1 for i := 3; i \u0026lt;= n; i++ { fn := FMinusOne + FMinusTwo FMinusTwo = FMinusOne FMinusOne = fn } return FMinusOne } "},{"id":42,"href":"/docs/algs/leetcode/73_set_matrix_zeroes/","title":"0073. Set Matrix Zeroes","section":"Leetcode","content":" Descriptioin # Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0\u0026rsquo;s.\nYou must do it in place.\nSolutions # 这里需要注意的是，因为要求不使用额外的内存空间，所以我们就要有这种充分利用原有空间的觉悟。这里的思想是，先检查第一行第一列是否有 0，如果有，则将相应的标志设置为 true，然后使用第一行和第一列来做标记。从第二行第二列开始遍历数组，当 matrix[i][j] = 0 时，则将该行对应的第一个数设置为 0，将该列对应的第一个数设置为 0。遍历结束之后再遍历一次数组，也是从第一行和第一列开始，如果改行或者该列的第一个元素为 0， 则将相应的相应的格子设置为 0.遍历结束后，再根据刚开始设置的行 flag 和列 flag 判断是否应该将第一行和第一列设置为 0.\nfunc setZeroes(matrix [][]int) { m, n := len(matrix), len(matrix[0]) var rowZero, colZero bool // 检查第一列是否包含 0 for i := 0; i \u0026lt; m ;i++ { if matrix[i][0] == 0 { colZero = true break } } // 检查第一行是否包含 0 for i := 0; i \u0026lt; n; i++ { if matrix[0][i] == 0 { rowZero = true break } } // 检查剩余行和列是否包含 0，如果包含，则将相应的第一行位置设为 0，第一列位置设为 0 for i := 1; i \u0026lt; m ;i++ { for j := 1; j \u0026lt; n; j++ { if matrix[i][j] == 0 { matrix[i][0] = 0 matrix[0][j] = 0 } } } // 根据第一行第一列的检测结果，将相应的行和列设置为 0 for i := 1; i \u0026lt; m; i++ { for j := 1; j \u0026lt; n; j++ { if matrix[i][0] == 0 || matrix[0][j] == 0 { matrix[i][j] = 0 } } } // 如果第一行有 0， 则将第一行设置为 0 if rowZero { for i := 0; i \u0026lt; n; i++ { matrix[0][i] = 0 } } // 如果第一列有 0， 则将第一列设置为 0 if colZero { for i := 0; i \u0026lt; m ;i++ { matrix[i][0] = 0 } } } "},{"id":43,"href":"/docs/algs/leetcode/74_search_a_2d_matrix/","title":"0074. Search a 2D Matrix","section":"Leetcode","content":" Description # Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:\nIntegers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.\nSolutions # Binary Search # 这题的二分解法真的比较巧妙。这里首先具备了两个特征：每一行从左向右递增，每一列从上到下递增。那么我们可以从第一列最后一个元素开始进行搜索，如果target 比当前元素要小，那么如果target 要存在，就只能在当前行上边，于是row-1；如果target比当前元素要大，那么如果该元素存在的话，智能在当前列右侧，于是col+1。按照以上规则进行遍历即可。\nfunc searchMatrix(matrix [][]int, target int) bool { m, n := len(matrix), len(matrix[0]) row, col := m-1, 0 for row \u0026gt;= 0 \u0026amp;\u0026amp; col \u0026lt; n { if matrix[row][col] == target { return true } if matrix[row][col] \u0026lt; target { col++ } // 上面的 if 语句可能会导致这里出现越界访问，所以要加上 col \u0026lt; n if col \u0026lt; n \u0026amp;\u0026amp; matrix[row][col] \u0026gt; target { row-- } } return false } "},{"id":44,"href":"/docs/algs/leetcode/75_sort_colors/","title":"0075. Sort Colors","section":"Leetcode","content":" Description # Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library\u0026rsquo;s sort function.\nSolutions # 其实这里应该用任意的一个排序算法都可以。\n冒泡排序的思路 # 参考冒泡排序算法。\n// 方法 1， 冒泡排序的思路 func sortColors(nums []int) { size := len(nums) for i := size -1; i \u0026gt; 0; i-- { for j := 0; j \u0026lt; i; j++ { if nums[j] \u0026gt; nums[j+1] { nums[j], nums[j+1] = nums[j+1], nums[j] } } } } 计数排序的思路 # func sortColors(nums []int) { colors := make([]int, 3) for _, color := range nums { colors[color]++ } var cur int for i := 0; i \u0026lt; 3; i++ { for j := 0; j \u0026lt; colors[i]; j++ { nums[cur] = i cur++ } } } "},{"id":45,"href":"/docs/algs/leetcode/76_minimum_window_substring/","title":"0076. Minimum Window Substring","section":"Leetcode","content":" Description # Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \u0026ldquo;\u0026rdquo;.\nThe testcases will be generated such that the answer is unique.\nA substring is a contiguous sequence of characters within the string.\nSolutions # Sliding Window # 这里应该很容易可以看出需要使用滑动窗口来做，但是与一般的滑动窗口不同的是，这里的滑动窗口中可以包含一些不在字符串 t 中的字符。另外还需要注意的是，窗口中字符的出现顺序不需要和 t 一致，但是出现次数需要一致。\n首先应该很容易能够想到的是，需要一个 map 来扫一遍 t，记录 t 中出现的字符的个数。而问题的难点在于如何维持窗口，并保证t 中的字符都出现在窗口内。 其实在维护这个滑动窗口的过程中，我们可以完全无视那些没有出现在 t 中的字符，这些字符在窗口右边界扩张的时候可以跳过，在左边界收缩的时候也可以跳过，这些字符只会影响窗口子串的长度。 那么我们先扫描一遍 t，统计每个字符出现的个数，将其存到字典 dict 中。然后初始化一个 left = 0，表示滑动窗口左边界；我们还需要一个 minLen，初始化为最大值，表示包含 t 中所有字符的滑动窗口的最小长度；我们还需要一个变量 cnt， 表示当前滑动窗口中已经匹配到的 t 中字符个数。 接着开始遍历 s 中的每个字符，这相当于扩展滑动窗口右边界。对于每个遍历到的字符，在 dict 中减去该字符的出现次数，减去之后如果该字符的出现次数仍然大于等于 0，则说明这个出现在滑动窗口中的字符 c 是出现在 t 中的，则 cnt 加 1。 这里忽略了那些出现在滑动窗口中但是没有出现在 t 中的字符，对于这些字符，减去 1 之后，dict 对该字符的计数小于 0，并不会对 cnt 产生影响。\n一旦 cnt 等于 t 长度，说明此时 t 中的所有字符都已经出现在了滑动窗口中，那么接下来就应该收缩窗口，找到能包含 t 中所有字符的最小窗口。需要收缩右边界吗？答案是不需要，因为我们在 cnt 等于 t 长度的时候才停下来，这个时候滑动窗口刚刚才匹配了 t 中最后一个字符，所以右边是没有冗余字符的，不需要收缩右边界。 但是对于左边界，是有可能会出现冗余的，于是我们就需要收缩左边界。那么怎么收缩呢？首先需要明确的是，我们收缩的目的是为了祛除左边界中的冗余字符，那么就是说，在收缩左边界的过程中，滑动窗口中已经匹配的字符数 cnt 应该不受影响，其值应该正好等于 t 的长度。\n收缩左边界的过程中，如果发现 minLen 比 i - left + 1还要长了，那么说明我们抛弃了更多的冗余字符，找到了可以包含 t 中全部字符的更小的滑动窗口，那么更新结果 res 。在收缩的过程中，因为左边界移动了，所以要把 dict 中字符补充回来，所以需要对字符的出现次数加 1；如果加 1 之后，该字符的出现次数大于等于 1 了，那么说明这个字符是出现在 t 中的字符，这次收缩影响到了滑动窗口中对 t 所有字符的计数值 cnt，则 cnt 需要减去 1. 最后返回\nfunc minWindow(s string, t string) string { m,n := len(s), len(t) var res string minLen, left, cnt := math.MaxInt, 0, 0 // 统计 t 中每个字符出现次数 dict := make(map[byte]int) for idx, _ := range t { dict[t[idx]]++ } // 右边界不断扩张 for i := 0; i \u0026lt; m; i++ { // 如果该字符是出现在了 t 中的字符，则 cnt 自增 dict[s[i]]-- if dict[s[i]] \u0026gt;= 0 { cnt++ } // 如果当前窗口中包含了 t 中所有字符 for cnt == n { // 如果当前窗口更小，那么更新结果值和最小窗口 if minLen \u0026gt; i - left + 1 { minLen = i - left + 1 res = s[left: i+1] } // 缩小左边界，缩小时候需要还原字符计数 dict[s[left]]++ if dict[s[left]] \u0026gt; 0 { cnt-- } left++ } } return res } "},{"id":46,"href":"/docs/algs/leetcode/78_subsets/","title":"0078. Subsets","section":"Leetcode","content":" Descrition # Given an integer array nums of unique elements, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.\nSolutions # 观察一下可以发现，其实子集合就是一个追加操作。你只需要把新元素不断的追加到就有的集合上构成一个新的集合，然后再将这个新集合添加到结果数组中即可。重复上述操作，直到你把原数组中的所有元素都遍历完一次即可。\nfunc subsets(nums []int) [][]int { res := [][]int{{}} size := len(nums) for i := 0; i \u0026lt; size; i++ { n := len(res) for j := 0; j \u0026lt; n; j++ { t := make([]int, len(res[j])) copy(t, res[j]) t = append(t, nums[i]) res = append(res, t) // 注意不能用下面这样的方式。 // 因为 golang 中切片其实底层是一个指向实际数组的指针，所以下面的添加可能会旧元素上进行添加，而不是在新元素上进行添加。 // t := res[j] // t = append(t, nums[i]) // res = append(res, t) } } return res } "},{"id":47,"href":"/docs/algs/leetcode/79_word_search/","title":"0079. Word Search","section":"Leetcode","content":" Description # Given an m x n grid of characters board and a string word, return true if word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\nSolutions # 递归回溯即可。\nfunc exist(board [][]byte, word string) bool { m, n := len(board), len(board[0]) for i := 0; i \u0026lt; m; i++ { for j := 0; j \u0026lt; n; j++ { if board[i][j] == word[0] { visited := make([][]bool, m) for i, _ := range visited { visited[i] = make([]bool, n) } if existBacktrace(board, word, i, j, m, n, \u0026amp;visited) { return true } } } } return false } func existBacktrace(board [][]byte, word string, si, sj, m, n int, visited *[][]bool) bool { if len(word) == 0 { return true } if si \u0026lt; 0 || sj \u0026lt; 0 || si \u0026gt;= m || sj \u0026gt;= n || (*visited)[si][sj] || board[si][sj] != word[0] { return false } if board[si][sj] == word[0] { // 不用重新建立一个 visited 数组,因为下面的语句会把 visited 数组还原 (*visited)[si][sj] = true if existBacktrace(board, word[1:], si+1, sj, m, n, visited) || existBacktrace(board, word[1:], si-1, sj, m, n, visited) || existBacktrace(board, word[1:], si, sj+1, m, n, visited) || existBacktrace(board, word[1:], si, sj-1, m, n, visited) { return true } (*visited)[si][sj] = false } return false } "},{"id":48,"href":"/docs/algs/leetcode/84_largest_rectangle_in_histogram/","title":"0084. Largest Rectangle in Histogram","section":"Leetcode","content":" Description # Given an array of integers heights representing the histogram\u0026rsquo;s bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\nSolutions # 寻找每一个局部峰值 i (heights[i] \u0026gt; heights[i+1])，然后从这个局部峰值 i 开始向前遍历所有的值，算出共同的矩形面积，每次对比保留最大值。 很不幸，超时了 :)\nfunc largestRectangleArea(heights []int) int { var res int size := len(heights) if size == 0 { return res } for i := 0; i \u0026lt; size; i++ { if i+1 \u0026lt; size \u0026amp;\u0026amp; heights[i] \u0026lt;= heights[i+1] { continue } curMin := heights[i] for j := i; j \u0026gt;= 0; j-- { if heights[j] \u0026lt; curMin { curMin = heights[j] } res = max(res, curMin * (i-j+1)) } } return res } func max(a,b int) int { if a \u0026lt; b { return b } return a } "},{"id":49,"href":"/docs/algs/leetcode/88_merge_sorted_array/","title":"0088. Merge Sorted Array","section":"Leetcode","content":" Description # You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\nSolutions # 题目意思是 nums1 的总长是 n+m， 但是只有前 m 个元素才是合法的，后 n 个元素相当于是空位置。现在需要你合并一下 nums1 和 nums2. Follow up 那里是问你是否能够就地合并。\n归并排序 # 很明显应该可以想到归并排序的思路，但是问题是，归并排序需要使用额外的空间。那么如何能够不使用额外的空间也可以合并这两个数组呢（这也是 Follow up 的要求）？其实这里要学会充分利用已有的数组空间，在 LeetCode 的众多题目中，利用已有空间的题并不少。这里我们可以先把 nums1 的 m 个元素右移，然后前面就可以空出来 n 个元素，这就相当于 n 个空位，那么我们就可以借助这 n 个空位完成归并排序。\nfunc merge(nums1 []int, m int, nums2 []int, n int) { // corner case if m == 0 \u0026amp;\u0026amp; n == 0 || n == 0 { return } // 将前 m 个元素每个往后移动 n 位 size := len(nums1) for i := m-1; i \u0026gt;= 0; i-- { nums1[i+n] = nums1[i] } // 归并排序 // 注意 pos1 的起始坐标 pos1, pos2, cur := size-m, 0, 0 for pos1 \u0026lt; size \u0026amp;\u0026amp; pos2 \u0026lt; n { if nums1[pos1] \u0026lt; nums2[pos2] { nums1[cur] = nums1[pos1] pos1++ } else { nums1[cur] = nums2[pos2] pos2++ } cur++ } for pos1 \u0026lt; size { nums1[cur] = nums1[pos1] pos1++ cur++ } for pos2 \u0026lt; n { nums1[cur] = nums2[pos2] pos2++ cur++ } } 插入排序 # 首先，nums1 的前 m 个元素已经排好序了，那么我们只需要将 nums2 的 n 个元素插入到 nums1 中，然后从插入的位置开始进行插入排序即可。\nfunc merge(nums1 []int, m int, nums2 []int, n int) { if m == 0 \u0026amp;\u0026amp; n == 0 || n == 0 { return } size := len(nums1) for i,j := m, 0; i \u0026lt; size; i,j = i+1, j+1 { nums1[i] = nums2[j] } for i := m; i \u0026lt; size; i++ { tmp := nums1[i] j := i for j \u0026gt; 0 \u0026amp;\u0026amp; nums1[j-1] \u0026gt; tmp { nums1[j] = nums1[j-1] j-- } nums1[j] = tmp } } "},{"id":50,"href":"/docs/algs/leetcode/91_decode_ways/","title":"0091. Decode Ways","section":"Leetcode","content":" Description # A message containing letters from A-Z can be encoded into numbers using the following mapping:\n\u0026lsquo;A\u0026rsquo; -\u0026gt; \u0026ldquo;1\u0026rdquo; \u0026lsquo;B\u0026rsquo; -\u0026gt; \u0026ldquo;2\u0026rdquo; \u0026hellip; \u0026lsquo;Z\u0026rsquo; -\u0026gt; \u0026ldquo;26\u0026rdquo; To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, \u0026ldquo;11106\u0026rdquo; can be mapped into:\n\u0026ldquo;AAJF\u0026rdquo; with the grouping (1 1 10 6) \u0026ldquo;KJF\u0026rdquo; with the grouping (11 10 6) Note that the grouping (1 11 06) is invalid because \u0026ldquo;06\u0026rdquo; cannot be mapped into \u0026lsquo;F\u0026rsquo; since \u0026ldquo;6\u0026rdquo; is different from \u0026ldquo;06\u0026rdquo;.\nGiven a string s containing only digits, return the number of ways to decode it.\nThe test cases are generated so that the answer fits in a 32-bit integer.\nSolutions # 一串字符有两种拆分方式，一种是拆分为单个字符，一种是拆分为两个字符，而拆分为单个字符的能力应该总是满足的，但是拆分为的两个字符的能力是有条件的。另外还需要注意的是，0 不能作为首字符，意味着不能把 0 拆分为单个字符，也不能把 0 放在双字符的开头。\nfunc numDecodings(s string) int { size := len(s) if size == 0 { return 0 } var res int numDecodingsRecur(s, \u0026amp;res) return res } func numDecodingsRecur(s string, res *int) { size := len(s) if size == 0 { *res += 1 } if size == 1 \u0026amp;\u0026amp; s != \u0026#34;0\u0026#34; { *res += 1 } if size \u0026gt;= 2 { if s[:1] == \u0026#34;0\u0026#34; { return } if s[:2] \u0026gt;= \u0026#34;10\u0026#34; \u0026amp;\u0026amp; s[:2] \u0026lt;= \u0026#34;26\u0026#34; { numDecodingsRecur(s[2:], res) } numDecodingsRecur(s[1:], res) } } "},{"id":51,"href":"/docs/algs/leetcode/92_reverse_linked_list_ii/","title":"0092. Reverse Linked List II","section":"Leetcode","content":" Description # Given the head of a singly linked list and two integers left and right where left \u0026lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list.\nSolutions # 使用头插法来翻转节点：先找到待翻转节点的前一个节点pre，pre 的下一个几点就是要翻转的第一个节点 cur，使用一个节点 t 表示 cur 的下一个节点，防止断链。然后将 cur 连接到 t 的下一个节点上，然后将 t 的下一个节点设置为 cur，然后再将 pre 指向 t，这样就完成了一个节点的翻转，然后继续翻转下面的节点即可。\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode { if head == nil || right \u0026lt; left { return nil } // 试用 dummy 防止出现需要翻转第一个节点的情况 dummy := new(ListNode) dummy.Next = head // 找到要翻转的节点的前一个节点 pre := dummy for i := 0; i \u0026lt; left-1;i++ { pre = pre.Next } // 翻转链表 cur := pre.Next for i := left; i \u0026lt; right; i++ { // 注意这里的翻转方式 t := cur.Next cur.Next = t.Next t.Next = pre.Next pre.Next = t // pre.Next = t // t.Next = cur // pre = t } return dummy.Next } "},{"id":52,"href":"/docs/algs/leetcode/94_binary_tree_inorder_traversal/","title":"0094. Bianry Tree Inorder Traversal","section":"Leetcode","content":" Description # Given the root of a binary tree, return the inorder traversal of its nodes\u0026rsquo; values.\nSolutions # 二叉树中序遍历，又分为迭代和递归两种方式。\nRecursive # func inorderTraversal(root *TreeNode) []int { var res []int if root == nil { return res } helper(root, \u0026amp;res) return res } func helper(root *TreeNode, res *[]int) { if root == nil { return } helper(root.Left, res) *res = append(*res, root.Val) helper(root.Right, res) } Iterative # 中序遍历需要借助栈来实现。\nfunc inorderTraversal(root *TreeNode) []int { var res []int if root == nil { return res } var stack []*TreeNode cur := root for cur != nil || len(stack) != 0 { for cur != nil { stack = append(stack, cur) cur = cur.Left } size := len(stack) cur = stack[size-1] stack = stack[:size-1] res = append(res, cur.Val) cur = cur.Right } return res } "},{"id":53,"href":"/docs/algs/leetcode/98_validate_binary_search_tree/","title":"0098. Validate Bianry Search Tree","section":"Leetcode","content":" Description # Given the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than the node\u0026rsquo;s key. The right subtree of a node contains only nodes with keys greater than the node\u0026rsquo;s key. Both the left and right subtrees must also be binary search trees.\nSolutions # Inorder Traversal # 首先可以使用中序遍历的的方式遍历一下，然后记录每个遍历到的节点值到一个数组里，然后判断这个数组是否有序即可。这里还可以优化一下，没必要存储整个数组，只需要使用一个指针 pre，记录中序遍历的前一个值即可，然后使用这个值与当前值进行比较，如果当前值小于等于 pre，那么说明这个序列不是递增的，则返回 false。全部遍历结束之后，返回 true。\nfunc isValidBST(root *TreeNode) bool { if root == nil { return true } var stack []*TreeNode cur := root pre := math.MinInt for cur != nil || len(stack) != 0 { for cur != nil { stack = append(stack, cur) cur = cur.Left } size := len(stack) cur = stack[size-1] stack = stack[:size-1] if cur.Val \u0026lt;= pre { return false } pre = cur.Val cur = cur.Right } return true } 有迭代当然有递归，下面是递归的方式：\nfunc isValidBST(root *TreeNode) bool { if root == nil { return true } return helper(root, math.MinInt, math.MaxInt) } func helper(root *TreeNode, mn,mx int) bool { if root == nil { return mn \u0026lt; mx } if root.Val \u0026lt; mn || root.Val \u0026gt; mx { return false } return helper(root.Left, mn, root.Val) \u0026amp;\u0026amp; helper(root.Right, root.Val, mx) } "},{"id":54,"href":"/docs/algs/leetcode/101_symmetric_tree/","title":"0101. Symmetric Tree","section":"Leetcode","content":" Description # Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).\nSolutions # Recursive # 简单题，左子树的左节点的值要等于右子树的右子树的右节点的值，左子树的右节点的值要等于右子树的左节点的值。\nfunc isSymmetric(root *TreeNode) bool { return helper(root, root) } func helper(root1, root2 *TreeNode) bool { if root1 == nil \u0026amp;\u0026amp; root2 == nil { return true } if root1 == nil || root2 == nil { return false } if root1.Val != root2.Val { return false } return helper(root1.Left, root2.Right) \u0026amp;\u0026amp; helper(root1.Right, root2.Left) } Iterative # 这里也可以使用中序遍历的方式，对这个树进行一次中序遍历，然后将所有节点值都放在数组中，然后检查这个数组的元素是否左右对称。这里也比较简单，就不写代码了。\n"},{"id":55,"href":"/docs/algs/leetcode/102_binary_tree_level_order_traversal/","title":"0102. Binary Tree Level Order Traversal","section":"Leetcode","content":" Description # Given the root of a binary tree, return the level order traversal of its nodes\u0026rsquo; values. (i.e., from left to right, level by level).\nSolutions # 层次遍历，使用队列来做即可。\nfunc levelOrder(root *TreeNode) [][]int { var res [][]int if root == nil { return res } queue := new(Queue) queue.Push(root) for queue.Len() != 0 { size := queue.Len() var arr []int for size != 0 { ele := queue.Pop().(*TreeNode) size -= 1 if ele == nil { continue } arr = append(arr, ele.Val) if ele.Left != nil { queue.Push(ele.Left) } if ele.Right != nil { queue.Push(ele.Right) } } res = append(res, arr) } return res } type Queue []interface{} func (q *Queue) Push(x interface{}) { *q = append(*q, x) } func (q *Queue) Pop() interface{} { size := q.Len() if size == 0 { return nil } ele := (*q)[0] *q = (*q)[1:] return ele } func (q *Queue) Len() int { return len(*q) } 也可以用一个数组来简单的模拟队列：\ntype TreeNode struct { Val int Left *TreeNode Right *TreeNode } func levelOrder(root *TreeNode) [][]int { if root == nil { return nil } var res [][]int var queue []*TreeNode queue = append(queue, root) for len(queue) != 0 { size := len(queue) var level []int for i := 0; i \u0026lt; size; i++ { node := queue[i] level = append(level, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } queue = queue[size:] res = append(res, level) } return res } "},{"id":56,"href":"/docs/algs/leetcode/103_binary_tree_zigzag_level_order_traversal/","title":"0103. Binary Tree ZigZag Level Order Traversal","section":"Leetcode","content":" Description # Given the root of a binary tree, return the zigzag level order traversal of its nodes\u0026rsquo; values. (i.e., from left to right, then right to left for the next level and alternate between).\nSolutions # 简单题，使用队列进行层次遍历即可。\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func zigzagLevelOrder(root *TreeNode) [][]int { var res [][]int if root == nil { return res } var queue []*TreeNode queue = append(queue, root) var flag bool for len(queue) != 0 { size := len(queue) var nums []int for i := 0; i \u0026lt; size; i++ { node := queue[i] nums = append(nums, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } queue = queue[size:] if flag { reverse(nums) flag = false } else { flag = true } res = append(res, nums) } return res } func reverse(nums []int) { size := len(nums) start, end := 0, size -1 for start \u0026lt; end { nums[start], nums[end] = nums[end], nums[start] start++ end-- } } "},{"id":57,"href":"/docs/algs/leetcode/104_maximum_depth_of_binary_tree/","title":"0104. Maximum Depth of Binary Tree","section":"Leetcode","content":" Description # Given the root of a binary tree, return its maximum depth.\nA binary tree\u0026rsquo;s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nSolutions # Recursive # 简单题，无需多说。\nfunc maxDepth(root *TreeNode) int { if root == nil { return 0 } return max(maxDepth(root.Left), maxDepth(root.Right)) + 1 } func max(a,b int) int { if a \u0026lt; b { return b } return a } Iterative # 这里只需要使用层次遍历，看最多可以遍历几层即可。\ntype TreeNode struct { Val int Left *TreeNode Right *TreeNode } func maxDepth(root *TreeNode) int { if root == nil { return 0 } var queue []*TreeNode = []*TreeNode{root} var depth int for len(queue) != 0 { size := len(queue) depth++ for i := 0; i \u0026lt; size; i++ { if queue[i].Left != nil { queue = append(queue, queue[i].Left) } if queue[i].Right != nil { queue = append(queue, queue[i].Right) } } queue = queue[size:] } return depth } "},{"id":58,"href":"/docs/algs/leetcode/105_construct_binary_tree_from_preorder_and_inorder_traversal/","title":"0105. Construct Bianry Tree From Preorder and Inorder Traversal","section":"Leetcode","content":" Description # Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\nSolutions # func buildTree(preorder []int, inorder []int) *TreeNode { pre_size, in_size := len(preorder), len(inorder) return buildTreeSolution(preorder, 0, pre_size-1, inorder, 0, in_size -1) } func buildTreeSolution(preorder []int, pleft, pright int, inorder []int, ileft, iright int) *TreeNode { if pleft \u0026gt; pright || ileft \u0026gt; iright { return nil } var rootIndex int for i := ileft; i \u0026lt;= iright; i++ { if inorder[i] == preorder[pleft] { rootIndex = i break } } root := new(TreeNode) root.Val = preorder[pleft] root.Left = buildTreeSolution(preorder, pleft+1, pleft + rootIndex - ileft, inorder, ileft, rootIndex-1) root.Right = buildTreeSolution(preorder, pleft + rootIndex-ileft+1, pright, inorder, rootIndex+1, iright) return root } "},{"id":59,"href":"/docs/algs/leetcode/108_convert_sorted_array_to_binary_search_tree/","title":"0108. Convert Sorted Array to Binary Search Tree","section":"Leetcode","content":" Description # Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.\nA height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\nSolutions # 简单题，直接递归构建即可。\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func sortedArrayToBST(nums []int) *TreeNode { size := len(nums) if size == 0 { return nil } return helper(nums, 0, size-1) } func helper(nums []int, start, end int) *TreeNode { if start \u0026gt; end { return nil } mid := (start+end)/2 node := new(TreeNode) node.Val = nums[mid] node.Left, node.Right = helper(nums, start, mid-1), helper(nums, mid+1, end) return node } "},{"id":60,"href":"/docs/algs/leetcode/111_minimum_depth_of_binary_tree/","title":"0111. Minimum Depth of Binary Tree","section":"Leetcode","content":" Description # Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.\nA height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\nSolutions # Iterative # 只需要简单的层次遍历，终止条件就是当队列中出现一个左右子节点均为空节点的节点即可。\ntype TreeNode struct { Val int Left *TreeNode Right *TreeNode } func minDepth(root *TreeNode) int { if root == nil { return 0 } var queue []*TreeNode = []*TreeNode{root} var depth int for len(queue) != 0 { depth++ size := len(queue) for i := 0; i \u0026lt; size;i++ { if queue[i].Left == nil \u0026amp;\u0026amp; queue[i].Right == nil { return depth } if queue[i].Left != nil { queue = append(queue, queue[i].Left) } if queue[i].Right != nil { queue = append(queue, queue[i].Right) } } queue = queue[size:] } return 0 } Recursive # 递归解法需要主体返回条件，首先当根节点为空时，需要返回 0，然后还需要加上两个条件”如果根节点的左节点为空，则返回右节点的遍历值；如果根节点的右节点为空，则需要返回左节点的遍历值“，如果不加上上面两个条件，那么对于 [1, null,2] 这样的树，结果会是 1 而不是 2，但 2 才是正确答案。\ntype TreeNode struct { Val int Left *TreeNode Right *TreeNode } func minDepth(root *TreeNode) int { if root == nil { return 0 } if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return 1 } if root.Left == nil { return minDepth(root.Right) + 1 } if root.Right == nil { return minDepth(root.Left) + 1 } return min(minDepth(root.Left), minDepth(root.Right)) + 1 } func min(a,b int) int { if a \u0026lt; b { return a } return b } "},{"id":61,"href":"/docs/algs/leetcode/116_populating_next_right_pointers_in_each_node/","title":"0116. Populating Next Right Pointers in Eech Node","section":"Leetcode","content":" Description # You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:\nstruct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\nInitially, all next pointers are set to NULL.\nSolutions # 简单题，只需要使用层次遍历即可。\nfunc connect(root *Node) *Node { if root == nil { return root } var queue []*Node queue = append(queue, root) for len(queue) != 0 { size := len(queue) var pre *Node for i := 0; i \u0026lt; size; i++ { if pre == nil { pre = queue[i] } else { pre.Next = queue[i] pre = queue[i] } if queue[i].Left != nil { queue = append(queue, queue[i].Left) } if queue[i].Right != nil { queue = append(queue, queue[i].Right) } } queue = queue[size:] } return root } "},{"id":62,"href":"/docs/algs/leetcode/118_pascals_triangle/","title":"0118. Pascal's Triangle","section":"Leetcode","content":" Description # Given an integer numRows, return the first numRows of Pascal\u0026rsquo;s triangle.\nIn Pascal\u0026rsquo;s triangle, each number is the sum of the two numbers directly above it\nSolutions # 这里有很多 trick，还是需要注意一下。\nfunc generate(numRows int) [][]int { var res [][]int for i := 0; i \u0026lt; numRows; i++ { var cur []int for j := 0; j \u0026lt; i+1; j++ { cur = append(cur, 1) } res = append(res, cur) for j := 1; j \u0026lt; i; j++ { res[i][j] = res[i-1][j-1] + res[i-1][j] } } return res } "},{"id":63,"href":"/docs/algs/leetcode/120_triangle/","title":"0120. Triangle","section":"Leetcode","content":" Description # Given a triangle array, return the minimum path sum from top to bottom.\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\nSolutions # Brute Force # 题主首先想出了贪心的解法，但是因为”局部最优并不代表全局最优“，所以没能通过，不过还是贴一下代码：\nfunc minimumTotal(triangle [][]int) int { size := len(triangle) arr := make([]int, size+1) var start int for i := 1; i \u0026lt;= size; i++ { if start + 1 \u0026lt; len(triangle[i-1]) \u0026amp;\u0026amp; triangle[i-1][start+1] \u0026lt; triangle[i-1][start] { start = start + 1 } arr[i] = dp[i-1] + triangle[i-1][start] } return arr[size] } 既然上面的贪心不行，那么使用递归来试试呢？于是楼主又写出了下面的解法：\nfunc minimumTotal(triangle [][]int) int { size := len(triangle) res := math.MaxInt helper(triangle, 0, 0, 0, size, \u0026amp;res) return res } func helper(triangle [][]int,pathSum int, curRow int, curCol int, size int, res *int) { if curRow \u0026gt;= size { *res = min(*res, pathSum) return } pathSum += triangle[curRow][curCol] helper(triangle, pathSum, curRow+1, curCol, size, res) helper(triangle, pathSum, curRow+1, curCol+1, size, res) } func min(a,b int) int { if a \u0026lt; b { return a } return b } 很明显，这是暴力枚举啊，结果不出意外的超时了，不过解法应该是没问题的。\nDynamic Programming # 这里还是要使用 DP 的方法来解，还是因为”局部最优解不代表全局最优解“，所以我们这里需要计算每一行的每个数的自顶向下的路径和，然后从最后一行的结果中选出最小的那个数来作为我们的结果。既然思路是这样，那么状态转移方程大概就是 dp[i][j] += min(dp[i-1][j-1], dp[i-1][j)，这里我们可以直接复用 triangle 这个数组，直接在数组上进行操作。另外还需要注意的是，迭代只能从第二行开始，并且每一行中的第一个数和最后一个数需要进行特殊处理。综合以上，代码如下：\nfunc minimumTotal(triangle [][]int) int { size := len(triangle) for i := 1; i \u0026lt; size; i++ { rowSize := len(triangle[i]) for j := 0; j \u0026lt; rowSize; j++ { if j == 0 { triangle[i][j] += triangle[i-1][j] } else if j == rowSize - 1 { triangle[i][j] += triangle[i-1][j-1] } else { triangle[i][j] += min(triangle[i-1][j-1], triangle[i-1][j]) } } } res := math.MaxInt rowLen := len(triangle[size-1]) for i := 0; i \u0026lt; rowLen; i++ { res = min(res, triangle[size-1][i]) } return res } func min(a,b int) int { if a \u0026lt; b { return a } return b } "},{"id":64,"href":"/docs/algs/leetcode/121_best_time_to_buy_and_sell_stock/","title":"0121. Best Time to But And Sell Stock","section":"Leetcode","content":" Description # You are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\nSolutions # 首先可以直接暴力求解，但是会超时。\nfunc maxProfit(prices []int) int { var res int length := len(prices) for i := 0; i \u0026lt; length; i++ { for j := i + 1; j \u0026lt; length; j++ { res = max(res, prices[j]-prices[i]) } } return res } func max(a,b int) int { if a \u0026gt; b { return a } return b } 这里也可以扫描一次数组，然后维护一个扫描过程中遇到的最小值，然后不断计算当前扫描到的值和该最小值的差值，取最大差值即可。\nfunc maxProfit(prices []int) int { var res int size := len(prices) if size \u0026lt; 2 { return res } minVal := prices[0] for _, value := range prices { res = max(res, value-minVal) if value \u0026lt; minVal { minVal = value } } return res } func max(a,b int) int { if a \u0026gt; b { return a } return b } 一种错误解法 是使用双指针，左指针从左到右找最小值，右指针从优到左找最大值。但是需要注意的是，这种解法有一个错误假设，就是最小值在最左边，而最大值在最右边，很明显这个假设是错误的，最大值和最小值可能出现在同一侧。\nsize := len(prices) if size \u0026lt; 2 { return 0 } // for 循环在 init 之后检查 condition，condition 通过之后会执行 body，body 执行之后会进行 increment，然后再比较 condition，如果 condition 通过，继续执行 body left, right := 0, size-1 for l, r := 0, size-1; l \u0026lt;= r; l, r = l+1, r-1 { if prices[l] \u0026lt; prices[left] { left = l } if prices[r] \u0026gt; prices[right] { right = r } } if prices[right] \u0026lt; prices[left] { return 0 } return prices[right] - prices[left] "},{"id":65,"href":"/docs/algs/leetcode/122_best_time_to_buy_and_sell_stock_ii/","title":"0122. Best Time to But And Sell Stock II","section":"Leetcode","content":" Description # You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\nFind and return the maximum profit you can achieve.\nSolutions # 如果要收益最大，那么最好是低价买入，高价卖出。所以只需要检查每一支股票，只要当前股票比前一天的大，那么就可以获得收益。\nfunc maxProfit(prices []int) int { var res int size := len(prices) if size \u0026lt;= 1 { return res } for i := 1; i \u0026lt; size; i++ { if prices[i] \u0026gt; prices[i-1] { res += prices[i]- prices[i-1] } } return res } "},{"id":66,"href":"/docs/algs/leetcode/124_binary_tree_maximum_path_sum/","title":"0124. Binary Tree Maximum Path Sum","section":"Leetcode","content":" Description # A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\nThe path sum of a path is the sum of the node\u0026rsquo;s values in the path.\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.\nSolutions # 比较明显的是，对于每个节点来说，我们需要知道经过其左子节点的 path 之和大还是经过其右子节点的 path 之和大。\nfunc maxPathSum(root *TreeNode) int { res := math.MinInt maxPathSumRecur(root, \u0026amp;res) return res } func maxPathSumRecur(root *TreeNode, res *int) int { if root == nil { return 0 } // 这里之所以在 max 中放一个 0，其实是做了一些剪枝操作。如果把这个与 0 的剪枝操作去掉，那么下面的代码还是比较好理解的。 // 如果把 0 去掉，那么下面就是分别求得当前节点左右子树的最大路径和，然后比较 res 与 左右节点和当前节点构成的路径之和的大小并 // 更新 res，最后返回左右路径中的较大者与当前节点值的和。 // 与 0 进行比较的话去除了路径和为负数的情况，做了一个不错的剪枝机制。 // 左子树的最大路径和，如果为负数，则返回 0 left := max(maxPathSumRecur(root.Left, res), 0) // 右子树的最大路径和，如果为负数，则返回 0 right := max(maxPathSumRecur(root.Right, res), 0) // 更新当前最大路径和 *res = max(*res, left + right + root.Val) // 选择当前能让路径和最大的分支 return max(left, right) + root.Val } func max(a, b int) int { if a \u0026lt; b { return b } return a } "},{"id":67,"href":"/docs/algs/leetcode/125_valid_palindrome/","title":"0125. Valid Palindrome","section":"Leetcode","content":" Description # A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\nGiven a string s, return true if it is a palindrome, or false otherwise.\nSolutions # Two Pointer # 简单题，去除非数字字母的字符之后直接判断即可。\nfunc isPalindrome(s string) bool { var rs []rune for _, r := range s { // skip none-alphanumeric characters if !(r \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; r \u0026lt;= \u0026#39;z\u0026#39; || r \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; r \u0026lt;= \u0026#39;Z\u0026#39; || r \u0026gt;=\u0026#39;0\u0026#39; \u0026amp;\u0026amp; r \u0026lt;= \u0026#39;9\u0026#39;) { continue } // convert upper case to lower case if r \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; r \u0026lt;= \u0026#39;Z\u0026#39; { r += \u0026#39;a\u0026#39; - \u0026#39;A\u0026#39; } // append to rs rs = append(rs, r) } // check if it is palindromic string left, right := 0, len(rs)-1 for left \u0026lt; right { if rs[left] != rs[right] { return false } left++ right-- } return true } "},{"id":68,"href":"/docs/algs/leetcode/127_word_ladder/","title":"0127. Word Ladder","section":"Leetcode","content":" Description # A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -\u0026gt; s1 -\u0026gt; s2 -\u0026gt; \u0026hellip; -\u0026gt; sk such that:\nEvery adjacent pair of words differs by a single letter. Every si for 1 \u0026lt;= i \u0026lt;= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\nSolutions # TODO\n"},{"id":69,"href":"/docs/algs/leetcode/128_longest_consecutive_sequence/","title":"0128. Longest Consecurive Sequence","section":"Leetcode","content":" Description # Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\nYou must write an algorithm that runs in O(n) time.\nSolutions # 使用一个集合存入所有的数字，然后遍历数组中的每个数字，如果其在集合中存在，那么将其移除，然后 pre 再自减 1，直至pre 不在集合之中，对 next 采用同样的方法，那么 next - pre -1 就是当前数字的最长连续序列。之所以要移除数字，是为了避免重复计算。比如说对于 4、3、2，如果计算 4 的时候不把 3 和 2 移除掉，那么计算 3 和 2 的时候就会出现重复计算的情况。\nfunc longestConsecutive(nums []int) int { var res int dict := make(map[int]bool) for _, num := range nums { dict[num] = true } for _, num := range nums { left, right := num -1, num + 1 for dict[left] == true { delete(dict, left) left-- } for dict[right] == true { delete(dict, right) right++ } res = max(res, right-left-1) } return res } func max(a,b int) int { if a \u0026lt; b { return b } return a } "},{"id":70,"href":"/docs/algs/leetcode/130_surrounded_regions/","title":"0130. Surrounded Regions","section":"Leetcode","content":" Description # Given an m x n matrix board containing \u0026lsquo;X\u0026rsquo; and \u0026lsquo;O\u0026rsquo;, capture all regions that are 4-directionally surrounded by \u0026lsquo;X\u0026rsquo;.\nA region is captured by flipping all \u0026lsquo;O\u0026rsquo;s into \u0026lsquo;X\u0026rsquo;s in that surrounded region.\nSolutions # DFS # 这个题的难点在于，对于从边上的\u0026rsquo;O\u0026rsquo;为起点的所有可达的\u0026rsquo;O\u0026rsquo;，在最后的结果中要保留。那么也就是所，在遍历中，需要对从边上的\u0026rsquo;O\u0026rsquo;可达到的所有\u0026rsquo;O\u0026rsquo;做一个特殊处理。这里首先遍历四条边，如果当前点是\u0026rsquo;O\u0026rsquo;，那么从当前点开始进行DFS，对于每个可达的\u0026rsquo;O\u0026rsquo;点，都将其设置为\u0026rsquo;Y\u0026rsquo;，表示这个点不需要处理。上面的处理结束之后，剩下的\u0026rsquo;O\u0026rsquo;都是需要处理的\u0026rsquo;O\u0026rsquo;，那么只需要再遍历一遍矩阵，将每个‘O’设置为\u0026rsquo;X\u0026rsquo;,同事将那么设置为\u0026rsquo;Y\u0026rsquo;的点还原为\u0026rsquo;O\u0026rsquo;即可。\nvar dirs [][]int = [][]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}} func solve(board [][]byte) { rows, cols := len(board), len(board[0]) // 先从边上的每个 \u0026#39;o\u0026#39;开始遍历，将其可达的所有 \u0026#39;o\u0026#39;都标记为 \u0026#39;y\u0026#39; for i := 0; i \u0026lt; rows; i++ { if board[i][cols-1] == \u0026#39;O\u0026#39; { dfs(board, i, cols-1, rows, cols) } if board[i][0] == \u0026#39;O\u0026#39; { dfs(board, i, 0, rows, cols) } } for i := 0; i \u0026lt; cols; i++ { if board[0][i] == \u0026#39;O\u0026#39; { dfs(board, 0, i, rows, cols) } if board[rows-1][i] == \u0026#39;O\u0026#39; { dfs(board, rows-1, i, rows, cols) } } for i := 0; i \u0026lt; rows; i++ { for j := 0; j \u0026lt; cols; j++ { // 对于剩余的每个 \u0026#39;o\u0026#39;，将其变为 \u0026#39;x\u0026#39; if board[i][j] == \u0026#39;O\u0026#39; { board[i][j] = \u0026#39;X\u0026#39; } // 将每个\u0026#39;y\u0026#39;还原为\u0026#39;o\u0026#39; if board[i][j] == \u0026#39;Y\u0026#39; { board[i][j] = \u0026#39;O\u0026#39; } } } } func dfs(board [][]byte, row, col, rows, cols int) { if row \u0026lt; 0 || row \u0026gt;= rows || col \u0026lt; 0 || col \u0026gt;= cols || board[row][col] == \u0026#39;X\u0026#39; || board[row][col] == \u0026#39;Y\u0026#39; { return } if board[row][col] == \u0026#39;O\u0026#39; { board[row][col] = \u0026#39;Y\u0026#39; } for _, dir := range dirs { dfs(board, row+dir[0], col + dir[1], rows, cols) } } "},{"id":71,"href":"/docs/algs/leetcode/131_palindrome_partitioning/","title":"0131. Palindrome Partitioning","section":"Leetcode","content":" Description # Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\nA palindrome string is a string that reads the same backward as forward.\nSolutions # 简单递归回溯即可。\nfunc partition(s string) [][]string { var res [][]string size := len(s) if size == 0 { return res } var cur []string helper(s,0,size, cur, \u0026amp;res) return res } func helper(s string, start, size int, cur []string, res *[][]string) { if start \u0026gt;= size { tmp := make([]string, len(cur)) copy(tmp, cur) *res = append(*res, tmp) return } for i := start; i \u0026lt; size; i++ { if isPalindrome(s[start: i+1]) { cur = append(cur, s[start:i+1]) helper(s, i+1, size, cur, res) cur = cur[:len(cur)-1] } } } func isPalindrome(s string) bool { size := len(s) left, right := 0, size -1 for left \u0026lt; right { if s[left] != s[right] { return false } left++ right-- } return true } "},{"id":72,"href":"/docs/algs/leetcode/133_clone_graph/","title":"0133. Clone Graph","section":"Leetcode","content":" Description # Given a reference of a node in a connected undirected graph.\nReturn a deep copy (clone) of the graph.\nEach node in the graph contains a value (int) and a list (List[Node]) of its neighbors.\nclass Node { public int val; public List\u0026lt;Node\u0026gt; neighbors; } Test case format:\nFor simplicity, each node\u0026rsquo;s value is the same as the node\u0026rsquo;s index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.\nAn adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\nThe given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.\nSolutions # DFS # 图克隆或者树克隆，最先想到的就是要使用 Hash Table，这里用 BFS 或者 DFS 来做都可以。\n/** * Definition for a Node. * type Node struct { * Val int * Neighbors []*Node * } */ func cloneGraph(node *Node) *Node { dict := make(map[*Node]*Node) return dfs(node, \u0026amp;dict) } func dfs(root *Node, dict *map[*Node]*Node) *Node { // 如果为空，直接返回 if root == nil { return nil } // 如果这个节点已经遍历过了，则返回其副本节点 if _, ok := (*dict)[root]; ok { return (*dict)[root] } // 如果这个节点没遍历过，则根据当前节点创建一个副本节点 // 同时复制当前节点和其它节点的关系，最后返回复制的节点 dummy := new(Node) dummy.Val = root.Val (*dict)[root] = dummy for _, node := range root.Neighbors { // 这里需要对返回的节点进行判空处理，空节点不能直接放入副本的邻居中 r := dfs(node, dict) if r != nil { (*dict)[root].Neighbors = append((*dict)[root].Neighbors , r) } } // 返回副本节点 return dummy } "},{"id":73,"href":"/docs/algs/leetcode/134_gas_station/","title":"0134. Gas Station","section":"Leetcode","content":" Description # There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].\nYou have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.\nGiven two integer arrays gas and cost, return the starting gas station\u0026rsquo;s index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique\nSolutions # 首先很容易想到简单模拟的暴力算法。将每一个点都作为起始点，使用 curGas 表示当前剩余的油量，然后从起始点开始遍历，每遍历到一个节点就加上该点可以获得的油量，然后减去到达该点的损耗，如果有一个点剩余油量小于 0，则说明无法到达该点，结束当前路径的遍历。然后选择下一条路径继续遍历即可。\n很不幸，超时了。\nfunc canCompleteCircuit(gas []int, cost []int) int { res := -1 size := len(gas) if size == 0 { return res } var curGas int for i := 0; i \u0026lt; size; i++ { curGas = 0 for j := i; j \u0026lt; i+size; j++ { if curGas \u0026lt; 0 { break } curGas += gas[j%size] curGas -= cost[j%size] } if curGas \u0026gt;= 0 { res = i break } } return res } 这里还可以优化一下。首先很容易想到，如果整个 gas 数组的和小于 cost 数组的和，那么肯定是没有路径的。然后还有一个比较难想到的点是，如果以 A 为起点的路径无法到达 B， 那么从 A 到 B 中间的任何一个点作为起点都无法到达 B，也就是说，A 到 B 中间的任何一个点都无法作为起点。\n这里可以简单证明一下，假设 A 到 B 中间存在一点 C，A 可以到达 C 但是无法到达 B。因为 A 无法到达 B，那么 A 到 B 这条路径的 gas 之和小于 cost 之和，而因为 A 可以到达 C，那么必然有 A 到 C 这条路的 gas 之和大于等于 cost 之和，因此如果以 C 作为起点，那么 C 必然无法到达 B，以 C 为起点的路径也无法环绕一圈。进而也就是说，A 到 B 之间任意一点都无法作为起点绕一圈，同理可证明 A 到 C 之前的节点。那么下一次遍历只需要从 B 的下一个节点开始即可。这样就可以降低一些总时间复杂度。\nfunc canCompleteCircuit(gas []int, cost []int) int { res := -1 size := len(gas) if size == 0 { return res } var start int for start \u0026lt; size { var curGas, i int for i = start; i \u0026lt; start + size; i++ { if curGas \u0026lt; 0 { break } curGas += gas[i%size] curGas -= cost[i%size] } if curGas \u0026gt;= 0 { res = start break } start = i } return res } "},{"id":74,"href":"/docs/algs/leetcode/136_single_number/","title":"0136. Single Number","section":"Leetcode","content":" Description # Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\nSolutions # 简单题，直接使用异或运算符即可。注意 res 初始化应该为 0.\nfunc singleNumber(nums []int) int { var res int for _, num := range nums { res ^= num } return res } "},{"id":75,"href":"/docs/algs/leetcode/138_copy_list_with_random_pointer/","title":"0138. Copy List With Random Pointer","section":"Leetcode","content":" Description # A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.\nConstruct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.\nFor example, if there are two nodes X and Y in the original list, where X.random \u0026ndash;\u0026gt; Y, then for the corresponding two nodes x and y in the copied list, x.random \u0026ndash;\u0026gt; y.\nReturn the head of the copied linked list.\nThe linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:\nval: an integer representing Node.val random_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node. Your code will only be given the head of the original linked list. Solutions # Hash Table # 使用哈希表来做，遍历原表，先记录 Next 指针，后记录 Random 指针。\ntype Node struct { Val int Next *Node Random *Node } func copyRandomList(head *Node) *Node { if head == nil { return nil } dict := make(map[*Node]*Node) node := new(Node) node.Val = head.Val dict[head] = node // copy next p, pre := head.Next, node for p != nil { n := new(Node) n.Val = p.Val pre.Next = n dict[p] = n pre = n p = p.Next } // copy random p, pre = head, node for p != nil { pre.Random = dict[p.Random] p = p.Next pre = pre.Next } return node } "},{"id":76,"href":"/docs/algs/leetcode/141_Linked-List-Cycle/","title":"0141. Linked List Cycle","section":"Leetcode","content":" Description # Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail\u0026rsquo;s next pointer is connected to. Note that pos is not passed as a parameter.\nReturn true if there is a cycle in the linked list. Otherwise, return false.\nSolutions # Hash Table # 很简单，使用哈希表记录一个节点是否被访问过两次即可。需要注意的是，题目并不保证给出的链表一定是有环的。\nfunc hasCycle(head *ListNode) bool { var res bool if head == nil || head.Next == nil { return res } dict := make(map[*ListNode]bool) cur := head for cur != nil { if _, ok := dict[cur]; ok { res = true break } dict[cur] = true cur = cur.Next } return res } Two Pointer # 使用快慢指针，如果链表有环，则快慢指针必然相交。\nfunc hasCycle(head *ListNode) bool { var res bool if head == nil || head.Next == nil { return res } slow, fast := head, head for fast != nil \u0026amp;\u0026amp; fast.Next != nil { fast = fast.Next.Next slow = slow.Next if slow == fast { res = true break } } return res } "},{"id":77,"href":"/docs/algs/leetcode/142_linked_list_cycle_ii/","title":"0142. Linked List Cycle II","section":"Leetcode","content":" Description # Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail\u0026rsquo;s next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.\nDo not modify the linked list.\nSolutions # Hash Table # 首先也是很自然的能够想到使用哈希表。\nfunc detectCycle(head *ListNode) *ListNode { if head == nil || head.Next == nil { return nil } dict := make(map[*ListNode]bool) cur := head for cur != nil { if _, ok := dict[cur]; ok { return cur } dict[cur] = true cur = cur.Next } return nil } Two Pointer # 快慢指针解法，参加 func detectCycle(head *ListNode) *ListNode { // corner case if head == nil || head.Next == nil { return nil } // 快慢指针一直往前走，直到二者相遇，或者 fast 到达无环链表末尾 slow, fast := head, head for fast != nil \u0026amp;\u0026amp; fast.Next != nil { slow = slow.Next fast = fast.Next.Next if fast == slow { break } } // 如果链表没有环，则返回 nil if fast == nil || fast.Next == nil { return nil } // fast 和 slow 的任意一个从头结点开始，然后让二者继续向前遍历，相遇节点即为入口节点 fast = head for fast != slow { fast = fast.Next slow = slow.Next } return fast } "},{"id":78,"href":"/docs/algs/leetcode/146_lru_cache/","title":"0146. LRU Cache","section":"Leetcode","content":" Description # Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity. int get(int key) Return the value of the key if the key exists, otherwise return -1. void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. The functions get and put must each run in O(1) average time complexity.\nSolutions # Hash Table \u0026amp; Array # 下面的解法严格来说并不符合题目要求的时间复杂度。\nimport \u0026#34;time\u0026#34; // 一个Cell type Cell struct { Key int Value int RecentUse int64 } // 一个LRU cache队列，通过map中的key快速映射到Data中相应节点的index type LRUCache struct { Cap int Data []*Cell Map map[int]int } func Constructor(capacity int) LRUCache { return LRUCache{ Cap: capacity, Data: make([]*Cell,0), Map:\tmake(map[int]int), } } //func (this *LRUCache) Get(key int) int { //\tvalue := -1 // //\tif v,ok := this.Map[key]; ok \u0026amp;\u0026amp; v != -1 { //\tvalue = this.Data[v-1].Value //\tthis.Data[v-1].RecentUse = time.Now().UnixNano() //\t} // //\treturn value //} func (this *LRUCache) Get(key int) int { value := -1 if v,ok := this.Map[key]; ok \u0026amp;\u0026amp; v != -1 { value = this.Data[v].Value // if Data[v], will out of index this.Data[v].RecentUse = time.Now().UnixNano() } return value } func (this *LRUCache) Put(key int, value int) { // If already exist, modify value and time index,ok := this.Map[key] // If the node already exist if ok \u0026amp;\u0026amp; index != -1 { this.Data[index].Value = value this.Data[index].RecentUse = time.Now().UnixNano() } else { // If the value doesn\u0026#39;t exist, then insert new node or replace with new one cell := \u0026amp;Cell{ Key: key, Value: value, RecentUse: time.Now().UnixNano(), } // If reach out its capacity, then replace the oldest one if this.Cap == len(this.Data) { min := time.Now().UnixNano() var idx int for i,v := range this.Data { if v.RecentUse \u0026lt; min { min = v.RecentUse idx = i } } this.Map[this.Data[idx].Key] = -1 this.Data[idx] = cell this.Map[key] = idx //this.Data[idx].RecentUse = time.Now().UnixNano() //this.Data[idx].Value = value //this.Data[idx].Key= key //this.Map[key] = idx } else { // It is not full, so we insert a node this.Data = append(this.Data, cell) this.Map[key] = len(this.Data) -1 } } } Hash Table \u0026amp; Double LinkedList # 这里使用双向链表和 Hash Table 来做，这样的话，get 和 put 操作都能得到 \\( \\Omicron(1) \\) 的复杂度。这里特别需要注意的是，双向链表最好可以加上一个 head 和 tail，这样在做删除操作的时候就可以避免很多条件判断，从而节省时间。\ntype Node struct { Key int Val int Next *Node Pre *Node } type LRUCache struct { size int capacity int head *Node tail *Node dict map[int]*Node } func (this *LRUCache) MoveToHead(node *Node) { this.RemoveNode(node) this.AddToHead(node) } func (this *LRUCache) RemoveNode(node *Node) { node.Pre.Next = node.Next node.Next.Pre = node.Pre } func (this *LRUCache) AddToHead(node *Node) { node.Next = this.head.Next this.head.Next.Pre = node node.Pre = this.head this.head.Next = node } func (this *LRUCache) RemoveTail() *Node { tail := this.tail.Pre this.RemoveNode(tail) return tail // 下面这种写法不对，因为删除之后 this.tail.Pre 指向的就不是同一个值了。 // this.RemoveNode(this.tail.Pre) // return this.tail.Pre } func Constructor(capacity int) LRUCache { head, tail := new(Node), new(Node) head.Next = tail tail.Pre = head return LRUCache{ head: head, tail: tail, capacity: capacity, size: 0, dict: make(map[int]*Node), } } func (this *LRUCache) Get(key int) int { if _, ok := (*this).dict[key]; !ok { return -1 } node := (*this).dict[key] this.MoveToHead(node) return node.Val } // - 已经存在，则直接返回 // - 否则直接插入，然后检查是否需要删除最后一个元素 func (this *LRUCache) Put(key int, value int) { if _, ok := (*this).dict[key]; ok { node := (*this).dict[key] node.Val = value this.MoveToHead(node) } else { node := new(Node) node.Key = key node.Val = value this.AddToHead(node) (*this).dict[key] = node (*this).size++ if this.size \u0026gt; this.capacity { removed := this.RemoveTail() delete((*this).dict, removed.Key) (*this).size-- } } } /** * Your LRUCache object will be instantiated and called as such: * obj := Constructor(capacity); * param_1 := obj.Get(key); * obj.Put(key,value); */ "},{"id":79,"href":"/docs/algs/leetcode/148_sort_list/","title":"0148. Sort List","section":"Leetcode","content":" Description # Given the head of a linked list, return the list after sorting it in ascending order.\nSolutions # 第一个想法很简单，先扫描一遍链表，把扫描到的值记录到数组，然后对数组进行排序，最后再把排序结果赋值给原链表即可。时间复杂度 \\(\\Omicron(n\\log n)\\) , 空间复杂度 \\($\\Omicron(n)$\\) 。\n方法二，可以用插入排序的思想。维持一个排好序的链表，从头结点开始扫描，每扫描到一个节点，就将其插入到这个有序链表中去。这样空间复杂度就是 \\($\\Omicron(1)$\\) ，时间复杂度 \\($\\Omicron(n^2)$\\) 。\nfollow up 但是这里要求的是时间复杂度 \\($\\Omicron(n\\log n)$\\) ，空间复杂度 \\($\\Omicron(1)$\\) ，那很明显上述解法都不满足。这里竟然可以用归并排序，归并排序的时间复杂度是 \\($\\Omicron(n\\logn)$\\) ，归并排序又分为自顶向下和自底向上两种，前者空间复杂度是 \\($\\Omicron(\\log n)$\\) （因为栈深度），后者可以达到 \\($\\Omicron(1)$\\) 。\n这里是自顶向下的解法，需要注意的是，在 getMiddle 函数中将 middle 节点和前一个节点断开是一个非常重要的操作。\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func sortList(head *ListNode) *ListNode { return mergeSortUpDown(head) } func mergeSortUpDown(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } mid := getMiddle(head) left := mergeSortUpDown(head) right := mergeSortUpDown(mid) return mergeUpDown(left, right) } func mergeUpDown(left,right *ListNode) *ListNode { dummy := new(ListNode) cur := dummy // 因为 mid 节点和之前的节点是断开的，所以这里可以直接用 left 和 nil 进行判断 for left != nil \u0026amp;\u0026amp; right != nil { if left.Val \u0026lt; right.Val { cur.Next = left left = left.Next } else { cur.Next = right right = right.Next } cur = cur.Next } // 另一半已经是有序的了，所以这里直接进行连接就好 if left != nil { cur.Next = left } else { cur.Next = right } return dummy.Next } // 这里不仅仅需要得到 middle 节点，还需要把 middle 节点开始的链路和前一个节点结尾的链路断开 func getMiddle(head *ListNode) *ListNode { var pre *ListNode slow, fast := head, head for fast != nil \u0026amp;\u0026amp; fast.Next != nil { pre = slow slow = slow.Next fast = fast.Next.Next } // 注意这里需要断开连接 pre.Next = nil return slow } 这里的自底向上的解法写起来相当 tricky， 不像是一个 middle 题该有的难度，所以暂时跳过了。\n"},{"id":80,"href":"/docs/algs/leetcode/150_evaluate_reverse_polish_notation/","title":"0150. Evaluate Reverse Polish Notation","section":"Leetcode","content":" Description # Evaluate the value of an arithmetic expression in Reverse Polish Notation.\nValid operators are +, -, *, and /. Each operand may be an integer or another expression.\nNote that division between two integers should truncate toward zero.\nIt is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.\nSolutions # 逆波兰表达式求值，使用栈能够很好的解决，在此几部多说了，直接上代码:\n// using stack func evalRPN(tokens []string) int { var res int size := len(tokens) if size \u0026lt;= 0 { return res } var stack []int for _, str := range tokens { num, isNum := strconv.Atoi(str) if len(stack) == 0 || isNum == nil { stack = append(stack, num) continue } size := len(stack) op1, op2 := stack[size-2], stack[size-1] stack = stack[:size-2] switch str { case \u0026#34;+\u0026#34;: stack = append(stack, op1 + op2) case \u0026#34;-\u0026#34; : stack = append(stack, op1 - op2) case \u0026#34;*\u0026#34;: stack = append(stack, op1*op2) case \u0026#34;/\u0026#34;: stack = append(stack, op1/op2) } } return stack[0] } "},{"id":81,"href":"/docs/algs/leetcode/155_min_stack/","title":"0155. Min Stack","section":"Leetcode","content":" Desctiption # Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\nImplement the MinStack class:\nMinStack() initializes the stack object. void push(int val) pushes the element val onto the stack. void pop() removes the element on the top of the stack. int top() gets the top element of the stack. int getMin() retrieves the minimum element in the stack. Solutions # 除了维持一个正常的栈来维持压入的元素之外，还需要维持一个单调递减栈当前的最小数。具体做法是，当压入一个元素的时候，如果单调栈中元素为空，则直接压入元素到单调栈中；如果单调中元素不为空，那么又分为单调栈顶元素比当前压入元素大还是小两种情况，如果栈顶元素比当前压入元素大，那么将当前压入元素压入单调栈；如果栈顶元素比当前压入元素小，那么再次压入栈顶元素。弹出时，除了对正常栈进行弹出之外，还需要对单调栈进行弹出操作。getMin 函数直接返回单调栈顶元素即可。\n// 维持一个单调栈，单调递减栈即可 type MinStack struct { nums []int monoStack []int } func Constructor() MinStack { return MinStack{nums: []int{}, monoStack: []int{}} } func (this *MinStack) Push(val int) { size := this.Len() if size == 0 { (*this).monoStack = append((*this).monoStack, val) } else { top := (*this).monoStack[size-1] if top \u0026lt;= val { (*this).monoStack = append((*this).monoStack, top) } else { (*this).monoStack = append((*this).monoStack, val) } } (*this).nums = append((*this).nums, val) } func (this *MinStack) Len() int { return len(this.nums) } func (this *MinStack) Pop() { size := this.Len() (*this).nums = (*this).nums[:size-1] (*this).monoStack = (*this).monoStack[:size-1] } func (this *MinStack) Top() int { size := this.Len() return (*this).nums[size-1] } func (this *MinStack) GetMin() int { size := this.Len() return (*this).monoStack[size-1] } /** * Your MinStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(val); * obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.GetMin(); */ "},{"id":82,"href":"/docs/algs/leetcode/160_intersection_of_two_linked_lists/","title":"0160. Intersection of Two Linked Lists","section":"Leetcode","content":" Description # Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.\nSolutions # Hash Table # 首先很容易想到哈希表的解法。\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode { if headA == nil || headB == nil { return nil } dict := make(map[*ListNode]bool) dummyA , dummyB := headA, headB for dummyA != nil { dict[dummyA] = true dummyA = dummyA.Next } for dummyB != nil { if _, ok := dict[dummyB]; ok { return dummyB } dummyB = dummyB.Next } return nil } Two Pointer # 其次可以想到的一个接法是，A 和 B 都不断往后走，直到走到尾部，此时让 A 从 B 开头继续走，而让 B 从 A 开头继续走，如果二者有相交节点的话，必然会在相交节点相遇。如果二者无相交节点的话，那么二者应该会同时为空。\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode { if headA == nil || headB == nil { return nil } dummyA, dummyB := headA, headB for { // 并不能确定一定有环，所以当二者同时为空时，说明无环 if dummyA == nil \u0026amp;\u0026amp; dummyB == nil { return nil } // A 继续从 B 头部开始遍历 if dummyA == nil { dummyA = headB } // B 继续从 A 头部开始遍历 if dummyB == nil { dummyB = headA } // 有重叠 if dummyA == dummyB { return dummyA } dummyA = dummyA.Next dummyB = dummyB.Next } return nil } "},{"id":83,"href":"/docs/algs/leetcode/162_find_peak_element/","title":"0162. Find Peak Element","section":"Leetcode","content":" Description # A peak element is an element that is strictly greater than its neighbors.\nGiven an integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -∞.\nYou must write an algorithm that runs in \\( Omicron(\\log n) \\) time.\nSolutions # One Pass Iteration # 这里可以通过一次数组的一次遍历来完成。为了方便，我们可以在头部和尾部分别添加上一个最小值，这样能够减少一些边界值判断。当然，这种方法并不符合题目要求的 \\( \\Omicron(n\\log n) \\) 的要求。\nfunc findPeakElement(nums []int) int { // 可以在前后都添加一个最小值，这样可以减少一些判断 nums = append([]int{math.MinInt}, append(nums, math.MinInt)...) size, start, res := len(nums), 1, 0 for start + 1 \u0026lt;= size { if nums[start] \u0026gt; nums[start-1] \u0026amp;\u0026amp; nums[start] \u0026lt; nums[start+1] { res = start } start++ } return res } 因为题目保证了一定会有答案，那么上述一趟遍历的解法就可以稍微优化一下：从第二个数字开始遍历，如果当前数字比前一个数字小，那么返回前一个数字的下标；如果整个数组都是递增数组，那么返回 size - 1.\nfunc findPeakElement(nums []int) int { size := len(nums) for i := 1; i \u0026lt; size; i++ { if nums[i] \u0026lt; nums[i-1] { return i - 1 } } return size - 1 } Monotone Stack # 这里还可以使用单调栈来解决。维护一个单调递增栈，如果当前遍历到的元素比栈顶元素要小，那么返回栈顶元素；如果栈为空或者当前元素比栈顶元素要大，那么将当前元素入栈，然后继续遍历。遍历过程中需要注意整个数组为递增数组或者数组中只有一个元素的情况，这种情况可以通过在遍历的时候将下标遍历到 size 来解决。\nfunc findPeakElement(nums []int) int { size := len(nums) if size == 1 { return 0 } // 因为测试用例中包含了开头就是最小值的测试用例，所以下面这个策略其实并不会奏效 // 可以在前后都添加一个最小值，这样可以减少一些判断 // nums = append([]int{math.MinInt64}, append(nums, math.MinInt64)...) // idx 之所以要遍历到 size ，是因为如果整个数组都是一个递增的数组的话，那么这个此时应该返回的是最后的一个数组下标 // 也就是说，这里其实是一个 corner case，需要进行特殊处理 var monoStack []int for idx := 0; idx \u0026lt;= size; idx++ { // 处理整个数组都为递增数组的情况，或者整个数组只有一个元素的情况（其实这个情况也包含在前一个情况中） if idx == size { return size - 1 } // 如果栈为空或者当前元素比栈顶元素要大，那么说明当前是递增的，将当前元素入栈 stackSize := len(monoStack) if stackSize == 0 || nums[idx] \u0026gt; nums[monoStack[stackSize - 1]] { monoStack = append(monoStack, idx) continue } // 如果栈顶元素比当前元素要大，那么说明找到了一个局部峰值，此时返回这个局部峰值即可 if nums[idx] \u0026lt; nums[monoStack[stackSize-1]] { return monoStack[stackSize-1] } } // 如果找不到局部峰值，那么返回-1 return -1 } Binary Search # 这里的 Binary Search 题主是很难想到的，并且在看到答案之后，还一度怀疑为什么这也可以？在考虑一下之后，发现确实是可以解出来的。这里我们取中间值，然后跟它后一个值进行比较，如果当前值比后一个值要小，那么就可以缩小区间，将 left 设为 middle + 1；否则，将 right 设为 middle。为什么这么做就可以呢？首先需要确定的是，我们这里需要的是局部峰值，而不是全局峰值，那么就是说，整个数组中，只要找出一个递增的数组即可。当 nums[mid] \u0026lt; nums[mid+1] 时，说明我们已经找到了一个递增的序列，那么在middle 之后必然是有局部峰值的，所以只需要把区间右移即可。反之，说明峰值在左侧，甚至可能峰值就是 middle，那么这个时候 right 就不能过分缩小，所以只需要将 right 赋为 middle 即可。二分法最重要的就是要做到区间收敛。\n这个解法还是太 tricky 了，面试时候不一定想得出来。\nfunc findPeakElement(nums []int) int { size := len(nums) left, right := 0, size - 1 for left \u0026lt; right { mid := left + (right-left)/2 if nums[mid] \u0026lt; nums[mid+1] { left = mid + 1 } else { right = mid } } return right } "},{"id":84,"href":"/docs/algs/leetcode/167_two_sum_ii_input_array_is_sorted/","title":"0167. Two Sum II - Input Array Is Sorted","section":"Leetcode","content":" Description # Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 \u0026lt;= index1 \u0026lt; index2 \u0026lt;= numbers.length.\nReturn the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.\nThe tests are generated such that there is exactly one solution. You may not use the same element twice.\nYour solution must use only constant extra space.\nSolutions # 这题很简单，使用双指针即可。\nfunc twoSum(numbers []int, target int) []int { size := len(numbers) left, right := 0, size -1 for left \u0026lt; right { sum := numbers[left] + numbers[right] if sum == target { return []int{left+1, right+1} } else if sum \u0026lt; target { left++ } else { right-- } } return nil } "},{"id":85,"href":"/docs/algs/leetcode/179_largest_numbe/","title":"0179. Largest Number","section":"Leetcode","content":" Description # Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.\nSince the result may be very large, so you need to return a string instead of an integer.\nSolutions # 这里的解法需要十分注意，跟一般的排序是有区别的。\nimport ( \u0026#34;strconv\u0026#34; \u0026#34;sort\u0026#34; \u0026#34;strings\u0026#34; ) func largestNumber(nums []int) string { var rs []string for _, num := range nums { rs = append(rs, strconv.Itoa(num)) } // 这里应该进行连接排序 sort.Slice(rs, func(i,j int) bool { return rs[i] + rs[j] \u0026gt; rs[j] + rs[i] }) res := strings.Join(rs, \u0026#34;\u0026#34;) size := len(res) // 如果全部都是 0，那么只需要保留最后一个 0 即可 var pos int for pos \u0026lt; size-1 \u0026amp;\u0026amp; res[pos] == \u0026#39;0\u0026#39; { pos++ } return res[pos:] } "},{"id":86,"href":"/docs/algs/leetcode/191_number_of_1_bits/","title":"0191. Number of 1 Bits","section":"Leetcode","content":" Description # Write a function that takes an unsigned integer and returns the number of \u0026lsquo;1\u0026rsquo; bits it has (also known as the Hamming weight).\nSolutions # 太简单了，并且输入还是无符号数，没啥好说的，直接看代码。\nfunc hammingWeight(num uint32) int { var res int for num != 0 { res += int(num\u0026amp;1) num \u0026gt;\u0026gt;= 1 } return res } "},{"id":87,"href":"/docs/algs/leetcode/200_number_of_islands/","title":"0200. Number of Islands","section":"Leetcode","content":" Description # Given an m x n 2D binary grid grid which represents a map of \u0026lsquo;1\u0026rsquo;s (land) and \u0026lsquo;0\u0026rsquo;s (water), return the number of islands.\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\nSolutions # DFS # 典型的 DFS 应用。这里跟求一个图中有多少个连通分量一样，因为每个方格只能是 \u0026lsquo;0\u0026rsquo; 或者 \u0026lsquo;1\u0026rsquo;，所以我们可以在遍历的时候直接把已经遍历过的地方都设为'0\u0026rsquo;。如果不想污染原数组，那么就用一个 map 来记录该位置是否被遍历过即可。\nfunc numIslands(grid [][]byte) int { row, col := len(grid), len(grid[0]) var res int for i := 0; i \u0026lt; row; i++ { for j := 0; j \u0026lt; col; j++ { if grid[i][j] != \u0026#39;0\u0026#39; { res++ dfs(grid, i, j, row, col) } } } return res } func dfs(grid [][]byte, row, col, rows, cols int) { if row \u0026gt;= rows || row \u0026lt; 0 || col \u0026gt;= cols || col \u0026lt; 0 || grid[row][col] == \u0026#39;0\u0026#39; { return } if grid[row][col] != \u0026#39;0\u0026#39; { grid[row][col] = \u0026#39;0\u0026#39; dfs(grid, row+1, col, rows, cols) dfs(grid, row-1, col, rows, cols) dfs(grid, row, col+1, rows, cols) dfs(grid, row, col-1, rows, cols) } } "},{"id":88,"href":"/docs/algs/leetcode/206_reverse_linked_list/","title":"0206. Reverse Linked List","section":"Leetcode","content":" Description # Given the head of a singly linked list, reverse the list, and return the reversed list.\nSolutions # Iterative # 迭代法，但是要注意虚拟头节点的使用。\nfunc reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } dummy := new(ListNode) cur := head for cur != nil { tail := dummy.Next next := cur.Next dummy.Next = cur cur.Next = tail cur = next } return dummy.Next } Recursive # 这里递归法如何反转节点也是需要十分注意的。\nfunc reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } res := reverseList(head.Next) head.Next.Next = head head.Next = nil return res } "},{"id":89,"href":"/docs/algs/leetcode/207_course_scheduler/","title":"0207. Course Scheduler","section":"Leetcode","content":" Description # There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1. Return true if you can finish all courses. Otherwise, return false. Solutions # Topological sorting # 这里是从拓扑排序的角度来做的，如果图中不存在环，那么所有节点应该都是可达的。这里构建一个邻接表 adjTable，adjTable[i]表示从 i 出发可以到达的节点。然后构建一个 map in，用来表示每个节点的入度，这里需要注意的是，需要先将每个节点的入度初始化为 0，这是因为如果你只在 in 中存储那些入度不为 0 的节点的话，那么在 BFS 的时候就找不到那些入度为 0 的节点了，这个地方是非常需要注意的。 接下来只需要按照正常 BFS 的流程走下去即可。最后检查是否有节点的入度大于 0， 如果存在，则说明有环，返回 false 即可。\nfunc canFinish(numCourses int, prerequisites [][]int) bool { // in 表示每个节点的入度，首先需要将所有节点的入度初始化为 0（重要） in := make(map[int]int) for i := 0; i \u0026lt; numCourses; i++ { in[i] = 0 } // 构建邻接表 adjTable := make(map[int][]int) size := len(prerequisites) for i := 0; i \u0026lt; size; i++ { adjTable[prerequisites[i][1]] = append(adjTable[prerequisites[i][1]], prerequisites[i][0]) // 这里只会统计入度不为 0 的节点，如果上一步没有将所有节点的入度初始化为 0 的话， // 那么在第三部的 BFS 中就很可能导致这些节点的确实 in[prerequisites[i][0]]++ } // 找到入度为 0 的节点并入队，这些节点将作为其实节点 var queue []int for key, value := range in { if value == 0 { queue = append(queue, key) } } // BFS for len(queue) != 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { // 对于每个从当前节点可达的节点，将其入度减 1。减 1 之后如果入度为 0，则将其加入队列中 nodes := adjTable[queue[i]] for _, value := range nodes { in[value]-- // 这里的判断条件意味着，即使 in[value] 小于 0 也没问题 if in[value] == 0 { queue = append(queue, value) } } } queue = queue[size:] } // 统计是否有节点的入度不为 0，如果存在，则说明存在环，无法完全结束 for _, value := range in { if value \u0026gt; 0 { return false } } // 无环，所有节点均可达 return true } BFS # 题主发现自己之前已经做过这个题了，这里就将代码贴出来。\n// 其实应该和容易能想到，这题考的就是图中的环检测。 // 关于图中的环检测，可以使用： 1. 拓扑排序 2.BFS/DFS // 拓扑排序的话，可以带环图去除正常边后入度不为 0 的角度来计算。 // 这里就新构造一个图，然后使用 DFS 来查询。 // type Node struct { // Val int // Neighbors []*Node // } func canFinish(numCourses int, prerequisites [][]int) bool { nodes := make(map[int]*Node, numCourses) for i := 0; i \u0026lt; numCourses; i++ { nodes[i] = new(Node) nodes[i].Val = i } // build tree for _, pre := range prerequisites { nodes[pre[0]].Neighbors = append(nodes[pre[0]].Neighbors, nodes[pre[1]]) } visited := make(map[int]int, numCourses) // 这里会出现一种情况，就是我们的图并不是一个连通图，会有不与任何其它节点连接的节点存在，所以起始节点不能设为 0 节点，而是应该每个节点都遍历一次 // 而且对于有向图的遍历来说，确实需要对每个节点都进行遍历 for i := 0; i \u0026lt; numCourses; i++ { if !canFinishDFS(nodes[i], \u0026amp;visited) { return false } } return true } // 这里有个问题，为什么使用了三种状态，而不是两种状态呢？DFS 的话，不应该使用两种状态就可以了吗？ // 因为一次dfs对应一个连通分量（这里指的是有向图的连通分量），我们只需要使用1表示在这次dfs里面已经访问过，如果在这次dfs里面再次访问，就表示有环， // dfs之后再把1变为0即可。这样做虽然是正确的，但是会超时。所以我们引入第三种状态，例如-1，表示这个节点已经在之前的dfs里面访问过而且这个节点的连通分量不会存在环， // 所以我们可以直接返回true。这样做可以避免重复访问。这才是引入三种状态的根本原因。 func canFinishDFS(node *Node, m *map[int]int) bool { if (*m)[node.Val] == -1 { return false } if (*m)[node.Val] == 1 { return true } (*m)[node.Val] = -1 neighbors := node.Neighbors for _, neighbor := range neighbors { if !canFinishDFS(neighbor, m) { return false } } (*m)[node.Val] = 1 return true } // 使用队列的 BFS 来对有向图进行环检测 func canFinishBFS(numCourses int, prerequisites [][]int) bool { size := len(prerequisites) if size == 0 { return true } graph := make([][]int, numCourses) in := make([]int, numCourses) for _, edge := range prerequisites { graph[edge[1]] = append(graph[edge[1]], edge[0]) in[edge[0]] += 1 } var queue []int for point, degree := range in { if degree == 0 { queue = append(queue, point) } } for len(queue) != 0 { front := queue[0] queue = queue[1:] points := graph[front] for _, point := range points { in[point] -= 1 // 为什么是在这里进行检测，而不是在下面注释掉的部分? // 因为如果是在下面进行检测的话，我们会将哪些原本已经入队的入度为0的节点再次入队，这显然是不对的，相当于进入了死循环，会超时 if in[point] == 0 { queue = append(queue, point) } } // for point, degree := range in { // if degree == 0 { // queue = append(queue, point) // } // } } for _, degree := range in { if degree != 0 { return false } } return true } "},{"id":90,"href":"/docs/algs/leetcode/210_course_scheduler_ii/","title":"0210. Course Scheduler II","section":"Leetcode","content":" Description # There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1. Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\nSolutions # Topological sorting # 这里与 207 题的区别就在于，这里不仅需要判断有没有环，如果没环的话还需要给出一条路径。那么只需要在 207 题的基础上稍微做一些修改即可。这里因为只需要给出一个可行解即可，所以只需要在 BFS 的过程中每遍历到一个节点，就将这个节点的加入到 res 中即可。还需要注意的是，最后可以直接通过判断 res 的大小是否与 numCourses 相等来判断是否存在环，因为按照上面的过程，如果不存在环的话，所有的节点都会被加入到 res 中去。\nfunc findOrder(numCourses int, prerequisites [][]int) []int { // in 表示每个节点的入度，首先需要将所有节点的入度初始化为 0（重要） in := make(map[int]int) for i := 0; i \u0026lt; numCourses; i++ { in[i] = 0 } // 构建邻接表 adjTable := make(map[int][]int) size := len(prerequisites) for i := 0; i \u0026lt; size; i++ { adjTable[prerequisites[i][1]] = append(adjTable[prerequisites[i][1]], prerequisites[i][0]) // 这里只会统计入度不为 0 的节点，如果上一步没有将所有节点的入度初始化为 0 的话， // 那么在第三部的 BFS 中就很可能导致这些节点的确实 in[prerequisites[i][0]]++ } // 找到入度为 0 的节点并入队，这些节点将作为其实节点 var queue []int for key, value := range in { if value == 0 { queue = append(queue, key) } } // BFS var res []int for len(queue) != 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { // 对于每个从当前节点可达的节点，将其入度减 1。减 1 之后如果入度为 0，则将其加入队列中 nodes := adjTable[queue[i]] res = append(res, queue[i]) for _, value := range nodes { in[value]-- // 这里的判断条件意味着，即使 in[value] 小于 0 也没问题 if in[value] == 0 { queue = append(queue, value) } } } queue = queue[size:] } // 统计是否有节点的入度不为 0，如果存在，则说明存在环，无法完全结束 // for _, value := range in { // if value \u0026gt; 0 { // return false // } // } // 这里只需要统计结果中的节点数等不等与 numCourse 的数量，如果不等，则说明有环，否则说明无环 if len(res) != numCourses { return nil } // 无环，所有节点均可达 return res } "},{"id":91,"href":"/docs/algs/leetcode/215_kth_largest_element_in_an_array/","title":"0215. Kth Largest Element in an Array","section":"Leetcode","content":" Description # Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nSolutions # Heap # 创建一个 k 个大小的最小堆，首先先将前 k 个元素压入堆中，而后面的元素只有当其比堆顶元素要大的时候才可以入堆。最后堆顶元素即为所求。\nimport ( \u0026#34;container/heap\u0026#34; ) func findKthLargest(nums []int, k int) int { return findKthLargestUsingSort(nums, 0, len(nums)-1, k) } // 解法1， 使用最大堆来解 func findKthLargestUsingHeap(nums []int, k int) int { var maxHeap MaxHeap heap.Init(\u0026amp;maxHeap) for _, num := range nums { heap.Push(\u0026amp;maxHeap, num) } for i := 0; i \u0026lt; k-1; i++ { heap.Pop(\u0026amp;maxHeap) } return heap.Pop(\u0026amp;maxHeap).(int) } //--------------- max heap ---------------------- type MaxHeap []int func (h MaxHeap) Len() int { return len(h) } func (h MaxHeap) Swap(i,j int) { h[i], h[j] = h[j], h[i] } func (h MaxHeap) Less(i,j int) bool { return h[i] \u0026gt; h[j] } func (h *MaxHeap) Push(x interface{}) { *h = append(*h, x.(int)) } func (h *MaxHeap) Pop() interface{} { size := h.Len() if size == 0 { return -1 } x := (*h)[size-1] *h = (*h)[:size-1] return x } Quick Select # 可以使用快排的 partition 算法。快排的 partition 算法中，选中选择一个基点作为 pivot，然后将小于 pivot 的元素放在 pivot 左边，大于 pivot 的元素放在 pivot 右边，然后返回 pivot 的下标，这样 pivot 左边的元素都比 pivot 小，右边的都比 pivot 大，这样的话就确定了一个元素的位置。那么我们只需要当 pivot = k-1 时候返回即可。\nfunc findKthLargest(nums []int, k int) int { return findKthLargestUsingSort(nums, 0, len(nums)-1, k) } func findKthLargestUsingSort(nums []int, left, right, k int) int { for { pivot := partition(nums, left, right) if pivot == k - 1 { return nums[k-1] } if pivot \u0026gt; k-1 { // 返回的 pivot 比 k-1 要大，说明查找太偏右了，需要往左查找 right = pivot - 1 } else { // 返回的 pivot 比 k-1 要小，说明查找太偏左了，需要往右查找 left = pivot + 1 } } } func partition(nums []int, left int, right int) int { pivot := nums[left] l,r := left + 1, right for l \u0026lt;= r { if (nums[l] \u0026lt; pivot \u0026amp;\u0026amp; nums[r] \u0026gt; pivot) { nums[l], nums[r] = nums[r], nums[l] l++ r-- } if nums[l] \u0026gt;= pivot { l++ } if nums[r] \u0026lt;= pivot { r-- } } nums[left], nums[r] = nums[r], nums[left] return r } 下面这种写法也可以：\nfunc findKthLargest(nums []int, k int) int { sort.Slice(nums, func(i,j int) bool { return nums[i] \u0026gt; nums[j] }) return quickSort(nums, 0, len(nums)-1, k-1) } func quickSort(nums []int, left, right, k int) int { if left \u0026gt; right { return -1 } pivot := quickSelect(nums, left, right) if pivot == k { return nums[pivot] } else if pivot \u0026lt; k { return quickSort(nums, pivot+1, right, k) } else { return quickSort(nums, left, pivot-1, k) } } func quickSelect(nums []int, left, right int) int { pivot := left left++ for left \u0026lt; right { for left \u0026lt; right \u0026amp;\u0026amp; nums[left] \u0026gt;= nums[pivot] { left++ } for left \u0026lt; right \u0026amp;\u0026amp; nums[right] \u0026lt;= nums[pivot] { right-- } if left \u0026lt; right { nums[left], nums[right] = nums[right], nums[left] } } nums[left-1], nums[pivot] = nums[pivot], nums[left-1] return left - 1 } "},{"id":92,"href":"/docs/algs/leetcode/224_basic_calculator/","title":"0224. Basic Calculator","section":"Leetcode","content":" Description # Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.\nNote: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().\nSolutions # 第一个想法就是，可以先把中缀表达式转换为后缀表达式，然后再对后缀表达式进行计算，这样就会简单很多。那么问题是，如果将一个带有括号的中缀表达式转换为后缀表达式呢？这里的精简版算法如下：\n声明 Q：输出队列 声明 S：操作符栈 遍历中缀表达式中的每一个 token x： - 如果 x 是一个操作数，则直接将 x 追加到输出队列 Q 末尾，否则往下检查； - 如果 x 是一个左括号\u0026#34;(\u0026#34;，则将 x 压入操作符栈，否则往下检查； - 如果 x 是一个操作符： - 如果操作符栈 S 栈顶为一个优先级大于等于 x 的操作符，则将 S 栈顶的操作符弹出并且追加到输出队列 Q 末尾，最后将 x 压入栈顶； - 如果操作符栈 S 栈顶为一个优先级小于等于 x 的操作符，或者不为操作符（这里只可能是左括号\u0026#34;（\u0026#34;）,则直接将 x 压入栈顶即可。 - 如果 x 是一个右括号，则将操作符栈 S 栈顶往下到第一个左括号之间的元素以此弹出炳且追加到输出队列末尾，然后将左括号丢弃，右括号也不用入栈。注意，如果栈到底后仍然没有找到左括号，则说明表达式不合法，左右括号不匹配。 最后将栈 S 中得到的元素全部依次弹出并且入队 Q 即可。 TODO\n"},{"id":93,"href":"/docs/algs/leetcode/225_implement_stack_using_queues/","title":"0225. Implement Stack using Queues","section":"Leetcode","content":" Description # Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).\nImplement the MyStack class:\nvoid push(int x) Pushes element x to the top of the stack. int pop() Removes the element on the top of the stack and returns it. int top() Returns the element on the top of the stack. boolean empty() Returns true if the stack is empty, false otherwise. Notes:\nYou must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid. Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue\u0026rsquo;s standard operations.\nSolutions # 简单题，可以使用数组模拟双向队列，二双线个队列本来就是一端进一端出的，那么这里只需要把出的一端统一到入的一端即可。\ntype Queue = []int type MyStack struct { nums Queue } func Constructor() MyStack { return MyStack{nums: []int{}} } func (this *MyStack) Push(x int) { (*this).nums = append((*this).nums, x) } func (this *MyStack) Pop() int { size := len((*this).nums) x := (*this).nums[size-1] (*this).nums = (*this).nums[:size-1] return x } func (this *MyStack) Top() int { size := len((*this).nums) return (*this).nums[size-1] } func (this *MyStack) Empty() bool { return len((*this).nums) == 0 } /** * Your MyStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Empty(); */ "},{"id":94,"href":"/docs/algs/leetcode/226_invert_binary_tree/","title":"0226. Invert Binary Tree","section":"Leetcode","content":" Description # Given the root of a binary tree, invert the tree, and return its root.\nSolutions # Recursive # 太简单了，递归交换每个节点的左右子节点即可。\nfunc invertTree(root *TreeNode) *TreeNode { if root == nil || root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return root } left, right := invertTree(root.Left), invertTree(root.Right) root.Left, root.Right = right, left return root } Iterative # 或者也可以用中序遍历的的迭代方式。\nfunc invertTreeIterative(root *TreeNode) *TreeNode { if root == nil { return nil } var queue []*TreeNode queue = append(queue, root) for len(queue) != 0 { node := queue[0] queue = queue[1:] node.Left, node.Right = node.Right, node.Left if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } return root } "},{"id":95,"href":"/docs/algs/leetcode/227_basic_calculator_ii/","title":"0227. Basic Calculator II","section":"Leetcode","content":" Description # Given a string s which represents an expression, evaluate this expression and return its value.\nThe integer division should truncate toward zero.\nYou may assume that the given expression is always valid. All intermediate results will be in the range of \\([-2^31, 2^31 - 1]\\) .\nNote: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().\nSolutions # 这个题目因为不涉及乘除法，相比第 224 题就简单很多了，老老实实使用栈来求值就好了。这里也可以先将中缀表达式转换为后缀表达式，然后再对后缀表达式进行求值。\n声明 Q：输出队列 声明 S：操作符栈 遍历中缀表达式中的每一个 token x： - 如果 x 是一个操作数，则直接将 x 追加到输出队列 Q 末尾，否则往下检查； - 如果 x 是一个操作符： - 如果操作符栈 S 栈顶为一个优先级大于等于 x 的操作符，则将 S 栈顶的操作符弹出并且追加到输出队列 Q 末尾，最后将 x 压入栈顶； - 如果操作符栈 S 栈顶为一个优先级小于等于 x 的操作符，则直接将 x 压入栈顶即可。 最后将栈 S 中得到的元素全部依次弹出并且入队 Q 即可。 TODO\n"},{"id":96,"href":"/docs/algs/leetcode/230_kth_smallest_element_in_a_bst/","title":"0230. Kth Smallest Element in a BST","section":"Leetcode","content":" Description # Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.\nSolutions # 这个题很简单，只需要使用中序遍历即可。一下分别给出递归和迭代的解法。\nRecursive # type TreeNode struct { Val int Left *TreeNode Right *TreeNode } func kthSmallest(root *TreeNode, k int) int { if root == nil { return math.MinInt } return helper(root, \u0026amp;k) } func helper(root *TreeNode, cur *int) int { if root == nil { return math.MinInt } val := helper(root.Left, cur) if val != math.MinInt { return val } *cur-- if 0 == *cur { return root.Val } return helper(root.Right, cur) } Iterative # type TreeNode struct { Val int Left *TreeNode Right *TreeNode } func kthSmallest(root *TreeNode, k int) int { var queue []*TreeNode cur := root var cnt int for len(queue) != 0 || cur != nil { for cur != nil { queue = append(queue, cur) cur = cur.Left } size := len(queue) // 注意这里不要覆盖了 cur，要使用 = 而不是 := cur = queue[size-1] queue = queue[:size-1] cnt++ if cnt == k { return cur.Val } cur = cur.Right } return -1 } "},{"id":97,"href":"/docs/algs/leetcode/232_implement_queue_using_stacks/","title":"0232. Implement Queue using Stacks","section":"Leetcode","content":" Description # Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).\nImplement the MyQueue class:\nvoid push(int x) Pushes element x to the back of the queue. int pop() Removes the element from the front of the queue and returns it. int peek() Returns the element at the front of the queue. boolean empty() Returns true if the queue is empty, false otherwise. Notes:\nYou must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack\u0026rsquo;s standard operations.\nSolutions # 这个目前也很简单，主要实现如下：使用两个队列，队列1专用于push，队列用专用于pop 和 peek。push 时，入队 stack1； pop 时，如果 stack2 不为空，则弹出 stack2 栈顶即可，若 stack2 为空，则将 stack1 的所有元素压入 stack2， 然后将 stack2 的栈顶元素弹出。\ntype MyQueue struct { stack1 []int stack2 []int } // comment this to resolve conflicts func Constructor() MyQueue { return MyQueue{ stack1: make([]int, 0), stack2: make([]int, 0), } } func (this *MyQueue) Push(x int) { this.stack1 = append(this.stack1, x) } func (this *MyQueue) Pop() int { var res int len1, len2 := len(this.stack1), len(this.stack2) if len2 != 0 { ele := this.stack2[len2-1] res = ele this.stack2 = this.stack2[:len2-1] } else { for i := len1 - 1; i \u0026gt;= 0; i-- { this.stack2 = append(this.stack2, this.stack1[i]) } this.stack1 = this.stack1[:0] len2 = len(this.stack2) res = this.stack2[len2-1] this.stack2 = this.stack2[:len2-1] } return res } func (this *MyQueue) Peek() int { var res int len1, len2 := len(this.stack1), len(this.stack2) if len2 != 0 { ele := this.stack2[len2-1] res = ele } else { for i := len1 - 1; i \u0026gt;= 0; i-- { this.stack2 = append(this.stack2, this.stack1[i]) } this.stack1 = this.stack1[:0] len2 = len(this.stack2) res = this.stack2[len2-1] } return res } func (this *MyQueue) Empty() bool { return len(this.stack1) == 0 \u0026amp;\u0026amp; len(this.stack2) == 0 } "},{"id":98,"href":"/docs/algs/leetcode/235_lowest_common_ancestor_of_a_binary_tree/","title":"0235. Lowest Common Ancestor of Binary Search Tree","section":"Leetcode","content":" Description # Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\nSolutions # Recursive # 这题很简单，因为 BST 本身就具备有序的性质，所以我们只需要抓住这个性质来进行遍历即可。首先我们假设 p 比 q 要小，那么对于递归遍历到的每个节点 root， 如果 root 的值大于最大 q 的值，那么说明最小公共节点一并比 root 要小，我们需要往root 的左子树进行查找；如果 root 的值小于最小值 p 的值，那么说明最小公共祖先一定比 p 要大，那么我们需要往 p 的右节点进行查找；否则，说明 root 的值刚好结余 p 和 q 之间，此时 root 就是我们所查找的最小公共组节点，返回 root 即可。\ntype TreeNode struct { Val int Left *TreeNode Right *TreeNode } func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if p.Val \u0026gt; q.Val { return lowestCommonAncestor(root, q, p) } if root.Val \u0026gt; q.Val { return lowestCommonAncestor(root.Left, p, q) } else if root.Val \u0026lt; p.Val { return lowestCommonAncestor(root.Right, p, q) } else { return root } } Recursive # 迭代解法也比较简单，思路跟上面一样，我这里就不多说了，直接上代码。\nfunc lowestCommonAncestorSolution2(root, p, q *TreeNode) *TreeNode { node := root for { if node.Val \u0026lt; min(q.Val, p.Val) { node = node.Right } else if node.Val \u0026gt; max(p.Val, q.Val) { node = node.Left } else { return node } } } "},{"id":99,"href":"/docs/algs/leetcode/236_lowest_common_ancestor_of_binary_tree/","title":"0236. Lowest Common Ancestor of Binary Tree","section":"Leetcode","content":" Description # Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\nSolutions # Recursive # 这里如果是一棵二叉排序树，那么问题就会简单很多，但是这里只是普通的二叉树，所以稍微就会稍微难一点。注释都写在代码中了，判断的过程值得好好体会一下。\ntype TreeNode struct { Val int Left *TreeNode Right *TreeNode } // lowestCommonAncestor 判断 root 节点 func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { // 首先空子树肯定不包含我们所要的 if root == nil { return nil } // 递归遍历左右子节点 left, right := lowestCommonAncestor(root.Left, p, q), lowestCommonAncestor(root.Right, p, q) // 如果当前根节点刚好等于其中一个节点的值，那么返回根节点 if root.Val == p.Val || root.Val == q.Val { return root } // 否则，如果左右节点中有一个非空，说明已经在左/右子树中找到了 lcs，那么返回该非空节点 if left == nil { return right } if right == nil { return left } // 此时左右节点都非空，说明当前根节点刚好是 lcs，则直接返回 root return root } "},{"id":100,"href":"/docs/algs/leetcode/240_search_a_2d_matrix_ii/","title":"0240. Search a 2D Matrix II","section":"Leetcode","content":" Description # Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:\nIntegers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom.\nSolutions # Binary Search # 这个题使用跟 74 题一样的解法完全可以解决。\n这题的二分解法真的比较巧妙。这里首先具备了两个特征：每一行从左向右递增，每一列从上到下递增。那么我们可以从第一列最后一个元素开始进行搜索，如果target 比当前元素要小，那么如果target 要存在，就只能在当前行上边，于是row-1；如果target比当前元素要大，那么如果该元素存在的话，智能在当前列右侧，于是col+1。按照以上规则进行遍历即可。\nfunc searchMatrix(matrix [][]int, target int) bool { m,n := len(matrix), len(matrix[0]) row, col := m - 1, 0 for row \u0026gt;= 0 \u0026amp;\u0026amp; col \u0026lt; n { if matrix[row][col] == target { return true } if matrix[row][col] \u0026lt; target { col++ } if col \u0026lt; n \u0026amp;\u0026amp; matrix[row][col] \u0026gt; target { row-- } } return false } "},{"id":101,"href":"/docs/algs/leetcode/263_ugly_number/","title":"0263. Ugly Number","section":"Leetcode","content":" Description # An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\nGiven an integer n, return true if n is an ugly number.\nSolutions # 如果一个数是丑数，那么它的因子必然只有 2、3、5 这三个，那么如果 n 能够被它的这些因子整除，那就不断的缩小 n，最后检查 n 不断被整除后的 n 其是否等于 1 即可。\nfunc isUgly(n int) bool { if n \u0026lt;= 0 { return false } if n \u0026lt;= 6 { return true } for n % 2 == 0 { n /= 2 } for n %3 == 0 { n /= 3 } for n % 5 == 0 { n /= 5 } return n == 1 } "},{"id":102,"href":"/docs/algs/leetcode/264_ugly_number_ii/","title":"0264. Ugly Number II","section":"Leetcode","content":" Description # An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\nGiven an integer n, return the nth ugly number.\nSolutions # 下面这种是错误的解法，下面的逻辑意味着丑数只能从 2 的幂、3 的幂以及 5 的幂中出现，但是 6 并不属于上述任何一种，但是 6 也是幂。\nfunc nthUglyNumber(n int) int { if n \u0026lt;= 6 { return n } res := 1 i2,i3,i5 := 1,1,1 for i := 2; i \u0026lt; n; i++ { res = min(i2*2, min(i3*3, i5*5)) // 错误做法。按照下面的逻辑，丑数只能从 2 的幂，3 的幂以及 5 的幂中出现，这个逻辑是不对的。 if res /2 == i2 { i2 *= 2 } if res / 3 == i3 { i3 *= 3 } if res / 5 == i5 { i5 *= 5 } } return res } func min(a,b int) int { if a \u0026lt; b { return a } return b } 下面这个才是正确的解法，这个解法是从已有丑数中找出下一个最小的丑数。\nfunc nthUglyNumber(n int) int { if n \u0026lt;= 6 { return n } var i2, i3, i5 int res := make([]int, n) res[0] = 1 for i := 1; i \u0026lt; n; i++ { // 取出当前队列的最小值 res[i] = min(res[i2]*2, min(res[i3]*3, res[i5]*5)) // 如果是这个队列贡献了这个值，那么更新队列元素 if res[i] == res[i2]*2 { i2++ } if res[i] == res[i3] * 3 { i3++ } if res[i] == res[i5] * 5 { i5++ } } return res[n-1] } func min(a,b int) int { if a \u0026lt; b { return a } return b } "},{"id":103,"href":"/docs/algs/leetcode/268_missing_number/","title":"0268. Missing Number","section":"Leetcode","content":" Description # Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.\nSolutions # 这题很简单，只需要使用求和公式来进行计算就可以了。直接给出代码。\nfunc missingNumber(nums []int) int { n := len(nums) sum := (0+n) * (n+1)/2 for _, num := range nums { sum -= num } return sum } "},{"id":104,"href":"/docs/algs/leetcode/277_find_the_celebrity/","title":"0277. Find the Celebrity","section":"Leetcode","content":" Description # Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.\nNow you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: \u0026ldquo;Hi, A. Do you know B?\u0026rdquo; to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).\nYou are given a helper function bool knows(a, b)which tells you whether A knows B. Implement a function int findCelebrity(n). There will be exactly one celebrity if he/she is in the party. Return the celebrity\u0026rsquo;s label if there is a celebrity in the party. If there is no celebrity, return -1.\nSolutions # Hash Table # 题主初始是这么想的：创建一个长度为 n 的 map，表示每个人都是名人，然后开始遍历矩阵，每遍历到一个位置，就 matrix[i][j]，如果 i 认识 j，那么说明 i 肯定不是名人，把 i 从 map 中删去。最后 map 中如果还剩下一个元素，那么最后剩下的那个元素就是名人，否则说明没有名人。\nfunc findCelebrity( n int) int { // 假定每个人都是名人 dict := make(map[int]int) for i := 0; i \u0026lt; n; i++ { dict[i] = true } for i := 0; i \u0026lt; n ;i++ { for j := 0; j \u0026lt; n; j++ { if knows(i,j) { // 如果 i 认识 j， 那么 i 不是名人；如果 i 还在 map 中，那么就把 i 从 map 中删去 if _, ok := dict[i]; ok { delete(dict, i) } } } } // 名人只会有一个 if len(dict) != 1 { return -1 } for key, _ := range dict { return key } } func knows(i,j int) bool { // do something return true } 题主网上看到一种比较妙的解法，核心大意是：初始假定候选人 res 为 0 号选手，然后遍历一次所有选手，如果 res 认识 j，那么说明 res 肯定不是名人，而 j 可能是名人，则将 res 更新为 j，等遍历完之后，再来判断 res 到底是不是名人。这时有需要从头开始遍历一次，如果 res 认识 i 或者 i 不认识 res，那么都说明 res 不是名人，此时说明没有名人，返回 -1 即可；否则如果全部遍历完之后，res 有效的话，说明 res 就是名人，则返回 res 即可。\n解释一下上面加粗的部分，为什么认为这个时候就没有名人了呢？ 其实可以从树的角度来进行思考（做个类比），上面的第一次遍历中，其实已经确保了一个事实：如果这是一个有向连通图，那么 res 表示了图中的一个节点，此时 res 必然不是名人；反之，说明 res 此时表示了那个名人节点（任意节点均有路径与其相连，但是它找不到一条路径与其它节点相连（除自身））。那么第二次循环所做的努力就是，排除上述的有向连通图的可能。\nfunc findCelebrity(n int) int { // 找出那个可能的名人节点 var res int for i := 1; i \u0026lt; n; i++ { if knows(res, i) { res = i } } // 排除这是一个连通图的可能 for i := 0; i \u0026lt; n; i++ { // 除自身外，如果有人不认识 res 或者 res 认识它，都说明这是一个连通图，则返回-1 if i != res \u0026amp;\u0026amp; (knows(res, i) || !knows(i, res)) { return -1 } } // res 是一个有效节点，返回即可 return res } "},{"id":105,"href":"/docs/algs/leetcode/278_first_bad_version/","title":"0278. First Bad Version","section":"Leetcode","content":" Description # You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\nSuppose you have n versions [1, 2, \u0026hellip;, n] and you want to find out the first bad one, which causes all the following ones to be bad.\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\nSolutions # Binary Search # 这题很简单，很容易看出来要使用二分法，简单进行二分搜索即可。\n/** * Forward declaration of isBadVersion API. * @param version your guess about first bad version * @return true if current version is bad *\tfalse if current version is good * func isBadVersion(version int) bool; */ func firstBadVersion(n int) int { left, right := 1, n for left \u0026lt; right { mid := left + (right - left)/2 if isBadVersion(mid) { right = mid } else { left = mid + 1 } } return left } "},{"id":106,"href":"/docs/algs/leetcode/281_zigzag_iterator/","title":"0281. Zigzag Iterator","section":"Leetcode","content":" Description # Given two 1d vectors, implement an iterator to return their elements alternately.\nFor example, given two 1d vectors:\nv1 = [1, 2] v2 = [3, 4, 5, 6] By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1, 3, 2, 4, 5, 6].\nFollow up: What if you are given k 1d vectors? How well can your code be extended to such cases?\nClarification for the follow up question: The \u0026ldquo;Zigzag\u0026rdquo; order is not clearly defined and is ambiguous for k \u0026gt; 2 cases. If \u0026ldquo;Zigzag\u0026rdquo; does not look right to you, replace \u0026ldquo;Zigzag\u0026rdquo; with \u0026ldquo;Cyclic\u0026rdquo;. For example:\nInput:\n[1,2,3] [4,5,6,7] [8,9] Output:\n[1,4,8,2,5,9,3,6,7] Solutions # 这里可以用队列。首先可以对每一个数组生成一个 pair 对，每个 pair 对包含 两个元素 start 和 end， 其中 start 表示当前应该打印的数字下标，end 表示当前数组的结尾位置（也就是 size），然后按照顺序将每个 pair 入队。读的时候就取出队头元素，如果 start 比 end 要小，那么取出 start 下标的值并输出，然后将 pair 的 start 加 1，放到队尾去；如果 start 等于 end 了，则说明这个数组已经遍历完成了，则从队列总删除这个 pair。\n因为不是 premium 会员，所以看不到代码签名，智能子集随便写一下了。\n// 下标 0 记录是哪一个数组，下标 1 记录该数组的 start， 下标 2 记录该数组的 end type Pair [3]int type ZigZagIterator struct { queue []Pair nums [][]int } func Construtor(nums ...[]int) ZigZagIterator { var queue []Pair for idx, num := range nums { size := len(num) queue = append(queue, []int{idx, 0, size}) } return ZigZagIterator{queue: queue, nums: nums} } func (this *ZigZagIterator) Next() int { size := len(*this.queue) top := (*this).queue[0] (*this).queue = (*this).queue[1:] for size != 0 \u0026amp;\u0026amp; top[1] == top[2] { top = (*this).queue[0] (*this).queue = (*this).queue[1:] size-- } // handle error if size == 0 { return -1 } x := (*this).nums[top[0]][top[1]] (*this).queue = append(*this.queue, []int{top[0], top[1]+1, top[2]}) return x } "},{"id":107,"href":"/docs/algs/leetcode/283_moving_zeroes/","title":"0283. Moving Zeroes","section":"Leetcode","content":" Description # Given an integer array nums, move all 0\u0026rsquo;s to the end of it while maintaining the relative order of the non-zero elements.\nNote that you must do this in-place without making a copy of the array.\nSolutions # Two Pointer # 简单题，直接上代码：\nfunc moveZeroes(nums []int) { size := len(nums) if size \u0026lt;= 1 { return } left, right := 0, 0 for right \u0026lt; size { if nums[right] != 0 { nums[left] = nums[right] left++ } right++ } for left \u0026lt; size { nums[left] = 0 left++ } } "},{"id":108,"href":"/docs/algs/codingInterviews/03_%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E7%BB%84/","title":"03. 数组中重复的数字","section":"Coding Interviews","content":" Description # 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组[2,3,1,0,2,5,3]，那么对应的输出是2或者3。存在不合法的输入的话输出-1\n数据范围： \\($0\\le n \\le 10000$\\) 进阶：时间复杂度 \\($\\Omicron(n)$\\) ，空间复杂度 \\($\\Omicron(n)$\\) Solutions # Hash table # 简单题，要么使用哈希表，要么就排一下序。\nfunc duplicate( numbers []int ) int { // write code here // size := len(numbers) dict := make(map[int]bool) for _, value := range numbers { if _, ok := dict[value]; ok { return value } dict[value] = true } return -1 } "},{"id":109,"href":"/docs/algs/leetcode/303_range_sum_query_immutable/","title":"0303. Range Sum Query - Immutable","section":"Leetcode","content":" Solutions # Brute Force \u0026amp; Memorial # 本来题主以为这里考的是使用记忆化数组来避免重复计算，结果一提交结果，发现自己还是太天真了\u0026hellip;\ntype NumArray struct { nums []int dict map[string]int } func Constructor(nums []int) NumArray { return NumArray{nums, make(map[string]int)} } func (this *NumArray) SumRange(left int, right int) int { if left == right { return (*this).nums[left] } if left \u0026gt; right { return 0 } target := string(left) + string(right) if _, ok := (*this).dict[target]; ok { return (*this).dict[target] } res := this.nums[left] + this.nums[right] + this.SumRange(left+1, right-1) (*this).dict[target] = res return res } /** * Your NumArray object will be instantiated and called as such: * obj := Constructor(nums); * param_1 := obj.SumRange(left,right); */ Prefix Sum # 网上看到有用前缀和的解法，只能说我实在是想不到\u0026hellip;.。总的来说就是，创建一个数组 predix 记录 [0,right] 的和，那么当要求计算 [left,right] 的和时，只需要使用[0,right]的和减去[0,left-1]即可。而为了方便计算，我们的数组增加了一个位置，这样在计算结果的时候，下标也后移 1，就会变成[0,right+1]的和减去[0,left] 的和\ntype NumArray struct { nums []int prefix []int } func Constructor(nums []int) NumArray { prefix := make([]int, len(nums)+1) idx := 1 var res int // [0,right] 的和为 prefix[right+1] for _, num := range nums { res += num prefix[idx] = res idx++ } return NumArray{nums, prefix} } // [0,right] 的和为 prefix[right+1]，而[left,right] 的和为[0, right]的和 减去 [0,left-1] 的和， // 对应到这里，即为 prefix[right+1] - prefix[left] func (this *NumArray) SumRange(left int, right int) int { return (*this).prefix[right+1] - (*this).prefix[left] } /** * Your NumArray object will be instantiated and called as such: * obj := Constructor(nums); * param_1 := obj.SumRange(left,right); */ "},{"id":110,"href":"/docs/algs/leetcode/307_range_sum_query_mutable/","title":"0304. Range Sum Query - Mutable","section":"Leetcode","content":" Description # Given an integer array nums, handle multiple queries of the following types:\nUpdate the value of an element in nums.\nCalculate the sum of the elements of nums between indices left and right inclusive where left \u0026lt;= right. Implement the NumArray class:\nNumArray(int[] nums) Initializes the object with the integer array nums.\nvoid update(int index, int val) Updates the value of nums[index] to be val.\nint sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + \u0026hellip; + nums[right]).\nSolutions # Prefix Sum # 这里参考 303 题和 304 题，很容易想出使用前缀和的解法。区别只是，在更新的时候，需要更新下标index 之后的每个前缀和，也正是因为这个更新操作，所以时间会高一些，但是可以通过 OJ。\ntype NumArray struct { nums []int prefix []int } func Constructor(nums []int) NumArray { size := len(nums) prefix := make([]int, size +1) for idx, num := range nums { prefix[idx+1] = prefix[idx] + num } return NumArray{nums, prefix} } func (this *NumArray) Update(index int, val int) { diff := val - (*this).nums[index] (*this).nums[index] = val for i := index+1; i \u0026lt;= len((*this).nums); i++ { (*this).prefix[i] += diff } } func (this *NumArray) SumRange(left int, right int) int { return (*this).prefix[right+1] - (*this).prefix[left] } /** * Your NumArray object will be instantiated and called as such: * obj := Constructor(nums); * obj.Update(index,val); * param_2 := obj.SumRange(left,right); */ "},{"id":111,"href":"/docs/algs/leetcode/304_range_sum_query_2d_immutable/","title":"0304. Range Sum Query 2D - Immutable","section":"Leetcode","content":" Description # Given a 2D matrix matrix, handle multiple queries of the following type:\nCalculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2). Implement the NumMatrix class:\nNumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix. int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).\nSolutions # Brute Force # 这是一个会超时的解法。\ntype NumMatrix struct { matrix [][]int } func Constructor(matrix [][]int) NumMatrix { rows, cols := len(matrix), len(matrix[0]) return NumMatrix{matrix} } func (this *NumMatrix) SumRegion(row1 int, col1 int, row2 int, col2 int) int { var res int for i := row1; i \u0026lt;= row2; i++ { for j := col1; j \u0026lt;= col2; j++ { res += (*this).matrix[i][j] } } return res } /** * Your NumMatrix object will be instantiated and called as such: * obj := Constructor(matrix); * param_1 := obj.SumRegion(row1,col1,row2,col2); */ Prefix Sum # 这是一个参考 303 题使用前缀和来求解的方法。使用了前缀和之后，如果我们想要快速求出(r1, c1)到(r2, c2)的矩形区间时，只需prefix[r2][c2] - prefix[r2][c1 - 1] - prefix[r1 - 1][c2] + prefix[r1 - 1][c1 - 1]即可，而又因为我们使用辅助行和辅助列，prefix 矩阵的位置相比原有位置每行每列都各新增了 1，所以最后的求解表达式就是prefix[r2+1][c2+1] - prefix[r2+1][c1] - prefix[r1][c2+1] + prefix[r1][c1]。\ntype NumMatrix struct { prefix [][]int } func Constructor(matrix [][]int) NumMatrix { m,n := len(matrix), len(matrix[0]) prefix := make([][]int, m+1) for idx, _ := range prefix { prefix[idx] = make([]int, n+1) } for i := 1; i \u0026lt;= m; i++ { for j := 1; j \u0026lt;= n; j++ { prefix[i][j] = prefix[i][j-1] + prefix[i-1][j] - prefix[i-1][j-1] + matrix[i-1][j-1] } } return NumMatrix{prefix} } func (this *NumMatrix) SumRegion(row1 int, col1 int, row2 int, col2 int) int { return (*this).prefix[row2+1][col2+1] - (*this).prefix[row2+1][col1] - (*this).prefix[row1][col2+1] + (*this).prefix[row1][col1] } /** * Your NumMatrix object will be instantiated and called as such: * obj := Constructor(matrix); * param_1 := obj.SumRegion(row1,col1,row2,col2); */ "},{"id":112,"href":"/docs/algs/leetcode/310_minimum_height_trees/","title":"0310. Minimum Height Tree","section":"Leetcode","content":" Description # A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.\nGiven a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h)) are called minimum height trees (MHTs).\nReturn a list of all MHTs\u0026rsquo; root labels. You can return the answer in any order.\nThe height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.\nSolutions # BFS # 题主最先想出的解法就是把每个节点都视作根节点，然后从根节点开始遍历，查找其最长路径长度。提交之后超时了：\nfunc findMinHeightTrees(n int, edges [][]int) []int { res := make(map[int][]int) graph := make(map[int][]int) curMin := math.MaxInt for _, edge := range edges { graph[edge[0]] = append(graph[edge[0]], edge[1]) graph[edge[1]] = append(graph[edge[1]], edge[0]) } for i := 0; i \u0026lt; n; i++ { visited := make([]bool, n) var queue []int = []int{i} var cnt int for len(queue) != 0 { cnt++ if cnt \u0026gt; curMin { break } size := len(queue) for j := 0; j \u0026lt; size; j++ { nodes := graph[queue[j]] for _, node := range nodes { if visited[node] { continue } queue = append(queue, node) } visited[queue[j]] = true } queue = queue[size:] } curMin = min(curMin, cnt) res[cnt] = append(res[cnt], i) } mht := math.MaxInt for cnt, _ := range res { if cnt \u0026lt; mht { mht = cnt } } return res[mht] } func min(a,b int) int { if a \u0026lt; b { return a } return b } 其实不难发现这个题超时的可能性太大了，因为上面的解法把每个节点都作为根节点，然后对以该节点作为根节点的子树进行遍历。\n题主想了好久都没想到解法，发呆发了好久。最后突然觉得这题跟之前做过的一个题目好像（但题主没找到这个题目）。大致解法如下:\n既然是求高度最小的数，那么也就意味着要尽可能缩小树的直径。怎么缩小树的直径呢，当然是每一轮都尽可能减少节点的数量。那么我们可以先统计每个节点的入度，然后统计每个节点可达的节点，因为这是无向图，所以入度要双向统计。然后将入度为 1 的节点入队，开始 BFS。每轮 BFS 都将当前节点可达的节点中将入度减 1，如果该可达节点的入度减为 1 的话，则将该节点加入队列中。那么什么时候停止呢，直到队列中节点数小于等于 2 的时候停止直到 n 的值小于等于 2 停止，此时的 BFS 轮数即为最小高度，而剩下的节点即为根节点。\nfunc findMinHeightTrees(n int, edges [][]int) []int { // n 为 1 时，只有一个节点可以作为根节点 if n == 1 { return []int{0} } graph := make(map[int]map[int]bool, n) for i := 0; i \u0026lt; n; i++ { graph[i] = make(map[int]bool) } // 无向图，双向统计 for _, edge := range edges { // in[edge[1]]++ // 记录从 edge [0] 可以到达哪些节点 graph[edge[0]][edge[1]] = true graph[edge[1]][edge[0]] = true } // 对于叶节点，则入队 var queue []int for i := 0; i \u0026lt; n; i++ { if len(graph[i]) == 1 { queue = append(queue, i) } } // 注意这里是 n \u0026gt; 2， 而不是 len(queue) \u0026gt; 2。 for n \u0026gt; 2 { size := len(queue) n -= size for i := 0; i \u0026lt; size; i++ { // 找到从 queue[i] 可达的所有节点 nodes := graph[queue[i]] for node, _ := range nodes { // 从 queue[i] 可达的所有节点中，删除其与 queue[i] 的关系。删除之后如果变成了叶节点，则将该节点入队 delete(graph[node], queue[i]) if len(graph[node]) == 1 { queue = append(queue, node) } } } queue = queue[size:] } return queue } "},{"id":113,"href":"/docs/algs/leetcode/313_super_ugly_number/","title":"0313. Super Ugly Number","section":"Leetcode","content":" Description # A super ugly number is a positive integer whose prime factors are in the array primes.\nGiven an integer n and an array of integers primes, return the nth super ugly number.\nThe nth super ugly number is guaranteed to fit in a 32-bit signed integer.\nSolutions # K Pointer # 这个题可以用第 264 题的解法来解。区别是，第 264 题中我们只有三个因子，但是这里的因子是不固定的，那么我们只需要使用一个 map 来充当 264 题中的多指针即可。\n关于为什么使用多指针就可以，这里参见一个 LeetCode 上的 回答:\n这道题一开始死活不明白三指针到底是怎么用的。后来突然就想明白了：\n例如 n = 10， primes = [2, 3, 5]。 打印出丑数列表：1, 2, 3, 4, 5, 6, 8, 9, 10, 12 首先一定要知道，后面的丑数一定由前面的丑数乘以2，或者乘以3，或者乘以5得来。例如，8,9,10,12一定是1, 2, 3, 4, 5, 6乘以2,3,5三个质数中的某一个得到。\n这样的话我们的解题思路就是：从第一个丑数开始，一个个数丑数，并确保数出来的丑数是递增的，直到数到第n个丑数，得到答案。那么问题就是如何递增地数丑数？\n观察上面的例子，假如我们用1, 2, 3, 4, 5, 6去形成后面的丑数，我们可以将1, 2, 3, 4, 5, 6分别乘以2, 3, 5，这样得到一共6*3=18个新丑数。也就是说1, 2, 3, 4, 5, 6中的每一个丑数都有一次机会与2相乘，一次机会与3相乘，一次机会与5相乘（一共有18次机会形成18个新丑数），来得到更大的一个丑数。\n这样就可以用三个指针，\npointer2, 指向1, 2, 3, 4, 5, 6中，还没使用乘2机会的丑数的位置。该指针的前一位已经使用完了乘以2的机会。 pointer3, 指向1, 2, 3, 4, 5, 6中，还没使用乘3机会的丑数的位置。该指针的前一位已经使用完了乘以3的机会。 pointer5, 指向1, 2, 3, 4, 5, 6中，还没使用乘5机会的丑数的位置。该指针的前一位已经使用完了乘以5的机会。 下一次寻找丑数时，则对这三个位置分别尝试使用一次乘2机会，乘3机会，乘5机会，看看哪个最小，最小的那个就是下一个丑数。最后，那个得到下一个丑数的指针位置加一，因为它对应的那次乘法使用完了。\n这里需要注意下去重的问题，如果某次寻找丑数，找到了下一个丑数10，则pointer2和pointer5都需要加一，因为5乘2等于10， 5乘2也等于10，这样可以确保10只被数一次。\n所以其实核心就是：\n每个丑数都是前面的丑数乘以因子得到的 每个丑数都有一次乘以所有因子的机会，一旦一个丑数乘以一个因子并且乘积被我们使用了，那么这个丑数与这个因子相乘的机会就用完了。换句话说，对应的这个因子的指针就应该后移。 func nthSuperUglyNumber(n int, primes []int) int { res := make([]int, n) res[0] = 1 // 记录每个指针的初始位置 dict := make(map[int]int, len(primes)) for _, prime := range primes { dict[prime] = 0 } var idx int for i := 1; i \u0026lt; n; i++ { r := selectMin(idx, res, dict) idx++ res[idx] = r // 将相应位置的下标指针后移 for prime, index := range dict { // 注意这里是 res[index] * prime if r == res[index] * prime { dict[prime]++ } } } return res[n-1] } // 选出一个最小的 func selectMin(idx int, res []int, dict map[int]int) int { // 这里注意 r 的初始化值，不能初始化为 0 r := math.MaxInt for prime, index := range dict { r = min(r, prime*res[index]) } return r } func min(a,b int) int { if a \u0026lt; b { return a } return b } "},{"id":114,"href":"/docs/algs/leetcode/314_binary_tree_vertical_order_traversal/","title":"0314. Binary Tree Vertical Order Traversal","section":"Leetcode","content":" Description # Given a binary tree, return the vertical order traversal of its nodes\u0026rsquo; values. (ie, from top to bottom, column by column).\nIf two nodes are in the same row and column, the order should be from left to right.\nSolutions # Level Order Traversal # 这里可以隐约看出来是要使用层序遍历，但是与一般的层序遍历的稍微有点不同。这里的主要思想是：对每个节点赋予一个值 col，然后对于其左节点，col 减 1，对于右节点， col 加 1。这样的话，同一列的节点都会有同一个值 col。在入队的时候，不仅需要将节点入队，还需要将节点的 row 入队，二者可以组成一个 pair。\nfunc vericalOrder(root *TreeNode) [][]int { if root == nil { return nil } var res [][]int type pair struct { Node *TreeNode Col int } // 层序遍历需要用到的队列 var queue []pair // 记录每个 col 上有哪些节点 dict := make(map[int]*TreeNode) queue = append(queue, pair{root, 0}) for len(queue) != 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { p := queue[0] queue = queue[1:] dict[p.Col] = append(dict[p.Col], p.Node) if p.Node.Left != nil { queue = append(queue, pair{p.Node.Left, p.Val - 1}) } if p.Node.Right != nil { queue = append(queue, pair{p.Node.Right, p.Val + 1}) } } queue = queue[size:] } // golang 的 map 不会根据 key 进行排序，所以需要手动进行排序 var keys []int for key, _ := range dict { keys = append(keys, key) } sort.Ints(keys) for _, key := range keys { nodes := dict[key] var level []int for _, node := range nodes { level = append(level, node.Val) } res = append(res, level) } return res } "},{"id":115,"href":"/docs/algs/leetcode/318_maximum_product_of_word_lengths/","title":"0318. Maximum Product of Word Lengths","section":"Leetcode","content":" Description # Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0.\nSolutions # \\( \\Omicron (n^2) \\) 的解法，相当于暴力求解了，因为限定了字符串中只会出现小写字符，而小写字符只有 26 个，那么就可以一个 32 位的 int 值 mask 来记录每个字符是否出现过，然后不同字符的 mask 之间进行相与，如果与的结果为 0，说明这两个字符没有重叠字符，那么就更新结果。\nfunc maxProduct(words []string) int { var res int size := len(words) dict := make(map[int]int, size) for i := 0; i \u0026lt; size; i++ { for _, r := range words[i] { dict[i] |= 1 \u0026lt;\u0026lt; (int(r) - int(\u0026#39;a\u0026#39;)) } for j := 0; j \u0026lt; i; j++ { if (dict[i] \u0026amp; dict[j]) == 0 { res = max(res, len(words[i]) * len(words[j])) } } } return res } func max(a,b int) int { if a \u0026lt; b { return b } return a } "},{"id":116,"href":"/docs/algs/leetcode/328_odd_even_linked_list/","title":"0328. Odd Even Linked List","section":"Leetcode","content":" Description # Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.\nThe first node is considered odd, and the second node is even, and so on.\nNote that the relative order inside both the even and odd groups should remain as it was in the input.\nYou must solve the problem in O(1) extra space complexity and O(n) time complexity.\nSolutions # 双指针。使用两个奇偶指针分别指向奇偶节点的起始位置，另外需要一个单独的指针 even_head 保存偶节点的起点位置。然后把奇节点的下一个位置指向偶节点的下一个位置（必然是奇节点），奇节点指针后移一步；再把偶节点的下一个位置指向奇节点的下一个问题（必然是偶节点），然后偶节点后移一步。最后把分开的偶节点连在奇节点后即可。\nfunc oddEvenList(head *ListNode) *ListNode { // corner case if head == nil || head.Next == nil || head.Next.Next == nil { return head } // 奇偶链表尾结点 odd, even := head, head.Next // even_head 指向偶链表起始节点 even_head := even // 注意这里的结束条件 for even != nil \u0026amp;\u0026amp; even.Next != nil { // 奇链表的下一个是偶链表尾结点的下一个 odd.Next = even.Next // 奇链表尾结点后移 odd = even.Next // 偶链表的下一个是奇链表尾结点的下一个 even.Next = odd.Next // 偶链表尾结点后移 even = odd.Next } // 把偶链表链接到奇链表后面 odd.Next = even_head return head } "},{"id":117,"href":"/docs/algs/leetcode/346_moving_average_from_data_stream/","title":"0346. Moving Average from Data Stream","section":"Leetcode","content":" Description # Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.\nExample: \u0026rsquo;\u0026rsquo;\u0026rsquo; MovingAverage m = new MovingAverage(3); m.next(1) = 1 m.next(10) = (1 + 10) / 2 m.next(3) = (1 + 10 + 3) / 3 m.next(5) = (10 + 3 + 5) / 3 \u0026rsquo;''\nSolutions # 很明显是使用队列啦。\ntype MovingAverage struct { nums []int size int sum int } /** Initialize your data structure here. */ func Constructor(size int) MovingAverage { return MovingAverage{nums: []int{}, size: size, sum: 0} } func (this *MovingAverage) Next(val int) float64 { if this.size \u0026lt; 3 { *this.nums = append(*this.nums, val) sum += val this.size++ } else { num := (*this).nums[0] *this.nums = (*this).nums[1:] sum -= num *this.nums = append(*this.nums, val) sum += val } return float64(sum/this.num) } /** * Your MovingAverage object will be instantiated and called as such: * obj := Constructor(size); * param_1 := obj.Next(val); */ "},{"id":118,"href":"/docs/algs/leetcode/347_top_k_frequent_elements/","title":"0347. Top K Frequent Elements","section":"Leetcode","content":" Description # Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.\nSolutions # Hash Table \u0026amp; Sort # 这里首先使用 map 来统计每个元素出现的次数，然后将元素和其出现的次数组成一个 pair 对，根据每个 pair 对的元素出现次数对 pair 对进行排序，最后取前 k 个即可。\nfunc topKFrequent(nums []int, k int) []int { dict := make(map[int]int) for _, num := range nums { dict[num]++ } type Pair struct { num int cnt int } var pairs []Pair for key, cnt := range dict { pairs = append(pairs, Pair{key, cnt}) } sort.Slice(pairs, func(i,j int) bool { return pairs[i].cnt \u0026gt; pairs[j].cnt }) var res []int for i := 0; i \u0026lt; k; i++ { res = append(res, pairs[i].num) } return res } Hash Table \u0026amp; Min Heap # 还是先对数组中元素的出现次数进行统计，然后将每个元素以及该元素出现的次数作为 pair 对插入最大堆中，最后只需要最大堆的前 k 个元素即可。\nfunc topKFrequent(nums []int, k int) []int { var res []int m := make(map[int]int) for _, value := range nums { m[value] += 1 } var maxHeap CustomizedMaxHeap heap.Init(\u0026amp;maxHeap) for num, count := range m { heap.Push(\u0026amp;maxHeap, []int{count, num}) } for i := 0; i \u0026lt; k; i++ { ele := heap.Pop(\u0026amp;maxHeap).([]int) res = append(res, ele[1]) } return res } // 自定义堆 type CustomizedMaxHeap [][]int func (h CustomizedMaxHeap) Len() int { return len(h) } func (h CustomizedMaxHeap) Less(i,j int) bool { return h[i][0] \u0026gt; h[j][0] } func (h CustomizedMaxHeap) Swap(i,j int) { h[i], h[j]= h[j], h[i] } func (h *CustomizedMaxHeap) Push(x interface{}) { *h = append(*h, x.([]int)) } func (h *CustomizedMaxHeap) Pop() interface{} { size := len(*h) res := (*h)[size-1] *h = (*h)[:size-1] return res } "},{"id":119,"href":"/docs/algs/leetcode/349_intersection_of_two_arrays/","title":"0349. Intersection of Two Arrays","section":"Leetcode","content":" Description # Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.\nSolutoins # 简单题，只需要使用 map 即可。\nfunc intersection(nums1 []int, nums2 []int) []int { d1,d2 := make(map[int]int), make(map[int]int) for _, num := range nums1 { d1[num]++ } for _, num := range nums2 { d2[num]++ } var res []int for key, _ := range d1 { if _, ok := d2[key]; ok { res = append(res, key) } } return res } "},{"id":120,"href":"/docs/algs/leetcode/350_intersection_of_two_arrays_ii/","title":"0350. Intersection of Two Arrays II","section":"Leetcode","content":" Description # Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.\nSolutions # 这里跟 349 题的区别是，一个元素可能会出现多次，所以我们在统计完两个书中的元素的出现次数之后，需要确定把该元素放几次到结果数组中，那么需要放几次呢？这个次数应该跟该元素在两个数组中出现的最小次数相等。\nfunc intersect(nums1 []int, nums2 []int) []int { d1,d2 := make(map[int]int), make(map[int]int) for _, num := range nums1 { d1[num]++ } for _, num := range nums2 { d2[num]++ } var res []int for key, value := range d1 { if cnt, ok := d2[key]; ok { m := min(cnt, value) for i := 0; i \u0026lt; m; i++ { res = append(res, key) } } } return res } func min(a,b int) int { if a \u0026lt; b { return a } return b } "},{"id":121,"href":"/docs/algs/leetcode/354_russian_doll_envelopes/","title":"0354. Russian Doll Envelopes","section":"Leetcode","content":" Description # You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.\nOne envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope\u0026rsquo;s width and height.\nReturn the maximum number of envelopes you can Russian doll (i.e., put one inside the other).\nNote: You cannot rotate an envelope.\nSolutions # 这题的直白翻译就是“俄罗斯套娃，问最多能套几个”。题主想出了一个 \\( \\Omicron(n^2) \\) 的DP 解法，奈何时间复杂度太高，死在最后几个测试用例上了。基本思路就是，先给信封根据宽度从小到大排一下序，然后创建一个 dp 数组，因为最少也能够装一个，所以 dp 数组的每个位置都先初始化为 1；然后从下标 1 开始遍历信封数组，对于每个 envelopes[i]，找出其当前能够装的最多的信封数，然后继续往后遍历。怎么找呢，对于每个信封 i，又新开一个从 0 到 i-1 的循环 j，然后比较信封 i 和信封 j 的宽度和长度，如果 i 能够装得下 j，那么就更新 \\( dp[i] = max(dp[i], dp[i-j]\u0026#43;1) \\) ，这里需要注意遍历的方向，一定是需要先从 0 到 i-1 的。先贴一下代码：\nfunc maxEnvelopes(envelopes [][]int) int { //corner case size := len(envelopes) if size \u0026lt;= 1 { return size } res := 1 sort.Slice(envelopes, func(i,j int) bool { return envelopes[i][0] \u0026lt; envelopes[j][0] }) dp := make([]int, size) for i := 0; i \u0026lt; size; i++ { dp[i] = 1 } for i := 1; i \u0026lt; size; i++ { for j := i; j \u0026gt; 0; j-- { if envelopes[i][0] \u0026gt; envelopes[i-j][0] \u0026amp;\u0026amp; envelopes[i][1] \u0026gt; envelopes[i-j][1] { dp[i] = max(dp[i], dp[i-j] + 1) res = max(res, dp[i]) } } } return res } func max(a,b int) int { if a \u0026lt; b { return b } return a } "},{"id":122,"href":"/docs/algs/leetcode/362_design_hit_counter/","title":"0362. Design Hit Counter","section":"Leetcode","content":" Description # Design a hit counter which counts the number of hits received in the past 5 minutes.\nEach function accepts a timestamp parameter (in seconds granularity) and you may assume that calls are being made to the system in chronological order (ie, the timestamp is monotonically increasing). You may assume that the earliest timestamp starts at 1.\nIt is possible that several hits arrive roughly at the same time.\nSolutions # 简单，使用队列即可。没产生一次 hit，检查队尾元素是否比当前 hit 的 second 要小，如果小，就把 second 入队，同时检查对首元素是否比 second - 300 要大，如果不是，则将这些元素出队即可。\ntype HitCounter struct { queue []int } func Constructor() HitCounter{ return HitCounter{queue: []int{}} } func (this *HitCounter) Hit(second int) { size := this.Len() if size == 0 { (*this).queue = append(*this.queue, second) return } else { tail := (*this).queue[size-1] if second \u0026lt;= tail { return } var i int for i \u0026lt; size { if (*this).queue[i] \u0026lt; second - 300 { i++ continue } break } (*this).queue = (*this).queue[i:] (*this).queue = append(*this.queue, val) } } func (this *HitCounter) Len() int { return len(*this.queue) } func (this *HitCounter) GetHits(second int) int { return this.Len() } "},{"id":123,"href":"/docs/algs/leetcode/367_valid_perfect_square/","title":"0362. Design Hit Counter","section":"Leetcode","content":" Description # Given a positive integer num, write a function which returns True if num is a perfect square else False.\nFollow up: Do not use any built-in library function such as sqrt.\nSolutions # Binary Search # 这里跟 69 题其实是完全一样的解法，需要注意的是，在开始的时候去除掉一些 corner case 能够让后面的整体逻辑更清晰一些。\nfunc isPerfectSquare(num int) bool { if num \u0026lt;= 1 { return true } left, right := 0, num for left \u0026lt; right { mid := left + (right - left)/2 res := mid * mid if res == num { return true } if res \u0026gt; num { right = mid } else { left = mid + 1 } } return false } "},{"id":124,"href":"/docs/algs/leetcode/366_find_leaves_of_binary_tree/","title":"0366. Find Leaves of Binary Tree","section":"Leetcode","content":" Description # Given a binary tree, collect a tree\u0026rsquo;s nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty.\nExample:\nInput: [1,2,3,4,5]\n1 / \\ 2 3 / \\ 4 5 Output: [[4,5,3],[2],[1]]\nSolutions # BFS # 这个题要求，每次都把叶节点给出调，然后再剩下的树中再把叶节点除掉，重复上述过程直到数中没有节点为止。仔细观察一下，你会发现，每次除掉的都是出度为 0 的节点。反过来说，如果你将这个树视作一个以叶节点为出发点的图，那么这个问题就会变成一个拓扑排序题。如果你能这么想，那问题也就很简单了。首先先将这个树视作一个以叶节点为出发点、以根节点为结束点的的有向图，然后统计每个节点的入度，每次把入度为 0 的节点放到数组中，然后将从该节点可达的节点的入度减去 1.循环上述过程即可，典型的拓扑排序问题。\n同样是上面的思路，但是可以不把这个图视作有向图，可以视作无向图，然后对无向图的每个节点统计出入度，上面的入度为 0 的条件可以替换为入度为 1 。\nGolang 本身没有 set， 确实很让人蛋疼。\nfunc findLeaves(root *TreeNode) [][]int { if root == nil { return nil } // 将树视为无向图，从根节点开始进行 BFS，对于每条边，统计两个节点的入度。 // 然后将入度为 1 的节点入队(因为无向图入度为 1 表示该节点为叶节点)，开始进行无向图的拓扑排序。 degree := make(map[int]map[int]bool) var queue []*TreeNode queue = append(queue, root) for len(queue) != 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[i] if _, ok := degree[node]; !ok { degree[node.Val] = make(map[int]bool) } if node.Left != nil { if _, ok := degree[node.Left.Val]; !ok { degree[node.Left.Val] = make(map[int]bool) } degree[node.Val][node.Left.Val] = true degree[node.Left.Val][node.Val] = true queue = append(queue, node.Left) } if node.Right != nil { if _, ok := degree[node.Right.Val]; !ok { degree[node.Right.Val] = make(map[int]bool) } degree[node.Val][node.Right.Val] = true degree[node.Right.Val][node.Val] = true queue = append(queue, node.Right) } } queue = queue[size:] } // 将入度为 1 的节点放入队列（这些入度为 1 的节点其实就是叶节点），再次开始 BFS var arr []int for key, peer := range degree { if len(peer) == 1 { arr = append(arr, key) } } // 再次开始 BFS， 每次在队列中的节点就是叶节点 var res [][]int for len(arr) != 0 { var level []int size := len(arr) for i := 0; i \u0026lt; size; i++ { nodes := degree[arr[i]] level = append(level, arr[i]) for node, _ := range nodes { delete(degree[node], queue[i]) if len(degree[node]) == 1 { queue = append(queue, node) } } } res = append(res, level) arr = arr[size:] } return res } "},{"id":125,"href":"/docs/algs/leetcode/378_kth_smallest_element_in_a_sorted_matrix/","title":"0378. Kth Smallest Element in a Sorted Matrix","section":"Leetcode","content":" Description # Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix.\nNote that it is the kth smallest element in the sorted order, not the kth distinct element.\nYou must find a solution with a memory complexity better than \\( \\Omicron(n^2) \\) Solutions # 这里可以使用最小堆，遍历矩阵，不断往堆中加入元素，遍历完之后，取堆中第 k 个元素就可。或者使用一个大小为 k 的最大堆，当堆中元素数量不足 k 时，将元素入堆，当堆中元素比 k 大时，将堆顶元素出堆即可。\nimport \u0026#34;container/heap\u0026#34; func kthSmallest(matrix [][]int, k int) int { var maxHeap MinHeap heap.Init(\u0026amp;maxHeap) m, n := len(matrix), len(matrix[0]) for i := 0; i \u0026lt; m; i++ { for j := 0; j \u0026lt; n; j++ { heap.Push(\u0026amp;maxHeap, matrix[i][j]) } } var res int for i := 0; i \u0026lt; k; i++ { res = heap.Pop(\u0026amp;maxHeap).(int) } return res } type MinHeap []int func (m MinHeap) Len() int { return len(m) } func (m MinHeap) Swap(i, j int) { m[i], m[j] = m[j], m[i] } // 这里控制是构造最小堆还是最大堆，如果使用 \u0026lt; 的话，构造的就是最小堆 func (m MinHeap) Less(i,j int) bool { return m[i] \u0026lt; m[j] } func (m *MinHeap) Push(x interface{}) { *m = append(*m, x.(int)) } // 这里永远应该弹出的是最后一个元素 func (m *MinHeap) Pop() interface{} { x := (*m)[m.Len()-1] *m = (*m)[:m.Len()-1] return x } "},{"id":126,"href":"/docs/algs/leetcode/380_insert_delete_getrandom_O1/","title":"0380. Insert Delete GetRandom O(1)","section":"Leetcode","content":" Description # Implement the RandomizedSet class:\nRandomizedSet() Initializes the RandomizedSet object. bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise. bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise. int getRandom() Returns a random element from the current set of elements (it\u0026rsquo;s guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned. You must implement the functions of the class such that each function works in average O(1) time complexity. Solutions # Hash Table \u0026amp; Array # 这里使用一个 Hash Table 和一个数组，Hash Table 存储的是值和该值在数组中的下标。这里稍微有点 tricky 的是，删除的时候，不是直接在 Hash Table 中删除该元素，而是在数组中将该元素和尾元素调换位置，然后删除尾元素。 这样所有操作都能达到 \\( \\Omicron(1) \\) 的时间复杂度。\nimport \u0026#34;math/rand\u0026#34; type RandomizedSet struct { dict map[int]int nums []int } func Constructor() RandomizedSet { return RandomizedSet{dict: make(map[int]int), nums: []int{}} } func (this *RandomizedSet) Insert(val int) bool { var present bool if _, ok := (*this).dict[val]; !ok { present = true size := len((*this).nums) (*this).nums = append((*this).nums, val) (*this).dict[val] = size } return present } func (this *RandomizedSet) Remove(val int) bool { var present bool if idx, ok := (*this).dict[val]; ok { present = true // 将待删除元素和最后一个元素交换，这样的话只需要删除最后一个元素即可，Remove 和 getRandom 都能达到 O(1) 的时间复杂度 size := len((*this).dict) (*this).dict[(*this).nums[size-1]] = idx (*this).nums[size-1], (*this).nums[idx] = (*this).nums[idx], (*this).nums[size-1] (*this).nums = (*this).nums[:size-1] delete((*this).dict, val) // 下面的删除办法起始是不对的，下面的删除只有当待删除元素是数组中最后一个元素才正确； // 否则的话，在数组中删除元素之后，dict 中存储的下标是错误的下标。因为删除中间元素会导致该元素之后的元素的下标前移 1 // idx := (*this).dict[val] // (*this).nums = append((*this).nums[:idx], (*this).nums[idx+1:]...) // delete((*this).dict, val) } return present } func (this *RandomizedSet) GetRandom() int { size := len((*this).nums) target := rand.Intn(size) return (*this).nums[target] } /** * Your RandomizedSet object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.Insert(val); * param_2 := obj.Remove(val); * param_3 := obj.GetRandom(); */ Hash Table # 这里是直接使用 Hash Table 的解法，虽然可以通过 OJ，但是 getRandom 的时间复杂度并不是 \\( \\Omicron(1) \\) 。\nimport \u0026#34;math/rand\u0026#34; type RandomizedSet struct { nums map[int]bool } func Constructor() RandomizedSet { return RandomizedSet{make(map[int]bool)} } func (this *RandomizedSet) Insert(val int) bool { var present bool if _, ok := (*this).nums[val]; !ok { present = true (*this).nums[val] = true } return present } func (this *RandomizedSet) Remove(val int) bool { var present bool if _, ok := (*this).nums[val]; ok { present = true delete((*this).nums, val) } return present } func (this *RandomizedSet) GetRandom() int { size := len((*this).nums) target := rand.Intn(size) var cur,res int for key,_ := range (*this).nums { if cur == target { res = key break } cur++ } return res } Double LinkedList # 下面是使用双向链表的解法，也可以通过 OJ，但是 getRandom 函数的时间复杂度也不符合要求。\nimport \u0026#34;math/rand\u0026#34; type Node struct { Val int Next *Node Pre *Node } type RandomizedSet struct { dict map[int]*Node head *Node tail *Node } func(this *RandomizedSet) AddToHead(node *Node) { node.Next = this.head.Next this.head.Next.Pre = node this.head.Next = node node.Pre = this.head } func (this *RandomizedSet) RemoveNode(node *Node) { node.Pre.Next = node.Next node.Next.Pre = node.Pre } func Constructor() RandomizedSet { head,tail := new(Node), new(Node) head.Next, tail.Pre = tail, head return RandomizedSet{dict: make(map[int]*Node), head: head, tail: tail} } func (this *RandomizedSet) Insert(val int) bool { var present bool if _, ok := (*this).dict[val]; !ok { present = true node := new(Node) node.Val = val this.AddToHead(node) (*this).dict[val] = node } return present } func (this *RandomizedSet) Remove(val int) bool { var present bool if node, ok := (*this).dict[val]; ok { present = true delete((*this).dict, val) this.RemoveNode(node) } return present } func (this *RandomizedSet) GetRandom() int { size := len((*this).dict) target := rand.Intn(size) + 1 cur := this.head var cnt,res int for cnt != target { cur = cur.Next cnt++ if cnt == target { res = cur.Val break } } return res } /** * Your RandomizedSet object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.Insert(val); * param_2 := obj.Remove(val); * param_3 := obj.GetRandom(); */ "},{"id":127,"href":"/docs/algs/codingInterviews/04_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/","title":"04. 二维数组中的查找","section":"Coding Interviews","content":" Description # 在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n数据范围：矩阵的长宽满足 \\($0 \\le n$\\) , \\($m \\le 500$\\) ， 矩阵中的值满足 \\($0 \\le val \\le 10^9$\\) 。\n进阶：空间复杂度 O(1)O(1) ，时间复杂度 O(n+m)O(n+m)\nSolutions # 从左下角开始进行遍历，因为数组维持了从左到右递增，从上到下递增的性质，那么如果当前元素比 target 要大， target 一定位于当前元素的右边；如果当前元素比 target 要小，那么 target 一定位于当前元素的上侧。\nfunc Find( target int , array [][]int ) bool { // write code here var res bool m, n := len(array), len(array[0]) x, y := m-1, 0 for { if x \u0026lt; 0 || y \u0026gt;= n { break } if array[x][y] == target { res = true break } if target \u0026gt; array[x][y] { y++ } // 这里要加上一个 y \u0026lt; n, 因为上一个 if 对 y 进行了自增，导致这里的 y 不一定合法 if y \u0026lt; n \u0026amp;\u0026amp; target \u0026lt; array[x][y] { x-- } } return res } "},{"id":128,"href":"/docs/algs/leetcode/409_longest_palindrome/","title":"0409. Longest Palindrome","section":"Leetcode","content":" Description # Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.\nLetters are case sensitive, for example, \u0026ldquo;Aa\u0026rdquo; is not considered a palindrome here.\nSolutions # Hash Table # 回文串有两种形式，一种是xxyy，另一种是xxyzz，也就是说，两边的字符需要出现偶数次，那么这里就可以转换为统计出现偶数次的字符的数量。在统计的过程中，如果发现有一个字符出现了奇数次，那么这个奇数次的字符就可以放在回文串的中心，那么就需要记录一下，最后在结果上加上 1.\nfunc longestPalindrome(s string) int { // 统计每个字符出现的次数 size := len(s) dict := make(map[byte]int) for i := 0; i \u0026lt; size; i++ { dict[s[i]]++ } var res int var addMid bool for _, num := range dict { res += num // 如果出现了奇数次，那么只取最大的偶数，也就是要减去 1 // 如果只是出现了一次的话，那么这里相当于没有加 if num % 2 == 1 { res -= 1 // 回文串有两种类型，一种是中间一个字符然后两边对称的形式， // 也就是说，如果有一个字符出现了奇数次，那么最后可以考虑把这个字符加上。 addMid = true } } if addMid { res += 1 } return res } "},{"id":129,"href":"/docs/algs/leetcode/417_pacific_atlantic_water_flow/","title":"0417. Pacific Atlantic Water Flow","section":"Leetcode","content":" Description # There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island\u0026rsquo;s left and top edges, and the Atlantic Ocean touches the island\u0026rsquo;s right and bottom edges.\nThe island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).\nThe island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell\u0026rsquo;s height is less than or equal to the current cell\u0026rsquo;s height. Water can flow from any cell adjacent to an ocean into the ocean.\nReturn a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.\nSolutions # 应该很容易就可以看出来，其实这是图搜索问题。\n解决方法是，对于图中的每一个点进行遍历，检查这个点是否能够有到达太平洋的路径以及到达大西洋的路径。如果两边都能够到达，则说明这个点就是我们要求的结果之一。 但是上述方法可能会导致很大的计算量，首先我们可以使用 DFS 的优化算法来进行遍历，其次的话我们还可以换一种思路来实现。\n由于直接搜索会导致大量的计算，而我们所要的结果路径必然是要以边缘点为最后节点的，那么我们可以从边缘点为开始节点进行搜索。分别创建两个二维数组，表示太平洋和大西洋。 然后对边缘进行 DFS，对于符合要求的点，将该数组对应点设置为 true，最后的结果就是两个数组均为 true 的节点。\nfunc pacificAtlantic(heights [][]int) [][]int { // 创建两个数组，分别代表从太平洋边缘出发能到达的点和从大西洋边缘出发能到达的点 rows, cols := len(heights), len(heights[0]) pacific, atlantic := make([][]bool, rows), make([][]bool, rows) for i := 0; i \u0026lt; rows; i++ { pacific[i] = make([]bool, cols) atlantic[i] = make([]bool, cols) } // 从边缘开始遍历，将所有能从太平洋边缘到达的点设置为 true，将所有能从大西洋边缘到达的点设置为 true // 到达意味着当前点的值要比前一个点要大。注意初始的 pre 要设置为最小值 for i := 0; i \u0026lt; rows; i++ { dfs(heights, pacific, math.MinInt, i, 0, rows, cols) dfs(heights, atlantic, math.MinInt, i, cols - 1, rows, cols) } for i := 0; i \u0026lt; cols; i++ { dfs(heights, pacific, math.MinInt, 0, i, rows, cols) dfs(heights, atlantic, math.MinInt, rows-1, i, rows, cols) } // 从两大洋都能到达的点，才是我们要的结果 var res [][]int for i := 0; i \u0026lt; rows; i++ { for j := 0; j \u0026lt; cols; j++ { if pacific[i][j] \u0026amp;\u0026amp; atlantic[i][j] { res = append(res, []int{i, j}) } } } return res } func dfs(heights [][]int, visited [][]bool, pre, curRow, curCol, rows, cols int) { // 对于越界的点，对于已经遍历过的点，对于当前值比前一个值要小的点，都需要再进行遍历 if curRow \u0026lt; 0 || curRow \u0026gt;= rows || curCol \u0026lt; 0 || curCol \u0026gt;= cols || visited[curRow][curCol] || heights[curRow][curCol] \u0026lt; pre { return } // 标记当前点已经遍历过，并开始遍历当前节点四周 visited[curRow][curCol] = true dfs(heights, visited, heights[curRow][curCol], curRow + 1, curCol, rows, cols) dfs(heights, visited, heights[curRow][curCol], curRow - 1, curCol, rows, cols) dfs(heights, visited, heights[curRow][curCol], curRow, curCol + 1, rows, cols) dfs(heights, visited, heights[curRow][curCol], curRow, curCol - 1, rows, cols) } "},{"id":130,"href":"/docs/algs/leetcode/424_longest_repeating_character_replacement/","title":"0424. Longest Repeating Character Replacement","section":"Leetcode","content":" Description # You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.\nSolutions # Sliding Window # 这个题题主又不会了，在网上看到可以使用滑动窗口来解。假设没有 k 的限制，也就是说可以替换任意多次，把一个字符串变为只有只有一个字符重复的字符串需要的最少置换次数是多少呢？其实就是扫描一遍字符串，记录出现次数最多的字符串的出现个数k，然后用总长度减去 k ，所得值即为最少置换次数。\n而如果带上了 k，那么就要满足: 子字符串的长度减去该子字符串中出现次数最多的字符的长度要小于等于 k。具体做法：\n使用一个变量 start 记录滑动窗口左边界，然后遍历字符串，记录每个单词的出现次数。 然后判断是否满足上面所说的那个条件，如果不满足，则前移 start，同时还需要注意减去该字符的出现次数，直到满足上面所说的条件，然后更新 res 即可。 需要注意的是，当滑动窗口的左边界向右移动了后，并不需要更新 maxCnt 的值。原因在于既然我们求的是最大值，那么既然此次已经出现了 maxCnt，那么后续我们只会希望出现比 maxCnt 更大的值，所以更新 maxCnt 没有意义。maxCnt 表示子字符串中出现次数最多的字符的出现个数。 func characterReplacement(s string, k int) int { var res, start, maxCnt int size := len(s) m := make(map[byte]int, 26) for i := 0; i \u0026lt; size; i++ { // 记录每个字符的出现次数 m[s[i]] += 1 // 更新子串中出现次数最多的字符的出现个数 maxCnt = max(maxCnt, m[s[i]]) for i-start+1-maxCnt \u0026gt; k { // 子字符串的长度减去该子字符串中出现次数最多的字符的长度要小于等于 k m[s[start]] -= 1 start += 1 } res = max(res, i-start+1) } return res } "},{"id":131,"href":"/docs/algs/leetcode/453_minimum_moves_to_equal_array_elements/","title":"0453. Minimum Moves to Equal Array Elements","section":"Leetcode","content":" Description # Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.\nIn one move, you can increment n - 1 elements of the array by 1.\nSolutions # Math # 这题的意思就是，对于一个长度为 n 的数组，每次可以给 n-1 个数组加 1，问最少要多少次，才能让整个数组的数字相等。那这里要给哪些数字加 1 呢？很明显可以想到，每次都需要给最小的 n-1 个数加 1，这也就意味着，每次 move 都需要排序来找出最小的 n - 1 个数。可惜的是，依照上面的思路，是无法通过 OJ 的。\n这里的解法比较 tricky，其实给 n-1 个数字加 1，就等同于给最大的数字减去 1. 那么每次 move 对最小的 n - 1 个数字加 1，就相当于每次 move 对最大的那个数减 1，那么问题也就转化为，求每个数字跟最小数字之间的差值，然后对这写差值进行累加即可。\nfunc minMoves(nums []int) int { var idx,res int // find min for i, _ := range nums { if nums[i] \u0026lt; nums[idx] { idx = i } } // get sum for _, num := range nums { res += num - nums[idx] } return res } "},{"id":132,"href":"/docs/algs/leetcode/454_4sum_ii/","title":"0454. 4 Sum II","section":"Leetcode","content":" Description # Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:\n0 \u0026lt;= i, j, k, l \u0026lt; n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0 Solutions # Hash Table \u0026amp;\u0026amp; Divide # 首先题主肯定是写了一个四重循环，提交上去然后不出意外的超时了（笑。\n然后经过一波搜索，发现可以这么做：这里使用的也算是分治思想，与其直接写一个四重循环，那么我们可以写两个二重循环，这样就可以有效降低时间复杂度。首先使用一个 map 记录 A 数组和 B 数组中每个元素组合之和出现的次数，然后再遍历 C 和 D，求出 C 和 D 当前元素组合的和，然后判断其相反数有没有在 map 中出现，如果出现了，则在结果上加上其出现的次数即可。不得不说，这个解法还是很巧妙的。\nfunc fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int { var res int dict := make(map[int]int) for _, num1 := range nums1 { for _, num2 := range nums2 { dict[num1+num2]++ } } for _, num1 := range nums3 { for _, num2 := range nums4 { if cnt,ok := dict[-num1-num2]; ok { res += cnt } } } return res } "},{"id":133,"href":"/docs/algs/leetcode/462_minimum_moves_to_equal_array_elements/","title":"0462. Minimum Moves to Equal Array Elements","section":"Leetcode","content":" Description # Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.\nIn one move, you can increment or decrement an element of the array by 1.\nTest cases are designed so that the answer will fit in a 32-bit integer.\nSolutions # Math # 这个题题主一开始以为是需要找到离平均数最近的那个数，然后用哪个数作为 target， 求这个数和其它所有数的差值的绝对值，对这些差值累加即可。结果提交之后，只能通过部分 OJ。\nfunc minMoves2(nums []int) int { size := len(nums) if size \u0026lt;= 1 { return 0 } var sum int for _, num := range nums { sum += num } sort.Ints(nums) avg, index := float32(sum) / float32(size), 0 for idx, _ := range nums { if absFloat(float32(nums[idx]) - avg) \u0026lt; absFloat(float32(nums[index]) - avg) { index = idx } } var res int for _, num := range nums { res += absInt(nums[index] - num) } return res } func absFloat(a float32) float32 { if a \u0026lt; 0 { return -a } return a } func absInt(a int) int { if a \u0026lt; 0 { return -a } return a } func min(a,b int) int { if a \u0026lt; b { return a } return b } 题主万万没想到，这里取的锚点是中位数。为什么中位数可以，而平均数就不可以呢？其实在对数组进行排序之后，就可以通过观察发现，要让所有元素相等，那么就需要增大左边的元素，减小右边的元素，直到所有元素相等。也就是说，所有元素需要中间相等，因此使用中位数比平均数更合适。这里可以用两个例子来说明，比如对于 [0,0,0,0,5] 以及 [0,0,0,4] 这两个数组，这二者取平均数作为锚点的话，所需要的 move 远大于取中值作为锚点来得大。也就是说，取均值肯定是不行的。\nfunc minMoves2(nums []int) int { sort.Ints(nums) res, left, right := 0, 0, len(nums) - 1 for left \u0026lt; right { res += nums[right] - nums[left] left++ right-- } return res } "},{"id":134,"href":"/docs/algs/leetcode/474_ones_and_zeroes/","title":"0474. Ones and Zeroes","section":"Leetcode","content":" Description # You are given an array of binary strings strs and two integers m and n.\nReturn the size of the largest subset of strs such that there are at most m 0\u0026rsquo;s and n 1\u0026rsquo;s in the subset.\nA set x is a subset of a set y if all elements of x are also elements of y.\nSolutions # 这里很难想到要用动态规划吧。假设 dp[i][j] 表示一个能包含 i 个 0 和 j 个 1 的子集中的字符串个数。则当扫描到字符串str[i]时，统计其中出现0 位 zeros，1 为 ones。则 \\(dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones]\u0026#43;1)\\) 。\nfunc findMaxForm(strs []string, m int, n int) int { dp := make([][]int, m+1) for idx, _ := range dp { dp[idx] = make([]int, n+1) } for _, str := range strs { zeroes, ones := count(str) // 注意领会这里，也就子问题的方向，应该是从 dp[0][0] 到 dp[zeroes][ones] for i := m; i \u0026gt;= zeroes; i-- { for j := n; j \u0026gt;= ones; j-- { dp[i][j] = max(dp[i][j], dp[i-zeroes][j-ones]+1) } } } return dp[m][n] } func max(a,b int) int { if a \u0026lt; b { return b } return a } func count(str string) (int, int) { var ones, zeroes int for idx, _ := range str { if str[idx] == \u0026#39;0\u0026#39; { zeroes++ } else { ones++ } } return zeroes, ones } "},{"id":135,"href":"/docs/algs/leetcode/485_max_consecutive_ones/","title":"0485. Max Consecutive Ones","section":"Leetcode","content":" Description # Given a binary array nums, return the maximum number of consecutive 1\u0026rsquo;s in the array.\nSolutions # Two Pointers # 这个就是一个简单题啦，使用双指针来做就好了,直接看代码就好。\nfunc findMaxConsecutiveOnes(nums []int) int { res, size, left, right := 0, len(nums), 0, 0 for right \u0026lt; size { // right 一直往右走，直到找到第一个非 1 的数才停下来 for right \u0026lt; size \u0026amp;\u0026amp; nums[right] == 1 { right++ res = max(res, right - left) } // 跳过所有非 1 的数，同时更新 left 指向第一个 1 for right \u0026lt; size \u0026amp;\u0026amp; nums[right] != 1 { right++ left = right } } return res } func max(a,b int) int { if a \u0026lt; b { return b } return a } "},{"id":136,"href":"/docs/algs/leetcode/487_max_consecutive_ones_ii/","title":"0487. Max Consecutive Ones II","section":"Leetcode","content":" Description # Given a binary array, find the maximum number of consecutive 1s in this array if you can flip at most one 0.\nExample 1:\nInput: [1,0,1,1,0] Output: 4 Explanation: Flip the first zero will get the the maximum number of consecutive 1s. After flipping, the maximum number of consecutive 1s is 4.\nNote:\nThe input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000\nFollow up: What if the input numbers come in one by one as an infinite stream? In other words, you can\u0026rsquo;t store all numbers coming from the stream as it\u0026rsquo;s too large to hold in memory. Could you solve it efficiently?\nSolutions # Sliding Window # 这个题就是 1004 题 Max Consecutive Ones III 的具体化，可以直接使用该题的解法来解答。\n可以维护一个窗口 [left,right] 来容纳至少k个0。当遇到了0，就累加 zero 的个数，然后判断如果此时0的个数大于k，则右移左边界left，如果移除掉的 nums[left] 为0，那么 zero 自减1。如果不大于k，则用窗口中数字的个数来更新 res.\nfunc longestOnes(nums []int, k int) int { res, size, left, right, cnt := 0, len(nums), 0, 0, 0 for right \u0026lt; size { // 对 0 计数 if nums[right] == 0 { cnt++ } // 如果 cnt 大于 k 了，那么缩小 left 窗口，如果此时nums[left] 为 0， 则更新 cnt 值 // 注意这里需要让 left 等于 right，因为下面计算 res 的时候加了 1 for left \u0026lt;= right \u0026amp;\u0026amp; cnt \u0026gt; k { if nums[left] == 0 { cnt-- } left++ } // 更新 res 值 res = max(res, right - left + 1) right++ } return res } func max(a,b int) int { if a \u0026lt; b { return b } return a } "},{"id":137,"href":"/docs/algs/leetcode/490_the_maze/","title":"0490. The Maze","section":"Leetcode","content":" Description # There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won\u0026rsquo;t stop rolling until hitting a wall. When the ball stops, it could choose the next direction.\nGiven the ball\u0026rsquo;s start position, the destination and the maze, determine whether the ball could stop at the destination.\nThe maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.\nSolutions # DFS # 这个题与一般的 DFS 题稍微不同的地方在于，这里并不是每次走一步，而是选定方向之后就一直走，直到遇到墙才停下来。但其实也没有变化很多，DFS 模板还是可以套上来用。\n这里需要注意两个点：\n首先，可以直接复用原数组来做标记，表示当前格子是否已经被遍历过。 其次，不需要对每个格子都做标记，实际上，只需要对边界的格子来做标记即可。 var dirs = [][]int{{0,1}, {0, -1}, {1, 0}, {-1, 0}} func hasPath(maze [][]int, start, destination int[]) bool { rows, cols := len(maze), len(maze[0]) return dfs(maze, start[0], start[1], destination[0], destination[1], rows, cols) } func dfs(maze [][]int, starti, startj, destinationi, destinationj, rows, cols int) bool { // 如果可达，直接返回 true if starti == destinationi \u0026amp;\u0026amp; startj == destinationj { return true } var res bool // 直接复用原数组，表示当前点已经遍历过 maze[starti][startj] = -1 for _, dir := range dirs { // 一直往一个方向走，直到越界或者遇到墙壁 x, y := starti, startj for x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; rows \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; cols \u0026amp;\u0026amp; maze[x][y] != -1 { x += dir[0] y += dir[1] } // 上面的循环会导致当前的[x,y]处于非法格子处，所以需要回退一步 x -= dir[0] y -= dir[1] // 当前格子没有遍历过，则以这个格子为起点，又开始往四面八方遍历 // 其实可以看出来，这里会有一次重复遍历。比如当前遍历中你一直往下走，遇到了墙壁， // 那么下一次遍历中你可能就会往上走，然后又回到上一次遍历的起点。 // 但是因为该起点已经被遍历过了，所以已经被标记过，因而不会再走入下面这个递归中 // // 上面说的这个问题，可以将 dirs 换成一个 map，key 为遍历的方向， // 然后在下面的 if 语句中再加一个条件，这样就可以避免往原方向再进行一次遍历 if maze[x][y] != -1 { res |= dfs(maze, x, y, destinationi, destinationj, rows, cols, cols) } } // 放回本次遍历的结果 return res } "},{"id":138,"href":"/docs/algs/codingInterviews/05_%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/","title":"05. 替换空格","section":"Coding Interviews","content":" Description # 请实现一个函数，将一个字符串s中的每个空格替换成“%20”。 例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。\n数据范围: \\($0 \\le len(s) \\le 1000$\\) 。保证字符串中的字符为大写英文字母、小写英文字母和空格中的一种。\nSolutions # func replaceSpace( s string ) string { // write code here var res string size := len(s) if size == 0 { return res } for _, r := range s { if r != \u0026#39; \u0026#39; { res += string(r) } else { res += \u0026#34;%20\u0026#34; } } return res } "},{"id":139,"href":"/docs/algs/leetcode/528_random_pick_with_weight/","title":"0528. Random Pick with Weight","section":"Leetcode","content":" Description # You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith index.\nYou need to implement the function pickIndex(), which randomly picks an index in the range [0, w.length - 1] (inclusive) and returns it. The probability of picking an index i is w[i] / sum(w).\nFor example, if w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.25 (i.e., 25%), and the probability of picking index 1 is 3 / (1 + 3) = 0.75 (i.e., 75%). Solutions # Binary Search # 这里的解法比较巧妙。首先这里每个数字被取到的比例是按照该数字的权重来计算的。比如说对于[1,3,2] 这是三个数字，每个数字取到的比例就是 1/6、3/6、2/6，这样的话，我们就不能按照平常的以下标作为取随机数的范围来计算。这里用到了一个小技巧：既然这里的和是 6，那么我们就以 6 作为 random 的边界，然后取一个随机数，如果取出的数是 0，那么就选第一个数 1；如果取出的数是 1、2、3，那么就取第二个数 3；如果取出的数是 4、5，那么就取第三个数 2。那么，我们就需要计算一个累加数组，并且让累加数组的下标与原数组的下标对应，这样的话只需要查找第一个大于随机数 x 数字的下标即可，该下标即为结果。查找的过程，我们可以使用二分查找来进行。\ntype Solution struct { sums []int } func Constructor(w []int) Solution { sum := w size := len(w) for i := 1; i \u0026lt; size; i++ { sum[i] = sum[i-1] + w[i] } return Solution{sum} } func (this *Solution) PickIndex() int { size := len((*this).sums) r := rand.Intn((*this).sums[size-1]) left, right := 0, size - 1 for left \u0026lt; right { mid := left + (right - left) /2 if (*this).sums[mid] \u0026lt;= r { left = mid + 1 } else { right = mid } } return right } /** * Your Solution object will be instantiated and called as such: * obj := Constructor(w); * param_1 := obj.PickIndex(); */ "},{"id":140,"href":"/docs/algs/leetcode/540_single_element_in_a_sorted_array/","title":"0540. Single Element in a Sorted Array","section":"Leetcode","content":" Description # You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.\nReturn the single element that appears only once.\nYour solution must run in \\(\\Omicron(\\log n) {{ \u0026lt; /katex \u0026gt;}} time and {{ \u0026lt; katex \u0026gt; \\Omicron(1) {{ \u0026lt; /katex \u0026gt; }}} space. ### Bit Manipulation 这个题一眼看到，首先想到的就是使用异或操作，因为异或会导致相同的元素相互抵消为零，所以最后只会剩下哪个只出现一次的元素。 ```go func singleNonDuplicate(nums []int) int { var res int for _, num := range nums { res ^= num } return res } ``` ### Binary Search 这里因为数组有序，并且题目也要求 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;/katex/katex.min.css\u0026#34; /\u0026gt; \u0026lt;script defer src=\u0026#34;/katex/katex.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;/katex/auto-render.min.js\u0026#34; onload=\u0026#34;renderMathInElement(document.body);\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;span\u0026gt; \\( \\Omicron(\\log n) \\) \u0026lt;/span\u0026gt; 的解法，所以可以想到要使用二分来解，但是这里怎么二分呢？这里用到了一个小 trick，我们将坐标两两归为一对，比如 0 和 1 归为一对，2 和 3 归为一对等，那么对应一个下标 i， 我们将 i 异或 1 就可以找到它对应的 peer 的下标。比如对于 0， 异或 1 就是 1，而对于 1，异或 1 就是 0。此时如果该 peer 跟当前数字不相等，那么说明左侧的顺序出现了紊乱，那么就需要向左侧收缩；如果相等的话，说明左侧顺序没问题，那么就需要向右收缩。 ```go func singleNonDuplicate(nums []int) int { size := len(nums) left, right := 0, size -1 for left \u0026lt; right { mid := left \u0026#43; (right - left)/2 // 异或 1 可以找到它对应的 peer 下标，如果二者相等，说明左侧有序，则需要向右收缩； // 如果二者不等，说明左侧无序，需要向左收缩。 if nums[mid] == nums[mid^1] { left = mid \u0026#43; 1 } else { right = mid } } return nums[left] } ```\\) "},{"id":141,"href":"/docs/algs/leetcode/542_01_matrix/","title":"0542. 01 Matrix","section":"Leetcode","content":" Description # Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.\nThe distance between two adjacent cells is 1.\nSolutions # BFS # 这里很容易能够想出 BFS 的解法，然后代码不难写。但是在题主写好并提交之后，在最后一个 case 上超时了，题主一看这个 case 的结构，心想不超时才怪呢\u0026hellip;.\n主要思路就是，如果一个格子是 0，那么该格子的距离肯定是 0。而如果该格子是 1，那么其距离就是对该格子进行 BFS 的距离。超时代码如下：\nvar dirs [][]int = [][]int{{1, 0}, {-1, 0}, {0, 1}, {0, -1}} func updateMatrix(mat [][]int) [][]int { // 初始化结果数组，将每个位置的值都设置为最大值 rows, cols := len(mat), len(mat[0]) res := make([][]int, rows) for idx, _ := range res { arr := make([]int, cols) for i := 0; i \u0026lt; cols; i++ { arr[i] = math.MaxInt } res[idx] = arr } for i := 0; i \u0026lt; rows; i++ { for j := 0; j \u0026lt; cols; j++ { if mat[i][j] == 0 { res[i][j] = 0 } else { res[i][j] = bfs(mat, i, j, rows, cols) } } } return res } func bfs(mat [][]int, curRow, curCol, rows, cols int) int { var queue [][]int var res int queue = append(queue, []int{curRow, curCol}) visited := make([][]bool, rows) for idx, _ := range visited { visited[idx] = make([]bool, cols) } visited[curRow][curCol] = true for len(queue) != 0 { res++ size := len(queue) for i := 0; i \u0026lt; size; i++ { for _, dir := range dirs { x, y := queue[i][0] + dir[0], queue[i][1] + dir[1] if x \u0026lt; 0 || x \u0026gt;= rows || y \u0026lt; 0 || y \u0026gt;= cols || visited[x][y] { continue } if mat[x][y] == 0 { return res } if mat[x][y] == 1 { queue = append(queue, []int{x, y}) } visited[x][y] = true } } queue = queue[size:] } return res } 题主想到的优化方式是，不是从每个值为 1 的格子为起点进行遍历，而是从每个值为 0 的格子为起点进行遍历，但是最后觉得这个方式其实并没有优化多少，这是对最后一个 case 而言是优化，对其它 case 而言可能耗时更长了。\n这是题主在网上看到的优化方法：首先遍历以此数组，将每个值为 0 的点入栈，将值为 1 的点的值都设置为 MaxInt。然后以队列中的点为起点进行遍历，每当遇到边界或者当前当前路径值+1 大于格子当前值的话，则跳过，没有更新该点的必要，否则将周围点的值更新为当前值加 1，然后将周围点的坐标加入队列，然后继续遍历。（题主感觉这里其实也没有优化多少，无非是减少了 BFS 的数量，但是这个解法对最后一个 case 管用\u0026hellip;）。最后 AC 的代码如下：\nvar dirs [][]int = [][]int{{1, 0}, {-1, 0}, {0, 1}, {0, -1}} func updateMatrix(mat [][]int) [][]int { rows, cols := len(mat), len(mat[0]) var queue [][]int for i := 0; i \u0026lt; rows; i++ { for j := 0; j \u0026lt; cols; j++ { // 将每个值为 0 的点都加入到队列中 if mat[i][j] == 0 { queue = append(queue, []int{i, j}) } // 如果值为 1， 则将其设置为 MaxInt if mat[i][j] == 1 { mat[i][j] = math.MaxInt } } } var res int for len(queue) != 0 { res++ size := len(queue) for i := 0; i \u0026lt; size; i++ { for _, dir := range dirs { // 如果越界或者格子值大于当前路径值 res，则跳过，无需更新 x, y := queue[i][0] + dir[0], queue[i][1] + dir[1] if x \u0026gt;= rows || x \u0026lt; 0 || y \u0026gt;= cols || y \u0026lt; 0 || res \u0026gt; mat[x][y] { continue } // 否则，更新格子值，并且将当前格子加入到队列中 mat[x][y] = res queue = append(queue, []int{x, y}) } } // 缩小队列 queue = queue[size:] } return mat } "},{"id":142,"href":"/docs/algs/leetcode/543_diameter_of_binary_tree/","title":"0543. Diameter of Binary Tree","section":"Leetcode","content":" Description # Given the root of a binary tree, return the length of the diameter of the tree.\nThe diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\nThe length of a path between two nodes is represented by the number of edges between them.\nSolutions # Recursive # 这是题主一开始想出来的方法：用一个全局变量 res 代表直径最大值，然后分别当前节点计算左右子树的最大高度，然后比较左右子树再加上当前节点拼起来的树的最大直径与 res 的大小，根据比较结果来更新 res。写得稍微有点复杂。\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func diameterOfBinaryTree(root *TreeNode) int { if root == nil { return 0 } var res int res = max(helper(root, \u0026amp;res), res) return res } func helper(node *TreeNode, res *int) int { // 如果是叶节点或者空节点，那么直径为 0 if node == nil || node.Left == nil \u0026amp;\u0026amp; node.Right == nil { return 0 } // 分别找到左右节点的最大高度 left, right := helper(node.Left, res), helper(node.Right, res) // 如果左右节点中有一个节点是空节点，那么 res 就只需要与其中的非空子节点的高度进行比较 if node.Left == nil || node.Right == nil { *res = max(*res, max(left, right)) } else { // 如果左右节点均非空，那么直径就是左子树的最大高度再加上右子树的最大高度，然后再加上 2。 // 将上述相加的结果与 res 进行比较 *res = max(*res, left+right+2) } // 返回以当前节点为跟的子树的最大高度，其值为左/右子树的最大高度再加上 1 return max(left, right) + 1 } func max(a,b int) int { if a \u0026lt; b { return b } return a } "},{"id":143,"href":"/docs/algs/leetcode/559_maximum_dpeth_of_n-ary_tree/","title":"0559. Maximum Depth of N-ary Tree","section":"Leetcode","content":" Description # Given a n-ary tree, find its maximum depth.\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nNary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).\nSolutions # Iterative # 简单的中序遍历即可。\ntype Node struct { Val int Children []*Node } func maxDepth(root *Node) int { if root == nil { return 0 } var queue []*Node = []*Node{root} var depth int for len(queue) != 0 { depth++ size := len(queue) for i := 0; i \u0026lt; size; i++ { for _, node := range queue[i].Children { if node != nil { queue = append(queue, node) } } } queue = queue[size:] } return depth } "},{"id":144,"href":"/docs/algs/leetcode/560_subarray_sum_equals_k/","title":"0560. Subarray Sum Equals K","section":"Leetcode","content":" Description # Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.\nA subarray is a contiguous non-empty sequence of elements within an array.\nSolutions # Prefix Sum # 这个题可以使用前缀和的技巧来解决。前缀和相关的介绍可以看 这里。\nfunc subarraySum(nums []int, k int) int { var res int size := len(nums) prefix := make([]int, size+1) // 计算前缀和 idx := 1 for _, num := range nums { prefix[idx] = prefix[idx-1] + num idx++ } // 计算子数组 for i := 1; i \u0026lt;= size; i++ { for j := 0; j \u0026lt; i; j++ { if prefix[i] - prefix[j] == k { res++ } } } return res } "},{"id":145,"href":"/docs/algs/leetcode/572_subtree_of_another_tree/","title":"0572. Subtree of Another Tree","section":"Leetcode","content":" Description # Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.\nA subtree of a binary tree tree is a tree that consists of a node in tree and all of this node\u0026rsquo;s descendants. The tree tree could also be considered as a subtree of itself.\nSolutions # Recursive # 这里其实是简单题 sameTree 的一个应用。很明显可以看到，我们需要递归遍历 root 中的每个节点，然后看以这个节点为根节点的树是否和 subRoot 为根节点的树是 SameTree 关系。\ntype TreeNode struct { Val int Left *TreeNode Right *TreeNode } func isSubtree(root *TreeNode, subRoot *TreeNode) bool { // 为什么这里单独针对 root 来进行判断呢？ // 因为 isSubtree 其实是针对 root 节点进行的递归，所以这里理应将 root 节点的状态作为返回的判断条件，而不是 subRoot。 if root == nil { return false } if sameTree(root, subRoot) { return true } return isSubtree(root.Left, subRoot) || isSubtree(root.Right, subRoot) } func sameTree(root, subRoot *TreeNode) bool { if root == nil \u0026amp;\u0026amp; subRoot == nil { return true } if root == nil || subRoot == nil { return false } if root.Val != subRoot.Val { return false } return sameTree(root.Left, subRoot.Left) \u0026amp;\u0026amp; sameTree(root.Right, subRoot.Right) } Iterative # 这里也有一种迭代的解法，那就是使用中序遍历的方式，将两棵树的节点值都存到数组中，然后查看 subRoot 的数组是否是 root 数组的子数组即可。\n"},{"id":146,"href":"/docs/algs/leetcode/583_delete_operation_for_two_strings/","title":"0583. Delete Operations for Two Strings","section":"Leetcode","content":" Description # Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same.\nIn one step, you can delete exactly one character in either string.\nSolutions # DP # 求最少的删除步数来使两个字符串一致，其实就是求两个字符串的最长公共子序列（注意，子序列意味着可以不连续），最少的步数就是二者的长度之和减去最长公共子序列的两倍。所以问题就是如何求两个字符串的最长公共子序列。定义 dp[i][j] 表示 str1（假设长度为m）的前i个字符和str2（假设长度为n）的前j个字符的最长公共子序列的长度，根据这个定义，我们最求所求的值就是dp[m][n]，那么我们应该申请的数组就是 (m+1) * (n+1)的二维数组。\n当 str1[i] 和 str2[j] 相等时，dp[i][j] 的值取决于str1的前i-1个i个字符和str2的前j个字符的最长公共子序列，也就是说， dp[i][j] = dp[i-1][j-1] + 1; 当 str1[i] 和 str2[j] 不相等时， 由于所求的时最大长度，dp[i][j] 的值就继承于 dp[i-1][j] 和 dp[i][j-1]中的较大者。 而对于初始条件，可以轻松得到， dp[0][j] = dp[i][0] = 0。\nfunc minDistance(word1 string, word2 string) int { m, n := len(word1), len(word2) if m == 0 || n == 0 { return 0 } dp := make([][]int, m+1) for idx, _ := range dp { dp[idx] = make([]int, n+1) } for i := 1; i \u0026lt;= m; i++ { for j := 1; j \u0026lt;= n; j++ { if word1[i-1] == word2[j-1] { dp[i][j] = dp[i-1][j-1] + 1 } else { dp[i][j] = max(dp[i-1][j], dp[i][j-1]) } } } return m + n - 2 * dp[m][n] } func max(a,b int) int { if a \u0026lt; b { return b } return a } "},{"id":147,"href":"/docs/algs/codingInterviews/06_%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/","title":"06. 从尾到头打印链表","section":"Coding Interviews","content":" Description # 输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。\nSolutions # Recursive # 递归解法，太简单直接看代码就可以。\nfunc printListFromTailToHead( head *ListNode) []int { // write code here var res []int printListFromTailToHeadHelper(head, \u0026amp;res) return res } func printListFromTailToHeadHelper(head *ListNode, res *[]int) { if head == nil { return } printListFromTailToHeadHelper(head.Next, res) *res = append(*res, head.Val) } Stack # 当然了，不用递归也可以用栈，直接看代码：\nfunc printListFromTailToHead( head *ListNode) []int { // write code here var res []int if head == nil { return res } var stack []*ListNode cur := head for cur != nil { stack = append(stack, cur) cur = cur.Next } size := len(stack) for i := size -1; i \u0026gt;= 0; i-- { res = append(res, stack[i].Val) } return res } "},{"id":148,"href":"/docs/algs/leetcode/630_course_schedule_iii/","title":"0630. Course Schedule III","section":"Leetcode","content":" Description # There are n different online courses numbered from 1 to n. You are given an array courses where courses[i] = [durationi, lastDayi] indicate that the ith course should be taken continuously for durationi days and must be finished before or on lastDayi.\nYou will start on the 1st day and you cannot take two or more courses simultaneously.\nReturn the maximum number of courses that you can take.\nSolutions # Greedy Algorithms # 这里的课程调度更前面的课程调度的题的解法都不太一样，这里采用的是贪心算法加最大堆。首先对按照结束时间对各个课程从小到达拍个序，然后遍历每个课程，将每个课程的耗时加入到 courseTaken 里面，并且将耗时也加入到最大堆中，当遍历到当前课程时，累计要花的时间 courseTaken 超过当前课程的结束时间时，我们就从最大堆中取出一个最大值，然后从 courseTaken 中减去这个最大值，这样的话，我们就可以尽量多上几门课。\nfunc scheduleCourse(courses [][]int) int { sort.Slice(courses, func(i,j int) bool { return courses[i][1] \u0026lt; courses[j][1] }) var courseTaken int var maxHeap MaxHeap heap.Init(\u0026amp;maxHeap) for _, course := range courses { courseTaken += course[0] heap.Push(\u0026amp;maxHeap, course[0]) if courseTaken \u0026gt; course[1] { c := heap.Pop(\u0026amp;maxHeap).(int) courseTaken -= c } } return maxHeap.Len() } type MaxHeap []int func (m MaxHeap) Len() int { return len(m) } func (m MaxHeap) Less(i,j int) bool { return m[i] \u0026gt; m[j] } func (m MaxHeap) Swap(i,j int) { m[i], m[j] = m[j], m[i] } func (m *MaxHeap) Push(x interface{}) { *m = append(*m, x.(int)) } func (m *MaxHeap) Pop() interface{} { x := (*m)[m.Len()-1] *m = (*m)[:m.Len()-1] return x } "},{"id":149,"href":"/docs/algs/leetcode/643_maximum_average_subarray_i_/","title":"0643. Maximum Average Subarray I","section":"Leetcode","content":" Description # You are given an integer array nums consisting of n elements, and an integer k.\nFind a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted.\nSolutions # Sliding Window # 这题没什么难度，可以用一个固定长度的队列来模拟滑动窗口即可。\nfunc findMaxAverage(nums []int, k int) float64 { var queue []int res, size, sum := math.MinInt, len(nums), 0 for i := 0; i \u0026lt; size; i++ { queue = append(queue, nums[i]) sum += nums[i] // 注意第一个 if 语句和第二个 if 语句的先后关系 if len(queue) \u0026gt; k { sum -= queue[0] queue = queue[1:] } if len(queue) == k \u0026amp;\u0026amp; sum \u0026gt; res { res = sum } } return float64(res)/float64(k) } "},{"id":150,"href":"/docs/algs/leetcode/647_palindromic_substrings/","title":"0647. Palindromic Substrings","section":"Leetcode","content":" Description # Given a string s, return the number of palindromic substrings in it.\nA string is a palindrome when it reads the same backward as forward.\nA substring is a contiguous sequence of characters within the string.\nSolutions # Two Pointer # 回文串的解法都是相对比较单一的，这里还是沿用老套路：遍历字符串中的每个位置，检查以这个位置为中心，或者以这个位置和前一个位置为中心的字符是否能组成回文串，检查的时候把 res 传到子函数中去，这样就可以更新 res 。\nfunc countSubstrings(s string) int { var res int size := len(s) for i := 0; i \u0026lt; size; i++ { findPalindrome(s, i,i,size,\u0026amp;res) findPalindrome(s,i-1,i,size,\u0026amp;res) } return res } func findPalindrome(s string, left,right,size int, res *int) { for left \u0026gt;= 0 \u0026amp;\u0026amp; right \u0026lt; size { if s[left] != s[right] { break } *res++ left-- right++ } } "},{"id":151,"href":"/docs/algs/leetcode/665_non_decreasing_array/","title":"0665. Non-decreasing Array","section":"Leetcode","content":" Description # Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element.\nWe define an array is non-decreasing if nums[i] \u0026lt;= nums[i + 1] holds for every i (0-based) such that (0 \u0026lt;= i \u0026lt;= n - 2).\nSolution # Greedy # 题主这题做了好久，多次提交都不正确，只好上网上看各路大神们的解法。这里用的是贪心思想，这里你会发现，对于一个序列 abcd，如果 c 比 b 要小，那么你要么更改 c 的值，让当前元素等于前一个元素，要么更改 b 的值，让前一个元素（相对于 c 而言）小于等于当前元素，那改谁的值会让你受益更多呢？其实是改 b 的值，也就是 nums[i-1] 的值，因为减少值没有风险，但是增加值却可能会带来风险。但是，如果你发现 a \u0026gt; c 的时候，那么你就需要更改 c 的值，也就是 nums[i]，否则的话，你就需要同时更改 a 和 b 的值，而这显然是不被允许的。\nfunc checkPossibility(nums []int) bool { size := len(nums) if size \u0026lt;= 1 { return true } cnt, i := 1, 1 for i \u0026lt; size { if nums[i] \u0026lt; nums[i-1] { cnt-- if cnt \u0026lt; 0 { return false } // 优先更改前一个元素 if i == 1 || nums[i-2] \u0026lt;= nums[i] { nums[i-1] = nums[i] } else { // 否则更改当前元素 nums[i] = nums[i-1] } } i++ } return true } "},{"id":152,"href":"/docs/algs/codingInterviews/07_%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"07. 重建二叉树","section":"Coding Interviews","content":" Description # 给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。\nSolutions # TODO\nfunc reConstructBinaryTree( pre []int , vin []int ) *TreeNode { // write code here pre_size, in_size := len(pre), len(vin) return buildTreeSolution(pre, 0, pre_size-1, vin, 0, in_size-1) } func buildTreeSolution(preorder []int, pleft, pright int, inorder []int, ileft, iright int) *TreeNode { if pleft \u0026gt; pright || ileft \u0026gt; iright { return nil } var rootIndex int for i := ileft; i \u0026lt;= iright; i++ { if inorder[i] == preorder[pleft] { rootIndex = i break } } root := new(TreeNode) root.Val = preorder[pleft] root.Left = buildTreeSolution(preorder, pleft+1, pleft+rootIndex-ileft, inorder, ileft, rootIndex-1) root.Right = buildTreeSolution(preorder, pleft+rootIndex-ileft+1, pright, inorder, rootIndex+1, iright) return root } "},{"id":153,"href":"/docs/algs/leetcode/718_maximum_length_of_repeated_subarray/","title":"0718. Maximum Length of Repeated Subarray","section":"Leetcode","content":" Description # Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays.\nSolutions # Dynamic Programming # 定义 dp[i][j]表示 nums1 中以 i 为结尾的子数组和 nums2 中以 j 为结尾的子数组当前的匹配的最长公共子数组的长度。如果 nums1[i] == num2[j]，说明当前两个数字相同，那么当前最长公共子数组的长度就是 nums1 以 i-1 为结尾的子数组和 nums2 以 j-1 为结尾的子数组的最长公共子数组的长度加 1，即 dp[i][j] = dp[i-1][j-1] + 1；否则说明二者当前无公共子子数组或者公共子数组在当前位置不连续，则dp[i][j] = 0。\nfunc findLength(nums1 []int, nums2 []int) int { m,n := len(nums1), len(nums2) dp := make([][]int, m+1) for idx, _ := range dp { dp[idx] = make([]int, n + 1) } var res int for i := 1; i \u0026lt;= m;i++ { for j := 1; j \u0026lt;= n; j++ { if nums1[i-1] == nums2[j-1] { dp[i][j] = dp[i-1][j-1] + 1 res = max(res, dp[i][j]) } else { dp[i][j] = 0 } } } return res } func max(a,b int) int { if a \u0026lt; b { return b } return a } "},{"id":154,"href":"/docs/algs/leetcode/735_asteroid_collision/","title":"0735. Asteroid Collisiion","section":"Leetcode","content":" Description # We are given an array asteroids of integers representing asteroids in a row.\nFor each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.\nFind out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet\nSolutions # 仔细分析一下，会发现只有一种情况下才会出现相互抵消的可能：前一个元素非空且前一个元素为正，后一个元素为负。因为我们需要不断的知道前一个元素是什么，所以可以使用栈来解。\n具体解法就是，不断的进行遍历，如果当前遍历到的元素为负数且栈非空，栈顶元素为正，那么就需要考虑从栈中弹出元素，其它情况下，都需要把元素直接入栈。那么怎么弹出呢？注意这里的弹出顺序是很重要的，另外弹出时候需要保证栈非空且栈顶元素为正：\n首先需要考虑栈顶元素比当前遍历元素要小的情况，此时需要把栈顶元素不断出栈。注意我们这里说的小，都是指小于当前遍历元素的绝对值。 然后上面的循环可能会出现两种情况，这两种情况下，我们都需要把当前遍历元素入栈，然后开启下一轮循环： 当前遍历元素比栈中所有元素都大，此时栈中没有元素了； 当前栈顶元素出现了负数，那么此时栈顶元素和遍历元素同号，此时无法抵消，也需要入栈。 上面的循环还可能会导致栈顶元素与当前遍历元素相等，此时弹出栈顶元素，然后开启下一轮循环。 func asteroidCollision(asteroids []int) []int { size := len(asteroids) if size \u0026lt;= 0 { return nil } var stack []int stack = append(stack, asteroids[0]) for i := 1; i \u0026lt; size; i++ { idx := len(stack) - 1 // 只有栈顶为正数且当前遍历元素为负数的情况才需要考虑弹栈 if idx \u0026gt;= 0 \u0026amp;\u0026amp; asteroids[i] \u0026lt; 0 \u0026amp;\u0026amp; stack[idx] \u0026gt; 0 { // 如果当前遍历到的元素一直比栈顶元素要大，那么将栈顶元素不断出栈 // 需要保证栈非空且栈顶元素为正数 for idx \u0026gt;= 0 \u0026amp;\u0026amp; stack[idx] \u0026gt; 0 \u0026amp;\u0026amp; stack[idx] \u0026lt; abs(asteroids[i]) { stack = stack[:idx] idx-- } // 上面的循环中可能出现栈中所有元素都要比当前遍历元素小，或者栈非空但是栈顶元素跟当前遍历元素同号且相等的情况，此时需要将当前遍历元素入栈；然后继续下一轮遍历 // if idx \u0026lt; 0 || idx \u0026gt;= 0 \u0026amp;\u0026amp; stack[idx] \u0026lt; 0 { stack = append(stack, asteroids[i]) continue } // 上面的循环中可能出现栈顶元素与当前遍历到的元素相等的情况，此时将栈顶元素出栈，然后继续下一轮遍历 // 需要保证栈非空且栈顶元素为正 if idx \u0026gt;= 0 \u0026amp;\u0026amp; stack[idx] \u0026gt; 0 \u0026amp;\u0026amp; abs(asteroids[i]) == stack[idx] { stack = stack[:idx] idx-- continue } // 上面的循环中可能出现栈顶元素比当前遍历元素要大的情况，此时当前遍历元素被抵消，继续下一轮遍历 // 需要保证栈非空且栈顶元素为正 if idx \u0026gt;= 0 \u0026amp;\u0026amp; stack[idx] \u0026gt; 0 \u0026amp;\u0026amp; stack[idx] \u0026gt; abs(asteroids[i]) { continue } } else { // 其余情况都不存在相互抵消的可能，所以直接入栈即可 stack = append(stack, asteroids[i]) } } return stack } func abs(a int) int { if a \u0026lt; 0 { return -a } return a } "},{"id":155,"href":"/docs/algs/leetcode/745_prefix_and_suffix_search/","title":"0745. Prefix and Suffix Search","section":"Leetcode","content":" Description # Design a special dictionary with some words that searchs the words in it by a prefix and a suffix.\nImplement the WordFilter class:\nWordFilter(string[] words) Initializes the object with the words in the dictionary. f(string prefix, string suffix) Returns the index of the word in the dictionary, which has the prefix prefix and the suffix suffix. If there is more than one valid index, return the largest of them. If there is no such word in the dictionary, return -1. Solutions # Hash Table # 一个长度为 n 的单词会有 n 个前缀和后缀，那么也就有 \\( \\Omicron(n^2) \\) 种组合。这里可以使用一个哈希表，来记录每个单词的前缀和后缀的组合对应的下标，key 为前缀和后缀的组合，为了应对相同字符出现的情况，我们可以在前后缀之间加上一个特殊字符，value 为 该前后缀组合对应的字符的下标。因为题目要求当字符相同时，返回最大的下标，那么这里我们只需要按照数组顺序从左向右进行遍历，然后遇到重复的前后缀组合，直接对下标进行替换即可。\ntype WordFilter struct { dict map[string]int } func Constructor(words []string) WordFilter { dict := make(map[string]int) size := len(words) for i := 0; i \u0026lt; size; i++ { s := len(words[i]) for j := 0; j \u0026lt;= s; j++ { for k := 0; k \u0026lt; s; k++ { key := words[i][:j] + \u0026#34;#\u0026#34; + words[i][k:] dict[key] = i } } } return WordFilter{dict} } func (this *WordFilter) F(prefix string, suffix string) int { key := prefix + \u0026#34;#\u0026#34; + suffix if idx, ok := (*this).dict[key]; ok { return idx } return -1 } /** * Your WordFilter object will be instantiated and called as such: * obj := Constructor(words); * param_1 := obj.F(prefix,suffix); */ "},{"id":156,"href":"/docs/algs/leetcode/752_open_the_lock/","title":"0752. Open the Lock","section":"Leetcode","content":" Description # You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: \u0026lsquo;0\u0026rsquo;, \u0026lsquo;1\u0026rsquo;, \u0026lsquo;2\u0026rsquo;, \u0026lsquo;3\u0026rsquo;, \u0026lsquo;4\u0026rsquo;, \u0026lsquo;5\u0026rsquo;, \u0026lsquo;6\u0026rsquo;, \u0026lsquo;7\u0026rsquo;, \u0026lsquo;8\u0026rsquo;, \u0026lsquo;9\u0026rsquo;. The wheels can rotate freely and wrap around: for example we can turn \u0026lsquo;9\u0026rsquo; to be \u0026lsquo;0\u0026rsquo;, or \u0026lsquo;0\u0026rsquo; to be \u0026lsquo;9\u0026rsquo;. Each move consists of turning one wheel one slot.\nThe lock initially starts at \u0026lsquo;0000\u0026rsquo;, a string representing the state of the 4 wheels.\nYou are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.\nGiven a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.\nSolutions # BFS # 这里既然是要求最小步数，那么用 BFS 会比较好，类似于层序遍历。与以前的迷宫遍历不同的是，这里是需要对字符串的每个字符来做遍历，遍历可以往前也可以往后。这里用-1 和 1 来表示往后和往前。此外还需要一个 hash table 来记录一个字符是否被遍历过，如果该字符没有被遍历过，并且也不是出现在 deadends 中的字符串，那么就可以将该字符加入到下一轮遍历的队列中。\nfunc openLock(deadends []string, target string) int { initialStr := \u0026#34;0000\u0026#34; // 如果 target 就是初始元素，则直接返回 0 if target == initialStr { return 0 } // 对每个 deadend 去重 dict := make(map[string]bool) for _, str := range deadends { dict[str] = true } // 如果 初始字符串就在 deadends 中，则无法得解 if _, ok := dict[initialStr]; ok { return -1 } var res int // 将初始字符串入队 var queue []string = []string{initialStr} // 记录一个字符串有没有被遍历过，如果没被遍历过，则需要加进队列中 visited := map[string]bool{initialStr: true} for len(queue) != 0 { res++ size := len(queue) // 对于当前一层的每个字符串 for i := 0; i \u0026lt; size; i++ { strlen := len(queue[i]) // 对于该字符串的每个字符 for j := 0; j \u0026lt; strlen; j++ { // + 1 表示向前，-1 表示向后 for k := -1; k \u0026lt;= 1; k++ { // 跳过 0 if k == 0 { continue } // 为覆盖\u0026#39;9\u0026#39; 加 1 之后变为\u0026#39;0\u0026#39; 和 \u0026#39;0\u0026#39; 减 1 只有变为\u0026#39;9\u0026#39;的情况， // 统一给每个字符加上 10 来进行运算，最后让其对 10 取余 rs := []rune(queue[i]) rs[j] = rune((int(rs[j]-\u0026#39;0\u0026#39;) + 10 + k) % 10 + int(\u0026#39;0\u0026#39;)) str := string(rs) // 如果当前字符等于 target 了，则说明已经找到了最小的步数，返回结果即可 if str == target { return res } // 如果 str 没有被访问过，并且没有出现在 deadends 中，则将其加入到队列中，进行下一轮遍历 _, vis := visited[str] _, ok := dict[str] if !ok \u0026amp;\u0026amp; !vis { queue = append(queue, str) } // 标记当前字符已经被遍历过 visited[str] = true } } } // 缩小队列 queue = queue[size:] } // 返回结果 return -1 } "},{"id":157,"href":"/docs/algs/leetcode/767_reorganizing_string/","title":"0767. Reorganize String","section":"Leetcode","content":" Description # Given a string s, rearrange the characters of s so that any two adjacent characters are not the same.\nReturn any possible rearrangement of s or return \u0026quot;\u0026quot; if not possible.\nSolutions # 这里的解法还是很巧妙的，需要注意一下。\ntype Pair struct { char byte cnt int } func reorganizeString(s string) string { dict := make(map[byte]int) for idx, _ := range s { dict[s[idx]]++ } var maxHeap MaxHeap heap.Init(\u0026amp;maxHeap) for char, cnt := range dict { if cnt \u0026gt; (len(s)+1)/2 { return \u0026#34;\u0026#34; } heap.Push(\u0026amp;maxHeap, Pair{char, cnt}) } var res string for maxHeap.Len() \u0026gt; 1 { first, second := heap.Pop(\u0026amp;maxHeap).(Pair), heap.Pop(\u0026amp;maxHeap).(Pair) res += string(first.char) res += string(second.char) first.cnt-- second.cnt-- if first.cnt \u0026gt; 0 { heap.Push(\u0026amp;maxHeap, first) } if second.cnt \u0026gt; 0 { heap.Push(\u0026amp;maxHeap, second) } } if maxHeap.Len() \u0026gt; 0 { first := heap.Pop(\u0026amp;maxHeap).(Pair) res += string(first.char) } return res } type MaxHeap []interface{} func(m MaxHeap) Len() int { return len(m) } func (m MaxHeap) Swap(i,j int) { m[i], m[j] = m[j], m[i] } // \u0026gt; 才是最大堆， \u0026lt; 是最小堆 func (m MaxHeap) Less(i,j int) bool { return m[i].(Pair).cnt \u0026gt; m[j].(Pair).cnt } func (m *MaxHeap) Push(x interface{}) { *m = append(*m, x) } func (m *MaxHeap) Pop() interface{} { x := (*m)[m.Len()-1] *m = (*m)[:m.Len()-1] return x } "},{"id":158,"href":"/docs/algs/codingInterviews/08_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/","title":"08. 二叉树的下一个节点","section":"Coding Interviews","content":" Description # 给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的next指针。下图为一棵有9个节点的二叉树。树中从父节点指向子节点的指针用实线表示，从子节点指向父节点的用虚线表示\nSolutions # 一般我们中序遍历都是从根节点开始的，但是这里并没有给出根节点，而是给出了一个要查找的节点。那首先我们可以通过不断的往上走，直到找到根节点，然后进行中序遍历，这样就可以找到我们需要的节点的下一个节点。这里的写法很简单，我们就不上代码了。\n那如果我们不找根节点，直接从当前节点开始遍历呢？这里情形就稍微有点复杂了，需要分情况讨论: - 如果当前节点有右节点，则右节点的最左节点就是我们所找的节点 - 如果当前节点没有右节点，且当前节点没有父节点，则返回 nil - 如果当前节点没有右节点，当前节点有父节点，且当前节点是父节点的左子节点，则返回当前节点的父节点 - 如果当前节点没有右节点，当前节点有父节点，且当前节点是父节点的右子节点，则一路向上查找，直到找到一个节点，这个节点是其父节点的左子节点，返回父节点；如果没有这样的父节点，返回 nil。\n下面给出上面第二种方法的代码。\nfunc GetNext(pNode *TreeLinkNode) *TreeLinkNode { if pNode == nil { return nil } // 情况一，当前节点的右子树非空，则直接找出当前节点的右子树的最左节点即可 if pNode.Right != nil { pNode = pNode.Right for pNode.Left != nil { pNode = pNode.Left } return pNode } // 情况二，当前节点的右子树为空，且父节点也为空，说明当前节点就是根节点，没有下一个节点，返回 nil 即可。 if pNode.Next == nil { return nil } // 情况三， 当前节点右子树为空，父节点非空，并且当前节点是其父节点的左节点，那么直接返回其父节点 if pNode == pNode.Next.Left { return pNode.Next } // 情况四， 当前节点右子树为空，父节点非空，并且当前节点是其父节点的右节点，那么不断向上查找，直到找到一个节点， // 这个节点是其父节点的左子节点，那么直接返回这个节点的父节点即可 for pNode != nil { parent := pNode.Next if parent.Left == pNode { return parent } pNode = parent } return nil } "},{"id":159,"href":"/docs/algs/leetcode/820_short_encoding_of_words/","title":"0820. Short Encoding of Words","section":"Leetcode","content":" Description # Solutions # Hash Table # 这道题给了我们一个单词数组，让我们对其编码，不同的单词之间加入#号，每个单词的起点放在一个坐标数组内，终点就是#号，能合并的单词要进行合并，问输入字符串的最短长度。题意不难理解，难点在于如何合并单词，我们观察题目的那个例子，me和time是能够合并的，只要标清楚其实位置，time的起始位置是0，me的起始位置是2，那么根据#号位置的不同就可以顺利的取出me和time。需要注意的是，如果me换成im，或者tim的话，就不能合并了，因为我们是要从起始位置到#号之前所有的字符都要取出来。\n这里使用 Hash Table 来做，将所有的单词先放到这个Hash Table 中。原理是对于每个单词，我们遍历其所有的后缀，比如time，那么就遍历ime，me，e，然后看 Hash Table 中是否存在这些后缀，有的话就删掉，那么 Hash Table 中的 me 就会被删掉，这样保证了留下来的单词不可能再合并了，最后再加上每个单词的长度到结果 res，并且同时要加上 # 号的长度。\nfunc minimumLengthEncoding(words []string) int { // 先将每个单词放进 hash 表中 dict := make(map[string]bool) for _, word := range words { dict[word] = true } // 对于 words 中的每个单词，找到其每个后缀，查看该后缀是否在 dict 中，如果在的话，则从 dict 中将该后缀删除 for _, word := range words { size := len(word) for i := 1; i \u0026lt; size; i++ { if _, ok := dict[word[i:]]; ok { delete(dict, word[i:]) } } } // 最后 dict 中剩下来的字符串都是不能合并的字符串，因为每个字符串和周围的字符串都要有一个#分隔，最后一个位置也需要一个#分隔， // 所以可以遍历 dict 中剩下的每个字符串，将其长度加 1 放到 res 中 var res int for word, _ := range dict { res += len(word) + 1 } return res } "},{"id":160,"href":"/docs/algs/leetcode/867_transpose_matrix/","title":"0867. Transpose Matrix","section":"Leetcode","content":" Description # Given a 2D integer array matrix, return the transpose of matrix.\nThe transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix\u0026rsquo;s row and column indices.\nSolutions # 简言之就是需要行列倒置。\nfunc transpose(matrix [][]int) [][]int { m,n := len(matrix),len(matrix[0]) res := make([][]int, n) for idx, _ := range res { res[idx] = make([]int, m) } for i := 0; i \u0026lt; m; i++ { for j := 0; j \u0026lt; n; j++ { res[j][i] = matrix[i][j] } } return res } "},{"id":161,"href":"/docs/algs/leetcode/876_median_of_the_linked_list/","title":"0876. Median of the Linked List","section":"Leetcode","content":" Description # Given the head of a singly linked list, return the middle node of the linked list.\nIf there are two middle nodes, return the second middle node.\nSolutions # 使用快慢指针法，最后返回慢指针指向的节点即可。\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func middleNode(head *ListNode) *ListNode { slow, fast := head, head // 注意这里的判断条件 for fast != nil \u0026amp;\u0026amp; fast.Next != nil { slow = slow.Next fast = fast.Next.Next } return slow } "},{"id":162,"href":"/docs/algs/leetcode/895_max_frequency_stack/","title":"0895. Max Frequency Stack","section":"Leetcode","content":" Description # Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.\nImplement the FreqStack class:\nFreqStack() constructs an empty frequency stack. void push(int val) pushes an integer val onto the top of the stack. int pop() removes and returns the most frequent element in the stack. If there is a tie for the most frequent element, the element closest to the stack\u0026rsquo;s top is removed and returned.\nSolutions # 首先可以很明确的是，一定要统计每个数字出现的次数。那么现在我们知道了每个数字出现的次数之后，如何知道对于指定的出现次数中会有哪些数字呢，并且这写数字还有一定的先后顺序？这个也可以通过一个 Hash Table 来解决，其中 key 为出现的次数，而 value 为一个数组，表示对应于该出现次数的数字。每次出现次数到达 key 时，我们就可以将对应的值 append 到 value 数组中，这样我们就可以知道对于特定的出现次数都包含了哪些数字。\n这里维持一个最大出现频率 maxFreq，那么接下来对应 push 操作，只需要将freq 中的对应数字的计数值增加，然后在 dict 中使用这个计数值作为 key，将当前值 append 到 value 中；对于 pop 操作，直接从 dict[maxFreq] 中取出最后一个数字 x，然后检查该频率对应的数组中是否还有数字，如果没有数字了，说明 maxFreq 对应频率的数字已经被取完了，接下来应该去 maxFreq - 1 的数组中去取，那么将 maxFreq 减去 1，此外还需要在 freq 中将对应的值的频率减去 1，最后返回 x 即可。\ntype FreqStack struct { maxFreq int freq map[int]int dict map[int][]int } func Constructor() FreqStack { var maxFreq int dict := make(map[int][]int) freq := make(map[int]int) return FreqStack{maxFreq, freq, dict} } func (this *FreqStack) Push(val int) { // 更新频率 (*this).freq[val]++ // 更新当前最大频率 (*this).maxFreq = max((*this).maxFreq, (*this).freq[val]) // 将 val 添加到对应频率的数组中 (*this).dict[(*this).freq[val]] = append((*this).dict[(*this).freq[val]], val) } func (this *FreqStack) Pop() int { // 在最大频率数组中取出最后一个数字 size := len((*this).dict[(*this).maxFreq]) x := (*this).dict[(*this).maxFreq][size-1] // 缩小最大频率数组的长度 (*this).dict[(*this).maxFreq] = (*this).dict[(*this).maxFreq][:size-1] // 如果最大频率数组中已经没有数字中，那么最大频率应该降低 // 因为频率是连续的，所以下面这一步可以确保上面的最大频率数组中不会取到空值 if len((*this).dict[(*this).freq[x]]) == 0 { (*this).maxFreq-- } // 将对应数组的频率降低 (*this).freq[x]-- return x } func max(a,b int) int { if a \u0026lt; b { return b } return a } /** * Your FreqStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(val); * param_2 := obj.Pop(); */ "},{"id":163,"href":"/docs/algs/codingInterviews/09_%E5%8F%8C%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/","title":"09. 双栈实现队列","section":"Coding Interviews","content":" Description # 用两个栈来实现一个队列，使用n个元素来完成 n 次在队列尾部插入整数(push)和n次在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。\n数据范围： \\($n \\le 1000$\\) 要求：存储n个元素的空间复杂度为 \\($\\Omicron(n)$\\) ，插入与删除的时间复杂度都是 \\($\\Omicron(1)$\\) Solutions # 使用两个队列，队列1专用于push，队列用专用于pop 和 peek。push 时，入队 stack1； pop 时，如果 stack2 不为空，则弹出 stack2 栈顶即可，若 stack2 为空，则将 stack1 的所有元素压入 stack2， 然后将 stack2 的栈顶元素弹出。\ntype MyQueue struct { stack1 []int stack2 []int } func Constructor() MyQueue { return MyQueue{ stack1: make([]int, 0), stack2: make([]int, 0), } } func (this *MyQueue) Push(x int) { this.stack1 = append(this.stack1, x) } func (this *MyQueue) Pop() int { var res int len1, len2 := len(this.stack1), len(this.stack2) if len2 != 0 { ele := this.stack2[len2-1] res = ele this.stack2 = this.stack2[:len2-1] } else { for i := len1 - 1; i \u0026gt;= 0; i-- { this.stack2 = append(this.stack2, this.stack1[i]) } this.stack1 = this.stack1[:0] len2 = len(this.stack2) res = this.stack2[len2-1] this.stack2 = this.stack2[:len2-1] } return res } func (this *MyQueue) Peek() int { var res int len1, len2 := len(this.stack1), len(this.stack2) if len2 != 0 { ele := this.stack2[len2-1] res = ele } else { for i := len1 - 1; i \u0026gt;= 0; i-- { this.stack2 = append(this.stack2, this.stack1[i]) } this.stack1 = this.stack1[:0] len2 = len(this.stack2) res = this.stack2[len2-1] } return res } func (this *MyQueue) Empty() bool { return len(this.stack1) == 0 \u0026amp;\u0026amp; len(this.stack2) == 0 } "},{"id":164,"href":"/docs/algs/leetcode/968_binary_tree_cameras/","title":"0968. Binary Tree Cameras","section":"Leetcode","content":" Description # You are given the root of a binary tree. We install cameras on the tree nodes where each camera at a node can monitor its parent, itself, and its immediate children.\nReturn the minimum number of cameras needed to monitor all nodes of the tree.\nSolutions # Greedy Algorithms # 这种 hard 题，题主肯定是不会做的啦（囧�� ），所以只好求助于网上大神了：\n这里先考虑把相机放在什么位置上能看到的节点最多（这样的话相机数量就会最少）？能放在叶节点吗？显然不能，叶节点最多只能看到两个节点；能放到根节点吗？根节点最多也只能看到 3 个。最优解是放在叶节点的父节点上，这样最多就可以看到四个节点。所以策略是先找到叶节点，然后在其父节点上放相机，同时标记父节点的父节点为被拍到了的状态。这样就有三种不同的状态，用 0 表示当前节点是叶节点，用 1 表示当前节点是叶节点的父节点并且放置了相机，用 2 表示当前节点是叶节点的爷爷节点，并且被相机拍到了。这里使用一个全局变量 res 记录相机个数。在递归过程中，若当前节点不存在，则返回 2，空节点也可以看做被相机拍到了。否则对相机左右节点递归调用，若二者中有一个返回 0，则当前节点至少有一个节点是叶节点，需要在当前位置放置一个相机，res 自增 1，并返回 1；如果左右节点的返回值中有一个为 1，说明左右节点中至少有一个已经放上了相机，当前节点已经被拍到了，返回 2。若都不是，则说明当前节点是叶节点，返回 0。在主函数中，若对根节点调用递归的返回值是 0，说明这个树只有一个节点或者根节点的左右节点没有子节点或者根节点就是叶节点，此时没有办法，只能在根节点上也放一个相机，否则不用加。\n其实上面的的解法，就是遍历再加上一个状态表征，理解了之后，发现其实也没有那么难（不是）。 详细代码如下：\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func minCameraCover(root *TreeNode) int { var res int r := helper(root, \u0026amp;res) // 如果返回值是 0，则说明当前根节点需要放置一个相机；否则不需要 if r \u0026lt; 1 { res += 1 } return res } func helper(root *TreeNode, res *int) int { // 空节点可以当做祖父节点 if root == nil { return 2 } left, right := helper(root.Left, res), helper(root.Right, res) // 如果左右节点有一个是叶节点，那么当前节点就是叶节点的父节点，需要放置一个相机 if left == 0 || right == 0 { *res++ return 1 } // 如果左右节点有一个节点是叶节点的父节点，那么当前节点就是叶节点的祖父节点，那么当前节点不需要放置相机; // 返回 2 表征自己当前是祖父节点 if left == 1 || right == 1 { return 2 } // 否则，说明当前节点是叶节点，则返回 0 return 0 } "},{"id":165,"href":"/docs/algs/leetcode/973_k_closest_points_to_origin/","title":"0973. K Closest Points to Origin","section":"Leetcode","content":" Description # Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).\nThe distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x1 - x2)2 + (y1 - y2)2).\nYou may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).\nSolutions # Sort # 这道题说到底就是一个排序问题，就是比较各个点到原点的距离，那么我们只需要根据这个距离对各个点进行排序即可。\nfunc kClosest(points [][]int, k int) [][]int { var res [][]int sort.Slice(points, func(i,j int) bool { return points[i][0]*points[i][0] + points[i][1]*points[i][1] \u0026lt; points[j][0]*points[j][0]+points[j][1]*points[j][1] }) for i := 0; i \u0026lt; k; i++ { res = append(res, points[i]) } return res } Heap # 这里也可以使用最大堆来做。创建一个 k 个大小的最大堆，然后把距离和 points 下标组成的 Pair 对插入堆中，根据距离进行排序，当堆中数量超过 k 时，将堆顶元素出堆。最后剩下的 k 个元素就是 k 个最小的元素。\n大致思想就是这样，代码就不写了。\n"},{"id":166,"href":"/docs/algs/codingInterviews/10_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/","title":"10. 斐波那契数列","section":"Coding Interviews","content":" Description # 输入一个正整数 n ，请你输出斐波那契数列的第 n 项\nSolutions # 简单题，简单的动态规划。\nfunc Fibonacci( n int ) int { // write code here if n \u0026lt;= 2 { return 1 } NMinusOne, NMinusTwo := 1, 1 for i := 3; i \u0026lt;= n; i++ { N := NMinusOne + NMinusTwo NMinusTwo = NMinusOne NMinusOne = N } return NMinusOne } "},{"id":167,"href":"/docs/algs/leetcode/1004_max_consecutive_ones_iii/","title":"1004. Max Consecutive Ones III","section":"Leetcode","content":" Description # Given a binary array nums and an integer k, return the maximum number of consecutive 1\u0026rsquo;s in the array if you can flip at most k 0\u0026rsquo;s.\nSolutions # Sliding Window # 这题一看就是要用滑动窗口来解啦，但是窗口的边界一定要控制好。题主初始写出了下面的解法，结果只通过了部分case，调来调去总是有一部分 case 不能照顾到。\nfunc longestOnes(nums []int, k int) int { res, size, left, right,cnt := 0, len(nums), 0, 0, 0 for right \u0026lt; size { // 如果 0 的数量比 k 小，那么继续扩大右边界 for right \u0026lt; size \u0026amp;\u0026amp; cnt \u0026lt;= k { if nums[right] == 0 { cnt++ } // 更新窗口值 res = max(res, right - left) right++ } // 缩小左边界 for left \u0026lt; right \u0026amp;\u0026amp; cnt \u0026gt; k { if nums[left] == 0 { cnt-- } left++ } } return res } func max(a,b int) int { if a \u0026lt; b { return b } return a } 于是题主最后还是去看了网上大神的解答，发现其实是自己搞复杂了，这个题完全没有必要写得像上面那么复杂。可以维护一个窗口 [left,right] 来容纳至少k个0。当遇到了0，就累加 zero 的个数，然后判断如果此时0的个数大于k，则右移左边界left，如果移除掉的 nums[left] 为0，那么 zero 自减1。如果不大于k，则用窗口中数字的个数来更新 res。\nfunc longestOnes(nums []int, k int) int { res, size, left, right, cnt := 0, len(nums), 0, 0, 0 for right \u0026lt; size { // 对 0 计数 if nums[right] == 0 { cnt++ } // 如果 cnt 大于 k 了，那么缩小 left 窗口，如果此时nums[left] 为 0， 则更新 cnt 值 // 注意这里需要让 left 等于 right，因为下面计算 res 的时候加了 1 for left \u0026lt;= right \u0026amp;\u0026amp; cnt \u0026gt; k { if nums[left] == 0 { cnt-- } left++ } // 更新 res 值 res = max(res, right - left + 1) right++ } return res } func max(a,b int) int { if a \u0026lt; b { return b } return a } "},{"id":168,"href":"/docs/algs/leetcode/1047_remove_all_duplicated_in_string/","title":"1047. Remove All Adjacent Duplicates in String","section":"Leetcode","content":" Description # You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.\nWe repeatedly make duplicate removals on s until we no longer can.\nReturn the final string after all such duplicate removals have been made. It can be proven that the answer is unique.\nSolutions # 很容易想到用栈。这里需要注意的是，对于\u0026quot;abbaca\u0026quot;这样的字符，移除之后的结果是 “ca”，而不是“abaca”喔，这里的删除是指一旦连续两个字符相同，那么把这两个字符都删去，而不是只保留一个。\nfunc removeDuplicates(s string) string { size := len(s) if size \u0026lt;= 1 { return s } var stack []rune for _, r := range s { size = len(stack) if size == 0 || stack[size-1] != r { stack = append(stack, r) continue } stack = stack[:size-1] } return string(stack) } "},{"id":169,"href":"/docs/algs/leetcode/1048_longest_string_chain/","title":"1048. Longest String Chain","section":"Leetcode","content":" Description # You are given an array of words where each word consists of lowercase English letters.\nwordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB.\nFor example, \u0026quot;abc\u0026quot; is a predecessor of \u0026quot;abac\u0026quot;, while \u0026quot;cba\u0026quot; is not a predecessor of \u0026quot;bcad\u0026quot;. A word chain is a sequence of words [word1, word2, ..., wordk] with k \u0026gt;= 1, where word1 is a predecessor of word2, word2 is a predecessor of word3, and so on. A single word is trivially a word chain with k == 1. Return the length of the longest possible word chain with words chosen from the given list of words.\nSolutions # DP # 题主这里首先想到的 DP 的解法，写出解法之后，一度以为会超时，结果提交之后竟然 ac 了。首先需要明白的是，题目并不要求你选的字符串之间需要连续，而且我们也可以看出来，对字符串进行排序之后其实更方便我们进行处理。于是首先我们先对数组进行排序：按照长度进行排序，长度相同的按照字典序进行排序。然后我们定义 dp[i]表示数组中 [0,i] 之间的最长 predecessor 长度，然后我们来一个双重循环，如果 j 是 i 的 predecessor 的话，就进行状态转移，转移方程为 dp[i] = max(dp[i], dp[j]+1)。因为最长 predecessor 长度可能并不一定会在最后一个字符串处取到，所以我们还需要一个 res 来记录我们当前计算到的最长 predecessor 长度。最后放回 res 即可.\nfunc longestStrChain(words []string) int { // 先排序，方便比较：首先根据长度进行排序，如果长度相同，则按照字典序排序 size := len(words) sort.Slice(words, func(i,j int) bool { m, n := len(words[i]), len(words[j]) if m == n { return words[i] \u0026lt; words[j] } return m \u0026lt; n }) // dp[i] 表示 [0,i] 内的最长 predecessor 个数，初始化为 1 dp := make([]int, size) for i := 0; i \u0026lt; size; i++ { dp[i] = 1 } res := 1 for i := 0; i \u0026lt; size; i++ { for j := 0; j \u0026lt; i; j++ { // 如果 j 是 i 的 predecessor， 那么更新 dp[i]，同时更新结果 res if isPredecessor(words[j], words[i]) { dp[i] = max(dp[i], dp[j]+1) res = max(res, dp[i]) } } } return res } // 判断两个字符是不是 predecessor 关系 func isPredecessor(s1,s2 string) bool { // s1 总是长度比较小的字符串 m, n := len(s1), len(s2) if m \u0026gt; n { s1, s2 = s2, s1 m,n = n, m } // 如果二者长度差不是 1，那么肯定没有 predecessor 关系 if n != m + 1 { return false } // 遍历长字符串s2，对于位置 i，判断 i 前面的字符和 i 后面的字符合起来的字符是不是与 s1 相等 for i := 0; i \u0026lt; n; i++ { // 对于第一个位置需要进行特殊处理 if i == 0 \u0026amp;\u0026amp; i + 1 \u0026lt; n \u0026amp;\u0026amp; s2[i+1:] == s1 { return true } // 对于最后一个位置需要特殊处理 if i == n-1 \u0026amp;\u0026amp; s2[:i] == s1 { return true } // i 前面的字符串和 i 后面的字符串合起来是不是等于 s1 // 如果是， 怎说明二者是 predecessor 关系 if s2[:i] + s2[i+1:] == s1 { return true } } // 没有找到 predecessor 关系，返回 false return false } func max(a,b int) int { if a \u0026lt; b { return b } return a } "},{"id":170,"href":"/docs/algs/leetcode/1060_missing_element_in_sorted_array/","title":"1060. Missing Element in Sorted Array","section":"Leetcode","content":" Description # Given an array containing n distinct numbers taken from 0, 1, 2, \u0026hellip;, n, find the one that is missing from the array.\nFor example, Given nums = [0, 1, 3] return 2.\nNote: Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?\nSolutions # Math # 这个题还是很简单的，首先需要求出求出 [0,n] 的累和，然后用这个累和减去数组中出现的每个数，最后剩下的数就是结果。\nfunc missingNumber(nums []int) int { size := len(nums) res := (1 + n)*n/2 for _, num := range nums { res -= num } return num } Bit Manipulation # 这个题也可以使用异或来做。既然从 0 到 n 中缺了一个，那么我们就可以使用从 0 到 n 的每个数字来跟数组中的数字进行异或操作，最后的那个数字肯定就是缺的那个数字啦。\nfunc missingNumber(n int) int { var res int for idx, num := range nums { res ^= (i+1)^nums[i] } return res } "},{"id":171,"href":"/docs/algs/leetcode/1062_longest_repeating_substring/","title":"1062. Longest Repeating Substring","section":"Leetcode","content":" Description # Given a string S, find out the length of the longest repeating substring(s). Return 0 if no repeating substring exists.\nSolutions # Dynamic Programming # 这种什么最长、最大的题目，当然是使用 DP 来解啦，不过题主想了好一会也没想到该怎么定义状态方程，只好上网去看各路大神怎么搞的：这里定了 dp[i][j] 表示 s 中以第 i 个字符为结尾的子串为和以第 j 个字符为结尾的子串的最大公共后缀的长度。当s[i] == s[j] 时，dp[i][j] = dp[i-1][j-1] + 1；否则，dp[i][j] = 0。在 dp 更新的过程中，不断保存最大值即可。\n这里 DP 的递推式跟「718. Maximum Length of Repeated Subarray」是一致的。\nfunc longestRepeatingSubstring(s string) int { res,size := math.MinInt, len(s) dp := make([]int, size + 1) for idx, _ := range dp { dp[idx] = make([]int, size + 1) } for i := 1; i \u0026lt;= size; i++ { for j := 1; j \u0026lt;i;j++ { if s[i-1] == s[j-1] { dp[i][j] = dp[i-1][j-1] + 1 } res = max(res, dp[i][j]) } } return res } func max(a,b int) int { if a \u0026lt; b { return b } return a } "},{"id":172,"href":"/docs/algs/leetcode/1086_high_five/","title":"1086. High Five","section":"Leetcode","content":" Description # Given a list of the scores of different students, items, where items[i] = [IDi, scorei] represents one score from a student with IDi, calculate each student\u0026rsquo;s top five average.\nReturn the answer as an array of pairs result, where result[j] = [IDj, topFiveAveragej] represents the student with IDj and their top five average. Sort result by IDj in increasing order.\nA student\u0026rsquo;s top five average is calculated by taking the sum of their top five scores and dividing it by 5 using integer division.\nSolutions # 这题应该算是简单题。首先需要使用一个 map 记录每个 ID 对应的所有分数，然后对这写分数按照从大到小排序，然后取出前 5 个来计算其均值即可。\nfunc highFive(items [][]int) [][]int { dict := make(map[int][]int) for _, item := range items { dict[item[0]] = append(dict[item[0]], item[1]) } var res [][]int for key, nums := range dict { sort.Slice(nums, func(i,j int) bool { return nums[i] \u0026gt; nums[j] }) var avg int for i := 0; i \u0026lt; 5; i++ { avg += nums[i] } res = append(res, []int{key, avg/5}) } return res } "},{"id":173,"href":"/docs/algs/leetcode/1091_shortest_path_in_binary_matrix/","title":"1091. Shortest Path in Binary Matrix","section":"Leetcode","content":" Description # Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1.\nA clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:\nAll the visited cells of the path are 0. All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner). The length of a clear path is the number of visited cells of this path. Solutions # BFS # 这个题很容易可以想到是使用 BFS，是迷宫遍历的变体。但是这里跟一般的迷宫遍历还是稍微有点区别：\n迷宫遍历只能往四个方向，而这里可以往八个方向。也就是说，千万别忘了在 dirs 中加上 [1,-1] 和 [-1, 1] 对 res 进行加 1 操作的时机不同。仔细看代码，这里是跟一般的迷宫遍历很不一样的。这里可以这么理解，普通的迷宫每移动一步都需要加 1，而这一题相当于你在当前位置所能够到的所有位置都只算做一个 move。 在 string 和 数字之间进行转换的时候，一定要使用标准转换函数，而不是使用 string 方法将数字转换为字符串，这样的转换结果是不对的。 下面就是题主初始写出来的答案，结果总是不能 AC：\ntype Cords struct { X int Y int } func shortestPathBinaryMatrix(grid [][]int) int { m, n := len(grid), len(grid[0]) if m == 0 || n == 0 || grid[0][0] != 0 { return -1 } var queue []Cords = []Cords{{0,0}} var dirs [][]int = [][]int{{1,0}, {-1, 0}, {0, 1}, {0, -1}, {1, 1}, {-1, -1}} res := 1 grid[0][0] = 1 for len(queue) != 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { for _, dir := range dirs { x, y := queue[i].X + dir[0], queue[i].Y + dir[1] if x \u0026lt; 0 || x \u0026gt;= m || y \u0026lt; 0 || y \u0026gt;= n || grid[x][y] != 0 { continue } // res 不应该在这里加，是否到达右下角也不应该在这里进行判断 res++ if x == m -1 \u0026amp;\u0026amp; y == n - 1 { return res } // 标记该点已经被访问过 grid[x][y] = 1 queue = append(queue, Cords{x,y}) } } } return -1 } func shortestPathBinaryMatrix(grid [][]int) int { m, n := len(grid), len(grid[0]) if m == 0 || n == 0 || grid[0][0] != 0 { return -1 } var queue [][]int = [][]int{{0,0}} // 注意点 1，需要 8 个方向 var dirs [][]int = [][]int{{1,0}, {-1, 0}, {0, 1}, {0, -1}, {1, 1}, {-1, -1}, {1, -1}, {-1, 1}} visited := map[string]bool{\u0026#34;00\u0026#34;: true} var res int for len(queue) != 0 { // 注意点 2，注意 res 自增的位置 res++ size := len(queue) for i := 0; i \u0026lt; size; i++ { // 注意点 3， 注意什么时候才需要对坐标进行判断 if queue[i][0] == m -1 \u0026amp;\u0026amp; queue[i][1] == n - 1 { return res } for _, dir := range dirs { x, y := queue[i][0] + dir[0], queue[i][1] + dir[1] // 注意点 4， 不能使用 string 来对数字进行转换 key := strconv.Itoa(x) + strconv.Itoa(y) if x \u0026lt; 0 || x \u0026gt;= m || y \u0026lt; 0 || y \u0026gt;= n || grid[x][y] == 1 || visited[key] { continue } visited[key] = true queue = append(queue, []int{x, y}) } } queue = queue[size:] } return -1 } "},{"id":174,"href":"/docs/algs/leetcode/1095_find_in_mountain_array/","title":"1095. Find in Mountain Array","section":"Leetcode","content":" Description # (This problem is an interactive problem.)\nYou may recall that an array arr is a mountain array if and only if:\narr.length \u0026gt;= 3 There exists some i with 0 \u0026lt; i \u0026lt; arr.length - 1 such that: arr[0] \u0026lt; arr[1] \u0026lt; \u0026hellip; \u0026lt; arr[i - 1] \u0026lt; arr[i] arr[i] \u0026gt; arr[i + 1] \u0026gt; \u0026hellip; \u0026gt; arr[arr.length - 1] Given a mountain array mountainArr, return the minimum index such that mountainArr.get(index) == target. If such an index does not exist, return -1. You cannot access the mountain array directly. You may only access the array using a MountainArray interface:\nMountainArray.get(k) returns the element of the array at index k (0-indexed). MountainArray.length() returns the length of the array. Submissions making more than 100 calls to MountainArray.get will be judged Wrong Answer. Also, any solutions that attempt to circumvent the judge will result in disqualification. Solutions # TODO "},{"id":175,"href":"/docs/algs/codingInterviews/11_%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/","title":"11. 旋转数组的最小数字","section":"Coding Interviews","content":" Descriptioin # 有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。\n数据范围： \\($1 \\le n \\le 10000$\\) ，数组中任意元素的值: \\($0 \\le val \\le 10000$\\) 。 要求：空间复杂度： \\($\\Omicron(1)$\\) ，时间复杂度： \\($\\Omicron(\\log n)$\\) Solutions # Binary Search # 二分查找，使用两个指针 left 和 right 分别指向数组的待查找序列的左侧和右侧，则：\n如果中间元素比右侧元素小，那么向左查找，即 right = mid 如果中间元素比右侧元素大，那么向右查找， 即 left = mid + 1 如果中间元素等于右侧元素，那么最小元素即可能在左边，也可能在右边，则可以收缩右边界 最后返回 left 指向的元素即可。 func minNumberInRotateArray( nums []int ) int { // write code here var res int size := len(nums) if size == 0 { return res } left, right := 0, size -1 for left \u0026lt; right { mid := (left+right)/2 if nums[mid] \u0026gt; nums[right] { left = mid + 1 } else if nums[mid] \u0026lt; nums[right] { right = mid } else if nums[mid] == nums[right] { right = right -1 } } return nums[left] } "},{"id":176,"href":"/docs/algs/codingInterviews/12_%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/","title":"12. 矩阵中的路径","section":"Coding Interviews","content":" Description # 请设计一个函数，用来判断在一个n乘m的矩阵中是否存在一条包含某长度为len的字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如: \\($\\begin{bmatrix} a \u0026amp; b \u0026amp; c \u0026amp;e \\\\ s \u0026amp; f \u0026amp; c \u0026amp; s \\\\ a \u0026amp; d \u0026amp; e\u0026amp; e\\\\ \\end{bmatrix}\\quad$\\) 矩阵中包含一条字符串\u0026quot;bcced\u0026quot;的路径，但是矩阵中不包含\u0026quot;abcb\u0026quot;路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 数据范围： \\($0 \\le n,m \\le 20$\\) , \\($1\\le len \\le 25$\\) Solutions # Backtracing # func hasPath( matrix [][]byte , word string ) bool { // write code here n,m := len(matrix), len(matrix[0]) for i := 0; i \u0026lt; n; i++ { for j := 0; j \u0026lt; m; j++ { // 剪枝 if word[0] == matrix[i][j] \u0026amp;\u0026amp; helper(matrix, word, i, j, n, m) { return true } } } return false } func helper(matrix [][]byte, word string, x,y,n,m int) bool { size := len(word) // 这里之所以可以直接取 word[0] 而不用判断数组越界，主要是因为下面第二个 if 语句会保证进入递归的 word 一定不是空串 if x \u0026lt; 0 || x \u0026gt;= n || y \u0026lt; 0 || y \u0026gt;= m || matrix[x][y] == \u0026#39;.\u0026#39; || word[0] != matrix[x][y] { return false } if size == 1 \u0026amp;\u0026amp; matrix[x][y] == word[0] { return true } // 这里可以直接使用原矩阵来判断特定点是否已经访问过，而不用再新开数组 tmp := matrix[x][y] matrix[x][y] = \u0026#39;.\u0026#39; res := helper(matrix, word[1:], x+1, y, n, m) || helper(matrix, word[1:], x-1, y, n, m) || helper(matrix, word[1:], x, y+1, n, m) || helper(matrix, word[1:], x, y-1, n, m) // 回溯结束之后要复原 matrix[x][y] = tmp return res } "},{"id":177,"href":"/docs/algs/leetcode/1209_remove_all_adjacent_duplicates_in_string_ii/","title":"1209. Remove All Adjacent Duplicates in String","section":"Leetcode","content":" Description # You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, causing the left and the right side of the deleted substring to concatenate together.\nWe repeatedly make k duplicate removals on s until we no longer can.\nReturn the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.\nSolutions # 第一想法还是使用跟 1047 题差不多同样的解法来解，但是可惜超时了。这里把代码贴出来：\nfunc removeDuplicates(s string, k int) string { size := len(s) if size \u0026lt; k { return s } var stack []rune for _, r := range s { size = len(stack) if size \u0026lt; k-1 || getSub(r, k-1) != string(stack[size-k+1:]) { stack = append(stack, r) continue } stack = stack[:size-k+1] } return string(stack) } func getSub(r rune, k int) string { var res string for i := 0; i \u0026lt; k; i++ { res += string(r) } return res } 看到网上的一种解法，还是使用栈，但是这里栈中并不直接存储字符，而是存储一个 pair 对，这个 pair 里包含两个元素，一个是对应的字符，另一个是该字符出现的次数。初始栈为空，然后开始遍历字符串，如果栈为空或者当前遍历到的元素跟栈顶元素不一致，则将当前遍历到的元素入栈；如果当前遍历到的元素与栈顶元素一致，则更新该栈顶元素字符的出现次数，如果出现次数到达了 k，那么就将该字符出栈。最后根据栈中的 pair 对再重新组装一次字符串即可。这个方法确实挺妙的.\ntype Pair struct { r rune count int } func removeDuplicates(s string, k int) string { size := len(s) if size \u0026lt; k { return s } var stack []Pair for _, r := range s { size = len(stack) // 如果栈为空或者当前遍历到的元素与栈顶元素不同，则入栈 if size == 0 || stack[size-1].r != r { stack = append(stack, Pair{r:r, count:1}) continue } // 如果当前遍历到的元素与栈顶元素相同，则判断是否需要将该元素出栈 if stack[size-1].r == r \u0026amp;\u0026amp; stack[size-1].count \u0026lt; k { // 如果已经有了 k 个，则将该元素出栈 stack[size-1].count++ if stack[size-1].count == k { stack = stack[:size-1] } } } var res string for _, pair := range stack { res += getSub(pair.r, pair.count) } return res } func getSub(r rune, k int) string { var res string for i := 0; i \u0026lt; k; i++ { res += string(r) } return res } "},{"id":178,"href":"/docs/algs/leetcode/1249_minimum_remove_to_make_valid_parentheses/","title":"1249. Minimum Remove to Make Valid Parentheses","section":"Leetcode","content":" Description # Given a string s of \u0026lsquo;(\u0026rsquo; , \u0026lsquo;)\u0026rsquo; and lowercase English characters.\nYour task is to remove the minimum number of parentheses ( \u0026lsquo;(\u0026rsquo; or \u0026lsquo;)\u0026rsquo;, in any positions ) so that the resulting parentheses string is valid and return any valid string.\nFormally, a parentheses string is valid if and only if:\nIt is the empty string, contains only lowercase characters, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string. Solutions # 括号合法性检测还是需要用到栈，这里用一个栈来保存那些不合法的括号（也就是最终字符串中不能包含的括号）。第一次检测时，遍历每个字符，如果该字符是括号，那么将其入栈，然后检测栈顶的两个字符是否能组成合法的一对括号，如果可以，则将该对括号出栈，然后继续遍历。遍历之后有可能会出现一种情况，那就是输入字符串全为括号，并且该字符串中不包含合法括号，那么此时栈长度就是输入字符串的长度，此时需要返回空字符串，这算是一个 corner case，需要特别处理。最后再遍历以此字符串，将出现栈中的字符排除到最终的输出字符串中即可。\nfunc minRemoveToMakeValid(s string) string { var stack []int for idx, _ := range s { if s[idx] != \u0026#39;(\u0026#39; \u0026amp;\u0026amp; s[idx] != \u0026#39;)\u0026#39; { continue } stack = append(stack, idx) size := len(stack) if size \u0026gt;= 2 \u0026amp;\u0026amp; s[stack[size-1]] ==\u0026#39;)\u0026#39; \u0026amp;\u0026amp; s[stack[size-2]] == \u0026#39;(\u0026#39; { stack = stack[:size-2] } } var res []rune size := len(stack) if size == len(s) { return \u0026#34;\u0026#34; } for idx, r := range s { if size != 0 \u0026amp;\u0026amp; stack[0] == idx { stack = stack[1:] size-- continue } res = append(res, r) } return string(res) } "},{"id":179,"href":"/docs/algs/leetcode/1268_search_suggestions_system/","title":"1268. Search Suggestions System","section":"Leetcode","content":" Description # You are given an array of strings products and a string searchWord.\nDesign a system that suggests at most three product names from products after each character of searchWord is typed. Suggested products should have common prefix with searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products.\nReturn a list of lists of the suggested products after each character of searchWord is typed.\nSolutions # Hash Table # 这里可以使用哈希表来解决。创建一个哈希表，其 key 为一个单词的前缀，而 value 为具有这个前缀的字符串数组。遍历 products 数组，然后数组中的每一个字符串，将该字符串对应的前缀作为 key，然后将该字符串添加到该 key 对应的字符串数组中。因为要求返回的结果要 lexicographically minimum，所以在遍历之前先对 products 进行一次排序。最后再遍历这个searchWord，从哈希表中取出对应的结果即可。\nfunc suggestedProducts(products []string, searchWord string) [][]string { dict := make(map[string][]string) sort.Strings(products) for _, product := range products { size := len(product) for i := 1; i \u0026lt;= size; i++ { dict[product[:i]] = append(dict[product[:i]], product) } } var res [][]string size := len(searchWord) for i := 1; i \u0026lt;= size; i++ { if arr, ok := dict[searchWord[:i]]; ok \u0026amp;\u0026amp; len(arr) \u0026gt;= 3 { res = append(res, arr[:3]) continue } // 这里其实是两种情况： // - 搜索词在 dict 中存在，并且对应的数组长度不足 3，那么直接添加该数组即可 // - 搜索词在 dict 中不存在，因为 golang map 中访问一个不存在的 key 会返回对应的零值（这里就是空数组），所以也可以直接添加 res = append(res, dict[searchWord[:i]]) } return res } Pruning # 在网上看到一种比较巧妙的方法，该方法的核心思想其实还是剪枝。首先先给 products 数组排个序，然后维护一个 suggested 数组，初始时suggested 数组直接拷贝 products 数组即可。然后在敲入每个字符的时候，新建一个 filter 数组，此时遍历 suggested 数组，如果单词对应位置的字符是敲入的字符的话，将单词加入 filter 数组，这样的话 filter 数组的前三个单词就是推荐的单词，取出来组成数组加入结果 res 中。然后把 suggested 数组更新为 filter 数组，这个操作就缩小了下一次查找的范围，算是一个比较巧妙的办法了。\nfunc suggestedProducts(products []string, searchWord string) [][]string { sort.Strings(products) suggested := products var res [][]string size := len(searchWord) for i := 1; i \u0026lt;= size; i++ { // 找出前缀匹配的字符加入到 filter 中 var filter []string for _, word := range suggested { if len(word) \u0026gt;= i \u0026amp;\u0026amp; word[:i] == searchWord[:i] { filter = append(filter, word) } } // 将 filter 中的前三个字符放入 res var tmp []string for _, word := range filter { if len(tmp) == 3 { break } tmp = append(tmp, word) } res = append(res, tmp) // 将 suggested 替换为新的 filter suggested = filter } return res } Trie Tree # 这里还可以使用前缀树来做。不过相比上面两种方法，前缀树的解法还是稍微复杂了点，所以这里就不写了。\n"},{"id":180,"href":"/docs/algs/codingInterviews/13_%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/","title":"13. 机器人的运动范围","section":"Coding Interviews","content":" Description # 地上有一个 rows 行和 cols 列的方格。坐标从 [0,0] 到 [rows-1,cols-1] 。一个机器人从坐标 [0,0] 的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 threshold 的格子。 例如，当 threshold 为 18 时，机器人能够进入方格 [35,37] ，因为 3+5+3+7 = 18。但是，它不能进入方格 [35,38] ，因为 3+5+3+8 = 19 。请问该机器人能够达到多少个格子？\n数据范围： \\($0 \\le threshold \\le 15$\\) ， \\($1 \\le rows,cols \\le 100$\\) Solutions # func movingCount( threshold int , rows int , cols int ) int { // write code here if rows \u0026lt;= 0 || cols \u0026lt;= 0 || threshold \u0026lt; 0 { return 0 } visited := make([][]bool, rows) for idx, _ := range visited { visited[idx] = make([]bool, cols) } return helper(threshold, rows, cols, 0, 0, \u0026amp;visited) } func helper(threshold int, rows int,cols int, row int, col int, visited *[][]bool) int { t := pathSum(row) + pathSum(col) if row \u0026lt; 0 || row \u0026gt;= rows || col \u0026lt; 0 || col \u0026gt;= cols || (*visited)[row][col] || t \u0026gt; threshold { return 0 } (*visited)[row][col] = true return 1 + helper(threshold, rows, cols, row+1, col, visited) + helper(threshold, rows, cols, row-1, col, visited) + helper(threshold, rows, cols, row, col+1, visited) + helper(threshold, rows, cols, row, col-1, visited) } func pathSum(num int) int { var sum int for num != 0 { sum += num%10 num /= 10 } return sum } "},{"id":181,"href":"/docs/algs/leetcode/1300_sum_of_mutated_array_closest_to_target/","title":"1300. Sum of Mutated Array Closest to Target","section":"Leetcode","content":" Description # Given an integer array arr and a target value target, return the integer value such that when we change all the integers larger than value in the given array to be equal to value, the sum of the array gets as close as possible (in absolute difference) to target.\nIn case of a tie, return the minimum such integer.\nNotice that the answer is not neccesarilly a number from arr.\nSolutions # TODO\n"},{"id":182,"href":"/docs/algs/leetcode/1332_remove_palindromic_subsequence/","title":"1332. Remove Palindromic Subsequences","section":"Leetcode","content":" Description # You are given a string s consisting only of letters \u0026lsquo;a\u0026rsquo; and \u0026lsquo;b\u0026rsquo;. In a single step you can remove one palindromic subsequence from s.\nReturn the minimum number of steps to make the given string empty.\nA string is a subsequence of a given string if it is generated by deleting some characters of a given string without changing its order. Note that a subsequence does not necessarily need to be contiguous.\nA string is called palindrome if is one that reads the same backward as well as forward.\nSolutions # 因为题目限制了只有两种字符并且回文串不一定要连续，那么意味着我们永远可以先删除所有的 a，然后再删除所有的字符 b，来让原字符变为空字符，那么也就是说，最多只会删除两次。如果是空字符，很明显无需删除，如果是回文字符，那么只需要删除一次。\nfunc removePalindromeSub(s string) int { // 如果是空字符，那么无需删除 size := len(s) if size == 0 { return 0 } // 检查是否是回文串，如果是回文串，那么只需要删除一次 rs := []rune(s) left, right := 0, size -1 for left \u0026lt; right { rs[left], rs[right] = rs[right], rs[left] left++ right-- } if s == string(rs) { return 1 } // 否则，你可以先删除所有的 a，然后再删除所有的 b，因为只有两个字符，那么最后必然是空字符串 return 2 } "},{"id":183,"href":"/docs/algs/leetcode/1342_number_of_steps_to_reduce_a_number_to_zero/","title":"1342. Number of Steps to Reduce a Number to Zero","section":"Leetcode","content":" Description # Given an integer num, return the number of steps to reduce it to zero.\nIn one step, if the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.\nSolutions # 这题太简单了，没什么好说的，直接上代码。\nfunc numberOfSteps(num int) int { var res int for num != 0 { if num%2 == 0 { num /= 2 } else { num -= 1 } res++ } return res } "},{"id":184,"href":"/docs/algs/codingInterviews/14_%E5%89%AA%E7%BB%B3%E5%AD%90/","title":"14. 剪绳子","section":"Coding Interviews","content":" Description # 给你一根长度为 n 的绳子，请把绳子剪成整数长的 m 段（ m 、 n 都是整数， n \u0026gt; 1 并且 m \u0026gt; 1 ， m \u0026lt;= n ），每段绳子的长度记为 k[1],\u0026hellip;,k[m] 。请问 k[1]k[2]\u0026hellip;*k[m] 可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18 。\n数据范围： \\($2 \\le n \\le 60$\\) 进阶：空间复杂度 \\($\\Omicron(1)$\\) ，时间复杂度 \\($\\Omicron(n)$\\) Solutions # Recursive # 我们可以发现，当我们求某一个数字的时候，我们只需要将这个数字分解出1,2,3。对于3以上的数字，其实也可以分解成这三个数字，比如4=2x2,5=2x3。对于分解出1的情况，我们发现这个是对答案没有贡献的。所以直接忽略。我们只需要讨论2和3的情况。所以，我们只需要将数字分为2和3组成的就行了。\nfunc cutRope( n int ) int { // write code here if n \u0026lt;= 3 { return n } return max(2*cutRope(n-2), 3*cutRope(n-3)) } func max(a,b int) int { if a \u0026lt; b { return b } return a } Dynamic Programming # 对于一个长度为 n 的绳子，如何确定其分出的最大乘积呢？我们可以尝试其中一段不可分的为 j，那么如果另一段 n-j 最大乘积已知，那么我们就可以遍历所有 j 找到这个最大乘积。因此用 dp[i] 表示长度为 i 的绳子可以被剪出来的最大乘积，那么后续遍历每个 j 的时候，我们取最大 dp[i] = max(dp[i], j *dp[i-j])即可。也就是:\nfor j := 1; j \u0026lt; i; j++ { dp[i] = max(dp[i], j * dp[i-j]) } 完整代码如下：\nfunc cutRope( n int ) int { // write code here // 不超过 3 的直接返回 if n \u0026lt;= 3 { return n } // 初始化 dp 数组 dp := make([]int, n+1) dp[1] = 1 dp[2] = 2 dp[3] = 3 dp[4] = 4 for i := 5; i \u0026lt;= n; i++ { for j := 1; j \u0026lt; i; j++ { dp[i] = max(dp[i], j * dp[i-j]) } } return dp[n] } func max(a,b int) int { if a \u0026lt; b { return b } return a } "},{"id":185,"href":"/docs/algs/leetcode/1423_maximum_points_you_can_obtain_from_cards/","title":"1423. Maximum Points You Can Obrain fron Cards","section":"Leetcode","content":" Description # There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints.\nIn one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards.\nYour score is the sum of the points of the cards you have taken.\nGiven the integer array cardPoints and the integer k, return the maximum score you can obtain.\nSolutions # Prefix Sum # leetcode 有一题的解法跟这一题几乎完全一样，但是可惜题主忘了到底是哪一题了。这个题要求每次从左边或者右边取一个数，取出这个数之后数组长度就会减少，要求取出 k 个数，并且让这个 k 个数的和最大。这里的关键就在于如何决策，取的时候到底是要从左边取还是要从右边取。这里最先想到的就是使用枚举的办法，不过这个办法是指数级别的，佷容易就会超时了。\n其实这个题，可以转换为使用前缀和来做。我们不去管决策，而是在这个数组中，找长度为 size -k 的一个子数组，让这个子数组的和最小，那么剩下的几个数的和自然就是相对最大的，于是问题就转换为找一个长度为 size -k 的和最小的子数组，这就是前缀和问题啦。\n// 转换为找一个长度为 size - k 的和最小的子数组，于是便转换为一个前缀和问题 func maxScore(cardPoints []int, k int) int { size := len(cardPoints) // 计算前缀和 prefix := make([]int, size + 1) for i := 1; i \u0026lt;= size; i++ { prefix[i] = prefix[i-1] + cardPoints[i-1] } // 注意 res 要设置为最大值，因为下面使用了 min 函数，如果初始化 res 为 0 的话，结果就总会是整个数组的和 res, left := math.MaxInt, 0 for left + size - k \u0026lt;= size { // 取长度为 size -k 的子数组的最小和 res = min(res, prefix[left+size-k] - prefix[left]) left++ } // 用整个数组的和减去子数组最小和，即为剩余数字最大和 return prefix[size] - res } func min(a,b int) int { if a \u0026lt; b { return a } return b } "},{"id":186,"href":"/docs/algs/leetcode/1429_first_unique_number/","title":"1429. First Unique Number","section":"Leetcode","content":" Description # You have a queue of integers, you need to retrieve the first unique integer in the queue.\nImplement the FirstUnique class:\nFirstUnique(int[] nums) Initializes the object with the numbers in the queue. int showFirstUnique() returns the value of the first unique integer of the queue, and returns -1 if there is no such integer. void add(int value) insert value to the queue. Solutions # 可以这么做： 维护一个哈希表，哈希表的 key 为数字，value 为一个Pair， Pair 中存储 key 在数组中的下标以及该数字的出现次数。然后再创建一个 queue， 将所有出现次数为 1 的数字按照在队列中的出现顺序入队。 调用 showFirstUnique 的时候， 从队列中取出元素，检查在哈希表中该元素的出现次数是否为 1，如果不是，则持续出对队，直到找到第一个出现次数为 1 的元素，然后将该元素输出。add 的时候，将该元素在哈希表中的对应次数加 1，并检查队头元素是否为该元素，如果是， 则将该元素出队即可。\nTODO\n"},{"id":187,"href":"/docs/algs/leetcode/1438_longest_continuous_subarray_with_absolute_diff_less_than_or_equal_to_limit/","title":"1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit","section":"Leetcode","content":" Description # Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit.\nSolutions # TODO\n"},{"id":188,"href":"/docs/algs/leetcode/1461_check_if_a_string_contains_all_binary_codes_of_size_k/","title":"1461. Check If a String Contains All Binary Codes of Size K","section":"Leetcode","content":" Description # Given a binary string s and an integer k, return true if every binary code of length k is a substring of s. Otherwise, return false.\nSolutions # Brute Force # 下面是题主一开始想出来的方法，可惜最后几个用例过于变态，所以超时了。\nfunc hasAllCodes(s string, k int) bool { size := len(s) if size \u0026lt; k { return false } // golang 格式化打印字符串，%04b 这个格式化字符串能够将数字转换为二进制表示，并且当表示字符串长度小于 4 时，能够自动在前面增加 0 作为 padding。 fmtStr := \u0026#34;%0\u0026#34; + strconv.Itoa(k) + \u0026#34;b\u0026#34; maxEle := int(math.Pow(2, float64(k))) - 1 for i := 0; i \u0026lt;= maxEle; i++ { r := fmt.Sprintf(fmtStr, i) if !strAnd(s, r) { return false } } return true } // 比较 op1 中是否包含 op2 这个字符串 func strAnd(op1, op2 string) bool { s1,s2 := len(op1), len(op2) for i := 0; i \u0026lt;= s1 - s2; i++ { if op1[i:i+s2] == op2 { return true } } return false } Hash Table # 很明显，上面的方法中 strAnd 部分的时间复杂度比较高，那么如何对这部分进行优化呢？strAnd 部分的时间复杂度较高的原因之一是，在使用不同的 op2 的时候，op1 都会被从头遍历，也就是说，op1 在 strAnd 中是不变的部分，重复对 op1 进行遍历是没必要的，我们可以直接使用一个 map 来存储 op1 中所有长度为 k 的子串，这样的话就能够省去很多的重复遍历。优化后的方法如下：\nfunc hasAllCodes(s string, k int) bool { size := len(s) if size \u0026lt; k { return false } // 一次性找出 s 中符号要求的字符串，这样可以避免 strAnd 中的重复比较 dict := make(map[string]bool) for i := 0; i \u0026lt;= size-k; i++ { dict[s[i:i+k]] = true } // golang 格式化打印字符串，%04b 这个格式化字符串能够将数字转换为二进制表示，并且当表示字符串长度小于 4 时，能够自动在前面增加 0 作为 padding。 fmtStr := \u0026#34;%0\u0026#34; + strconv.Itoa(k) + \u0026#34;b\u0026#34; maxEle := int(math.Pow(2, float64(k))) - 1 for i := 0; i \u0026lt;= maxEle; i++ { r := fmt.Sprintf(fmtStr, i) if _, ok := dict[r]; !ok { return false } // if !strAnd(s, r) { // return false // } } return true } // 比较 op1 中是否包含 op2 这个字符串 func strAnd(op1, op2 string) bool { s1,s2 := len(op1), len(op2) for i := 0; i \u0026lt;= s1 - s2; i++ { if op1[i:i+s2] == op2 { return true } } return false } 上面的解法还可以再优化,因为 map 自带去重功能，而一个字符串如果要包含所有长度为 k 的二进制字符串，那么 dict 的长度是需要大于等于 2^k 的。\nfunc hasAllCodes(s string, k int) bool { size := len(s) if size \u0026lt; k { return false } // 一次性找出 s 中符号要求的字符串，这样可以避免 strAnd 中的重复比较 dict := make(map[string]bool) for i := 0; i \u0026lt;= size-k; i++ { dict[s[i:i+k]] = true } return len(dict) \u0026gt;= (1 \u0026lt;\u0026lt; k) // 实际上到这里已经不需要下面的循环来进行比较了。因为 map 自带去重功能，而一个字符串如果要包含所有长度为 k 的二进制字符串，那么 dict 的长度是需要大于等于 2^k 的。 // golang 格式化打印字符串，%04b 这个格式化字符串能够将数字转换为二进制表示，并且当表示字符串长度小于 4 时，能够自动在前面增加 0 作为 padding。 // fmtStr := \u0026#34;%0\u0026#34; + strconv.Itoa(k) + \u0026#34;b\u0026#34; // maxEle := int(math.Pow(2, float64(k))) - 1 // for i := 0; i \u0026lt;= maxEle; i++ { // r := fmt.Sprintf(fmtStr, i) // if _, ok := dict[r]; !ok { // return false // } // // if !strAnd(s, r) { // // return false // // } // } // return true } // 比较 op1 中是否包含 op2 这个字符串 func strAnd(op1, op2 string) bool { s1,s2 := len(op1), len(op2) for i := 0; i \u0026lt;= s1 - s2; i++ { if op1[i:i+s2] == op2 { return true } } return false } "},{"id":189,"href":"/docs/algs/leetcode/1472_design_browser_history/","title":"1472. Design Browser History","section":"Leetcode","content":" Description # You have a browser of one tab where you start on the homepage and you can visit another url, get back in the history number of steps or move forward in the history number of steps.\nImplement the BrowserHistory class:\nBrowserHistory(string homepage) Initializes the object with the homepage of the browser. void visit(string url) Visits url from the current page. It clears up all the forward history. string back(int steps) Move steps back in history. If you can only return x steps in the history and steps \u0026gt; x, you will return only x steps. Return the current url after moving back in history at most steps. string forward(int steps) Move steps forward in history. If you can only forward x steps in the history and steps \u0026gt; x, you will forward only x steps. Return the current url after forwarding in history at most steps. Solutions # 简单题，维护一个栈即可。\ntype BrowserHistory struct { urls []string pos int } func Constructor(homepage string) BrowserHistory { return BrowserHistory{urls: []string{homepage}, pos: 0} } func (this *BrowserHistory) Visit(url string) { (*this).urls = (*this).urls[:(*this).pos+1] (*this).urls = append((*this).urls, url) (*this).pos++ } func (this *BrowserHistory) Back(steps int) string { size := (*this).pos+1 if size \u0026lt;= steps { ele := (*this).urls[0] (*this).pos = 0 return ele } (*this).pos -= steps return (*this).urls[(*this).pos] } func (this *BrowserHistory) Forward(steps int) string { size := len((*this).urls[(*this).pos+1:]) if size \u0026lt;= steps { (*this).pos = len((*this).urls)-1 return (*this).urls[(*this).pos] } (*this).pos += steps return (*this).urls[(*this).pos] } /** * Your BrowserHistory object will be instantiated and called as such: * obj := Constructor(homepage); * obj.Visit(url); * param_2 := obj.Back(steps); * param_3 := obj.Forward(steps); */ "},{"id":190,"href":"/docs/algs/leetcode/1480_running_sum_of_1d_array/","title":"1480. Running Sum of 1d Array","section":"Leetcode","content":" Description # Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]).\nReturn the running sum of nums.\nSolutions # 简单题，直接看代码就好了。\nfunc runningSum(nums []int) []int { var res []int var pre int for _, num := range nums { pre += num res = append(res, pre) } return res } "},{"id":191,"href":"/docs/algs/codingInterviews/15_%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD-1-%E7%9A%84%E4%B8%AA%E6%95%B0/","title":"15. 二进制中 1 的个数","section":"Coding Interviews","content":" Description # 输入一个整数 n ，输出该数32位二进制表示中1的个数。其中负数用补码表示。\nSolutions # Bit Manipulation # 这里需要注意的是，因为负数用补码表示，而负数补码右移会导致高位补 1，所以对负数不能直接进行右移。\nfunc NumberOf1( n int ) int { // write code here var count int t := 0x80000000 for n != 0 { count += (n \u0026amp; t) \u0026gt;\u0026gt; 31 n \u0026lt;\u0026lt;= 1 } return count } "},{"id":192,"href":"/docs/algs/codingInterviews/16_%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/","title":"16. 数值的整数次方","section":"Coding Interviews","content":" Description # 实现函数 double Power(double base, int exponent)，求base的exponent次方。\n注意： 1.保证base和exponent不同时为0。 2.不得使用库函数，同时不需要考虑大数问题 3.有特殊判题，不用考虑小数点后面0的位数。\n数据范围： \\($|base| \\le 100$\\) ， \\($|exponent| \\le 100$\\) ,保证最终结果一定满足 \\($|val| \\le 10^4$\\) 进阶：空间复杂度 \\($\\Omicron(1)$\\) ，时间复杂度 \\($\\Omicron(n)$\\) 快速幂 # func Power( base float64 , exponent int ) float64 { // write code here if base == 0 { return 0 } var negative bool if exponent \u0026lt; 0 { negative = true exponent = -exponent } res := helper(base, exponent) if negative { res = 1 / res } return res } func helper(base float64, exponent int) float64 { if base == 0 { return 0 } if exponent == 0 { return 1 } if exponent == 1 { return base } return helper(base, exponent/2) * helper(base, exponent/2) * helper(base, exponent%2) } "},{"id":193,"href":"/docs/algs/leetcode/1642_furthest_building_you_can_reach/","title":"1642. Furthest Building you Can Reach","section":"Leetcode","content":" Description # You are given an integer array heights representing the heights of buildings, some bricks, and some ladders.\nYou start your journey from building 0 and move to the next building by possibly using bricks or ladders.\nWhile moving from building i to building i+1 (0-indexed),\nIf the current building\u0026rsquo;s height is greater than or equal to the next building\u0026rsquo;s height, you do not need a ladder or bricks. If the current building\u0026rsquo;s height is less than the next building\u0026rsquo;s height, you can either use one ladder or (h[i+1] - h[i]) bricks. Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally. Solutions # Greedy \u0026amp;\u0026amp; Heap # 这道题的贪心思路应该是比较容易想到的：好钢一定要用在刀刃上，而梯子就是一块好钢，我们要尽可能用在高度差比较大的地方。或者也可以这么说：尽可能用完每一块砖块，只有砖块实在不够的时候，才考虑来使用梯子。那么接下来问题就来了，既然要把梯子尽可能用在高度差比较大的地方，那么什么地方才算是高度差比较大呢？也就是说，我们如何才能让计算机知道这里高度差比较大呢？很不幸，计算机不知道，没有后视之明。不过这里可以用一个小技巧：刚开始优先使用梯子，对于每个高度差，都将该高度差放入到优先度列中；当队列长度超过 l 时，说明此时的梯子已经被用完了，那么接下来我们就需要把那些大材小用的梯子用砖块替换掉，统计替换这个梯子所需要的砖块数并与我们已有的砖块数进行比较，如果某一个时刻这个累加值超过了我们拥有的砖块数，那么说明我们此时就无法再向前移动了，返回此时的下标减去 1 即可。如果我们能到达最后一个建筑物，那么直接返回长度减 1 即可。\nfunc furthestBuilding(heights []int, bricks int, ladders int) int { size := len(heights) var deltaH int var minHeap MinHeap heap.Init(\u0026amp;minHeap) for i := 1; i \u0026lt; size; i++ { // 计算高度差，如果是高到低或者平移，则直接继续遍历 x := heights[i] - heights[i-1] if x \u0026gt; 0 { // 这里优先使用梯子，只有当没有梯子使用的时候，才开始考虑使用砖块 heap.Push(\u0026amp;minHeap, x) if minHeap.Len() \u0026gt; ladders { // 这里就相当于把那些大材小用的梯子用砖块来代替掉，需要用多少砖块来代替呢？ // 最小堆中的堆顶元素就是我们所需要的砖块 deltaH += heap.Pop(\u0026amp;minHeap).(int) // deltaH += t.(int) } // 当我们有足够的砖块可以用来代替梯子的时候，我们就可以继续进行比那里； // 否则当砖块不足的时候，说明此时我们已经无法继续向前走了 if deltaH \u0026gt; bricks { return i - 1 } } } // 我们可以走到最后一个建筑物 return size - 1 } type MinHeap []int func (m MinHeap) Len() int { return len(m) } func (m MinHeap) Less(i,j int) bool { return m[i] \u0026lt; m[j] } func (m MinHeap) Swap(i,j int) { m[i], m[j] = m[j], m[i] } func (m *MinHeap) Push(x interface{}) { *m = append(*m, x.(int)) } func (m *MinHeap) Pop() interface{} { size := m.Len() x := (*m)[size-1] *m = (*m)[:size-1] return x } "},{"id":194,"href":"/docs/algs/leetcode/1647_minimum_deletions_to_make_character_frequencies_unique/","title":"1647. Minimum Deletions to Make Character Frequencies Unique","section":"Leetcode","content":" Description # A string s is called good if there are no two different characters in s that have the same frequency.\nGiven a string s, return the minimum number of characters you need to delete to make s good.\nThe frequency of a character in a string is the number of times it appears in the string. For example, in the string \u0026ldquo;aab\u0026rdquo;, the frequency of \u0026lsquo;a\u0026rsquo; is 2, while the frequency of \u0026lsquo;b\u0026rsquo; is 1.\nSolutions # Greedy \u0026amp;\u0026amp; Sort # 题主初始看到这个题，没啥思路，但是看到 topic 是贪心和排序，心里就大概直到是咋回事了。首先肯定需要统计每个字符的出现次数，然后去做删除操作，那么怎么删除呢？先需要对每个字符的出现次数按照从大到小排个序，然后从第二大的数字开始遍历，如果这个数字大于等于前一个数字，那么就不断把这个数字减 1（这里应该也可以一步到位，不需要使用 for 循环），直到当前数字比前一个数字要小，减的过程中不断增加 res 的值，最后遍历完之后，res 的值即为结果。这里需要注意的是，为什么是从大到小进行排序，而不是从小到大进行排序呢？这里就是一个贪心的思路，如果我们从小到大进行排序的话，我们对频率数字从头到尾进行处理，那么就要要求后面的数字比前面的数字要大，如果不大的话，就要把后面的整个数字删掉。但是注意啊，因为后面的数字往往更大，我们这么一删，就相当于在结果 res 上增加了一个很大的数；而如果我们是从大到小排序，并且从大到小进行处理，那么这个时候后面的数更小，删去后面的数只会给 res 增加一个很小的值，那这显然是从大道小进行处理更划算了。\nfunc minDeletions(s string) int { var res int // corner case size := len(s) if size \u0026lt;= 1 { return res } // 统计每个字符的出现频率 dict := make(map[byte]int) for idx, _ := range s { dict[s[idx]]++ } // 对出现频率按照从大到小进行排序 var fre []int for _, v := range dict { fre = append(fre, v) } sort.Slice(fre, func(i,j int) bool { return fre[i] \u0026gt; fre[j] }) // 从第二个数开始进行遍历，如果该数大于等于前一个数，那么不断削减该数的值，直到比前一个数要小 size = len(fre) for i := 1; i \u0026lt; size; i++ { // 这里要限制 fre[i] \u0026gt; 0 ，因为一旦频率为 0，说明这个字符串就不需要出现了，没必要再往下减了 for fre[i-1] \u0026lt;= fre[i] \u0026amp;\u0026amp; fre[i] \u0026gt; 0 { // 每次削减都需要让结果自增 fre[i] -= 1 res++ } } return res } 上面的 for 循环也可以一步到位，写成下面这样：\nfunc minDeletions(s string) int { var res int // corner case size := len(s) if size \u0026lt;= 1 { return res } // 统计每个字符的出现频率 dict := make(map[byte]int) for idx, _ := range s { dict[s[idx]]++ } // 对出现频率按照从大到小进行排序 var fre []int for _, v := range dict { fre = append(fre, v) } sort.Slice(fre, func(i,j int) bool { return fre[i] \u0026gt; fre[j] }) // 从第二个数开始进行遍历，如果该数大于等于前一个数，那么不断削减该数的值，直到比前一个数要小 size = len(fre) for i := 1; i \u0026lt; size; i++ { // 这里要限制 fre[i] \u0026gt; 0 ，因为一旦频率为 0，说明这个字符串就不需要出现了，没必要再往下减了 if fre[i] \u0026gt;= fre[i-1] { if fre[i-1] \u0026lt;= 1 { res += fre[i] fre[i] = 0 } else { res += fre[i] - (fre[i-1]-1) fre[i] = fre[i-1] - 1 } } } return res } "},{"id":195,"href":"/docs/algs/leetcode/1658_minimum_operations_to_reduce_x_to_zero/","title":"1658. Minimum Operations to Reduce X to Zero","section":"Leetcode","content":" Description # You are given an integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x. Note that this modifies the array for future operations.\nReturn the minimum number of operations to reduce x to exactly 0 if it is possible, otherwise, return -1.\nSolutions # Backtrace # 这是题主一开始想出来的解法，直接暴力回溯，但是超时了。仔细分析一下，发现时间复杂度确很高得离谱\u0026hellip;\nfunc minOperations(nums []int, x int) int { res := math.MaxInt helper(nums, x, 0, \u0026amp;res) if res == math.MaxInt { return -1 } return res } func helper(nums []int, x int, cur int, res *int) { size := len(nums) if x \u0026lt; 0 { return } if x == 0 { *res = min(*res, cur) return } if size == 0 { return } helper(nums[1:], x - nums[0], cur+1, res) helper(nums[:size-1], x - nums[size-1], cur+1, res) } func min(a,b int) int { if a \u0026lt; b { return a } return b } Prefix Sum # 楼主在思考上面的回溯法优化中，其实还是有看到这题的一点前缀和的特征的，但是在想不出来具体的解法\u0026hellip;.最后还是看了网上的解法\u0026hellip;\n其实我们可以转换一下思路，不要总想着「什么时候选择左边，什么时候选择右边」。其实这个问题可以转换一下就是，在原数组中找到一个子数组，让这个子数组的和等于整个数组的和减去题目要求的 x，如果存在这样的最长子数组，那么久返回总数组的长度减去子数组的长度，否则，返回-1。而因为这里要求的最小操作次数，那么意味着我们只需要找最长的子数组即可。这么一转换的话，是不是马上又回到了我们熟悉的前缀和了呢？\n这是题主首先写出的前缀和解法，结果也是超时了\u0026hellip;\nfunc minOperations(nums []int, x int) int { size := len(nums) prefix := make([]int, size+1) for idx, num := range nums { prefix[idx+1] = prefix[idx] + num } // corner case if prefix[size] \u0026lt; x { return -1 } res := math.MaxInt for i := 1; i \u0026lt;= size; i++ { for j := 0; j \u0026lt;= i; j++ { if prefix[j] + prefix[size] - prefix[i] == x { res = min(res, size - i + j) } } } if res == math.MaxInt { return -1 } return res } func min(a,b int) int { if a \u0026lt; b { return a } return b } 稍微优化一下，提交之后勉强通过：\nfunc minOperations(nums []int, x int) int { size := len(nums) prefix := make([]int, size+1) for idx, num := range nums { prefix[idx+1] = prefix[idx] + num } // corner case if prefix[size] \u0026lt; x { return -1 } if prefix[size] == x { return size } // 连续子数组的和 sumOfSubArr := prefix[size] - x // 使用一个 map， key 为前缀和，value 为达成该前缀和的下标，用来记录指定前缀和可以在哪个下标求得 dict := make(map[int]int) res := math.MinInt for i, preSum := range prefix { // 如果存在一个子数组[j,i]使得 prefix[i] - prefix[j] = sumOfSubArr， 那么也就只需要比较 res 和 i-j 的大小即可。 // 这里我们使用一个 map 来表示 prefix[j]，这样的话只O(n) 的遍历。 s := preSum - sumOfSubArr if idx, ok := dict[s]; ok { res = max(res, i - idx) } if _, ok := dict[preSum]; !ok { dict[preSum] = i } } if res == math.MinInt { return -1 } return size - res } func max(a,b int) int { if a \u0026lt; b { return b } return a } Sliding Window # 这里也可以使用滑动窗口来解。思路还是跟前面相似，都是要找到最大子数组，其和等于整个数组的和减去 x，只不过使用了滑动窗口的方式来解决。方法是维持一个滑动窗口，每当窗口中的值大于 subArrSum 时，收缩左边界；如果相等，则说明找到了一个连续子数组，使其和等于了整个数组和减去 x，那么更新 res。每次遍历都需要不断移动右边界。\nfunc minOperations(nums []int, x int) int { size := len(nums) var sum int for _, num := range nums { sum += num } // corner case if sum == x { return size } if sum \u0026lt; x { return -1 } // 维护一个滑动窗口，如果滑动窗口中的值之和大于连续子数组和，则左边界右移； // 如果滑动窗口中的值之和等于最大连续子数组和，则说明找到了一个子数组，其和加上 x 等于整个数组和，那么更新 res // 每次遍历，都需要不断移动右边界 res := math.MaxInt left, right, windowSum, subArrSum := 0, 0, 0, sum - x for right \u0026lt; size { windowSum += nums[right] for windowSum \u0026gt; subArrSum { windowSum -= nums[left] left++ } if windowSum == subArrSum { res = min(res, size - (right-left+1)) } right++ } if res == math.MaxInt { return -1 } return res } func min(a,b int) int { if a \u0026lt; b { return a } return b } "},{"id":196,"href":"/docs/algs/leetcode/1689_partitioning_into_minimum_number_of_deci-binary_numbers/","title":"1689. Partitioning Into Minimum Number of Deci-Binary Numbers","section":"Leetcode","content":" Description # A decimal number is called deci-binary if each of its digits is either 0 or 1 without any leading zeros. For example, 101 and 1100 are deci-binary, while 112 and 3001 are not.\nGiven a string n that represents a positive decimal integer, return the minimum number of positive deci-binary numbers needed so that they sum up to n.\nSolutions # 这题题主以为是要用动态规划之类的解法来做，结果想了好一会都没想出来，然后到网上去搜大神们答案，于是搜到了 这个。看完答案，我只想说，人和人真的，天壤之别\u0026hellip;\n这里的解法浓缩成一句话就是：答案就是 n 这个字符串中最大的数字（指 0-9 之间）。翻译一下大佬的证明就是：\n假设 n 中最大的数字是 x。以内 deci-binary 中只能包含 0 和 1，所以我们至少需要 x 个数字加起来才能达到数字 x（这里的意思就是，假设一个数字是 5，那么因为 deci-binary 中最大的数只能为 1，所以达到和为 5 的话，至少也需要 5 个数字，这样应该稍微好理解一些）。\n以 n = 135 为例，我们初始化 5 个 deci-binary 数（因为 135 中最大的数字是 5），每个数长度为 3（长度要与字符串 n 的长度相同，故而 3）：\na1 = 000 a2 = 000 a3 = 000 a4 = 000 a5 = 000 对于第一个数字（所谓的第一个数字，应该是指字符串 n 的第一个数字），我们把 \\(a_x \\) 前 n[0] 个数字初始化为 1；对于第二个数字，我们把前 n[1]个数字初始化为 1；同理对于第三个数字，我们把前 n[2] 个数字初始化为 1，最后有：\na1 = 111 a2 = 011 a3 = 011 a4 = 001 a5 = 001 可以发现，把这些数字加起来，可以得到 n，即 111 + 22 + 22 + 1 + 1 = 135.\n于是得证，只需要 x 个数字即可得到 n 这个数。\n时间复杂度 \\( \\Omircon(L) \\) ， 空间复杂度 \\( \\Omircon(1) \\) 。\n代码如下：\nfunc minPartitions(n string) int { var res int size := len(n) for i := 0; i \u0026lt; size; i++ { res = max(res, int(n[i] - \u0026#39;0\u0026#39;)) } return res } func max(a,b int) int { if a \u0026lt; b { return b } return a } "},{"id":197,"href":"/docs/algs/leetcode/1695_maximum_erasure_value/","title":"1695. Maximum Erasure Value","section":"Leetcode","content":" Description # You are given an array of positive integers nums and want to erase a subarray containing unique elements. The score you get by erasing the subarray is equal to the sum of its elements.\nReturn the maximum score you can get by erasing exactly one subarray.\nAn array b is called to be a subarray of a if it forms a contiguous subsequence of a, that is, if it is equal to a[l],a[l+1],\u0026hellip;,a[r] for some (l,r).\nSolutions # Sliding Window \u0026amp; Hash Table # 这题一眼可以看出来要使用滑动窗口来解。而且还是我们之前经常使用过的滑动窗口配合 Hash Table 的套路，这题的解法跟 3. Longest Substring Without Repeating Character几乎一模一样。\nfunc maximumUniqueSubarray(nums []int) int { size := len(nums) // calculate prefix sum // 前缀和用于方便计算子数组和 prefix := make([]int, size+1) for idx, num := range nums { prefix[idx+1] = num + prefix[idx] } // 注意 left 的初值，因为 left 总是取窗口左边界的前一个，所以这里只初值取-1 即可。 res,left,right := 0,-1,0 dict := make(map[int]int) for right \u0026lt; size { if idx, ok := dict[nums[right]]; ok \u0026amp;\u0026amp; idx \u0026gt; left { left = idx } res = max(res, prefix[right+1] - prefix[left+1]) dict[nums[right]] = right right++ } return res } func max(a,b int) int { if a \u0026lt; b { return b } return a } "},{"id":198,"href":"/docs/algs/codingInterviews/17_%E6%89%93%E5%8D%B0%E4%BB%8E-1-%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84-n-%E4%BD%8D%E6%95%B0/","title":"17. 打印从 1 到最大的 n 位数","section":"Coding Interviews","content":" Description # 输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。\n用返回一个整数列表来代替打印 n 为正整数，0 \u0026lt; n \u0026lt;= 5 Solutions # func printNumbers( n int ) []int { // write code here var res []int if n == 0 { return res } curMax := 0 for n \u0026gt; 0 { curMax *= 10 curMax += 9 n-- } for i := 1; i \u0026lt;= curMax; i++ { res = append(res, i) } return res } "},{"id":199,"href":"/docs/algs/codingInterviews/18_%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/","title":"18. 删除链表的节点","section":"Coding Interviews","content":" Description # 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。\n1.此题对比原题有改动 2.题目保证链表中节点的值互不相同 3.该题只会输出返回的链表和结果做对比，所以若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点\nSolutions # 这里一个非常需要注意的点就是，如果头结点也要被删除的话怎么办？如果头结点的也要被删除的话，那么判断条件就会变得比较复杂，这里的一个解决办法就是，增加一个虚拟的头结点，然后让这个虚拟的头结点指向真正的头结点，遍历的时候就从这个虚拟的头结点开始遍历，这样就能够应付真实头结点也要被删除的情况。\n不多说，直接上代码。\nfunc deleteNode( head *ListNode , val int ) *ListNode { // write code here dummpy := new(ListNode) dummpy.Next = head pre, cur := dummpy, head for cur != nil { if cur.Val == val { pre.Next = cur.Next break } pre = cur cur = cur.Next } return dummpy.Next } "},{"id":200,"href":"/docs/algs/codingInterviews/21_%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/","title":"21. 调整数组顺序使奇数位于偶数前面","section":"Coding Interviews","content":" Description # 输入一个长度为 n 整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前面部分，所有的偶数位于数组的后面部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。\n数据范围： \\($0 \\le n \\le 5000$\\) ，数组中每个数的值 \\($0 \\le val \\le 10000$\\) 要求：时间复杂度 \\($\\Omicron(n)$\\) ，空间复杂度 \\($\\Omicron(n)$\\) 进阶：时间复杂度 \\($\\Omicron(n^2)$\\) ，空间复杂度 \\($\\Omicron(1)$\\) Solutions # Array # 分别创建两个数组，一个用于存储奇数，一个用于存储偶数，然后扫描一次原数组，将奇数放入奇数数组，将偶数放入偶数数组，最后再将这两个数组拼接在一起即可。\nfunc reOrderArray( array []int ) []int { // write code here size := len(array) if size == 0 { return nil } var odd, even []int for _, num := range array { if num %2 == 0 { even = append(even, num) } else { odd = append(odd, num) } } return append(odd, even...) } In-place # 上一个方法是使用了额外的数组空间，这里还要一种不需要使用额外空间的方法：使用一个指针 cur 表示当前已经遍历到的元素，使用一个指针 odd 表示当前奇数元素应该存储的位置，odd 和 cur 初始都为 0.扫描一遍数组，当前扫描到的元素为偶数时，则 cur++，继续遍历下一个，如果当前遍历到的元素为奇数，则先保存这个元素的值到 tmp，然后将 [odd, cur-1] 的元素都后移一个位置，然后再将tmp 放到 odd 指向 位置，然后 odd 自增，cur 自增，继续下一次扫描。\n"},{"id":201,"href":"/docs/algs/codingInterviews/22_%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E6%9C%80%E5%90%8E-k-%E4%B8%AA%E8%8A%82%E7%82%B9/","title":"22. 链表中倒数最后 k 个节点","section":"Coding Interviews","content":" Description # 输入一个长度为 n 的链表，设链表中的元素的值为 ai ，返回该链表中倒数第k个节点。 如果该链表长度小于k，请返回一个长度为 0 的链表。\n数据范围： \\($0 \\leq n \\leq 10^5$\\) , \\($0 \\leq a_i \\leq 10^9$\\) ， \\($0 \\leq k \\leq 10^9$\\) 要求：空间复杂度 \\($\\Omicron(n)$\\) ，时间复杂度 \\($\\Omicron(n)$\\) 进阶：空间复杂度 \\($\\Omicron(1)$\\) ，时间复杂度 \\($\\Omicron(n)$\\) Solutions # 快慢指针 # 简答题目，不多说，直接上代码。\nfunc FindKthToTail( pHead *ListNode , k int ) *ListNode { // write code here fast, slow := pHead, pHead for k != 0 { if fast == nil { return nil } fast = fast.Next k-- } for fast != nil { fast = fast.Next slow = slow.Next } return slow } Stack # 当然也可以直接用栈来做，只是提供一个思路，详细代码就不写了。\n"},{"id":202,"href":"/docs/algs/codingInterviews/23_%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9/","title":"23. 链表中环的入口节点","section":"Coding Interviews","content":" Description # 给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。\n数据范围： \\($n\\le10000$\\) ， \\($1\u0026lt;=结点值\u0026lt;=10000$\\) 要求：空间复杂度 \\($\\Omicron(1)$\\) ，时间复杂度 \\($\\Omicron(n)$\\) Solutions # 哈希表 # 最简单的做法是， 从头到尾遍历链表，然后一个哈希表来记录已经遍历过的节点。第一个被重复遍历的节点就是我们所求的结果（前提是链表中存在环）。\nfunc EntryNodeOfLoop(pHead *ListNode) *ListNode { if pHead == nil { return nil } cur := pHead dict := make(map[*ListNode]bool) for cur != nil { if _, ok := dict[cur]; ok { return cur } dict[cur] = true cur = cur.Next } return nil } 双指针 # 通过快慢指针来解。 func EntryNodeOfLoop(pHead *ListNode) *ListNode { if pHead == nil { return nil } // 找到相遇节点 slow, fast := pHead, pHead for fast != nil \u0026amp;\u0026amp; fast.Next != nil { fast = fast.Next.Next slow = slow.Next if slow == fast { break } } // 如果链表中没有环，则返回 nil if fast == nil || fast.Next == nil { return nil } // 此时 fast 和 slow 相遇，那么只需要任意一个节点再走 X 步即可 fast = pHead for fast != slow { fast = fast.Next slow = slow.Next } return fast } "},{"id":203,"href":"/docs/algs/codingInterviews/24_%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","title":"24. 反转链表","section":"Coding Interviews","content":" Description # 给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。\n数据范围： \\($0\\leq n\\leq1000$\\) 要求：空间复杂度 \\($\\Omicron(1)$\\) ，时间复杂度 \\($\\Omicron(n)$\\) 。\nSolutions # 参考链表插入中的头插法。下面的递归反转解法中连接各个节点的方式需要注意一下：\nfunc ReverseList( pHead *ListNode ) *ListNode { // write code here return reverseListSolution3(pHead) } func reverseListSolution3(pHead *ListNode) *ListNode { // 到最后一个节点则返回 if pHead == nil || pHead.Next == nil { return pHead } // 继续反转下一个节点 newHead := reverseListSolution3(pHead.Next) // 逆转当前节点的（注意画图理解） pHead.Next.Next = pHead // 断开当前节点与下一个节点的关系 pHead.Next = nil // 返回最后一个节点作为头结点 return newHead } "},{"id":204,"href":"/docs/algs/codingInterviews/25_%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/","title":"25. 合并两个排序的链表","section":"Coding Interviews","content":" Description # 输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。 数据范围： \\($0 \\le n \\le 1000$\\) ， \\($-1000 \\le 节点值 \\le 1000$\\) 要求：空间复杂度 \\($\\Omicron(1)$\\) ，时间复杂度 \\($\\Omicron(n)$\\) Solutions # 参考归并排序，很简单。\nfunc Merge( pHead1 *ListNode , pHead2 *ListNode ) *ListNode { // write code here if pHead1 == nil { return pHead2 } if pHead2 == nil { return pHead1 } head := new(ListNode) cur := head h1, h2 := pHead1, pHead2 for h1 != nil \u0026amp;\u0026amp; h2 != nil { h := new(ListNode) if h1.Val \u0026lt; h2.Val { h.Val = h1.Val h1 = h1.Next } else { h.Val = h2.Val h2 = h2.Next } cur.Next = h cur = cur.Next } if h1 != nil { cur.Next = h1 } if h2 != nil { cur.Next = h2 } return head.Next } "},{"id":205,"href":"/docs/algs/codingInterviews/26_%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/","title":"26. 树的子结构","section":"Coding Interviews","content":" Description # 输入两棵二叉树A，B，判断B是不是A的子结构。（我们约定空树不是任意一个树的子结构）\nSolutions # 这里需要注意如何将左右节点又作为一个子问题来求解的方法。\nfunc HasSubtree( pRoot1 *TreeNode , pRoot2 *TreeNode ) bool { // write code here // 空树不是任意一个树的子结构 if pRoot2 == nil { return false } if pRoot1 == nil \u0026amp;\u0026amp; pRoot2 != nil { return false } // 判断是否是子结构 if sameTree(pRoot1, pRoot2) { return true } // 将左右节点又分别作为一个子问题 return HasSubtree(pRoot1.Left, pRoot2) || HasSubtree(pRoot1.Right, pRoot2) } func sameTree(p, q *TreeNode) bool { if p == nil \u0026amp;\u0026amp; q == nil { return true } if p != nil \u0026amp;\u0026amp; q == nil { return true } if p == nil \u0026amp;\u0026amp; q != nil { return false } if p.Val != q.Val { return false } return sameTree(p.Left, q.Left) \u0026amp;\u0026amp; sameTree(p.Right, q.Right) } "},{"id":206,"href":"/docs/algs/codingInterviews/27_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/","title":"27. 二叉树的镜像","section":"Coding Interviews","content":" Description # 操作给定的二叉树，将其变换为源二叉树的镜像。 数据范围：二叉树的节点数 \\($0 \\le n \\le 1000$\\) ， 二叉树每个节点的值 \\($0\\le val \\le 1000$\\) 。 要求： 空间复杂度 \\($\\Omicron(n)$\\) 。本题也有原地操作，即空间复杂度 \\($\\Omicron(1)$\\) 的解法，时间复杂度 \\($\\Omicron(n)$\\) Solutions # 简单题，左右节点交换即可，直接上代码。\nfunc Mirror( pRoot *TreeNode ) *TreeNode { // write code here if pRoot == nil { return nil } pRoot.Right, pRoot.Left = Mirror(pRoot.Left), Mirror(pRoot.Right) return pRoot } "},{"id":207,"href":"/docs/algs/codingInterviews/28_%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"28. 对称的二叉树","section":"Coding Interviews","content":" Description # 给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）\nSolutions # Recursive # func isSymmetrical( pRoot *TreeNode ) bool { // write code here if pRoot == nil { return true } return isSameTree(pRoot.Left, pRoot.Right) } func isSameTree(root1, root2 *TreeNode) bool { if root1 == nil \u0026amp;\u0026amp; root2 == nil { return true } if root1 == nil || root2 == nil { return false } if root1.Val != root2.Val { return false } return isSameTree(root1.Left, root2.Right) \u0026amp;\u0026amp; isSameTree(root1.Right, root2.Left) } "},{"id":208,"href":"/docs/algs/codingInterviews/29_%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/","title":"29. 顺时针打印矩阵","section":"Coding Interviews","content":" Description # 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： [[1,2,3,4], [5,6,7,8], [9,10,11,12], [13,14,15,16]] 则依次打印出数字 [1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10]\n数据范围: \\($0 \\le matrix.length \\le 100$\\) \\($0 \\le matrix[i].length \\le 100$\\) Solutions # 老面孔了，不多介绍。\nfunc printMatrix( matrix [][]int ) []int { // write code here var res []int m, n := len(matrix), len(matrix[0]) top, down, left, right := 0, m-1, 0, n-1 for top \u0026lt;= down \u0026amp;\u0026amp; left \u0026lt;= right {\t// 注意这里是等号，从而让只有一行/列的时候也能进入循环 for i := left; i \u0026lt;= right; i++ { res = append(res, matrix[top][i]) } // 避免上下重合 top++ if top \u0026gt; down { break } for i := top; i \u0026lt;= down; i++ { res = append(res, matrix[i][right]) } // 避免左右重合 right-- if right \u0026lt; left { break } for i := right; i \u0026gt;= left; i-- { res = append(res, matrix[down][i]) } // 避免上下重合 down-- if down \u0026lt; top { break } for i := down; i \u0026gt;= top; i-- { res = append(res, matrix[i][left]) } // 避免左右重合 left++ if left \u0026gt; right { break } } return res } "},{"id":209,"href":"/docs/algs/codingInterviews/30_%E5%8C%85%E5%90%AB-min-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/","title":"30. 包含 min 函数的栈","section":"Coding Interviews","content":" Description # 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数，输入操作时保证 pop、top 和 min 函数操作时，栈中一定有元素。\n此栈包含的方法有： push(value):将value压入栈中 pop():弹出栈顶元素 top():获取栈顶元素 min():获取栈中最小元素\n数据范围：操作数量满足 \\($0 \\le n \\le 300$\\) ，输入的元素满足 \\($|val| \\le 10000$\\) 进阶：栈的各个操作的时间复杂度是 \\($\\Omicron(1)$\\) ，空间复杂度是 \\($\\Omicron(n)$\\) 。\nSolutions # Stack # 使用两个栈，一个栈stack1用于正常压入和弹出，另一个栈stack2用于实现单调栈。当压入一个元素时，如果当前元素比 stack2 的栈顶元素还要大，则将当前元素压入 stack1 的同时，还将当前元素压入 stack2，如果当前元素不比 stack2 的栈顶元素要大，则将 stack2 的栈顶元素重复入栈。当弹出元素时，将 stack1 和 stack2 的栈顶元素同步弹出。当获取最小值时，只需要取出 stack2 的栈顶元素即可。\n// 用于实现正常的 push 与 pop 操作 var stack1 []int // 用于存储最小值 var stack2 []int func Push(node int) { // write code here stack1 = append(stack1, node) size := len(stack2) if size == 0 || stack2[size-1] \u0026gt; node { stack2 = append(stack2, node) } else { stack2 = append(stack2, stack2[size-1]) } } func Pop() { // write code here size := len(stack1) stack1 = stack1[:size-1] stack2 = stack2[:size-1] } func Top() int { // write code here size := len(stack1) return stack1[size-1] } func Min() int { // write code here size := len(stack2) return stack2[size-1] } "},{"id":210,"href":"/docs/algs/codingInterviews/31_%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/","title":"31. 栈的压入弹出序列","section":"Coding Interviews","content":" Description # 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。\nSolutions # 栈模拟 # 新建一个栈来模拟出栈序列。使用一个指针 inPos 指向当前入栈序列的单签入栈元素，使用另一个指针 outPos 指向出栈序列当前应该出栈的元素，然后开始模拟出入栈。\n首先，如果当前栈顶元素和出栈序列匹配，则出栈栈顶元素，并且将 outPos 右移，直到二者不匹配或者栈为空 将 inPos 指针指向的入栈序列的元素入栈，然后将 inPos 右移。 不断循环上述过程，直到入栈序列中的所有元素都入栈。 最后判断是否出栈序列中的所有元素都已经匹配完成即可。 func IsPopOrder( pushV []int , popV []int ) bool { // write code here size := len(pushV) if size == 0 { return true } var stack []int stack = append(stack, pushV[0]) inPos, outPos := 1, 0 // 为什么这里的循环用的是 \u0026lt;= ，而不是 \u0026lt; ？ // 因为有可能我们一直从入栈序列中入栈的操作，直到所有元素都已经入栈。如果只使用 \u0026lt; 符号的话， // 我们就无法判断出栈序列是否和栈顶元素匹配（当然你也可以在 for 循环之后再加上这一步，只不过加 // 上这个=号之后可以少写一点代码）. for inPos \u0026lt;= size { // 如果栈顶元素和出栈序列当前元素匹配，则可以一直出栈 s := len(stack) for s \u0026gt; 0 \u0026amp;\u0026amp; popV[outPos] == stack[s-1] { stack = stack[:s-1] s-- outPos++ } // 为什么这里要有个 break ? // 很明显，当入栈序列已经全部入栈了时，我们需要跳出这个循环 if inPos == size { break } // 当前栈中没有元素和出栈序列匹配，或者栈已经为空，则将入栈序列入栈 stack = append(stack, pushV[inPos]) inPos++ } // 入栈序列遍历完之后，如果此时栈中的元素个数为0，则说明是有效序列； // 否则如果栈中还有元素，则说明是无效序列。 return len(stack) == 0 \u0026amp;\u0026amp; outPos == size } "},{"id":211,"href":"/docs/algs/codingInterviews/32_%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"32. 从上往下打印二叉树","section":"Coding Interviews","content":" Description # 不分行从上往下打印出二叉树的每个节点，同层节点从左至右打印\nSolutions # 层次遍历即可，直接上代码。\nfunc PrintFromTopToBottom( root *TreeNode ) []int { // write code here var res []int if root == nil { return res } var queue []*TreeNode queue = append(queue, root) for len(queue) != 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[i] if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } res = append(res, node.Val) } queue = queue[size:] } return res } "},{"id":212,"href":"/docs/algs/codingInterviews/33_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/","title":"33. 二叉搜索树的后序遍历序列","section":"Coding Interviews","content":" Description # 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回 true ,否则返回 false。假设输入的数组的任意两个数字都互不相同。\n数据范围： 节点数量 \\($0 \\le n \\le 1000$\\) ，节点上的值满足 \\($1 \\le val \\le 10^{5}$\\) ，保证节点上的值各不相同 要求：空间复杂度 O(n)O(n) ，时间时间复杂度 \\($\\Omicron(n^2)$\\) Solutions # 后序遍历具有“左右根”的结构，而因为这里是二叉搜索树，那么必然有左子树所有元素比根小，右子树所有元素比根大，那么我们只需要确定根所在的位置，然后从该位置向左查找，直到第一个比根小的元素，然后从该元素往左都是左子树，从该元素下一个位置到根元素的前一个位置都是右子树的元素，然后只需要检查左子树是否比根元素小，右子树是否比根元素大，然后递归检查左子树和有右子树即可。\nfunc VerifySquenceOfBST(sequence []int ) bool { // write code here size := len(sequence) if size == 0 { return false } return helper(sequence, 0, size-1) } func helper(sequence []int, left, right int) bool { if left \u0026gt;= right { return true } root := sequence[right] sep := right-1 for sep \u0026gt;= 0 \u0026amp;\u0026amp; sequence[sep] \u0026gt; root { sep-- } for i := 0; i \u0026lt;= sep; i++ { if sequence[i] \u0026gt; root { return false } } return helper(sequence, left, sep) \u0026amp;\u0026amp; helper(sequence, sep+1, right-1) } "},{"id":213,"href":"/docs/algs/codingInterviews/34_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E4%BA%8C/","title":"34. 二叉树中和为某一值的路径（二）","section":"Coding Interviews","content":" Description # 输入一颗二叉树的根节点root和一个整数expectNumber，找出二叉树中结点值的和为expectNumber的所有路径。 1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点 2.叶子节点是指没有子节点的节点 3.路径只能从父节点到子节点，不能从子节点到父节点 4.总节点数目为n\nSolutions # 因为这里的路径要求是从根节点到叶子节点的，所以也很简单，直接回溯即可。但是需要注意的是，下面这种通过 expectedNum - root.Val 的方式能够减少额外维护一个当前路径上的元素组成的数组的开销，很值得推荐。\nfunc FindPath( root *TreeNode , expectNumber int ) [][]int { // write code here var res [][]int if root == nil { return res } var nums []int findPathHelper(root, expectNumber, nums, \u0026amp;res) return res } func findPathHelper(root *TreeNode, expecteNumber int, nums []int, res *[][]int) { if root == nil { return } // 这里能够减少单独再维护一个数组的开销，很值得推荐 nums = append(nums, root.Val) expecteNumber -= root.Val if expecteNumber == 0 \u0026amp;\u0026amp; root.Left == nil \u0026amp;\u0026amp; root.Right == nil { tmp := make([]int, len(nums)) copy(tmp, nums) *res = append(*res, tmp) return } findPathHelper(root.Left, expecteNumber, nums, res) findPathHelper(root.Right, expecteNumber, nums, res) size := len(nums) nums = nums[:size-1] } "},{"id":214,"href":"/docs/algs/codingInterviews/35_%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/","title":"35. 复杂链表的复制","section":"Coding Interviews","content":" Description # 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）。 下图是一个含有5个结点的复杂链表。图中实线箭头表示next指针，虚线箭头表示random指针。为简单起见，指向null的指针没有画出。\nSolutions # 链表或者图的复制非常适合用哈希表来做。\nfunc Clone( head *RandomListNode ) *RandomListNode { //write your code here if head == nil { return nil } dict := make(map[*RandomListNode]*RandomListNode) p := head for p != nil { node := new(RandomListNode) node.Label = p.Label dict[p] = node p = p.Next } p = head for p != nil { dict[p].Next = dict[p.Next] dict[p].Random = dict[p.Random] p = p.Next } return dict[head] } "},{"id":215,"href":"/docs/algs/codingInterviews/36_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/","title":"36. 二叉搜索树与双向链表","section":"Coding Interviews","content":" Description # 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。 注意: 1.要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继 2.返回链表中的第一个节点的指针 3.函数返回的TreeNode，有左右指针，其实可以看成一个双向链表的数据结构 4.你不用输出双向链表，程序会根据你的返回值自动打印输出\nSolutions # 这里的解法还是很巧妙的，需要多多注意。\nvar head, pre *TreeNode func Convert( pRootOfTree *TreeNode ) *TreeNode { // write code here if pRootOfTree == nil { return pRootOfTree } convertHelper(pRootOfTree) return head } // 这里就是一个中序遍历 func convertHelper(cur *TreeNode) { if cur == nil { return } convertHelper(cur.Left) // 如果 pre 为空，说明已经遍历到了最左节点，那么这个节点很明显就是头结点。 // 如果 pre 不为空，说明此时遍历到的不是最左节点，而是其他的一般节点，那么此时就需要做一个连接 if pre == nil { head = cur } else { pre.Right = cur cur.Left = pre } pre = cur convertHelper(cur.Right) } "},{"id":216,"href":"/docs/algs/codingInterviews/37_%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"37. 序列化二叉树","section":"Coding Interviews","content":" Description # 请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树。\n二叉树的序列化(Serialize)是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树等遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#）\n二叉树的反序列化(Deserialize)是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。\nSolutions # PreOrder Traversal # 采用先序遍历的方式进行序列化，同样采用先序遍历的方式进行反序列化。\nvar emptyNode string = \u0026#34;#\u0026#34; var seperator string = \u0026#34; \u0026#34; func Serialize( root *TreeNode ) string { // write code here if root == nil { return \u0026#34;\u0026#34; } var res []string _serialize(root, \u0026amp;res) return strings.Join(res, seperator) } func _serialize(root *TreeNode, res *[]string) { if root != nil { v := strconv.Itoa(root.Val) *res = append(*res, v) _serialize(root.Left, res) _serialize(root.Right, res) } else { // 递归是收敛的 *res = append(*res, emptyNode) } } func Deserialize( s string ) *TreeNode { // write code here if len(s) == 0 { return nil } values := strings.Split(s, seperator) return _deserialize(\u0026amp;values) } func _deserialize(values *[]string) *TreeNode { // 注意这里，为什么这里不会出现数组越界访问呢，也就是说，你是如何保证数组里一定会有元素的呢？ // 其实在序列化的时候，对于每一条路径，我们最后会走到的节点不是叶子节点，而是该叶子节点的两个空子节点。 // 那么也就是说，序列化后的字符的最后一个字符一定是 \u0026#34;#\u0026#34; 符号，代表走到空节点，那么一定也会在下面的第一个 if 后即递归终止，那么肯定就不会出现数组越界访问的情况。 s := (*values)[0] *values = (*values)[1:] // 递归是收敛的 if s == emptyNode { return nil } v, _ := strconv.Atoi(s) root := new(TreeNode) root.Val = v root.Left = _deserialize(values) root.Right = _deserialize(values) return root } Level Order Traversal # 基于层次遍历的思想，但是需要将序列化的顺序和反序列化的顺序一一对应起来。序列化时，如果该节点非空，则将节点值序列化，然后将其左右子节点入队，如果节点为空，则用特定的字符来代替。反序列化时，也是使用层次遍历的方式，先是使用一个节点作为根节点，然后将其入队，然后不断从队列中取出节点来更新其子节点。从字符串中取值的时候，如果当前取到的值代表是一个空节点，则可以直接跳过。\n注意领会，这里序列化和反序列的顺序其实是一一对应的。\nfunc Serialize( root *TreeNode ) string { // write code here if root == nil { return \u0026#34;\u0026#34; } var res []string emptyNode := \u0026#34;#\u0026#34; seperator := \u0026#34; \u0026#34; var queue []*TreeNode queue = append(queue, root) for len(queue) != 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[i] if node != nil { s := strconv.Itoa(node.Val) res = append(res, s) queue = append(queue, node.Left) queue = append(queue, node.Right) } else { res = append(res, emptyNode) } } queue = queue[size:] } return strings.Join(res, seperator) } func Deserialize( s string ) *TreeNode { // write code here if len(s) == 0 { return nil } seperator := \u0026#34; \u0026#34; emptyNode := \u0026#34;#\u0026#34; nodes := strings.Split(s, seperator) root := new(TreeNode) root.Val,_ = strconv.Atoi(nodes[0]) nodes = nodes[1:] var queue []*TreeNode queue = append(queue, root) for len(queue) != 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[i] val := nodes[0] nodes = nodes[1:] if val != emptyNode { v,_ := strconv.Atoi(val) tmp := new(TreeNode) tmp.Val = v node.Left = tmp queue = append(queue, tmp) } val = nodes[0] nodes = nodes[1:] if val != emptyNode { v,_ := strconv.Atoi(val) tmp := new(TreeNode) tmp.Val = v node.Right = tmp queue = append(queue, tmp) } } queue = queue[size:] } return root } "},{"id":217,"href":"/docs/algs/codingInterviews/38_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/","title":"38. 字符串的排列","section":"Coding Interviews","content":" Description # 输入一个长度为 n 字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组。\n例如输入字符串ABC,则输出由字符A,B,C所能排列出来的所有字符串ABC,ACB,BAC,BCA,CBA和CAB。\nSolutions # 使用全排列的思想来做。\nfunc Permutation( str string ) []string { // write code here var res []string size := len(str) if size == 0 { return res } dict := make(map[string]bool) permutate([]rune(str), 0, size, \u0026amp;dict) for key, _ := range dict { res = append(res, key) } return res } func permutate(str []rune, start int, size int, dict *map[string]bool) { if start == size { s := string(str) if _, ok := (*dict)[s]; !ok { (*dict)[s] = true } return } for i := start; i \u0026lt; size; i++ { str[start], str[i] = str[i], str[start] // 注意这里是 start + 1 而不是 i+1 permutate(str, start+1, size, dict) // 交换之后要还原 str[start], str[i] = str[i], str[start] } } "},{"id":218,"href":"/docs/algs/codingInterviews/39_%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/","title":"39. 数组中出现次数超过一半的数字","section":"Coding Interviews","content":" Description # 给一个长度为 n 的数组，数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。\n数据范围： \\($n \\le 50000$\\) ，数组中元素的值 \\($0 \\le val \\le 10000$\\) 要求：空间复杂度： \\($\\Omicron(1)$\\) ，时间复杂度 \\($\\Omicron(n)$\\) Solutions # 使用一个数字 cur 表示当前已经遍历到的元素，使用 cnt 表示当前 cur 出现次数。遍历一次数组，每当 cnt \u0026lt;= 0 时，则将 cur 更新为当前扫描到的元素，如果当前扫描的元素 num 不等于 cur， 那么 cnt \u0026ndash;，如果相等，则 cnt++，最后剩下的这个 cur 必然是多数元素。\n因为多数元素出现次数超过一半，所以扫描时，少数元素会把多数元素的出现次数给抵消掉，但是无论怎么抵消，多数元素的出现次数还是比所有少数元素的出现次数要少，所以最后剩下的元素一定是那个多数元素。\nfunc MoreThanHalfNum_Solution( numbers []int ) int { // write code here var cnt int cur := -1 for _, num := range numbers { if cnt \u0026lt;= 0 { cur = num cnt = 1 } else if num == cur { cnt++ } else if num != cur { cnt-- } } return cur } "},{"id":219,"href":"/docs/algs/codingInterviews/40_%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E4%B8%AA%E6%95%B0/","title":"40. 最小的 k 个数","section":"Coding Interviews","content":" Description # 给定一个长度为 n 的可能有重复值的数组，找出其中不去重的最小的 k 个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4(任意顺序皆可)。 数据范围： \\($0\\le k,n \\le 10000$\\) ，数组中每个数的大小 \\($0 \\le val \\le 1000$\\) 要求：空间复杂度 \\($\\Omicron(n)$\\) ，时间复杂度 \\($\\Omicron(n\\log n)$\\) Solutions # Min Heap # 使用最小堆的思想来做。把元素不断地压入堆中，然后再将前 k 个元素出堆即可。\nimport \u0026#34;container/heap\u0026#34; /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * @param input int整型一维数组 * @param k int整型 * @return int整型一维数组 */ func GetLeastNumbers_Solution( input []int , k int ) []int { // write code here var minHeap MinHeap var res []int heap.Init(\u0026amp;minHeap) for _, value := range input { heap.Push(\u0026amp;minHeap, value) } for i := 0; i \u0026lt; k; i++ { x := heap.Pop(\u0026amp;minHeap) res = append(res, x.(int)) } return res } //********** min heap ************** type MinHeap []int func (m MinHeap) Less (i,j int) bool { return m[i] \u0026lt; m[j] } func (m MinHeap) Len() int { return len(m) } func (m MinHeap) Swap(i,j int) { m[i], m[j] = m[j],m[i] } func (m *MinHeap) Push(x interface{}) { *m = append(*m, x.(int)) } func (m *MinHeap) Pop() interface {} { x := (*m)[m.Len()-1] *m = (*m)[:m.Len()-1] return x } Quick Sort # 因为快排每次都会选中一个元素作为 pivot，然后将比 pivot 小的元素放到左边，将比 pivot 大的元素放到右边，然后返回 pivot 这个元素最终所在的 index。也就是说，idnex 之前的元素都是比 pivot 要小的元素，那么只要这个 pivot 等于 k -1， 然后返回 nums[:k]即可。\n"},{"id":220,"href":"/docs/algs/codingInterviews/41_%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","title":"41. 数据流中的中位数","section":"Coding Interviews","content":" Description # 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。\n数据范围：数据流中数个数满足 \\($1 \\le n \\le 1000$\\) ，大小满足 \\($1 \\le val \\le 1000$\\) 进阶： 空间复杂度 \\($\\Omicron(n)$\\) ， 时间复杂度 \\($\\Omicron(n\\log n)$\\) Solutions # Heap # 分别维持一个大根堆和小根堆，大根堆存储 median 左边的元素，小根堆存储 median 右边的元素，每当新来一个元素，优先放在右边小根堆，然后将小根堆堆顶元素放入大根堆。如果右边小根堆元素数量小于左边大根堆元素数量，那么将右边小根堆堆顶元素弹出并压入左边大根堆中，这样就能维持左边大根堆数量至多比右边小根堆数量多一个。\ntype MedianFinder struct { minHeap MinHeapArr maxHeap MaxHeap } func Constructor() MedianFinder { var minHeap MinHeapArr var maxHeap MaxHeap heap.Init(\u0026amp;minHeap) heap.Init(\u0026amp;maxHeap) return MedianFinder{ minHeap: minHeap, maxHeap: maxHeap, } } func (this *MedianFinder) AddNum(num int) { // 关键还是在这里的调整，这里的调整保证了左边大根堆的元素数量至多比右边小根堆的数量多一个：当元素总数为偶数时，二者相等；为奇数时，左边比右边大 1 heap.Push(\u0026amp;(*this).minHeap, num) heap.Push(\u0026amp;(*this).maxHeap, heap.Pop(\u0026amp;this.minHeap)) if (*this).minHeap.Len() \u0026lt; (*this).maxHeap.Len() { heap.Push(\u0026amp;this.minHeap, heap.Pop(\u0026amp;this.maxHeap)) } } func (this *MedianFinder) FindMedian() float64 { if this.minHeap.Len() \u0026gt; this.maxHeap.Len() { x := heap.Pop(\u0026amp;this.minHeap).(int) heap.Push(\u0026amp;this.minHeap, x) return float64(x) } else { x := heap.Pop(\u0026amp;this.minHeap).(int) heap.Push(\u0026amp;this.minHeap, x) y := heap.Pop(\u0026amp;this.maxHeap).(int) heap.Push(\u0026amp;this.maxHeap, y) return float64(x+y) / 2 } } //--------------- max heap ---------------------- type MaxHeap []int func (h MaxHeap) Len() int { return len(h) } func (h MaxHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h MaxHeap) Less(i, j int) bool { return h[i] \u0026gt; h[j] } func (h *MaxHeap) Push(x interface{}) { *h = append(*h, x.(int)) } func (h *MaxHeap) Pop() interface{} { size := h.Len() if size == 0 { return -1 } x := (*h)[size-1] *h = (*h)[:size-1] return x } //************** min heap ************************** type MinHeapArr []int func (h MinHeapArr) Len() int { return len(h) } func (h MinHeapArr) Less(i, j int) bool { return h[i] \u0026lt; h[j] } func (h MinHeapArr) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *MinHeapArr) Push(x interface{}) { *h = append(*h, x.(int)) } func (h *MinHeapArr) Pop() interface{} { size := len(*h) res := (*h)[size-1] *h = (*h)[:size-1] return res } "},{"id":221,"href":"/docs/algs/codingInterviews/42_%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/","title":"42. 连续子数组的最大和","section":"Coding Interviews","content":" Description # 输入一个长度为n的整型数组array，数组中的一个或连续多个整数组成一个子数组，子数组最小长度为1。求所有子数组的和的最大值。\nSolutions # Kadane 方法 # 参见这个 链接， 已经有现成的 \\($\\Omicron(n)$\\) 方法。\npackage main import \u0026#34;math\u0026#34; /** * * @param array int整型一维数组 * @return int整型 */ func FindGreatestSumOfSubArray( array []int ) int { // write code here size := len(array) if size == 0 { return 0 } sum := int(math.MinInt32) res := sum for i := 0; i \u0026lt; size; i++ { sum = max(array[i], sum+array[i]) res = max(res, sum) } return res } func max(a,b int) int { if a \u0026lt; b { return b } return a } 动态规划 # 定义 dp[i] 表示以 i 为结尾的连续子数组的最大和，则很明显，dp[i] 的值受到 dp[i-1] 和 array[i] 的影响，稍微一想即可得到转态转移方程： \\($dp[i] = \\max (dp[i-1] \u0026#43; array[i], array[i])$\\) func FindGreatestSumOfSubArray( array []int ) int { // write code here size := len(array) if size == 0 { return 0 } res := array[0] dp := make([]int, size) dp[0] = array[0] for i := 1; i \u0026lt; size; i++ { dp[i] = max(dp[i-1]+array[i], array[i]) res = max(res, dp[i]) } return res } func max(a,b int) int { if a \u0026lt; b { return b } return a } "},{"id":222,"href":"/docs/algs/codingInterviews/43_%E6%95%B4%E6%95%B0%E4%B8%AD-1-%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/","title":"43. 整数中 1 出现的次数","section":"Coding Interviews","content":" Description # 输入一个整数 n ，求 1～n 这 n 个整数的十进制表示中 1 出现的次数 例如， 1~13 中包含 1 的数字有 1 、 10 、 11 、 12 、 13 因此共出现 6 次\n注意：11 这种情况算两次\n数据范围： \\($1 \\le n \\le 30000$\\) 进阶：空间复杂度 \\($\\Omicron(1)$\\) ，时间复杂度 \\($\\Omicron(n\\log n)$\\) Solutions # TODO\n"},{"id":223,"href":"/docs/algs/codingInterviews/45_%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/","title":"45. 把数组排成最小的数","section":"Coding Interviews","content":" Description # 输入一个非负整数数组numbers，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 例如输入数组[3，32，321]，则打印出这三个数字能排成的最小数字为321323。 1.输出结果可能非常大，所以你需要返回一个字符串而不是整数 2.拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0\n数据范围: \\($0\u0026lt;=len(numbers)\u0026lt;=100$\\) Solutions # 这里的解法比较巧妙，如果没有做过这个题目的话，第一次碰到应该很难做出来。在 golang 中，我们对数组排序的时候可以指定一个 less 函数，来表明我们希望的排序策略，比如说 4 \u0026lt; 5， 那么 4 应该排在 5 前面。而这里涉及到的是字符串拼接，对于 \u0026ldquo;bc\u0026rdquo; 和 \u0026ldquo;bca\u0026rdquo; 这两个字符串，一般的排序方法会把 bc 排到 bca 前面，这样就会出现 \u0026ldquo;bcbca\u0026rdquo; 这个字符，很明显这不是最小的。这里单独排序一个字符显然是不行的，我们的解决办法是对两个字符的不同拼接进行比较，这样就可以确定什么样的拼接能够放在前面，这样的拼接导致的整体字符串的字典序更小一些。\nfunc PrintMinNumber( numbers []int ) string { // write code here var res string size := len(numbers) if size == 0 { return res } var strs []string for _, value := range numbers { s := strconv.Itoa(value) strs = append(strs, s) } sort.Slice(strs, func(i, j int) bool { return strs[i] + strs[j] \u0026lt; strs[j] + strs[i] }) res = strings.Join(strs, \u0026#34;\u0026#34;) return res } "},{"id":224,"href":"/docs/algs/codingInterviews/46_%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"46. 把数字翻译成字符串","section":"Coding Interviews","content":" Description # 有一种将字母编码成数字的方式：\u0026lsquo;a\u0026rsquo;-\u0026gt;1, \u0026lsquo;b-\u0026gt;2\u0026rsquo;, \u0026hellip; , \u0026lsquo;z-\u0026gt;26\u0026rsquo;。 我们把一个字符串编码成一串数字，再考虑逆向编译成字符串。 由于没有分隔符，数字编码成字母可能有多种编译结果，例如 11 既可以看做是两个 \u0026lsquo;a\u0026rsquo; 也可以看做是一个 \u0026lsquo;k\u0026rsquo; 。但 10 只可能是 \u0026lsquo;j\u0026rsquo; ，因为 0 不能编译成任何结果。 现在给一串数字，返回有多少种可能的译码结果\nSolutions # Recursive # func solve( nums string ) int { // write code here var res int size := len(nums) if size == 0 { return 0 } helper(nums, \u0026amp;res) return res } func helper(nums string, res *int) { size := len(nums) if size == 0 { *res += 1 return } // 如果开头字符是 0， 那么说明只是一次不合法的拆分在，直接返回即可 if nums[0] == \u0026#39;0\u0026#39; { return } // 如果可能将连个字符放在一起，则将两个字符放在一起 if size \u0026gt;= 2 \u0026amp;\u0026amp; nums[:2] \u0026gt;= \u0026#34;10\u0026#34; \u0026amp;\u0026amp; nums[:2] \u0026lt;= \u0026#34;26\u0026#34; { helper(nums[2:], res) } // 永远可以拆分为单个字符 helper(nums[1:], res) } Dynamic Programming # 定义 dp(i) 表示以第 i 位结尾的前缀串翻译的方案数，初始化 dp[0] = dp[1] = 1, 可以得出递推方程： \\(dp[i]=\\begin{cases} dp[i-2] \u0026#43; dp[i-1], \u0026amp; 10 \\le nums[i-2: i] \\le 25 \\\\ dp[i-1], \u0026amp; else \\end{cases}\\) "},{"id":225,"href":"/docs/algs/codingInterviews/47_%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/","title":"47. 礼物的最大价值","section":"Coding Interviews","content":" Description # 在一个m\\times nm×n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？ 如输入这样的一个二维数组， [ [1,3,1], [1,5,1], [4,2,1] ] 那么路径 1→3→5→2→1 可以拿到最多价值的礼物，价值为12\nSolutions # Dynamic Programming # 定义 dp[i][j] 表示在 grid[i][j] 所能得到的最大礼物值，则很明显，dp[i][j]的值要么是从左边转移得到的，要么是从上侧转移得到的，则可以得到递推方程 dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1])。base case 的话，很明显，第一行的数据只能从左边得到，第一列数据只能从上侧得到。我们可以直接复用原数组，这样还能节省一下空间开销。\nfunc maxValue( grid [][]int ) int { // write code here m,n := len(grid), len(grid[0]) // 如果我们开辟一个 (m+1) * (n+1) 的数组，那么下面这两个 for 语句就不需要了，代码可以更加简洁。 // 第一列只能来自上方 for i := 1; i \u0026lt; m; i++ { grid[i][0] += grid[i-1][0] } // 第一行只能来自左边 for i := 1; i \u0026lt; n; i++ { grid[0][i] += grid[0][i-1] } for i := 1; i \u0026lt; m; i++ { for j := 1; j \u0026lt; n; j++ { grid[i][j] = grid[i][j] + max(grid[i-1][j], grid[i][j-1]) } } return grid[m-1][n-1] } "},{"id":226,"href":"/docs/algs/codingInterviews/48_%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"48. 最长不含重复字符的子字符串","section":"Coding Interviews","content":" Description # 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。 数据范围: \\($\\text{s.length}\\le 40000$\\) Solutions # 滑动窗口 # func lengthOfLongestSubstring( s string ) int { // write code here size := len(s) if size \u0026lt;= 1 { return size } res, start := 1, -1 dict := make(map[byte]int) // 这里用等号主要是因为当最后几个字符串都不重复时，如果不在这里加上一个等号，则可能会缺少一次计算，从而导致结果不准确。 // 下面的第一个 if 也是为了跟这种情况搭配才加上的。 for i := 0; i \u0026lt;= size; i++ { if i == size { res = max(res, i - start - 1) break } if index, ok := dict[s[i]]; ok \u0026amp;\u0026amp; index \u0026gt; start { res = max(res, i - start - 1) start = index } dict[s[i]] = i } return res } func max(a,b int) int { if a \u0026lt; b { return b } return a } 下面是上面这种解法的更简介写法：\nfunc lengthOfLongestSubstring( s string ) int { // write code here size := len(s) if size \u0026lt;= 1 { return size } // 处理 corner case， 最少会有一个不重复子串 // 注意 start 初始赋值为-1而不是 0，因为窗口的左边界是从 0 开始计算的 res, start := 1, -1 dict := make(map[byte]int) for i := 0; i \u0026lt; size; i++ { // 当出现重复字符时，就更新滑动窗口左边界 // 注意这里为什么要加上一个 index \u0026gt; start 的判断条件：因为这是一个 map，有的字符可能之前已经出现过了， // 但是这个字符可能并没有出现在我们正在维持的滑动窗口中，所以要把这种情况给排除 if index, ok := dict[s[i]]; ok \u0026amp;\u0026amp; index \u0026gt; start { start = index } // 不断扩展窗口右边界 dict[s[i]] = i // 持续扩大滑动窗口最大值 res = max(res, i - start) } return res } func max(a,b int) int { if a \u0026lt; b { return b } return a } "},{"id":227,"href":"/docs/algs/codingInterviews/49_%E4%B8%91%E6%95%B0/","title":"49. 丑数","section":"Coding Interviews","content":" Description # 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第 n个丑数。\n数据范围： \\($0 \\le n \\le 2000$\\) 要求：空间复杂度 \\($\\Omicron(n)$\\) ， 时间复杂度 \\($\\Omicron(n)$\\) Solutions # 很明显丑数只会是可以用 \\($2^x*3^y*5^z$\\) 表示的一个数字。分别表示从 1 开始乘 2、3、5 的三条丑数队列，每次从这三个丑数队列中取出最小的数字来作为我们当前得到的最小丑数，然后更新那个贡献了这个数字的丑数队列的下一个值。更精简的做法是，我们可以直接维护三个指针 i2、i3、 i5, 来表示这个三个队列。\nfunc GetUglyNumber_Solution( index int ) int { // write code here if index == 0 { return 0 } var i2, i3, i5 int res := make([]int, index) res[0] = 1 for i := 1; i \u0026lt; index; i++ { // 取出当前队列的最小值 res[i] = min(res[i2]*2, min(res[i3]*3, res[i5]*5)) // 如果是这个队列贡献了这个值，那么更新队列元素 if res[i] == res[i2]*2 { i2++ } if res[i] == res[i3] * 3 { i3++ } if res[i] == res[i5] * 5 { i5++ } } return res[index-1] } func min(a,b int) int { if a \u0026lt; b { return a } return b } "},{"id":228,"href":"/docs/algs/codingInterviews/50_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/","title":"50. 第一个只出现一次的字符","section":"Coding Interviews","content":" Description # 在一个长为 字符串中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）\n数据范围： \\($0 \\le n \\le 10000$\\) ，且字符串只有字母组成。 要求：空间复杂度 \\($\\Omicron(n)$\\) ，时间复杂度 \\($\\Omicron(n)$\\) Solutions # Hash Table # 使用一个 hash table 记录每个字符出现的次数，然后再从头扫描一次 str，遇到第一个出现次数为 1 的字符则返回其下标；否则返回-1.\nfunc FirstNotRepeatingChar( str string ) int { // write code here size := len(str) if size == 0 { return -1 } dict := make(map[byte]int) for idx, _ := range str { dict[str[idx]]++ } for idx, _ := range str { if cnt, _ := dict[str[idx]]; cnt == 1 { return idx } } return -1 } "},{"id":229,"href":"/docs/algs/codingInterviews/51_%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/","title":"51. 数组中的逆序对","section":"Coding Interviews","content":" Description # 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P mod 1000000007\n数据范围： 对于 \\($50\\%$\\) 的数据, \\($size \\leq 10^4$\\) 对于 \\($100\\%$\\) 的数据, \\($size\\leq 10^5$\\) 数组中所有数字的值满足 \\($0 \\le val \\le 1000000$\\) 要求：空间复杂度 \\($\\Omicron(n)$\\) ，时间复杂度 \\($\\Omicron(n \\log n)$\\) Solutions # 如果两个区间为[4, 3] 和[1, 2], 那么逆序数为(4,1),(4,2),(3,1),(3,2)，同样的如果区间变为有序，比如[3,4] 和 [1,2], 那么逆序数也是一样的，也就是说区间有序和无序结果是一样的。但是区间有序带来的好处是，比如[3,4] 和 [1,2]，如果3 \u0026gt; 1, 显然3后面的所有数都大于1，那么逆序对计算就会方便很多。\nMerge Sort # const MOD int = 1000000007 func InversePairs( data []int ) int { // write code here var res int size := len(data) if size \u0026lt;= 1 { return res } tmp := make([]int, size) mergeSort(data, tmp, 0, size-1, \u0026amp;res) return res } func mergeSort(nums,tmp []int, start, end int, res *int) { if start \u0026gt;= end { return } mid := (start + end)/2 mergeSort(nums, tmp, start, mid, res) mergeSort(nums, tmp, mid+1, end, res) merge(nums, tmp, start, mid, end, res) } func merge(nums,tmp []int, start, mid, end int, res *int) { left, right := start, mid+1 var idx int for left \u0026lt;= mid \u0026amp;\u0026amp; right \u0026lt;= end { if nums[left] \u0026gt; nums[right] { tmp[idx] = nums[right] right++ *res += mid - left + 1 *res %= MOD } else { tmp[idx] = nums[left] left++ } idx++ } for left \u0026lt;= mid { tmp[idx] = nums[left] idx++ left++ } for right \u0026lt;= end { tmp[idx] = nums[right] idx++ right++ } for i,k := start, 0; i \u0026lt;= end; i,k = i+1, k+1 { nums[i] = tmp[k] } } "},{"id":230,"href":"/docs/algs/codingInterviews/52_%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/","title":"52. 两个链表的第一个公共节点","section":"Coding Interviews","content":" Description # 输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）\n数据范围： \\($n \\le 1000$\\) 要求：空间复杂度 \\($\\Omicron(1)$\\) ，时间复杂度 \\($\\Omicron(n)$\\) Solutions # 从两个链表的头节点 pHead1 和 pHead2 开始不断向后遍历，如果 pHead1 遍历到末尾，则从 pHead2 开始继续进行遍历，如果 pHead2 遍历到末尾，则从 pHead1 开始继续进行遍历。这样的话，如果存在公共节点，那么它们就会在第一个公共节点处相遇，此时他们都走过了相同的路程，返回这个节点即可。\nfunc FindFirstCommonNode( pHead1 *ListNode , pHead2 *ListNode ) *ListNode { // write code here p1, p2 := pHead1, pHead2 for p1 != p2 { if p1 == nil { p1 = pHead2 }else { p1 = p1.Next } if p2 == nil { p2 = pHead1 } else { p2 = p2.Next } } return p1 } "},{"id":231,"href":"/docs/algs/codingInterviews/53_%E6%95%B0%E5%AD%97%E5%9C%A8%E5%8D%87%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/","title":"53. 数字在升序数组中出现的次数","section":"Coding Interviews","content":" Description # 给定一个长度为 n 的非降序数组和一个非负数整数 k ，要求统计 k 在数组中出现的次数\n数据范围： \\($0 \\le n \\le 1000 $\\) , \\($0 \\le k \\le 100$\\) ，数组中每个元素的值满足 \\($0 \\le val \\le 100$\\) . 要求：空间复杂度 \\($\\Omicron(1)$\\) ，时间复杂度 \\($\\Omicron(\\log n)$\\) Solutions # Binary Search # func GetNumberOfK( data []int , k int ) int { // write code here var res int size := len(data) if size \u0026lt; 1 { return res } left, right := 0, size - 1 for left \u0026lt;= right { mid := (left +right)/2 if data[mid] \u0026gt; k { right = mid - 1 } else if data[mid] \u0026lt; k { left = mid + 1 } else if data[mid] == k { l,r := mid, mid for l \u0026gt;= 0 \u0026amp;\u0026amp; data[l] == k { l-- } for r \u0026lt; size \u0026amp;\u0026amp; data[r] == k { r++ } res = r - l - 1 break } } return res } "},{"id":232,"href":"/docs/algs/codingInterviews/54_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9/","title":"54. 二叉搜索树的第 k 个节点","section":"Coding Interviews","content":" Description # 给定一棵结点数为n 二叉搜索树，请找出其中的第 k 小的TreeNode结点值。 1.返回第k小的节点值即可 2.不能查找的情况，如二叉树为空，则返回-1，或者k大于n等等，也返回-1 3.保证n个节点的值不一样\n数据范围： \\($0 \\le n \\le1000$\\) ， \\($0 \\le k \\le1000$\\) ，树上每个结点的值满足 \\($0 \\le val \\le 1000$\\) 进阶：空间复杂度 \\($\\Omicron(n)$\\) ，时间复杂度 \\($\\Omicron(n)$\\) Solutions # 很简单，中序遍历求第 k 个节点即可。\nfunc KthNode( proot *TreeNode , k int ) int { // write code here if proot == nil { return -1 } var stack []*TreeNode cur := proot for cur != nil || len(stack) != 0 { for cur != nil { stack = append(stack, cur) cur = cur.Left } size := len(stack) cur = stack[size-1] stack = stack[:size-1] k-- if k == 0 { return cur.Val } cur = cur.Right } return -1 } "},{"id":233,"href":"/docs/algs/codingInterviews/55_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/","title":"55. 二叉树的深度","section":"Coding Interviews","content":" Description # 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度，根节点的深度视为 1 。\n数据范围：节点的数量满足 \\($0 \\le n \\le 100$\\) ，节点上的值满足 \\($0 \\le val \\le 100$\\) 进阶：空间复杂度 \\($\\Omciron(1)$\\) ，时间复杂度 \\($\\Omicron(n)$\\) Solutions # 简单题，不多说直接上代码。\nfunc TreeDepth( pRoot *TreeNode ) int { // write code here if pRoot == nil { return 0 } return max(TreeDepth(pRoot.Left), TreeDepth(pRoot.Right)) + 1 } func max(a, b int) int { if a \u0026lt; b { return b } return a } "},{"id":234,"href":"/docs/algs/codingInterviews/56_%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/","title":"56. 数组中只出现一次的两个数字","section":"Coding Interviews","content":" Description # 一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。\n数据范围：数组长度 \\($2\\le n \\le 1000$\\) ，数组中每个数的大小 \\($0 \u0026lt; val \\le 1000000$\\) 要求：空间复杂度 \\($\\Omicron(1)$\\) ，时间复杂度 \\($\\Omicron(n)$\\) 提示：输出时按非降序排列。\nSolutions # Hash Table # 建立一个哈希表，对每个出现的数字计数，最后将只出现一次的数字返回即可。\n// 使用哈希表 func FindNumsAppearOnce( array []int ) []int { dict := make(map[int]int) for _, value := range nums { dict[value]++ } var res []int for value, count := range dict { if count == 1 { res = append(res, value) } } if len(res) == 2 \u0026amp;\u0026amp; res[1] \u0026lt; res[0] { res[0], res[1] = res[1], res[0] } return res } 位运算 # 如果只要一个数字是不同的，那么很容易计算，只需要直接对整个数组计算异或值即可，这个异或值即为我们所求。但是这里有两个不同值，那么怎么办呢？方法就是对他们进行分组（这里不需要两个组的元素数量相同），将两个不同的值分到不同的组里面，而且还要把相同的值分到同一个组里面，这样分别对两个不同的组进行异或计算，得到的两个值就是我们所求的两个数。\n那么怎么分组呢？关键是要找出两个数字之间的差异，这里可以使用异或来进行操作。两个不同的数字进行异或，他们对应的某一位如果不同，那么对应的异或结果的那一位就是 1，我们可以使用这个特性来对整个数组进行分组：首先算出整个数组的异或值，然后找出这个异或值的第一个二进制值为 1 的位，然后使用这个位代表的值来对整个数组进行分组，并对每个分组分别计算异或值，这样就可以得到我们所求的两个值。\nfunc FindNumsAppearOnce( array []int ) []int { // write code here var xor int // 找到最终的异或值 for _, value := range array { xor ^= value } // 找到异或结果中二进制为 1 的那一位 t := 1 for t \u0026amp; xor == 0 { t \u0026lt;\u0026lt;= 1 } // 这里赋值为 0 并不会影响异或结果 var a,b int // 根据 t 将数组分为两个分组 for _, value := range array { if value \u0026amp; t == 0 { a ^= value } else { b ^= value } } if a \u0026lt; b { return []int{a, b} } else { return []int{b, a} } } "},{"id":235,"href":"/docs/algs/codingInterviews/57_%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/","title":"57. 和为 S 的两个数字","section":"Coding Interviews","content":" Description # 输入一个升序数组 array 和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，返回任意一组即可，如果无法找出这样的数字，返回一个空数组即可。\n数据范围: \\($0 \\le len(array) \\le 10^5$\\) , \\($1 \\le array[i] \\le 10^6$\\) Solutions # func FindNumbersWithSum( array []int , sum int ) []int { // write code here size := len(array) if size \u0026lt;= 1 { return nil } left, right := 0, size -1 for left \u0026lt; right { if array[left] + array[right] == sum { return []int{array[left], array[right]} } else if array[left] + array[right] \u0026lt; sum { left++ } else if array[left] + array[right] \u0026gt; sum { right-- } } return nil } "},{"id":236,"href":"/docs/algs/codingInterviews/58_%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"58. 左旋转字符串","section":"Coding Interviews","content":" Description # 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列 S ，请你把其循环左移 K 位后的序列输出。例如，字符序列 S = ”abcXYZdef” , 要求输出循环左移 3 位后的结果，即 “XYZdefabc”\n数据范围：输入的字符串长度满足 \\($0 \\le len \\le 100$\\) ， \\($0 \\le n \\le 100$\\) 进阶：空间复杂度 \\($\\Omicron(n)$\\) ，时间复杂度 \\($\\Omicron(n)$\\) Solutions # 字符串拼接 # func LeftRotateString( str string , n int ) string { // write code here size := len(str) if size == 0 || n%size == 0 { return str } n %= size // n 可能会大于 size，所以需要取余 left, right := str[:n], str[n:] return right+left } 字符串翻转 # 先将整个字符串翻转一次，然后再将从左边开始数的 size - n 个字符翻转一次，最后再将右边剩余的 n 个字符翻转一次。\nfunc LeftRotateString( str string , n int ) string { // write code here size := len(str) if size == 0 || n%size == 0 { return str } n %= size // n 可能会大于 size，所以需要取余 rs := []rune(str) for i,j := 0, size-1; i \u0026lt; j; i,j = i+1, j-1 { rs[i],rs[j] = rs[j], rs[i] } for i,j := 0, size-n-1; i \u0026lt; j; i,j = i+1, j-1 { rs[i],rs[j] = rs[j], rs[i] } for i, j := size-n, size-1; i \u0026lt; j; i,j = i+1, j-1 { rs[i], rs[j] = rs[j], rs[i] } return string(rs) } "},{"id":237,"href":"/docs/algs/codingInterviews/59_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/","title":"59. 滑动窗口的最大值","section":"Coding Interviews","content":" Description # 给定一个长度为 n 的数组 nums 和滑动窗口的大小 size ，找出所有滑动窗口里数值的最大值。\n例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。\nSolutions # Dequeue # 使用一个单调递减的单调队列来做。维持一个最大长度为 size 的单调队列，每当遍历到当前元素 i，如果当前元素 nums[i] 比队列尾部元素要大，则不断将队列尾部元素出队，直到队列为空或者当前元素 nums[i] 比队尾元素要小，然后将当前元素入队。这样的话，队列中要么维持着一个最大值，要么顶多维持着 size 个相对递减的连续值。然后检查队首元素是否过期，如果过期，则将队首元素出队，因为我们每次顶多入队一个，所以每次遍历也顶多只会有一个元素过期。最后检查当前窗口长度是否达到 size，如果达到了，则将队列首部元素入队即可。\n// 可以使用单调递减的单调队列来实现 func maxInWindows( num []int , size int ) []int { // write code here var res []int n := len(num) if size \u0026lt; 1 || n \u0026lt; 1 { return res } var queue []int for i := 0; i \u0026lt; n; i++ { // 如果当前遍历到的元素比队尾元素要大，则不断将队尾元素出队 curLen := len(queue) for curLen \u0026gt; 0 \u0026amp;\u0026amp; num[i] \u0026gt; num[queue[curLen-1]] { curLen-- queue = queue[:curLen] } queue = append(queue, i) // 如果当前队首元素滑出左边界，则将其删除 if queue[0] + size \u0026lt;= i { queue = queue[1:] } // 如果当前已经构成了一个有效的滑动窗口，则将当前最大值存入结果 if size \u0026lt;= i+1 { res = append(res, num[queue[0]]) } } return res } "},{"id":238,"href":"/docs/algs/codingInterviews/61_%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/","title":"61. 扑克牌顺子","section":"Coding Interviews","content":" Description # 现在有2副扑克牌，从扑克牌中随机五张扑克牌，我们需要来判断一下是不是顺子。 有如下规则：\nA为1，J为11，Q为12，K为13，A不能视为14 大、小王为 0，0可以看作任意牌 如果给出的五张牌能组成顺子（即这五张牌是连续的）就输出true，否则就输出false。 4.数据保证每组5个数字，每组最多含有4个零，数组的数取值为 [0, 13] 要求：空间复杂度 \\($\\Omicron(1)$\\) ，时间复杂度 \\($\\Omicron(n \\log n)$\\) ，本题也有时间复杂度 \\($\\Omicron(n)$\\) 的解法\nSolutions # 建立一个大小为14 的数组，记录每只牌出现的次数。然后从 1 开始遍历这个数组直到第一只计数值为 1 的牌，如果任意一只牌的计数值大于 1，则返回 false；然后从这只牌开始模拟，如果以这只牌开始的五只牌都能构成顺子，则返回 true；否则\nfunc IsContinuous( numbers []int ) bool { // write code here // 记录每只牌出现的次数 emu := make([]int, 14) for _, value := range numbers { emu[value]++ } for i := 1; i \u0026lt; 14; i++ { // 任意一只牌的出现次数大于 1，则无法构成顺子 if emu[i] \u0026gt; 1 { return false } // 如果这只牌只出现了一次，那么检查能不能构成顺子 if emu[i] == 1 { // 顶多检查五只牌 for j := i; i+5 \u0026lt; 14 \u0026amp;\u0026amp; j \u0026lt; i+5; j++ { // 任何一只牌出现次数大于 1，则返回 false if emu[j] \u0026gt; 1 { return false } // 如果当前牌只出现了一次，则继续遍历 if emu[j] == 1 { continue } // 如果当前牌没有出现，则看 0 是否还有剩余，如果有，则继续遍历；如果没有，则返回 false if emu[j] == 0 { if emu[0] \u0026gt; 0 { emu[0]-- continue } else { return false } } } // 以 i 开头的牌组可以成为顺子，返回 true return true } } // 没有找到任何一个顺子，返回 false return false } "},{"id":239,"href":"/docs/algs/codingInterviews/62_%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0/","title":"62. 圆圈中最后剩下的数","section":"Coding Interviews","content":" Description # 每年六一儿童节，牛客都会准备一些小礼物和小游戏去看望孤儿院的孩子们。其中，有个游戏是这样的：首先，让 n 个小朋友们围成一个大圈，小朋友们的编号是0~n-1。然后，随机指定一个数 m ，让编号为0的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始，继续0\u0026hellip; m-1报数\u0026hellip;.这样下去\u0026hellip;.直到剩下最后一个小朋友，可以不用表演，并且拿到牛客礼品，请你试着想下，哪个小朋友会得到这份礼品呢？\nSolutions # 循环链表模拟 # 可以将元素串成一个循环链表，然后进行遍历即可。\n使用数组模拟 # 用数组求解的基本思想就是用一个一维数组去标识这 n 个人的状态，默认全为 1 ，也就是都在圈子内，当数到 m 的人出圈之后，标识置为 0（就是出圈了），同时报数器清 0，下一个人要从 1 开始。在每次报数之前要判断他是否在圈子内（也就是他的标识是否为 1 ），如果在圈子里面才会继续报数。定义一个变量记录出圈的人数， 出圈的人数等于 n-1 时，则游戏结束。\n"},{"id":240,"href":"/docs/algs/codingInterviews/63_%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A5%BD%E6%97%B6%E6%9C%BA/","title":"63. 买卖股票的最好时机","section":"Coding Interviews","content":" Description # 假设你有一个数组prices，长度为n，其中prices[i]是股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益 1.你可以买入一次股票和卖出一次股票，并非每天都可以买入或卖出一次，总共只能买入和卖出一次，且买入必须在卖出的前面的某一天 2.如果不能获取到任何利润，请返回0 3.假设买入卖出均无手续费\nSolutions # 一次扫描，扫描过程中维护当前扫描到的数字的最小值，然后不断的用当前扫描到的数字减去这个最小得到一个差，取这个差的最大值即可。\nfunc maxProfit( prices []int ) int { // write code here var res int size := len(prices) if size == 0 { return res } curMin := prices[0] for _, price := range prices { if price \u0026lt; curMin { curMin = price } res = max(res, price-curMin) } return res } "},{"id":241,"href":"/docs/algs/codingInterviews/65_%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/","title":"65. 不用加减乘除做加法","section":"Coding Interviews","content":" Description # 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。\n数据范围：两个数都满足 \\($-10 \\le n \\le 1000$\\) 进阶：空间复杂度 \\($\\Omicron(1)$\\) ，时间复杂度 \\($\\Omicron(1)$\\) Solutions # Bit Manipulation # 使用位与操作表示两数相加的进位（需要左移一位）， 使用异或操作表示两数相加的和，这样就可以递归计算，递归终止条件是进位为 0.\nfunc Add( num1 int , num2 int ) int { // write code here if num1 == 0 { return num2 } carry := (num1 \u0026amp; num2) \u0026lt;\u0026lt; 1 sum := num1 ^ num2 return Add(carry, sum) } "},{"id":242,"href":"/docs/algs/codingInterviews/67_%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%88%90%E6%95%B4%E6%95%B0atoi/","title":"67. 把字符串转成整数(atoi)","section":"Coding Interviews","content":" Description # 写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。传入的字符串可能有以下部分组成: 1.若干空格 2.（可选）一个符号字符（\u0026rsquo;+\u0026rsquo; 或 \u0026lsquo;-\u0026rsquo;） 3. 数字，字母，符号，空格组成的字符串表达式 4. 若干空格\n转换算法如下: 1.去掉无用的前导空格 2.第一个非空字符为+或者-号时，作为该整数的正负号，如果没有符号，默认为正数 3.判断整数的有效部分： 3.1 确定符号位之后，与之后面尽可能多的连续数字组合起来成为有效整数数字，如果没有有效的整数部分，那么直接返回0 3.2 将字符串前面的整数部分取出，后面可能会存在存在多余的字符(字母，符号，空格等)，这些字符可以被忽略，它们对于函数不应该造成影响 3.3 整数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231的整数应该被调整为 −231 ，大于 231 − 1 的整数应该被调整为 231 − 1 4.去掉无用的后导空格\nSolutions # "},{"id":243,"href":"/docs/algs/codingInterviews/66_%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/","title":"67. 构建乘积数组","section":"Coding Interviews","content":" Description # 给定一个数组 A[0,1,\u0026hellip;,n-1] ,请构建一个数组 B[0,1,\u0026hellip;,n-1] ,其中 B 的元素 B[i]=A[0]A[1]\u0026hellip;*A[i-1]A[i+1]\u0026hellip;*A[n-1]（除 A[i] 以外的全部元素的的乘积）。程序中不能使用除法。（注意：规定 B[0] = A[1] * A[2] * \u0026hellip; * A[n-1]，B[n-1] = A[0] * A[1] * \u0026hellip; * A[n-2]） 对于 A 长度为 1 的情况，B 无意义，故而无法构建，用例中不包括这种情况。\n数据范围： \\($1 \\le n \\le 10$\\) ，数组中元素满足 \\($|val| \\le 10$\\) Solutions # Array # 使用两个数组，一个数组left从左到右扫描，left[i] 表示从 A 数组开始位置到 i 位置之前的元素的累乘；一个数组 right 从右向左扫描， right[i] 表示从数组最后一个位置到 i 位置的累乘。最后复用 left ，left[i] *= right[i]， left 即为所求。\nfunc multiply( A []int ) []int { // write code here size := len(A) if size \u0026lt;= 1 { return nil } left, right := make([]int, size), make([]int, size) left[0], right[size-1] = 1, 1 for i := 1; i \u0026lt; size; i++ { left[i] = A[i-1] * left[i-1] } for i := size-2; i \u0026gt;= 0; i-- { right[i] = A[i+1] * right[i+1] } for i := 0; i \u0026lt; size; i++ { left[i] *= right[i] } return left } "},{"id":244,"href":"/docs/algs/codingInterviews/68_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","title":"68. 二叉搜索树的最近公共祖先","section":"Coding Interviews","content":" Description # 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\nSolutions # Recursive # 如果当前节点的值比要查找的值的最小值还要小，说明应该往当前节点的右节点进行查找；如果当前节点的值比要查找的值的最大值还要大，说明应该往当前节点的左子树进行查找。否则说明当前节点处于要查找的值之间，那么当前节点就是我们要查找的最近公共祖先。\nfunc lowestCommonAncestor( root *TreeNode , p int , q int ) int { // write code here if root == nil { return -1 } // 保持 p 比 q 要小 if p \u0026gt; q { p,q = q, p } res := lcaHelper(root, p, q) return res.Val } func lcaHelper(root *TreeNode, mn,mx int) *TreeNode { if root.Val \u0026gt; mx { return lcaHelper(root.Left, mn, mx) } else if root.Val \u0026lt; mn { return lcaHelper(root.Right, mn, mx) } else { return root } } "},{"id":245,"href":"/docs/algs/codingInterviews/70_%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/","title":"70. 矩形覆盖","section":"Coding Interviews","content":" Description # 我们可以用 21 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 21 的小矩形无重叠地覆盖一个 2*n 的大矩形，从同一个方向看总共有多少种不同的方法？\n数据范围： \\($0 \\le n \\le 38$\\) 进阶：空间复杂度 \\($\\Omicron(1)$\\) ，时间复杂度 \\($\\Omicron(n)$\\) 注意：约定 n == 0 时，输出 0\nSolutions # 举例可以发现这其实也是个斐波那契数列问题。\nfunc rectCover( number int ) int { // write code here if number \u0026lt;= 3 { return number } NMinusTwo, NMinusOne := 2, 3 for i := 4; i \u0026lt;= number; i++ { N := NMinusOne + NMinusTwo NMinusTwo = NMinusOne NMinusOne = N } return NMinusOne } "},{"id":246,"href":"/docs/algs/codingInterviews/69_%E8%B7%B3%E5%8F%B0%E9%98%B6/","title":"70. 跳台阶","section":"Coding Interviews","content":" Description # 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。\n数据范围： \\($1 \\leq n \\leq 40$\\) 要求：时间复杂度： \\($\\Omicron(n)$\\) ，空间复杂度： \\($\\Omicron(1)$\\) Solutions # 动态规划 # func jumpFloor( number int ) int { // write code here if number \u0026lt;= 1 { return number } NMinusTwo, NMinusOne := 0, 1 for i := 1; i \u0026lt;= number; i++ { n := NMinusOne + NMinusTwo NMinusTwo = NMinusOne NMinusOne = n } return NMinusOne } "},{"id":247,"href":"/docs/algs/codingInterviews/71_%E8%B7%B3%E5%8F%B0%E9%98%B6%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98/","title":"71. 跳台阶扩展问题","section":"Coding Interviews","content":" Description # 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶(n为正整数)总共有多少种跳法。\nSolutions # Math # 其实可以通过举例来发现规律: \\($f(n) = 2 * f(n-1) (n \u0026gt; 2)$\\) ，如果 \\($0 \\le n \\le 2$\\) ，则直接返回 n 即可。\nfunc jumpFloorII( number int ) int { // write code here if number \u0026lt;= 2 { return number } return int(math.Pow(2, float64(number-1))) } "},{"id":248,"href":"/docs/algs/codingInterviews/73_%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97/","title":"73. 翻转单词序列","section":"Coding Interviews","content":" Description # 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“nowcoder. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a nowcoder.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？\nSolutions # 先翻转整个句子，然后再针对每个空格分割的单词单独翻转。\nfunc ReverseSentence( str string ) string { // write code here size := len(str) if size \u0026lt;= 1 { return str } runes := []rune(str) size = len(runes) // 先翻转整个字符串 for left,right := 0, size-1; left \u0026lt; right; left,right = left+1, right-1 { runes[left],runes[right] = runes[right], runes[left] } // 再翻转这个字符串里的每个单词 var left, right int for right \u0026lt;= size { for right \u0026lt; size \u0026amp;\u0026amp; runes[right] != \u0026#39; \u0026#39; { right++ } for i,j := left, right-1; i \u0026lt; j \u0026amp;\u0026amp; right \u0026lt;= size; i,j = i+1, j-1 { runes[i], runes[j] = runes[j], runes[i] } left,right = right+1, right+1 } return string(runes) } "},{"id":249,"href":"/docs/algs/codingInterviews/74_%E5%92%8C%E4%B8%BA-S-%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/","title":"74. 和为 S 的连续正数序列","section":"Coding Interviews","content":" Description # 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列?\n数据范围： \\($0 \u0026lt; n \\le 100$\\) 进阶：时间复杂度 \\($\\Omicron(n)$\\) Solutions # Sliding Window # 从某一个数字开始的连续序列和等于目标数如果有，只能有一个，于是我们可以用这个性质来使区间滑动。\n使用滑动窗口，left 指向窗口左边，right 指向窗口右边，初始时 left 和 right 分别等于 1 和 2.然后计算 [left, right] 这个区间的数字的和，如果和刚好等于 sum，则将这些数字存入 res；如果和大于 sum，说明窗口中元素太多了，需要收缩左窗口；如果和小于 sum，说明窗口中元素太少了，需要收缩右窗口。\nfunc FindContinuousSequence( sum int ) [][]int { // write code here var res [][]int left, right := 1, 2 for left \u0026lt; right { s := (left+right) * (right - left+1)/2 if s == sum { var tmp []int for i := left; i \u0026lt;= right; i++ { tmp = append(tmp, i) } res = append(res, tmp) left++ } else if s \u0026gt; sum { left++ } else if s \u0026lt; sum { right++ } } return res } "},{"id":250,"href":"/docs/algs/codingInterviews/75_%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/","title":"75. 字符流中第一个不重复出现的字符","section":"Coding Interviews","content":" Description # 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 \u0026ldquo;go\u0026rdquo; 时，第一个只出现一次的字符是 \u0026ldquo;g\u0026rdquo; 。当从该字符流中读出前六个字符 “google\u0026quot; 时，第一个只出现一次的字符是\u0026quot;l\u0026quot;。\n数据范围：字符串长度满足 \\($1 \\le n \\le 1000$\\) ，字符串中出现的字符一定在 ASCII 码内。 进阶：空间复杂度 \\($\\Omicron(n)$\\) ，时间复杂度 \\($\\Omicron(n)$\\) Solutions # var dict = make(map[byte]int) var bs []byte func Insert(ch byte) { bs = append(bs, ch) dict[ch]++ } func FirstAppearingOnce() byte { for _, ch := range bs { if cnt, _ := dict[ch]; cnt == 1 { return ch } } return byte(\u0026#39;#\u0026#39;) } "},{"id":251,"href":"/docs/algs/codingInterviews/76_%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9/","title":"76. 删除链表中重复的节点","section":"Coding Interviews","content":" Description # 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表 1-\u0026gt;2-\u0026gt;3-\u0026gt;3-\u0026gt;4-\u0026gt;4-\u0026gt;5 处理后为 1-\u0026gt;2-\u0026gt;5\n数据范围：链表长度满足 \\($0 \\le n \\le 1000$\\) ，链表中的值满足 \\($1 \\le val \\le 1000$\\) 进阶：空间复杂度 \\($\\Omicron(n)$\\) ，时间复杂度 \\($\\Omicron(n)$\\) Solutions # 并不难，但是要注意虚拟头结点的使用。\nfunc deleteDuplication( pHead *ListNode ) *ListNode { // write code here if pHead == nil { return nil } // 增加一个虚拟头结点，方便头结点的删除 dummyHead := new(ListNode) dummyHead.Next = pHead pre , cur := dummyHead, pHead for cur != nil { if cur.Next != nil \u0026amp;\u0026amp; cur.Val == cur.Next.Val { p := cur for p != nil \u0026amp;\u0026amp; p.Val == cur.Val { p = p.Next } pre.Next = p cur = p } else { pre = cur cur = cur.Next } } return dummyHead.Next } "},{"id":252,"href":"/docs/algs/codingInterviews/77_%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"77. 按之字形顺序打印二叉树","section":"Coding Interviews","content":" Description # 给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）\n数据范围： \\($0 \\le n \\le 1500$\\) ,树上每个节点的val满足 \\($|val| \\le 1500$\\) 要求：空间复杂度： \\($\\Omicron(n)$\\) ，时间复杂度： \\($\\Omicron(n)$\\) Solutions # 就是一个树的层次遍历，不多说。\nfunc Print( pRoot *TreeNode ) [][]int { // write code here var res [][]int if pRoot == nil { return res } var queue []*TreeNode queue = append(queue, pRoot) var reverse bool for len(queue) != 0 { size := len(queue) var arr []int for i := 0; i \u0026lt; size; i++ { top := queue[i] arr = append(arr, top.Val) if top.Left != nil { queue = append(queue, top.Left) } if top.Right != nil { queue = append(queue, top.Right) } } queue = queue[size:] if reverse { reverseArr(arr) reverse = false } else { reverse = true } res = append(res, arr) } return res } func reverseArr(arr []int) { size := len(arr) left, right := 0, size -1 for left \u0026lt; right { arr[left], arr[right] = arr[right], arr[left] left++ right-- } } "},{"id":253,"href":"/docs/algs/codingInterviews/78_%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/","title":"78. 把二叉树打印成多行","section":"Coding Interviews","content":" Description # 给定一个节点数为 n 二叉树，要求从上到下按层打印二叉树的 val 值，同一层结点从左至右输出，每一层输出一行，将输出的结果存放到一个二维数组中返回。\nSolutions # Level Order Traversal # 简单题，只需要进行一次层次遍历即可。\nfunc Print( pRoot *TreeNode ) [][]int { // write code here var res [][]int if pRoot == nil { return res } var queue []*TreeNode queue = append(queue, pRoot) for len(queue) != 0 { size := len(queue) var level []int for i := 0; i \u0026lt; size; i++ { node := queue[i] level = append(level, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, level) queue = queue[size:] } return res } "},{"id":254,"href":"/docs/algs/codingInterviews/79_%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"79. 判断是不是平衡二叉树","section":"Coding Interviews","content":" Description # 输入一棵节点数为 n 二叉树，判断该二叉树是否是平衡二叉树。 在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树 平衡二叉树（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。\nSolutions # 这里需要注意，光判断根节点是否是平衡二叉树是不够的，还需要对每个子树都做相应的判断。注意这里的解法跟 26 题的相似性。\nfunc IsBalanced_Solution( pRoot *TreeNode ) bool { // write code here if pRoot == nil { return true } if !isBalanced(getTreeHeight(pRoot.Left), getTreeHeight(pRoot.Right)) { return false } return IsBalanced_Solution(pRoot.Left) \u0026amp;\u0026amp; IsBalanced_Solution(pRoot.Right) } func isBalanced(a, b int) bool { if a \u0026gt;b { a, b = b, a } return b - a \u0026lt;= 1 } func getTreeHeight(root *TreeNode) int { if root == nil { return 0 } return max(getTreeHeight(root.Left), getTreeHeight(root.Right)) + 1 } func max(a,b int) int { if a \u0026lt; b { return b } return a } "},{"id":255,"href":"/docs/algs/codingInterviews/81_%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2II/","title":"81. 调整数组顺序使奇数位于偶数前面 II","section":"Coding Interviews","content":" Description # 输入一个长度为 n 整数数组，数组里面可能含有相同的元素，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前面部分，所有的偶数位于数组的后面部分，对奇数和奇数，偶数和偶数之间的相对位置不做要求，但是时间复杂度和空间复杂度必须如下要求。\n数据范围： \\($0 \\le n \\le 50000$\\) ，数组中每个数的值 \\($0 \\le val \\le 10000$\\) 要求：时间复杂度 \\($\\Omicron(n)$\\) ，空间复杂度 \\($\\Omicron(1)$\\) Solutions # 参考快速排序将小于 pivot 的元素放在左侧，将大于 pivot 的元素放在右侧的做法。这里使用两个指针left和 right，分别指向数组开头和末尾，然后 left 不断向右遍历，直到查找到偶数元素停止，然后 right 不断向左遍历，直到查找到奇数元素停止，然后交换 left 和 right 指向的元素，这样就把奇数放在了左侧，偶数放在了右侧，然后继续遍历，直到 left 和 right 重叠为止。\nfunc reOrderArrayTwo( array []int ) []int { // write code here size := len(array) if size \u0026lt;= 1 { return array } left, right := 0, size -1 for left \u0026lt; right { for left \u0026lt; right \u0026amp;\u0026amp; array[left] % 2 == 1 { left++ } for left \u0026lt; right \u0026amp;\u0026amp; array[right] % 2 == 0 { right-- } array[left], array[right] = array[right], array[left] left++ right-- } return array } "},{"id":256,"href":"/docs/algs/codingInterviews/82_%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E4%B8%80/","title":"82. 二叉树中和为某一值的路径（一）","section":"Coding Interviews","content":" Description # 给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。 1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点 2.叶子节点是指没有子节点的节点 3.路径只能从父节点到子节点，不能从子节点到父节点 4.总节点数目为n\nSolutions # 因为这里的路径是从根节点开始的，所以也很简单，直接递归回溯即可。\nfunc hasPathSum( root *TreeNode , sum int ) bool { // write code here if root == nil { return false } var stack []*TreeNode var num int cur := root for cur != nil || len(stack) != 0 { for cur != nil { num += cur.Val stack = append(stack, cur) cur = cur.Left } if num == sum \u0026amp;\u0026amp; cur == nil { return true } size := len(stack) cur = stack[size-1] stack = stack[:size-1] if cur.Left != nil { num -= cur.Left.Val } cur = cur.Right } return false } "},{"id":257,"href":"/docs/algs/codingInterviews/84_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84III/","title":"84. 二叉树中和为某一值的路径 III","section":"Coding Interviews","content":" Description # 给定一个二叉树root和一个整数值 sum ，求该树有多少路径的的节点值之和等于 sum 。 1.该题路径定义不需要从根节点开始，也不需要在叶子节点结束，但是一定是从父亲节点往下到孩子节点 2.总节点数目为n 3.保证最后返回的路径个数在整形范围内(即路径个数小于 \\($2^{31}$\\) -1)\nSolutions # 注意，这里的路径不一定需要从根节点开始，也不一定需要在叶节点结束。\nRecursice # 核心思想就是，每个节点都可能是一条路径的起始节点，所以每个节点都需要作为根节点来遍历一次。\nvar res int func FindPath( root *TreeNode , sum int ) int { // write code here if root == nil { return res } findPathHelper(root, sum) // 每个节点都需要作为根节点来进行一次查找 FindPath(root.Left, sum) FindPath(root.Right, sum) return res } func findPathHelper(root *TreeNode, sum int) { if root == nil { return } // 注意这里的小技巧 if sum == root.Val { res++ } findPathHelper(root.Left, sum - root.Val) findPathHelper(root.Right, sum - root.Val) } "},{"id":258,"href":"/docs/algs/codingInterviews/85_%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C-II/","title":"85. 连续子数组的最大和 II","section":"Coding Interviews","content":" Description # 输入一个长度为n的整型数组array，数组中的一个或连续多个整数组成一个子数组，找到一个具有最大和的连续子数组。 1.子数组是连续的，比如[1,3,5,7,9]的子数组有[1,3]，[3,5,7]等等，但是[1,3,7]不是子数组 2.如果存在多个最大和的连续子数组，那么返回其中长度最长的，该题数据保证这个最长的只存在一个 3.该题定义的子数组的最小长度为1，不存在为空的子数组，即不存在[]是某个数组的子数组 4.返回的数组不计入空间复杂度计算\nSolutions # Kadane 方法 # 详情参见 42 题的 「连续子数组的最大和」，这个方法跟那个方法是同一个思路。\nfunc FindGreatestSumOfSubArray( array []int ) []int { // write code here size := len(array) if size == 0 { return nil } var start, end int res, sum := array[0],array[0] for i := 1; i \u0026lt; size; i++ { // 这里的 start 可能会在不断的向右扩张，而 end 只有在 sum 比 res 大的时候才会扩展，所以可能会出现 start 比 end 大的情况。 if array[i] \u0026gt; sum + array[i] { start = i } sum = max(array[i], sum+array[i]) if sum \u0026gt;= res { res = sum end = i } } // 当 start 不断向前推进时，可能会出现 start 大于 end 的情况，这个时候需要重置 start 的值 if start \u0026gt; end { start = end } return array[start: end+1] } func max(a,b int) int { if a \u0026lt; b { return b } return a } 上面的这个解法的优化, 这个方法其实也可以改成动态规划的方法，只需要将 sum 替换成 dp[i] 即可。\nfunc FindGreatestSumOfSubArray( array []int ) []int { // write code here size := len(array) if size == 0 { return nil } // start 和 end 是不断扩展的指针 var start, end int // resl 和 resr 指向最大连续和子数组的起始和结束区间 var resl, resr int res, sum := array[0],array[0] for i := 1; i \u0026lt; size; i++ { end++ // 重置 start 指针 if array[i] \u0026gt; sum + array[i] { start = i } sum = max(array[i], sum+array[i]) // 有可能出现连续子数组的最大和虽然不再增长，但是子数组的长度在增长的情况 if sum \u0026gt; res || sum == res \u0026amp;\u0026amp; (end - start + 1) \u0026gt; (resr - resl + 1) { res = sum resl = start resr = end } } return array[resl: resr+1] } func max(a,b int) int { if a \u0026lt; b { return b } return a } "},{"id":259,"href":"/docs/algs/codingInterviews/86_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","title":"86. 二叉树中两个节点的最近公共祖先","section":"Coding Interviews","content":" Description # 给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。\n数据范围：树上节点数满足 \\($1 \\le n \\le 10^5$\\) , 节点值val满足区间 [0,n) 要求：时间复杂度 \\($\\Omicron(n)$\\) Solutions # Recursive # 具体解释看注释即可。\nfunc lowestCommonAncestor( root *TreeNode , o1 int , o2 int ) int { // write code here if root == nil { return -1 } res := lcaHelper(root, o1, o2) return res.Val } func lcaHelper(root *TreeNode, o1, o2 int) *TreeNode { // 如果已经遍历到空节点或者已经找到其中一个节点，则返回该节点 if root == nil || root.Val == o1 || root.Val == o2 { return root } // 分别查找左子树和右子树 left := lcaHelper(root.Left, o1, o2) right := lcaHelper(root.Right, o1, o2) // 如果left 为空，说明这两个节点在 root 的右子树上，则返回右子树查找结果 if left == nil { return right } // 如果 right 为空，说明这两个节点在 root 的左子树上，则返回左子树查找结果 if right == nil { return left } // 如果 left 和 right 都不为空，则说明这两个节点一个在 root 的左子树上，一个在 root 的右子树上，则返回 root 即可 return root } "},{"id":260,"href":"/docs/algs/leetcode/Blind-75-list/","title":"Blind 75 List","section":"Leetcode","content":" Blind 75 # Sequence # Two Sum\n使用一个 map 记录元素值与元素下标的映射，只需要一次扫描数组，检查 target - value 是否在 map 中，同时将 value 和其下标放到 map 中 。\nBest Time to Buy and Sell Stock\n使用一个值记录当前扫描到的最小值，然后扫描一次数组，每扫描到一个值，用当前值减去当前得到的最小值，然后得到结果，取结果的最大值。如果当前值小于最小值，则更新最小值为当前值。只需要一次扫描。\nContains Duplicate\n简单题，只需要一个 map 就可以了，扫描一次即可。\nProduct of Array Except Self 创建两个数组left 和 right，数组 left[i] 表示 i 位置前的元素的累积，数组 right[i]表示 i 位置后的元素的累积。然后创建一个数组 res， res[i] = left[i] * right[i]。\nMaximum Subarray\nKadane 算法，最优子结构性质，当前位置的和取决于前一个位置的子数组和以及当前元素。\ndef max_subarray(arr): max_sum_so_far, sum_ending_here = arr[0], arr[0] for e in range(arr[1:]): sum_ending_here = max(e, sum_ending_here + e) max_sum_so_far = max(max_sum_so_far, sum_ending_here) return max_sum_so_far 如果数组中有负数，并且允许返回长度为 0 的子数列，则该问题可以改为：\ndef max_subarray(arr): max_sum_so_far, sum_ending_here = 0, 0 for e in range(arr): sum_ending_here = max(sum_ending_here + e, e) max_sum_so_far = max(max_sum_so_far, sum_ending_here) return max_sum_so_far TODO 重点关注\nMaximum Product Subarray\n动态规划，这里看起来和 53 题类似，但是其实这里的 0 和负数会对结果造成比较大的影响。解决方法是使用两个数组，一个数组 greater 记录包含当前元素的最大积的值，另一个数组 lesser 记录包含当前元素的最小积的值。 然后当前的最大最小值只会在 greater[i-1]*nums[i]、nums[i] 和 lesser[i-1]*nums[i] 中产生。\nTODO 重点关注这题\nFind Minimum in Rotated Sorted Array\n主要还是：举出例子，注意观察；注意这个性质：旋转数组一分为二之后，其中一个一定是有序的，另一个可能有序、可能无序。\nSearch in Rotated Sorted Array\n二分法。谁能想到是需要根据 middle 来判断向哪一边前进呢，而且 left 和 right 的取值也很巧妙.\n对于旋转数组，需要注意的是：因为数组原先是有序的，所以将数组一分为二之后，其中一定有一个是有序的，另一个可能有序，也可能部分有序。此时有序部分用二分查找。无序部分再一分为二，其中一个一定有序，而另一个可能有序，可能无序。循环即可。\n在使用while 循环进行搜索的时候，一定要注意缩小范围。也就是说，一方面要让结果收敛，另一方面要保持出口单一。\nTODO 二分法复习\n3 Sum\n排序+双指针 需要注意这几点：\n适当剪枝： 包括如何去重、为什么要进行排序、遍历多少次、为什么遇到整数之后可以直接跳出循环 有序数组使用双指针 是否可以更改原数组，如果可以，那么排序是否会带来不一样的效果 Container With Most Water\n贪心，怎么移动，移动的时候是移动左边还是移动右边，基于什么策略去移动，木桶效应。\nBinary # Sum of Two Integers\n二进制运算（异或模拟二进制加法和，与运算模拟进位，进位还需要左移），何时结束递归。\nNumber of 1 Bits\nSuper easy, 后面不需要再花时间看。\nCounting Bits\n想到解法很简单，但找到规律不容易。有趣的规律是：如果 n 是奇数，数字 n 中包含的 1 的个数等于数字 n/2 所包含的 1 的个数加 1；如果 n 是偶数，数字 n 包含的 1 的个数等于数字 n/2 包含的 1 的个数。\nMissing Number\n很简单，只需要记住等差数列求和公式即可： n*(a1+an)/2\nReverse Bits\n很容易想到解法。\nDynamic Programming # Climbing Stairs\n斐波那契数列，Fn = Fn-1 + Fn-2\nCoin Change\nTODO recheck\n注意的是，局部最优解不等于全局最优解，所以这里使用贪心算法得到一个可行解是不够的，要求出所有解，然后取其中最小值。推导式： dp[i] = min(dp[i], dp[i - coins[j]] + 1) if coins[j] \u0026lt;= dp[i].\nLongest Increasing Subsequence\nTODO recheck\n这题需要重点关注一下，因为自己对这个的应用还不够熟练。\n核心代码：\nfor i := 1; i \u0026lt; size; i++ { for j := 0; j \u0026lt; i;j++ { if nums[i] \u0026gt; nums[j] { dp[i] = max(dp[i], dp[j]+ 1) } } // 注意这里，最后所求的并不是dp[size-1] res = max(res, dp[i]) } return res } 字符串求极值一般可以考虑一下使用动态规划，动态规划想不出转移方程则可以尝试使用贪心。\nLongest Common Subsequence\nTODO recheck\n这题跟 583_delete_operation_for_two_strings 是一样的解法，也跟 516_longest_palindromic_subsequence 是一样的，是典型的的二维dp问题。\n在 longest palindromic subsequence 中，一定要注意遍历的方向，dp具有最优子结构性质，而这意味着你在求解一个问题时，需要完全求解出这个问题的子问题的解。\n需要注意这几个问题：\n状态方程式怎么定义的 为什么数组是 (m+1) * (n+1) 的 为什么比较的时候是 text1[i-1] 与 text2[j-1]比较 Longest Palindrome Subsequence\nTODO recheck\n参见上一题的解答。\nDelete Operation for Two Strings\nTODO recheck\n参见上一题的解答\nWord Break\nTODO recheck\n这一题需要特别注意，尤其需要注意dp数组的定义，这里的初始化条件也需要注意，此外还需要注意子问题的求解方向。结束遍历的条件也是需要特别注意的。\nCombination Sum\nCombination Sum 是一系列题，分别有leetcode 39 题 Combination Sum， 40 题的 Combination Sum II, 216 题的 Combination Sum III 和 377 题的 Combination Sum IV。\n39 题比较简单，注意边界条件即可。40 题和39 题其实是差不多的。216题也不难。\n377 题竟然是使用动态规划来解的，我肯定想不到这种解法。\nTODO\n在 39 题中，需要注意的是，在回溯的过程中， 我们可以一次性添加多个元素，而不是只添加一个，这样可以减少一些回溯过程：\nfor i := start; i \u0026lt; size; i++ { for j := target/candidates[i]; j \u0026gt; 0; j-- { //一次性添加多个同一元素 for k := 0; k \u0026lt; j; k++ { cur = append(cur, candidates[i]) } combinationSumHelper(candidates, i+1, target - j * candidates[i], cur, res) // 复原 cur = cur[:len(cur) - j] } } 在第 40 题中，需要注意的是，可以直接对数组进行排序，从而就不需要再使用 map 来进行手动去重。另外还需要特别注意该题中的剪枝用法。\nHouse Robber\nTODO recheck\n这个题需要注意初始条件是怎么算出来的。\nHouse Robber II\nTODO recheck\n这个好取巧，直接剔除抢和不抢的情况，然后算两次取最大值。\nDecode ways\nTODO 这一题还没写\nUnique Path\n注意排列组合计算方法。注意这里为什么需要用更小的值来作为上值，为什么选择另一个数可能会导致溢出，从而得到结果0.\n// 计算从m里面抽n个 res := 1 for i := 0; i \u0026lt; n; i++ { res *= (m-i) res /= (i+1) } Jump Games\nTODO recheck 对于动态规划，自己的解题能力还需要加强\n这里的贪心解法很有意思。\nGraph # Clone Graph\nTODO recheck\n本质上就是进行一次 DFS 或者 BFS，但是要注意去重。这里需要注意的是，map 的 key 和 value 分别对应的原节点和其克隆出来的节点吗，而不是仅仅记录一个节点是否有被 clone 过。\nCourse Schedule\n很明显的有向图环检测问题。这里并不需要我们真的建立一个图，而是可以使用邻接表（也就是二维数组）的方式来表示图，然后使用一个一维数组来表示各个节点的入度是对少。\n遍历的时候，将那些入度为0的节点放入到队列中，然后对队列进行迭代，直到队列长度为0即可。这里需要注意的是，在进行 BFS 的时候，在添加新节点的时候注意不要把那些已经遍历过的节点重新放入到队列中，这样会导致重复遍历形成环，从而导致超时。\nPacific Atlantic Water Flow 对每个点都可以进行一次深度遍历，分别看这个点能否到达两大洋，如果一个点既能够到达大西洋，也能够到达太平洋，那么这个点就是结果之一。这里的一个优化方法就是，由于必须要到达两大洋，所以不需要对每个点都进行遍历，而是只需要对边上的点进行遍历即可。对边上的点进行深度遍历，如果一个点既能够到达太平洋，也能够到达大西洋，那么这个点就是我们所需要的结果。\nNumber of Islands\n抽象成一个图，使用深度优先遍历，遍历之后看一共有多少个连通分量即可。\n不是很难，但是要注意边界条件的设置。\nLongest Consecutive Sequence\nTODO recheck\n这里跟图关系不大，主要还是使用 map，然后使用一个相对比较取巧的方法来计算。\nAlien dict\n这题稍微看上去有点复杂，现在暂时还没做。\nGraph Valid Tree\n这题很简单，就是验证给出的节点能够构成树，如果要构成树，那么就需要满足两个条件：首先就是没有环，其次就是只有一个连通分量。这个很容易解决。\nNumber of Connected Components in an Undirected Graph\n这里也很简单。主要问题还是如何表示无向图和有向图的问题，解决这个问题之后，后续无非是深度遍历和广度遍历的问题。\nInterval # Insert Interval TODO recheck\n这个题需要好好注意，自己在这个题的解法上并不简介。注意边界条件。\nMerge Intervals 做了上一题之后，应该不太难想到这一题的思路。\nNon-overlapping Intervals TODO recheck\n这题我不会，需要多注意。注意贪心策略的选择。\nMeeting Rooms 简单题，无需再看。\nMeeting Rooms II TODO recheck\n这题比较难，最好能够动手画一下图，这样会好理解一些。\nLinked list # 链表这一块要特别注意虚拟头结点的使用，插入一个虚拟头节点能够避免很多问题。\nReverse a linked list 简单题\nDetect Cycle in a Linked List\n简单题，可以使用快慢指针或者 map。\nMerge Two Sorted List\n简单题，无需再过多关注\nMerge K Sorted List 简单题， 只需要使用堆即可。\nRemove Nth Node From End Of List\n简单题，无需过多关注。\nReorder List\nTODO recheck\n这个也不是很难，其实还是链表的反转问题。这里一个需要注意的点是，如何找到 mid 节点，快慢指针的快指针是如何进行遍历的，以及特别需要注意的是，找到中点之后，要把前半段和后半段断开，不然很容易导致出现环，从而出现超时。\nMatrix # Set Matrix Zeroes TODO recheck 解法比较巧妙，需要注意一下。\nSpiral Matrix TODO recheck\n注意遍历方向和 coner case\nRotate Image TODO recheck\n注意矩阵主对角线旋转和副对角线旋转的公式。\n矩阵旋转：\n主对角线对折： arr[i][j] = arr[j][i] 副对角线对折： arr[i][j] = arr[n-j-1][n-i-1] for i := 0; i \u0026lt; n; i++ { for j := 0; j \u0026lt; n-i; j++ { matrix[i][j], matrix[n-j-1][n-i-1] = matrix[n-j-1][n-i-1], matrix[i][j] } } 横向对折： arr[i][j] = arr[n-i-1][j] 纵向对折： arr[i][j] = arr[i][n-j-1] Word Search 同 Word Search II 一样，这里需要注意的是，不同情况的回溯函数之间的状态不能相互干扰。\nString # 前三题都是滑动窗口题目。回文子串题注意活用中心扩散方法。\nLongest Substring Without Repeating Characters TODO recheck\n注意这里是如何维持滑动窗口的。尤其要注意的是移动左指针的条件：字符出现在了 map 中但是并不一定出现在了滑动窗口中，只有字符出现在了滑动窗口中才需要滑动左指针。\nLongest Repeating Character Replacement TODO recheck\n这题比较难，不过分析过程很有意思。\nMinimum Window Substring TODO recheck\n这题也比较难，问题在于如何维持一个可以包含冗余字符的滑动窗口，值得再看几遍。\nValid Anagram 简单题，无需关注。\nGroup Anagrams 简单题，无需再关注。\nValid Parentheses 简单题，无需关注。\nValid Palindrome 简单题，无需关注。\nLongest Palindromic Substring 可以关注一下如何使用动态规划的方式来解决这个问题。\nPalindromic Substrings TODO recheck\n这里要注意活用中心扩散算法\nEncode and Decode Strings 两种方法：\n编码时间把字符串长度编码进去，解码的时候直接根据长度进行分割即可 使用一些特殊字符进行分隔 Tree # Maximum Depth of Binary Tree 简单题，无需再看。\nSame Tree\nTODO recheck\n简单题，但是还是需要注意一下。\nInvert a Binary Tree 简单题\nBinary Tree Maximum Path Sum\nTODO recheck\n难题，但是分析过程还是比较有意思的。需要注意的是，res 初值不能取 0，而是要取一个最小值.\nSerialize and Deserialize Binary Tree\nTODO recheck\n其实不难，只需要使用层次遍历即可。主要的问题是，在层次遍历序列化的时候，需要保留空节点，在反序列化的时候，也需要保留空节点。\nSubtree of Another Tree TODO recheck\n不是很难，关键点在于，如何写对 sameTree 这个函数。\nConstruct Binary Tree from Preorder and Inorder Traversal\n这题主要注意 corner case\nValidate Binary Search Tree\nTODO recheck\n这里需要注意的是如何充分利用中序遍历。这里的递归方法值得好好研究一下。\nKth Smallest Element in a BST 简单题，只需要中序遍历的迭代解法即可解决。\nLowest Common Ancestor of BST TODO recheck\n关键在于抓住 BST 的性质。\nImplement Trie(Prefix Tree) TODO recheck\n注意如何表示前缀树\nDesign Add and Search Words Data Structure TODO recheck\n虽然是前缀树的一个应用，但是需要注意如何应对通配符。\nWord Search II 这里需要注意两点：\n首先可以复用原数组，让其保存访问状态，这样就可以避免开辟额外的 visite 的数组来节省空间 如果不复用原数组，而要额外开辟 visited 数组的话，注意每次搜索的时候 visited 的状态不能相互影响。 Heap # Merge K Sorted List 这个很简单，只需要好好使用堆即可。\nTop K Frequent Elements\n可以用 Map 来做，key 表示元素，value 表示元素出现的次数，如果每个元素出现的次数是独一无二的，那么最后对 v 进行排序即可。 也可以用自定义大根堆来做，堆的元素是二元数组，其中第一个元素表示出现的次数，第二个元素表示元素值。\nFind Median from Data Stream TODO recheck\n这里的难点在于在插入时，如何保证两个堆的数量基本上是相等的。解决办法是，优先插入左边大根堆，然后将左边的大根堆堆顶元素插入右边小根堆，此时如果发现左边大根堆的数量小于右边小根堆的数量，那么将右边小根堆的堆顶元素插入左边小根堆。这样的话，就可以维持：左边的大根堆元素数量要么比右边大 1，要么二者相等。\n"},{"id":261,"href":"/docs/algs/leetcode/Top-Leetcode-Interview-Questions/","title":"Top Interview Questions","section":"Leetcode","content":" Two Sum 简单题，可跳过。\nAdd Two Numbers 不难，注意 dummyHead 的使用\nLongest Substring Without Repeating Character 滑动窗口，不难。\nMedian of Two Sorted Arrays TODO 难题， 暂时跳过\nLongest Palindromic Substring 不难\nReverse Integer NOTE 注意这里对溢出的处理技巧，以及对负数的处理\nString to Integer(atoi) 不难，只是繁琐\nRegular Expression Matching TODO 暂时跳过\nContainer With Most Water 不难，但是要注意一题多解\nRoman to Integer 不难\nLongest Common Prefix 不难\n3Sum TODO 注意如何做优化，这里的优化技巧很值得学习学习\nLetter Combinations of a Phone Number 简单题，不难\nRemove Nth Node From End of List 不难\nValid Parentheses 简单题\nMerge Two Sorted Lists 简单题\nGenerate Parentheses\n"},{"id":262,"href":"/docs/algs/basic/msort/notes/","title":"排序算法笔记","section":"Basic","content":" 归并排序 # 归并排序才用了分治法。 从下图可以看到这棵树很像一颗完全二叉树，它的树高为 \\($\\log_2^n$\\) ,每次合并操作的平均复杂度是 \\($\\Omega(n)$\\) ， 所以总的时间复杂度是 \\($n\\log_2^n$\\) 。最好、最坏和平均复杂度均一致。 动图演示如下： 归并排序分为自顶向下的排序和自底向上的排序。自顶向下的排序先把元素不断的二分，直到子数组的元素个数为一个，然后再将两个有序的序列合并成一个新的有序序列，两个新的有序序列又可以合并成另一个新的有序序列，以此类推，直到合并成一个有序的数组。一般自顶向下方法可以通过递归来做。自底向上的想是先把数组中一个一个归并成两两有序的序列，两两有序的序列再归并成四有序序列，两个四有序序列再归并成八有序序列，直到归并的长度大于整个数组的长度。需要注意的是，数组按照归并长度划分，最后一个子数组可能不满足长度要求，这个情况需要特殊处理。一般自底向上归并可以用循环来实现。\n希尔排序 # 希尔排序也叫缩小增量排序， 是简单插入排序的改进版。希尔排序是基于插入排序的以下两点性质做出改进的：\n插入排序在对几乎已经排好序的数据进行操作时，效率很高，可以打到线性排序的效率。 插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。 希尔排序的基本思想是：把整个待排序序列分成若干个子序列分别进行插入排序，等数组基本有序之后，再对全体数据进行直接插入排序。\n需要注意的是，希尔排序要的不是让子数组完全有序，而是只需要部分有序即可。\n快速排序 # 快排采用分治法，基本思想是： 通过一趟排序将要排序的序列分成两部分，其中一部分的所有数据都比另一部分要小，然后再通过此方法对数据的左右俩部分分别进行快速排序。\n快排的性能对数据的有序性很敏感，数据越有序，快排的性能越差。对于一个顺序数组进行快排，性能会达到 \\($\\Omicron(n)^2$\\) ，所以尽量在进行快排之前将数组打乱。\n快排的平均期望时间是 \\($\\Omicron(n\\log n)$\\) ， 且 \\($\\Omicron(n\\log n)$\\) 中隐含的常数因子很小，比复杂度稳定于 \\($\\Omicron(n\\log n)$\\) 的归并排序要小很多。所以，对大多数顺序性较弱的随机数组而言，快排总是优于归并排序。\n堆排序 # 堆是具有如下性质的一棵完全二叉树：每个节点的值都大于等于其左右子节点的值，称为大顶堆；每个节点的值都小于等于其左右子节点的值，称为小顶堆。因为堆是一棵完全二叉树，所以也可以用数组来存储。假设小标从 0 开始，则其左子节点位置为 2i+1, 右子节点为 2i + 2, 父节点为 （i-1)/2。\n"},{"id":263,"href":"/docs/algs/others/2.-%E7%AD%89%E6%A6%82%E7%8E%87%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E4%B8%AD-k-%E4%B8%AA%E5%85%83%E7%B4%A0/","title":"等概率返回数组中 k 个元素","section":"Others","content":" 题目描述 # 给你一个输入数据流，数据内容为一系列的信号。 设计一个方法，能在流的终止信号到达时，返回数据流内的随机k个信号结果。 要求：数据流内每个信号被选中的概率均等。数据流内信号个数不足k个时，全部返回。\nSolutions # 这个题之前在考研的时候见过，核心思想是：维持一个大小为 k 的数组，然后将输入的前 k 个元素存入到数组中的，对于后面的每个元素，使用随机数产生一个[0,k-1]之内的数，然后使用这个数作为下标，替换掉数组中对应位置的数。最后返回数组中的这 k 个数为止。\n"},{"id":264,"href":"/docs/algs/leetcode/14-patterns-to-ace-any-coding-interview-questions/","title":"14 Patterns to Ace Any Coding Interview Questions","section":"Leetcode","content":"关于算法笔试的常见的十四中模式。\n1. 滑动窗口 # 特征 # 问题输入是线性的数据结构 目的是找出最长/短子字符串、子数组或者指定期望值 2. 双指针 # 特征 # 对有序序列或者链表进行操作，目的是找到满足特定条件的一串元素 目标是一对元素或者三个元素，甚至是一个子数组 3. 快慢指针 # 特征 # 问题是处理链表或者数组中的循环 当你需要知道某个元素在整个链表中的位置 4. 区间合并 # 区间合并的几种情况： 。\n特征 # 对互斥区间生成一个链表 出现关键词“overlaping intervals” 5. 循环排序(cyclic sort) # 6. 链表就地翻转 # 7. 树的深度优先遍历 # 8. 树的广度优先遍历 # 9. 双堆 # 10. 子集 # 11. 改动的二分搜索 # 12. Top K 个元素 # 一般可以用最大/小堆来解决\n13. K 路合并 # 可以使用最大/小堆来实现\n14. 拓扑排序 # Refs # 14 Patterns to Ace Any Coding Interview Questions Blind 75 # Sequence # Two Sum\n使用一个 map 记录元素值与元素下标的映射，只需要一次扫描数组，检查 target - value 是否在 map 中，同时将 value 和其下标放到 map 中 。\n[tag_map]\nBest Time to Buy and Sell Stock\n使用一个值记录当前扫描到的最小值，然后扫描一次数组，每扫描到一个值，用当前值减去当前得到的最小值，然后得到结果，取结果的最大值。如果当前值小于最小值，则更新最小值为当前值。只需要一次扫描。\nContains Duplicate\n简单题，只需要一个 map 就可以了，扫描一次即可。\n[tag_map]\nProduct of Array Except Self 创建两个数组left 和 right，数组 left[i] 表示 i 位置前的元素的累积，数组 right[i]表示 i 位置后的元素的累积。然后创建一个数组 res， res[i] = left[i] * right[i]。\nMaximum Subarray\nKadane 算法，最优子结构性质，当前位置的和取决于前一个位置的子数组和以及当前元素。\ndef max_subarray(arr): max_sum_so_far, sum_ending_here = arr[0], arr[0] for e in range(arr[1:]): sum_ending_here = max(e, sum_ending_here + e) max_sum_so_far = max(max_sum_so_far, sum_ending_here) return max_sum_so_far 如果数组中有负数，并且允许返回长度为 0 的子数列，则该问题可以改为：\ndef max_subarray(arr): max_sum_so_far, sum_ending_here = 0, 0 for e in range(arr): sum_ending_here = max(sum_ending_here + e, e) max_sum_so_far = max(max_sum_so_far, sum_ending_here) return max_sum_so_far TODO 重点关注\nMaximum Product Subarray\n动态规划，这里看起来和 53 题类似，但是其实这里的 0 和负数会对结果造成比较大的影响。解决方法是使用两个数组，一个数组 greater 记录包含当前元素的最大积的值，另一个数组 lesser 记录包含当前元素的最小积的值。 然后当前的最大最小值只会在 greater[i-1]*nums[i]、nums[i] 和 lesser[i-1]*nums[i] 中产生。\nTODO 重点关注这题\nFind Minimum in Rotated Sorted Array\n主要还是：举出例子，注意观察；注意这个性质：旋转数组一分为二之后，其中一个一定是有序的，另一个可能有序、可能无序。\nSearch in Rotated Sorted Array\n二分法。谁能想到是需要根据 middle 来判断向哪一边前进呢，而且 left 和 right 的取值也很巧妙.\n对于旋转数组，需要注意的是：因为数组原先是有序的，所以将数组一分为二之后，其中一定有一个是有序的，另一个可能有序，也可能部分有序。此时有序部分用二分查找。无序部分再一分为二，其中一个一定有序，而另一个可能有序，可能无序。循环即可。\n在使用while 循环进行搜索的时候，一定要注意缩小范围。也就是说，一方面要让结果收敛，另一方面要保持出口单一。 TODO 二分法复习\n3 Sum\n排序+双指针 需要注意这几点：\n适当剪枝： 包括如何去重、为什么要进行排序、遍历多少次、为什么遇到整数之后可以直接跳出循环 有序数组使用双指针 是否可以更改原数组，如果可以，那么排序是否会带来不一样的效果 Container With Most Water\n贪心，怎么移动，移动的时候是移动左边还是移动右边，基于什么策略去移动，木桶效应。\nBinary # Sum of Two Integers\n二进制运算（异或模拟二进制加法和，与运算模拟进位，进位还需要左移），何时结束递归。\nNumber of 1 Bits\nSuper easy, 后面不需要再花时间看。\nCounting Bits\n想到解法很简单，但找到规律不容易。有趣的规律是：如果 n 是奇数，数字 n 中包含的 1 的个数等于数字 n/2 所包含的 1 的个数加 1；如果 n 是偶数，数字 n 包含的 1 的个数等于数字 n/2 包含的 1 的个数。\nMissing Number\n很简单，只需要记住等差数列求和公式即可： n*(a1+an)/2\nReverse Bits\n很容易想到解法。\nDynamic Programming # Climbing Stairs\n斐波那契数列，Fn = Fn-1 + Fn-2\nCoin Change\nTODO recheck 注意的是，局部最优解不等于全局最优解，所以这里使用贪心算法得到一个可行解是不够的，要求出所有解，然后取其中最小值。推导式： dp[i] = min(dp[i], dp[i - coins[j]] + 1) if coins[j] \u0026lt;= dp[i].\nLongest Increasing Subsequence\nTODO recheck 这题需要重点关注一下，因为自己对这个的应用还不够熟练。\n核心代码：\nfor i := 1; i \u0026lt; size; i++ { for j := 0; j \u0026lt; i;j++ { if nums[i] \u0026gt; nums[j] { dp[i] = max(dp[i], dp[j]+ 1) } } // 注意这里，最后所求的并不是dp[size-1] res = max(res, dp[i]) } return res } 字符串求极值一般可以考虑一下使用动态规划，动态规划想不出转移方程则可以尝试使用贪心。\nLongest Common Subsequence\nTODO recheck\n这题跟 583_delete_operation_for_two_strings 是一样的解法，也跟 516_longest_palindromic_subsequence 是一样的，是典型的的二维dp问题。\n在 longest palindromic subsequence 中，一定要注意遍历的方向，dp具有最优子结构性质，而这意味着你在求解一个问题时，需要完全求解出这个问题的子问题的解。\n需要注意这几个问题：\n状态方程式怎么定义的 为什么数组是 (m+1) * (n+1) 的 为什么比较的时候是 text1[i-1] 与 text2[j-1]比较 Longest Palindrome Subsequence\nTODO recheck\n参见上一题的解答。\nDelete Operation for Two Strings\nTODO recheck\n参见上一题的解答\nWord Break\nTODO recheck\n这一题需要特别注意，尤其需要注意dp数组的定义，这里的初始化条件也需要注意，此外还需要注意子问题的求解方向。结束遍历的条件也是需要特别注意的。\nCombination Sum\nCombination Sum 是一系列题，分别有leetcode 39 题 Combination Sum， 40 题的 Combination Sum II, 216 题的 Combination Sum III 和 377 题的 Combination Sum IV。\n39 题比较简单，注意边界条件即可。40 题和39 题其实是差不多的。216题也不难。\n377 题竟然是使用动态规划来解的，我肯定想不到这种解法。 #TODO\n在 39 题中，需要注意的是，在回溯的过程中， 我们可以一次性添加多个元素，而不是只添加一个，这样可以减少一些回溯过程：\nfor i := start; i \u0026lt; size; i++ { for j := target/candidates[i]; j \u0026gt; 0; j-- { //一次性添加多个同一元素 for k := 0; k \u0026lt; j; k++ { cur = append(cur, candidates[i]) } combinationSumHelper(candidates, i+1, target - j * candidates[i], cur, res) // 复原 cur = cur[:len(cur) - j] } } 在第 40 题中，需要注意的是，可以直接对数组进行排序，从而就不需要再使用 map 来进行手动去重。另外还需要特别注意该题中的剪枝用法。\nHouse Robber\nTODO recheck\n这个题需要注意初始条件是怎么算出来的。\nHouse Robber II\nTODO recheck\n这个好取巧，直接剔除抢和不抢的情况，然后算两次取最大值。\nDecode ways\nTODO 这一题还没写\nUnique Path\n注意排列组合计算方法。注意这里为什么需要用更小的值来作为上值，为什么选择另一个数可能会导致溢出，从而得到结果0.\n// 计算从m里面抽n个 res := 1 for i := 0; i \u0026lt; n; i++ { res *= (m-i) res /= (i+1) } Jump Games\nTODO recheck 对于动态规划，自己的解题能力还需要加强 这里的贪心解法很有意思。\nGraph # Clone Graph\nTODO recheck\n本质上就是进行一次 DFS 或者 BFS，但是要注意去重。这里需要注意的是，map 的 key 和 value 分别对应的原节点和其克隆出来的节点吗，而不是仅仅记录一个节点是否有被 clone 过。\nCourse Schedule\n很明显的有向图环检测问题。这里并不需要我们真的建立一个图，而是可以使用邻接表（也就是二维数组）的方式来表示图，然后使用一个一维数组来表示各个节点的入度是对少。\n遍历的时候，将那些入度为0的节点放入到队列中，然后对队列进行迭代，直到队列长度为0即可。这里需要注意的是，在进行 BFS 的时候，在添加新节点的时候注意不要把那些已经遍历过的节点重新放入到队列中，这样会导致重复遍历形成环，从而导致超时。\nPacific Atlantic Water Flow 对每个点都可以进行一次深度遍历，分别看这个点能否到达两大洋，如果一个点既能够到达大西洋，也能够到达太平洋，那么这个点就是结果之一。这里的一个优化方法就是，由于必须要到达两大洋，所以不需要对每个点都进行遍历，而是只需要对边上的点进行遍历即可。对边上的点进行深度遍历，如果一个点既能够到达太平洋，也能够到达大西洋，那么这个点就是我们所需要的结果。\nNumber of Islands\n抽象成一个图，使用深度优先遍历，遍历之后看一共有多少个连通分量即可。\n不是很难，但是要注意边界条件的设置。\nLongest Consecutive Sequence\nTODO recheck 这里跟图关系不大，主要还是使用 map，然后使用一个相对比较取巧的方法来计算。\nAlien dict\n这题稍微看上去有点复杂，现在暂时还没做。\nGraph Valid Tree\n这题很简单，就是验证给出的节点能够构成树，如果要构成树，那么就需要满足两个条件：首先就是没有环，其次就是只有一个连通分量。这个很容易解决。\nNumber of Connected Components in an Undirected Graph\n这里也很简单。主要问题还是如何表示无向图和有向图的问题，解决这个问题之后，后续无非是深度遍历和广度遍历的问题。\nInterval # Insert Interval TODO recheck 这个题需要好好注意，自己在这个题的解法上并不简介。注意边界条件。\nMerge Intervals 做了上一题之后，应该不太难想到这一题的思路。\nNon-overlapping Intervals TODO recheck\n这题我不会，需要多注意。注意贪心策略的选择。\nMeeting Rooms 简单题，无需再看。\nMeeting Rooms II TODO recheck\n这题比较难，最好能够动手画一下图，这样会好理解一些。\nLinked list # 链表这一块要特别注意虚拟头结点的使用，插入一个虚拟头节点能够避免很多问题。\nReverse a linked list 简单题\nDetect Cycle in a Linked List\n简单题，可以使用快慢指针或者 map。\nMerge Two Sorted List\n简单题，无需再过多关注\nMerge K Sorted List 简单题， 只需要使用堆即可。\nRemove Nth Node From End Of List\n简单题，无需过多关注。\nReorder List\nTODO recheck 这个也不是很难，其实还是链表的反转问题。这里一个需要注意的点是，如何找到 mid 节点，快慢指针的快指针是如何进行遍历的，以及特别需要注意的是，找到中点之后，要把前半段和后半段断开，不然很容易导致出现环，从而出现超时。\nMatrix # Set Matrix Zeroes TODO recheck 解法比较巧妙，需要注意一下。\nSpiral Matrix TODO recheck 注意遍历方向和 coner case\nRotate Image TODO recheck 注意矩阵主对角线旋转和副对角线旋转的公式。\n矩阵旋转：\n主对角线对折： arr[i][j] = arr[j][i] 副对角线对折： arr[i][j] = arr[n-j-1][n-i-1] for i := 0; i \u0026lt; n; i++ { for j := 0; j \u0026lt; n-i; j++ { matrix[i][j], matrix[n-j-1][n-i-1] = matrix[n-j-1][n-i-1], matrix[i][j] } } 横向对折： arr[i][j] = arr[n-i-1][j] 纵向对折： arr[i][j] = arr[i][n-j-1] Word Search 同 Word Search II 一样，这里需要注意的是，不同情况的回溯函数之间的状态不能相互干扰。\nString # 前三题都是滑动窗口题目。回文子串题注意活用中心扩散方法。\nLongest Substring Without Repeating Characters TODO recheck\n注意这里是如何维持滑动窗口的。尤其要注意的是移动左指针的条件：字符出现在了 map 中但是并不一定出现在了滑动窗口中，只有字符出现在了滑动窗口中才需要滑动左指针。\nLongest Repeating Character Replacement TODO recheck 这题比较难，不过分析过程很有意思。\nMinimum Window Substring TODO recheck 这题也比较难，问题在于如何维持一个可以包含冗余字符的滑动窗口，值得再看几遍。\nValid Anagram 简单题，无需关注。\nGroup Anagrams 简单题，无需再关注。\nValid Parentheses 简单题，无需关注。\nValid Palindrome 简单题，无需关注。\nLongest Palindromic Substring 可以关注一下如何使用动态规划的方式来解决这个问题。\nPalindromic Substrings TODO recheck 这里要注意活用中心扩散算法\nEncode and Decode Strings 两种方法：\n编码时间把字符串长度编码进去，解码的时候直接根据长度进行分割即可 使用一些特殊字符进行分隔 Tree # Maximum Depth of Binary Tree 简单题，无需再看。\nSame Tree\nTODO recheck 简单题，但是还是需要注意一下。\nInvert a Binary Tree 简单题\nBinary Tree Maximum Path Sum\nTODO recheck 难题，但是分析过程还是比较有意思的。需要注意的是，res 初值不能取 0，而是要取一个最小值.\nSerialize and Deserialize Binary Tree\nTODO recheck 其实不难，只需要使用层次遍历即可。主要的问题是，在层次遍历序列化的时候，需要保留空节点，在反序列化的时候，也需要保留空节点。\nSubtree of Another Tree TODO recheck 不是很难，关键点在于，如何写对 sameTree 这个函数。\nConstruct Binary Tree from Preorder and Inorder Traversal\n这题主要注意 corner case\nValidate Binary Search Tree\nTODO recheck 这里需要注意的是如何充分利用中序遍历。这里的递归方法值得好好研究一下。\nKth Smallest Element in a BST 简单题，只需要中序遍历的迭代解法即可解决。\nLowest Common Ancestor of BST TODO recheck 关键在于抓住 BST 的性质。\nImplement Trie(Prefix Tree) TODO recheck 注意如何表示前缀树\nDesign Add and Search Words Data Structure TODO recheck 虽然是前缀树的一个应用，但是需要注意如何应对通配符。\nWord Search II 这里需要注意两点：\n首先可以复用原数组，让其保存访问状态，这样就可以避免开辟额外的 visite 的数组来节省空间 如果不复用原数组，而要额外开辟 visited 数组的话，注意每次搜索的时候 visited 的状态不能相互影响。 Heap # Merge K Sorted List 这个很简单，只需要好好使用堆即可。\nTop K Frequent Elements\n可以用 Map 来做，key 表示元素，value 表示元素出现的次数，如果每个元素出现的次数是独一无二的，那么最后对 v 进行排序即可。 也可以用自定义大根堆来做，堆的元素是二元数组，其中第一个元素表示出现的次数，第二个元素表示元素值。\nFind Median from Data Stream TODO recheck\n这里的难点在于在插入时，如何保证两个堆的数量基本上是相等的。解决办法是，优先插入左边大根堆，然后将左边的大根堆堆顶元素插入右边小根堆，此时如果发现左边大根堆的数量小于右边小根堆的数量，那么将右边小根堆的堆顶元素插入左边小根堆。这样的话，就可以维持：左边的大根堆元素数量要么比右边大 1，要么二者相等。\n分类 # 树 # Binary Tree Preorder Traversal 简单题， 后续不需要再看。 "},{"id":265,"href":"/docs/algs/leetcode/692_top_k_frequent_words/","title":"692 Top K Frequent Words","section":"Leetcode","content":" Description # Given an array of strings words and an integer k, return the k most frequent strings.\nReturn the answer sorted by the frequency from highest to lowest. Sort the words with the same frequency by their lexicographical order.\nSolutions # Hash Table \u0026amp; Sort # 首先还是创建一个 dict 统计一下各个单词出现的次数， 然后用单词以及该单词出现的次数组成 pair 对，把这些 pair 对组成数组中，然后根据每个单词的出现频率对这个数组进行排序，如果单词频率相同，则根据单词的字母顺序进行排序。最后放回前 k 个即可。\nfunc topKFrequent(words []string, k int) []string { dict := make(map[string]int) for _, word := range words { dict[word]++ } type Pair struct { str string cnt int } var pairs []Pair for word, cnt := range dict { pairs = append(pairs, Pair{word, cnt}) } sort.Slice(pairs, func(i, j int) bool { if pairs[i].cnt == pairs[j].cnt { return pairs[i].str \u0026lt; pairs[j].str } return pairs[i].cnt \u0026gt; pairs[j].cnt }) var res []string for i := 0; i \u0026lt; k; i++ { res = append(res, pairs[i].str) } return res } "}]